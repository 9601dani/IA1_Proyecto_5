(self.webpackChunkchatbot12=self.webpackChunkchatbot12||[]).push([[179],{255:e=>{function t(e){return Promise.resolve().then(()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}t.keys=()=>[],t.resolve=t,t.id=255,e.exports=t},566:(e,t,n)=>{var s=n(683),r=n(669),a=n(64),i=n(763),o=n(553),u=n(464),l=n(147);l.alea=s,l.xor128=r,l.xorwow=a,l.xorshift7=i,l.xor4096=o,l.tychei=u,e.exports=l},683:function(e,t,n){var s;!function(e,r,a){function i(e){var t,n=this,s=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var s=.02519603282416938*(t+=e.charCodeAt(n));s-=t=s>>>0,t=(s*=t)>>>0,t+=4294967296*(s-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=s(" "),n.s1=s(" "),n.s2=s(" "),n.s0-=s(e),n.s0<0&&(n.s0+=1),n.s1-=s(e),n.s1<0&&(n.s1+=1),n.s2-=s(e),n.s2<0&&(n.s2+=1),s=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new i(e),s=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.alea=u}(0,e=n.nmd(e))},464:function(e,t,n){var s;!function(e,r,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,s=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-s|0,s=s<<24^s>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-s|0,t.d=s<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var s=0;s<n.length+20;s++)t.b^=0|n.charCodeAt(s),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.tychei=u}(0,e=n.nmd(e))},669:function(e,t,n){var s;!function(e,r,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var s=0;s<n.length+64;s++)t.x^=0|n.charCodeAt(s),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xor128=u}(0,e=n.nmd(e))},553:function(e,t,n){var s;!function(e,r,a){function i(e){var t=this;t.next=function(){var e,n,s=t.w,r=t.X,a=t.i;return t.w=s=s+1640531527|0,n=r[a+34&127],e=r[a=a+1&127],n^=n<<13,e^=e<<17,n=r[a]=(n^=n>>>15)^(e^=e>>>12),t.i=a,n+(s^s>>>16)|0},function(e,t){var n,s,r,a,i,o=[],u=128;for(t===(0|t)?(s=t,t=null):(t+="\0",s=0,u=Math.max(u,t.length)),r=0,a=-32;a<u;++a)t&&(s^=t.charCodeAt((a+32)%t.length)),0===a&&(i=s),s^=s<<10,s^=s>>>15,s^=s<<4,s^=s>>>13,a>=0&&(r=0==(n=o[127&a]^=s+(i=i+1640531527|0))?r+1:0);for(r>=128&&(o[127&(t&&t.length||0)]=-1),r=127,a=512;a>0;--a)s=o[r+34&127],n=o[r=r+1&127],s^=s<<13,n^=n<<17,o[r]=(s^=s>>>15)^(n^=n>>>12);e.w=i,e.X=o,e.i=r}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&(s.X&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xor4096=u}(0,e=n.nmd(e))},763:function(e,t,n){var s;!function(e,r,a){function i(e){var t=this;t.next=function(){var e,n,s=t.x,r=t.i;return e=s[r],n=(e^=e>>>7)^e<<24,n^=(e=s[r+1&7])^e>>>10,n^=(e=s[r+3&7])^e>>>3,n^=(e=s[r+4&7])^e<<7,e=s[r+7&7],s[r]=n^=(e^=e<<13)^e<<9,t.i=r+1&7,n},function(e,t){var n,s=[];if(t===(0|t))s[0]=t;else for(t=""+t,n=0;n<t.length;++n)s[7&n]=s[7&n]<<15^t.charCodeAt(n)+s[n+1&7]<<13;for(;s.length<8;)s.push(0);for(n=0;n<8&&0===s[n];++n);for(8==n&&(s[7]=-1),e.x=s,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&(s.x&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xorshift7=u}(0,e=n.nmd(e))},64:function(e,t,n){var s;!function(e,r,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var s=0;s<n.length+64;s++)t.x^=0|n.charCodeAt(s),s==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&o(s,n),r.state=function(){return o(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xorwow=u}(0,e=n.nmd(e))},147:(e,t,n)=>{var s;!function(r,a){var i,o=this,u=256,l=a.pow(u,6),c=a.pow(2,52),h=2*c,d=255;function p(e,t,n){var s=[],d=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(r)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(u):(e=new Uint8Array(u),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(s){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(r)]}}():e,3),s),p=new f(s),v=function(){for(var e=p.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,b(y(p.S),r),(t.pass||n||function(e,t,n,s){return s&&(s.S&&m(s,p),e.state=function(){return m(p,{})}),n?(a.random=e,t):e})(v,d,"global"in t?t.global:this==a,t.state)}function f(e){var t,n=e.length,s=this,r=0,a=s.i=s.j=0,i=s.S=[];for(n||(e=[n++]);r<u;)i[r]=r++;for(r=0;r<u;r++)i[r]=i[a=d&a+e[r%n]+(t=i[r])],i[a]=t;(s.g=function(e){for(var t,n=0,r=s.i,a=s.j,i=s.S;e--;)t=i[r=d&r+1],n=n*u+i[d&(i[r]=i[a=d&a+t])+(i[a]=t)];return s.i=r,s.j=a,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,s=[],r=typeof e;if(t&&"object"==r)for(n in e)try{s.push(g(e[n],t-1))}catch(a){}return s.length?s:"string"==r?e:e+"\0"}function b(e,t){for(var n,s=e+"",r=0;r<s.length;)t[d&r]=d&(n^=19*t[d&r])+s.charCodeAt(r++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(a.seedrandom=p,b(a.random(),r),e.exports){e.exports=p;try{i=n(42)}catch(v){}}else void 0===(s=(function(){return p}).call(t,n,t,e))||(e.exports=s)}([],Math)},862:(e,t,n)=>{"use strict";var s={};n.r(s),n.d(s,{assertParamsValid:()=>sv,computeFlatOffset:()=>gv,computeOutShape:()=>av,getNormalizedAxes:()=>lv,isSliceContinous:()=>mv,maskToAxes:()=>rv,parseSliceParams:()=>bv,sliceInfo:()=>yv,startForAxis:()=>pv,startIndicesWithElidedDims:()=>cv,stopForAxis:()=>fv,stopIndicesWithElidedDims:()=>hv,stridesForAxis:()=>dv,stridesWithElidedDims:()=>iv});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>MI,computeOutShape:()=>OI,segOpComputeOptimalWindowSize:()=>DI});var a={};n.r(a),n.d(a,{ERF_A1:()=>hI,ERF_A2:()=>dI,ERF_A3:()=>pI,ERF_A4:()=>fI,ERF_A5:()=>mI,ERF_P:()=>cI,PARALLELIZE_THRESHOLD:()=>Yk,SELU_SCALE:()=>lI,SELU_SCALEALPHA:()=>uI,applyActivation:()=>Jx,assertAndGetBroadcastShape:()=>xw,assertAxesAreInnerMostDims:()=>Yw,assertParamsConsistent:()=>Kk,assignToTypedArray:()=>II,axesAreInnerMostDims:()=>Hw,calculateShapes:()=>oI,checkEinsumDimSizes:()=>$I,combineLocations:()=>Gw,complexWithEvenIndex:()=>wI,complexWithOddIndex:()=>xI,computeConv2DInfo:()=>Pv,computeConv3DInfo:()=>jv,computeDefaultPad:()=>Vv,computeDilation2DInfo:()=>Mv,computeOptimalWindowSize:()=>Zk,computeOutAndReduceShapes:()=>Kw,computeOutShape:()=>Xk,computePool2DInfo:()=>zv,computePool3DInfo:()=>Lv,convertConv2DDataFormat:()=>Kv,decodeEinsumEquation:()=>EI,eitherStridesOrDilationsAreOne:()=>Gv,expandShapeToKeepDim:()=>Xw,exponent:()=>_I,exponents:()=>CI,fromStringArrayToUint8:()=>LI,fromUint8ToStringArray:()=>zI,getAxesPermutation:()=>Zw,getBroadcastDims:()=>vw,getComplexWithIndex:()=>kI,getEinsumComputePath:()=>TI,getEinsumPermutation:()=>NI,getFusedBiasGradient:()=>Zx,getFusedDyActivation:()=>Yx,getImageCenter:()=>Jk,getInnerMostAxes:()=>Qw,getPermuted:()=>eI,getReductionAxes:()=>ww,getReshaped:()=>Qk,getReshapedPermuted:()=>tI,getSliceBeginCoords:()=>nI,getSliceSize:()=>sI,getUndoAxesPermutation:()=>Jw,isIdentityPermutation:()=>AI,log:()=>bI,mergeRealAndImagArrays:()=>yI,prepareAndValidate:()=>rI,prepareSplitSize:()=>FI,segment_util:()=>r,shouldFuse:()=>Qx,slice_util:()=>s,splitRealAndImagArrays:()=>vI,tupleValuesAreOne:()=>Hv,upcastType:()=>jb,validateInput:()=>iI,validateUpdateShape:()=>aI,warn:()=>gI});var i={};function o(e){return"function"==typeof e}n.r(i),n.d(i,{addImpl:()=>uF,bincountImpl:()=>eD,bincountReduceImpl:()=>tD,ceilImpl:()=>rD,concatImpl:()=>cD,expImpl:()=>sO,expm1Impl:()=>uO,floorImpl:()=>_O,gatherV2Impl:()=>DO,greaterImpl:()=>MO,lessImpl:()=>XO,linSpaceImpl:()=>tM,logImpl:()=>sM,maxImpl:()=>yM,maximumImpl:()=>xM,minimumImpl:()=>AM,multiplyImpl:()=>LD,negImpl:()=>VM,notEqualImpl:()=>XM,prodImpl:()=>uz,rangeImpl:()=>cz,rsqrtImpl:()=>kz,simpleAbsImpl:()=>bF,sliceImpl:()=>YF,sparseFillEmptyRowsImpl:()=>Wz,sparseReshapeImpl:()=>qz,squaredDifferenceImpl:()=>Zz,stridedSliceImpl:()=>nL,subImpl:()=>fO,tileImpl:()=>oL,topKImpl:()=>uL,transposeImpl:()=>CF,uniqueImpl:()=>pL});let u=!1;const l={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else u&&console.log("RxJS: Back to a better error behavior. Thank you. <3");u=e},get useDeprecatedSynchronousErrorHandling(){return u}};function c(e){setTimeout(()=>{throw e},0)}const h={closed:!0,next(e){},error(e){if(l.useDeprecatedSynchronousErrorHandling)throw e;c(e)},complete(){}},d=(()=>Array.isArray||(e=>e&&"number"==typeof e.length))();function p(e){return null!==e&&"object"==typeof e}const f=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();let m=(()=>{class e{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._ctorUnsubscribe=!0,this._unsubscribe=e)}unsubscribe(){let t;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:s,_unsubscribe:r,_subscriptions:a}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof e)n.remove(this);else if(null!==n)for(let e=0;e<n.length;++e)n[e].remove(this);if(o(r)){s&&(this._unsubscribe=void 0);try{r.call(this)}catch(i){t=i instanceof f?g(i.errors):[i]}}if(d(a)){let e=-1,n=a.length;for(;++e<n;){const n=a[e];if(p(n))try{n.unsubscribe()}catch(i){t=t||[],i instanceof f?t=t.concat(g(i.errors)):t.push(i)}}}if(t)throw new f(t)}add(t){let n=t;if(!t)return e.EMPTY;switch(typeof t){case"function":n=new e(t);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof e)){const t=n;n=new e,n._subscriptions=[t]}break;default:throw new Error("unrecognized teardown "+t+" added to Subscription.")}let{_parentOrParents:s}=n;if(null===s)n._parentOrParents=this;else if(s instanceof e){if(s===this)return n;n._parentOrParents=[s,this]}else{if(-1!==s.indexOf(this))return n;s.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[n]:r.push(n),n}remove(e){const t=this._subscriptions;if(t){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}}}return e.EMPTY=function(e){return e.closed=!0,e}(new e),e})();function g(e){return e.reduce((e,t)=>e.concat(t instanceof f?t.errors:t),[])}const b=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class y extends m{constructor(e,t,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=h;break;case 1:if(!e){this.destination=h;break}if("object"==typeof e){e instanceof y?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new v(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new v(this,e,t,n)}}[b](){return this}static create(e,t,n){const s=new y(e,t,n);return s.syncErrorThrowable=!1,s}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class v extends y{constructor(e,t,n,s){let r;super(),this._parentSubscriber=e;let a=this;o(t)?r=t:t&&(r=t.next,n=t.error,s=t.complete,t!==h&&(a=Object.create(t),o(a.unsubscribe)&&this.add(a.unsubscribe.bind(a)),a.unsubscribe=this.unsubscribe.bind(this))),this._context=a,this._next=r,this._error=n,this._complete=s}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;l.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:n}=l;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):c(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;c(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);l.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(n){if(this.unsubscribe(),l.useDeprecatedSynchronousErrorHandling)throw n;c(n)}}__tryOrSetError(e,t,n){if(!l.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(s){return l.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=s,e.syncErrorThrown=!0,!0):(c(s),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const w=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function x(e){return e}let k=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const n=new e;return n.source=this,n.operator=t,n}subscribe(e,t,n){const{operator:s}=this,r=function(e,t,n){if(e){if(e instanceof y)return e;if(e[b])return e[b]()}return e||t||n?new y(e,t,n):new y(h)}(e,t,n);if(r.add(s?s.call(r,this.source):this.source||l.useDeprecatedSynchronousErrorHandling&&!r.syncErrorThrowable?this._subscribe(r):this._trySubscribe(r)),l.useDeprecatedSynchronousErrorHandling&&r.syncErrorThrowable&&(r.syncErrorThrowable=!1,r.syncErrorThrown))throw r.syncErrorValue;return r}_trySubscribe(e){try{return this._subscribe(e)}catch(t){l.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:n,isStopped:s}=e;if(t||s)return!1;e=n&&n instanceof y?n:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=I(t))((t,n)=>{let s;s=this.subscribe(t=>{try{e(t)}catch(r){n(r),s&&s.unsubscribe()}},n,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[w](){return this}pipe(...e){return 0===e.length?this:(0===(t=e).length?x:1===t.length?t[0]:function(e){return t.reduce((e,t)=>t(e),e)})(this);var t}toPromise(e){return new(e=I(e))((e,t)=>{let n;this.subscribe(e=>n=e,e=>t(e),()=>e(n))})}}return e.create=t=>new e(t),e})();function I(e){if(e||(e=l.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const C=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class _ extends m{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const n=t.indexOf(this.subscriber);-1!==n&&t.splice(n,1)}}class S extends y{constructor(e){super(e),this.destination=e}}let E=(()=>{class e extends k{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[b](){return new S(this)}lift(e){const t=new N(this,this);return t.operator=e,t}next(e){if(this.closed)throw new C;if(!this.isStopped){const{observers:t}=this,n=t.length,s=t.slice();for(let r=0;r<n;r++)s[r].next(e)}}error(e){if(this.closed)throw new C;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,n=t.length,s=t.slice();for(let r=0;r<n;r++)s[r].error(e);this.observers.length=0}complete(){if(this.closed)throw new C;this.isStopped=!0;const{observers:e}=this,t=e.length,n=e.slice();for(let s=0;s<t;s++)n[s].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new C;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new C;return this.hasError?(e.error(this.thrownError),m.EMPTY):this.isStopped?(e.complete(),m.EMPTY):(this.observers.push(e),new _(this,e))}asObservable(){const e=new k;return e.source=this,e}}return e.create=(e,t)=>new N(e,t),e})();class N extends E{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):m.EMPTY}}function $(e){return e&&"function"==typeof e.schedule}function T(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new A(e,t))}}class A{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new R(e,this.project,this.thisArg))}}class R extends y{constructor(e,t,n){super(e),this.project=t,this.count=0,this.thisArg=n||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const F=e=>t=>{for(let n=0,s=e.length;n<s&&!t.closed;n++)t.next(e[n]);t.complete()};function D(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const O=D(),M=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function z(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const L=e=>{if(e&&"function"==typeof e[w])return n=e,e=>{const t=n[w]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(M(e))return F(e);if(z(e))return(e=>t=>(e.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,c),t))(e);if(e&&"function"==typeof e[O])return t=e,e=>{const n=t[O]();for(;;){let t;try{t=n.next()}catch(s){return e.error(s),e}if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof n.return&&e.add(()=>{n.return&&n.return()}),e};{const t=p(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,n};function P(e,t){return new k(n=>{const s=new m;let r=0;return s.add(t.schedule(function(){r!==e.length?(n.next(e[r++]),n.closed||s.add(this.schedule())):n.complete()})),s})}function j(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[w]}(e))return function(e,t){return new k(n=>{const s=new m;return s.add(t.schedule(()=>{const r=e[w]();s.add(r.subscribe({next(e){s.add(t.schedule(()=>n.next(e)))},error(e){s.add(t.schedule(()=>n.error(e)))},complete(){s.add(t.schedule(()=>n.complete()))}}))})),s})}(e,t);if(z(e))return function(e,t){return new k(n=>{const s=new m;return s.add(t.schedule(()=>e.then(e=>{s.add(t.schedule(()=>{n.next(e),s.add(t.schedule(()=>n.complete()))}))},e=>{s.add(t.schedule(()=>n.error(e)))}))),s})}(e,t);if(M(e))return P(e,t);if(function(e){return e&&"function"==typeof e[O]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new k(n=>{const s=new m;let r;return s.add(()=>{r&&"function"==typeof r.return&&r.return()}),s.add(t.schedule(()=>{r=e[O](),s.add(t.schedule(function(){if(n.closed)return;let e,t;try{const n=r.next();e=n.value,t=n.done}catch(s){return void n.error(s)}t?n.complete():(n.next(e),this.schedule())}))})),s})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof k?e:new k(L(e))}class V extends y{constructor(e){super(),this.parent=e}_next(e){this.parent.notifyNext(e)}_error(e){this.parent.notifyError(e),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class W extends y{notifyNext(e){this.destination.next(e)}notifyError(e){this.destination.error(e)}notifyComplete(){this.destination.complete()}}function B(e,t){if(t.closed)return;if(e instanceof k)return e.subscribe(t);let n;try{n=L(e)(t)}catch(s){t.error(s)}return n}function q(e,t,n=Number.POSITIVE_INFINITY){return"function"==typeof t?s=>s.pipe(q((n,s)=>j(e(n,s)).pipe(T((e,r)=>t(n,e,s,r))),n)):("number"==typeof t&&(n=t),t=>t.lift(new U(e,n)))}class U{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new H(e,this.project,this.concurrent))}}class H extends W{constructor(e,t,n=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(s){return void this.destination.error(s)}this.active++,this._innerSub(t)}_innerSub(e){const t=new V(this),n=this.destination;n.add(t);const s=B(e,t);s!==t&&n.add(s)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e){this.destination.next(e)}notifyComplete(){const e=this.buffer;this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function G(e=Number.POSITIVE_INFINITY){return q(x,e)}function K(e,t){return t?P(e,t):new k(F(e))}function X(){return function(e){return e.lift(new Y(e))}}class Y{constructor(e){this.connectable=e}call(e,t){const{connectable:n}=this;n._refCount++;const s=new Z(e,n),r=t.subscribe(s);return s.closed||(s.connection=n.connect()),r}}class Z extends y{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:n}=this,s=e._connection;this.connection=null,!s||n&&s!==n||s.unsubscribe()}}class J extends k{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new m,e.add(this.source.subscribe(new ee(this.getSubject(),this))),e.closed&&(this._connection=null,e=m.EMPTY)),e}refCount(){return X()(this)}}const Q=(()=>{const e=J.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class ee extends S{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function te(){return new E}function ne(e){for(let t in e)if(e[t]===ne)return t;throw Error("Could not find renamed property on target object.")}function se(e,t){for(const n in t)t.hasOwnProperty(n)&&!e.hasOwnProperty(n)&&(e[n]=t[n])}function re(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(re).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function ae(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const ie=ne({__forward_ref__:ne});function oe(e){return e.__forward_ref__=oe,e.toString=function(){return re(this())},e}function ue(e){return le(e)?e():e}function le(e){return"function"==typeof e&&e.hasOwnProperty(ie)&&e.__forward_ref__===oe}class ce extends Error{constructor(e,t){super(function(e,t){return`${e?`NG0${e}: `:""}${t}`}(e,t)),this.code=e}}function he(e){return"string"==typeof e?e:null==e?"":String(e)}function de(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():he(e)}function pe(e,t){const n=t?` in ${t}`:"";throw new ce("201",`No provider for ${de(e)} found${n}`)}function fe(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function me(e){return{providers:e.providers||[],imports:e.imports||[]}}function ge(e){return be(e,ve)||be(e,xe)}function be(e,t){return e.hasOwnProperty(t)?e[t]:null}function ye(e){return e&&(e.hasOwnProperty(we)||e.hasOwnProperty(ke))?e[we]:null}const ve=ne({"\u0275prov":ne}),we=ne({"\u0275inj":ne}),xe=ne({ngInjectableDef:ne}),ke=ne({ngInjectorDef:ne});var Ie=function(e){return e[e.Default=0]="Default",e[e.Host=1]="Host",e[e.Self=2]="Self",e[e.SkipSelf=4]="SkipSelf",e[e.Optional=8]="Optional",e}({});let Ce;function _e(e){const t=Ce;return Ce=e,t}function Se(e,t,n){const s=ge(e);return s&&"root"==s.providedIn?void 0===s.value?s.value=s.factory():s.value:n&Ie.Optional?null:void 0!==t?t:void pe(re(e),"Injector")}function Ee(e){return{toString:e}.toString()}var Ne=function(e){return e[e.OnPush=0]="OnPush",e[e.Default=1]="Default",e}({}),$e=function(e){return e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",e}({});const Te="undefined"!=typeof globalThis&&globalThis,Ae="undefined"!=typeof window&&window,Re="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Fe="undefined"!=typeof global&&global,De=Te||Fe||Ae||Re,Oe={},Me=[],ze=ne({"\u0275cmp":ne}),Le=ne({"\u0275dir":ne}),Pe=ne({"\u0275pipe":ne}),je=ne({"\u0275mod":ne}),Ve=ne({"\u0275loc":ne}),We=ne({"\u0275fac":ne}),Be=ne({__NG_ELEMENT_ID__:ne});let qe=0;function Ue(e){return Ee(()=>{const t={},n={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===Ne.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||Me,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||$e.Emulated,id:"c",styles:e.styles||Me,_:null,setInput:null,schemas:e.schemas||null,tView:null},s=e.directives,r=e.features,a=e.pipes;return n.id+=qe++,n.inputs=Ye(e.inputs,t),n.outputs=Ye(e.outputs),r&&r.forEach(e=>e(n)),n.directiveDefs=s?()=>("function"==typeof s?s():s).map(He):null,n.pipeDefs=a?()=>("function"==typeof a?a():a).map(Ge):null,n})}function He(e){return Je(e)||function(e){return e[Le]||null}(e)}function Ge(e){return function(e){return e[Pe]||null}(e)}const Ke={};function Xe(e){return Ee(()=>{const t={type:e.type,bootstrap:e.bootstrap||Me,declarations:e.declarations||Me,imports:e.imports||Me,exports:e.exports||Me,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&(Ke[e.id]=e.type),t})}function Ye(e,t){if(null==e)return Oe;const n={};for(const s in e)if(e.hasOwnProperty(s)){let r=e[s],a=r;Array.isArray(r)&&(a=r[1],r=r[0]),n[r]=s,t&&(t[r]=a)}return n}const Ze=Ue;function Je(e){return e[ze]||null}function Qe(e,t){const n=e[je]||null;if(!n&&!0===t)throw new Error(`Type ${re(e)} does not have '\u0275mod' property.`);return n}const et=20,tt=10;function nt(e){return Array.isArray(e)&&"object"==typeof e[1]}function st(e){return Array.isArray(e)&&!0===e[1]}function rt(e){return 0!=(8&e.flags)}function at(e){return 2==(2&e.flags)}function it(e){return 1==(1&e.flags)}function ot(e){return null!==e.template}function ut(e,t){return e.hasOwnProperty(We)?e[We]:null}class lt{constructor(e,t,n){this.previousValue=e,this.currentValue=t,this.firstChange=n}isFirstChange(){return this.firstChange}}function ct(){return ht}function ht(e){return e.type.prototype.ngOnChanges&&(e.setInput=pt),dt}function dt(){const e=ft(this),t=null==e?void 0:e.current;if(t){const n=e.previous;if(n===Oe)e.previous=t;else for(let e in t)n[e]=t[e];e.current=null,this.ngOnChanges(t)}}function pt(e,t,n,s){const r=ft(e)||function(e,t){return e.__ngSimpleChanges__=t}(e,{previous:Oe,current:null}),a=r.current||(r.current={}),i=r.previous,o=this.declaredInputs[n],u=i[o];a[o]=new lt(u&&u.currentValue,t,i===Oe),e[s]=t}function ft(e){return e.__ngSimpleChanges__||null}let mt;function gt(e){return!!e.listen}ct.ngInherit=!0;const bt={createRenderer:(e,t)=>void 0!==mt?mt:"undefined"!=typeof document?document:void 0};function yt(e){for(;Array.isArray(e);)e=e[0];return e}function vt(e,t){return yt(t[e])}function wt(e,t){return yt(t[e.index])}function xt(e,t){return e.data[t]}function kt(e,t){const n=t[e];return nt(n)?n:n[0]}function It(e){return 4==(4&e[2])}function Ct(e){return 128==(128&e[2])}function _t(e,t){return null==t?null:e[t]}function St(e){e[18]=0}function Et(e,t){e[5]+=t;let n=e,s=e[3];for(;null!==s&&(1===t&&1===n[5]||-1===t&&0===n[5]);)s[5]+=t,n=s,s=s[3]}const Nt={lFrame:Gt(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function $t(){return Nt.bindingsEnabled}function Tt(){return Nt.lFrame.lView}function At(){return Nt.lFrame.tView}function Rt(){let e=Ft();for(;null!==e&&64===e.type;)e=e.parent;return e}function Ft(){return Nt.lFrame.currentTNode}function Dt(e,t){const n=Nt.lFrame;n.currentTNode=e,n.isParent=t}function Ot(){return Nt.lFrame.isParent}function Mt(){return Nt.isInCheckNoChangesMode}function zt(e){Nt.isInCheckNoChangesMode=e}function Lt(){return Nt.lFrame.bindingIndex++}function Pt(e,t){const n=Nt.lFrame;n.bindingIndex=n.bindingRootIndex=e,jt(t)}function jt(e){Nt.lFrame.currentDirectiveIndex=e}function Vt(){return Nt.lFrame.currentQueryIndex}function Wt(e){Nt.lFrame.currentQueryIndex=e}function Bt(e){const t=e[1];return 2===t.type?t.declTNode:1===t.type?e[6]:null}function qt(e,t,n){if(n&Ie.SkipSelf){let s=t,r=e;for(;s=s.parent,!(null!==s||n&Ie.Host||(s=Bt(r),null===s)||(r=r[15],10&s.type)););if(null===s)return!1;t=s,e=r}const s=Nt.lFrame=Ht();return s.currentTNode=t,s.lView=e,!0}function Ut(e){const t=Ht(),n=e[1];Nt.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function Ht(){const e=Nt.lFrame,t=null===e?null:e.child;return null===t?Gt(e):t}function Gt(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function Kt(){const e=Nt.lFrame;return Nt.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const Xt=Kt;function Yt(){const e=Kt();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function Zt(){return Nt.lFrame.selectedIndex}function Jt(e){Nt.lFrame.selectedIndex=e}function Qt(e,t){for(let n=t.directiveStart,s=t.directiveEnd;n<s;n++){const t=e.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:r,ngAfterViewInit:a,ngAfterViewChecked:i,ngOnDestroy:o}=t;s&&(e.contentHooks||(e.contentHooks=[])).push(-n,s),r&&((e.contentHooks||(e.contentHooks=[])).push(n,r),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,r)),a&&(e.viewHooks||(e.viewHooks=[])).push(-n,a),i&&((e.viewHooks||(e.viewHooks=[])).push(n,i),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,i)),null!=o&&(e.destroyHooks||(e.destroyHooks=[])).push(n,o)}}function en(e,t,n){sn(e,t,3,n)}function tn(e,t,n,s){(3&e[2])===n&&sn(e,t,n,s)}function nn(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function sn(e,t,n,s){const r=null!=s?s:-1,a=t.length-1;let i=0;for(let o=void 0!==s?65535&e[18]:0;o<a;o++)if("number"==typeof t[o+1]){if(i=t[o],null!=s&&i>=s)break}else t[o]<0&&(e[18]+=65536),(i<r||-1==r)&&(rn(e,n,t,o),e[18]=(4294901760&e[18])+o+2),o++}function rn(e,t,n,s){const r=n[s]<0,a=n[s+1],i=e[r?-n[s]:n[s]];if(r){if(e[2]>>11<e[18]>>16&&(3&e[2])===t){e[2]+=2048;try{a.call(i)}finally{}}}else try{a.call(i)}finally{}}const an=-1;class on{constructor(e,t,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=n}}function un(e,t,n){const s=gt(e);let r=0;for(;r<n.length;){const a=n[r];if("number"==typeof a){if(0!==a)break;r++;const i=n[r++],o=n[r++],u=n[r++];s?e.setAttribute(t,o,u,i):t.setAttributeNS(i,o,u)}else{const i=a,o=n[++r];cn(i)?s&&e.setProperty(t,i,o):s?e.setAttribute(t,i,o):t.setAttribute(i,o),r++}}return r}function ln(e){return 3===e||4===e||6===e}function cn(e){return 64===e.charCodeAt(0)}function hn(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let s=0;s<t.length;s++){const r=t[s];"number"==typeof r?n=r:0===n||dn(e,n,r,null,-1===n||2===n?t[++s]:null)}}return e}function dn(e,t,n,s,r){let a=0,i=e.length;if(-1===t)i=-1;else for(;a<e.length;){const n=e[a++];if("number"==typeof n){if(n===t){i=-1;break}if(n>t){i=a-1;break}}}for(;a<e.length;){const t=e[a];if("number"==typeof t)break;if(t===n){if(null===s)return void(null!==r&&(e[a+1]=r));if(s===e[a+1])return void(e[a+2]=r)}a++,null!==s&&a++,null!==r&&a++}-1!==i&&(e.splice(i,0,t),a=i+1),e.splice(a++,0,n),null!==s&&e.splice(a++,0,s),null!==r&&e.splice(a++,0,r)}function pn(e){return e!==an}function fn(e){return 32767&e}function mn(e,t){let n=e>>16,s=t;for(;n>0;)s=s[15],n--;return s}let gn=!0;function bn(e){const t=gn;return gn=e,t}let yn=0;function vn(e,t){const n=xn(e,t);if(-1!==n)return n;const s=t[1];s.firstCreatePass&&(e.injectorIndex=t.length,wn(s.data,e),wn(t,null),wn(s.blueprint,null));const r=kn(e,t),a=e.injectorIndex;if(pn(r)){const e=fn(r),n=mn(r,t),s=n[1].data;for(let r=0;r<8;r++)t[a+r]=n[e+r]|s[e+r]}return t[a+8]=r,a}function wn(e,t){e.push(0,0,0,0,0,0,0,0,t)}function xn(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function kn(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,s=null,r=t;for(;null!==r;){const e=r[1],t=e.type;if(s=2===t?e.declTNode:1===t?r[6]:null,null===s)return an;if(n++,r=r[15],-1!==s.injectorIndex)return s.injectorIndex|n<<16}return an}function In(e,t,n){!function(e,t,n){let s;"string"==typeof n?s=n.charCodeAt(0)||0:n.hasOwnProperty(Be)&&(s=n[Be]),null==s&&(s=n[Be]=yn++);const r=255&s;t.data[e+(r>>5)]|=1<<r}(e,t,n)}function Cn(e,t,n){if(n&Ie.Optional)return e;pe(t,"NodeInjector")}function _n(e,t,n,s){if(n&Ie.Optional&&void 0===s&&(s=null),0==(n&(Ie.Self|Ie.Host))){const r=e[9],a=_e(void 0);try{return r?r.get(t,s,n&Ie.Optional):Se(t,s,n&Ie.Optional)}finally{_e(a)}}return Cn(s,t,n)}function Sn(e,t,n,s=Ie.Default,r){if(null!==e){const a=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(Be)?e[Be]:void 0;return"number"==typeof t?t>=0?255&t:Nn:t}(n);if("function"==typeof a){if(!qt(t,e,s))return s&Ie.Host?Cn(r,n,s):_n(t,n,s,r);try{const e=a(s);if(null!=e||s&Ie.Optional)return e;pe(n)}finally{Xt()}}else if("number"==typeof a){let r=null,i=xn(e,t),o=an,u=s&Ie.Host?t[16][6]:null;for((-1===i||s&Ie.SkipSelf)&&(o=-1===i?kn(e,t):t[i+8],o!==an&&Fn(s,!1)?(r=t[1],i=fn(o),t=mn(o,t)):i=-1);-1!==i;){const e=t[1];if(Rn(a,i,e.data)){const e=$n(i,t,n,r,s,u);if(e!==En)return e}o=t[i+8],o!==an&&Fn(s,t[1].data[i+8]===u)&&Rn(a,i,t)?(r=e,i=fn(o),t=mn(o,t)):i=-1}}}return _n(t,n,s,r)}const En={};function Nn(){return new Dn(Rt(),Tt())}function $n(e,t,n,s,r,a){const i=t[1],o=i.data[e+8],u=Tn(o,i,n,null==s?at(o)&&gn:s!=i&&0!=(3&o.type),r&Ie.Host&&a===o);return null!==u?An(t,i,u,o):En}function Tn(e,t,n,s,r){const a=e.providerIndexes,i=t.data,o=1048575&a,u=e.directiveStart,l=a>>20,c=r?o+l:e.directiveEnd;for(let h=s?o:o+l;h<c;h++){const e=i[h];if(h<u&&n===e||h>=u&&e.type===n)return h}if(r){const e=i[u];if(e&&ot(e)&&e.type===n)return u}return null}function An(e,t,n,s){let r=e[n];const a=t.data;if(r instanceof on){const i=r;i.resolving&&function(e,t){throw new ce("200",`Circular dependency in DI detected for ${e}`)}(de(a[n]));const o=bn(i.canSeeViewProviders);i.resolving=!0;const u=i.injectImpl?_e(i.injectImpl):null;qt(e,s,Ie.Default);try{r=e[n]=i.factory(void 0,a,e,s),t.firstCreatePass&&n>=s.directiveStart&&function(e,t,n){const{ngOnChanges:s,ngOnInit:r,ngDoCheck:a}=t.type.prototype;if(s){const s=ht(t);(n.preOrderHooks||(n.preOrderHooks=[])).push(e,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,s)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-e,r),a&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,a),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,a))}(n,a[n],t)}finally{null!==u&&_e(u),bn(o),i.resolving=!1,Xt()}}return r}function Rn(e,t,n){return!!(n[t+(e>>5)]&1<<e)}function Fn(e,t){return!(e&Ie.Self||e&Ie.Host&&t)}class Dn{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return Sn(this._tNode,this._lView,e,void 0,t)}}function On(e){return Ee(()=>{const t=e.prototype.constructor,n=t[We]||Mn(t),s=Object.prototype;let r=Object.getPrototypeOf(e.prototype).constructor;for(;r&&r!==s;){const e=r[We]||Mn(r);if(e&&e!==n)return e;r=Object.getPrototypeOf(r)}return e=>new e})}function Mn(e){return le(e)?()=>{const t=Mn(ue(e));return t&&t()}:ut(e)}const zn="__parameters__";function Ln(e,t,n){return Ee(()=>{const s=function(e){return function(...t){if(e){const n=e(...t);for(const e in n)this[e]=n[e]}}}(t);function r(...e){if(this instanceof r)return s.apply(this,e),this;const t=new r(...e);return n.annotation=t,n;function n(e,n,s){const r=e.hasOwnProperty(zn)?e[zn]:Object.defineProperty(e,zn,{value:[]})[zn];for(;r.length<=s;)r.push(null);return(r[s]=r[s]||[]).push(t),e}}return n&&(r.prototype=Object.create(n.prototype)),r.prototype.ngMetadataName=e,r.annotationCls=r,r})}class Pn{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=fe({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return`InjectionToken ${this._desc}`}}const jn=new Pn("AnalyzeForEntryComponents"),Vn=Function;function Wn(e,t){void 0===t&&(t=e);for(let n=0;n<e.length;n++){let s=e[n];Array.isArray(s)?(t===e&&(t=e.slice(0,n)),Wn(s,t)):t!==e&&t.push(s)}return t}function Bn(e,t){e.forEach(e=>Array.isArray(e)?Bn(e,t):t(e))}function qn(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function Un(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}function Hn(e,t,n){let s=Kn(e,t);return s>=0?e[1|s]=n:(s=~s,function(e,t,n,s){let r=e.length;if(r==t)e.push(n,s);else if(1===r)e.push(s,e[0]),e[0]=n;else{for(r--,e.push(e[r-1],e[r]);r>t;)e[r]=e[r-2],r--;e[t]=n,e[t+1]=s}}(e,s,t,n)),s}function Gn(e,t){const n=Kn(e,t);if(n>=0)return e[1|n]}function Kn(e,t){return function(e,t,n){let s=0,r=e.length>>1;for(;r!==s;){const n=s+(r-s>>1),a=e[n<<1];if(t===a)return n<<1;a>t?r=n:s=n+1}return~(r<<1)}(e,t)}const Xn={},Yn=/\n/gm,Zn="__source",Jn=ne({provide:String,useValue:ne});let Qn;function es(e){const t=Qn;return Qn=e,t}function ts(e,t=Ie.Default){if(void 0===Qn)throw new Error("inject() must be called from an injection context");return null===Qn?Se(e,void 0,t):Qn.get(e,t&Ie.Optional?null:void 0,t)}function ns(e,t=Ie.Default){return(Ce||ts)(ue(e),t)}function ss(e){const t=[];for(let n=0;n<e.length;n++){const s=ue(e[n]);if(Array.isArray(s)){if(0===s.length)throw new Error("Arguments array must have arguments.");let e,n=Ie.Default;for(let t=0;t<s.length;t++){const r=s[t],a=r.__NG_DI_FLAG__;"number"==typeof a?-1===a?e=r.token:n|=a:e=r}t.push(ns(e,n))}else t.push(ns(s))}return t}function rs(e,t){return e.__NG_DI_FLAG__=t,e.prototype.__NG_DI_FLAG__=t,e}const as=rs(Ln("Inject",e=>({token:e})),-1),is=rs(Ln("Optional"),8),os=rs(Ln("SkipSelf"),4);function us(e,t){e.__ngContext__=t}function ls(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function cs(e){return e.ngDebugContext}function hs(e){return e.ngOriginalError}function ds(e,...t){e.error(...t)}class ps{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),n=this._findContext(e),s=function(e){return e.ngErrorLogger||ds}(e);s(this._console,"ERROR",e),t&&s(this._console,"ORIGINAL ERROR",t),n&&s(this._console,"ERROR CONTEXT",n)}_findContext(e){return e?cs(e)?cs(e):this._findContext(hs(e)):null}_findOriginalError(e){let t=hs(e);for(;t&&hs(t);)t=hs(t);return t}}const fs=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(De))();function ms(e){return e instanceof Function?e():e}var gs=function(e){return e[e.Important=1]="Important",e[e.DashCase=2]="DashCase",e}({});function bs(e,t){return(void 0)(e,t)}function ys(e){const t=e[3];return st(t)?t[3]:t}function vs(e){return xs(e[13])}function ws(e){return xs(e[4])}function xs(e){for(;null!==e&&!st(e);)e=e[4];return e}function ks(e,t,n,s,r){if(null!=s){let a,i=!1;st(s)?a=s:nt(s)&&(i=!0,s=s[0]);const o=yt(s);0===e&&null!==n?null==r?$s(t,n,o):Ns(t,n,o,r||null,!0):1===e&&null!==n?Ns(t,n,o,r||null,!0):2===e?function(e,t,n){const s=As(e,t);s&&function(e,t,n,s){gt(e)?e.removeChild(t,n,s):t.removeChild(n)}(e,s,t,n)}(t,o,i):3===e&&t.destroyNode(o),null!=a&&function(e,t,n,s,r){const a=n[7];a!==yt(n)&&ks(t,e,s,a,r);for(let i=tt;i<n.length;i++){const r=n[i];zs(r[1],r,e,t,s,a)}}(t,e,a,n,r)}}function Is(e,t,n){return gt(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function Cs(e,t){const n=e[9],s=n.indexOf(t),r=t[3];1024&t[2]&&(t[2]&=-1025,Et(r,-1)),n.splice(s,1)}function _s(e,t){if(e.length<=tt)return;const n=tt+t,s=e[n];if(s){const a=s[17];null!==a&&a!==e&&Cs(a,s),t>0&&(e[n-1][4]=s[4]);const i=Un(e,tt+t);zs(s[1],r=s,r[11],2,null,null),r[0]=null,r[6]=null;const o=i[19];null!==o&&o.detachView(i[1]),s[3]=null,s[4]=null,s[2]&=-129}var r;return s}function Ss(e,t){if(!(256&t[2])){const n=t[11];gt(n)&&n.destroyNode&&zs(e,t,n,3,null,null),function(e){let t=e[13];if(!t)return Es(e[1],e);for(;t;){let n=null;if(nt(t))n=t[13];else{const e=t[10];e&&(n=e)}if(!n){for(;t&&!t[4]&&t!==e;)nt(t)&&Es(t[1],t),t=t[3];null===t&&(t=e),nt(t)&&Es(t[1],t),n=t&&t[4]}t=n}}(t)}}function Es(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let s=0;s<n.length;s+=2){const e=t[n[s]];if(!(e instanceof on)){const t=n[s+1];if(Array.isArray(t))for(let n=0;n<t.length;n+=2){const s=e[t[n]],r=t[n+1];try{r.call(s)}finally{}}else try{t.call(e)}finally{}}}}(e,t),function(e,t){const n=e.cleanup,s=t[7];let r=-1;if(null!==n)for(let a=0;a<n.length-1;a+=2)if("string"==typeof n[a]){const e=n[a+1],i="function"==typeof e?e(t):yt(t[e]),o=s[r=n[a+2]],u=n[a+3];"boolean"==typeof u?i.removeEventListener(n[a],o,u):u>=0?s[r=u]():s[r=-u].unsubscribe(),a+=2}else{const e=s[r=n[a+1]];n[a].call(e)}if(null!==s){for(let e=r+1;e<s.length;e++)(0,s[e])();t[7]=null}}(e,t),1===t[1].type&&gt(t[11])&&t[11].destroy();const n=t[17];if(null!==n&&st(t[3])){n!==t[3]&&Cs(n,t);const s=t[19];null!==s&&s.detachView(e)}}}function Ns(e,t,n,s,r){gt(e)?e.insertBefore(t,n,s,r):t.insertBefore(n,s,r)}function $s(e,t,n){gt(e)?e.appendChild(t,n):t.appendChild(n)}function Ts(e,t,n,s,r){null!==s?Ns(e,t,n,s,r):$s(e,t,n)}function As(e,t){return gt(e)?e.parentNode(t):t.parentNode}function Rs(e,t,n,s){const r=function(e,t,n){return function(e,t,n){let s=t;for(;null!==s&&40&s.type;)s=(t=s).parent;if(null===s)return n[0];if(2&s.flags){const t=e.data[s.directiveStart].encapsulation;if(t===$e.None||t===$e.Emulated)return null}return wt(s,n)}(e,t.parent,n)}(e,s,t),a=t[11],i=function(e,t,n){return function(e,t,n){return 40&e.type?wt(e,n):null}(e,0,n)}(s.parent||t[6],0,t);if(null!=r)if(Array.isArray(n))for(let o=0;o<n.length;o++)Ts(a,r,n[o],i,!1);else Ts(a,r,n,i,!1)}function Fs(e,t){if(null!==t){const n=t.type;if(3&n)return wt(t,e);if(4&n)return Os(-1,e[t.index]);if(8&n){const n=t.child;if(null!==n)return Fs(e,n);{const n=e[t.index];return st(n)?Os(-1,n):yt(n)}}if(32&n)return bs(t,e)()||yt(e[t.index]);{const n=Ds(e,t);return null!==n?Array.isArray(n)?n[0]:Fs(ys(e[16]),n):Fs(e,t.next)}}return null}function Ds(e,t){return null!==t?e[16][6].projection[t.projection]:null}function Os(e,t){const n=tt+e+1;if(n<t.length){const e=t[n],s=e[1].firstChild;if(null!==s)return Fs(e,s)}return t[7]}function Ms(e,t,n,s,r,a,i){for(;null!=n;){const o=s[n.index],u=n.type;if(i&&0===t&&(o&&us(yt(o),s),n.flags|=4),64!=(64&n.flags))if(8&u)Ms(e,t,n.child,s,r,a,!1),ks(t,e,r,o,a);else if(32&u){const i=bs(n,s);let u;for(;u=i();)ks(t,e,r,u,a);ks(t,e,r,o,a)}else 16&u?Ls(e,t,s,n,r,a):ks(t,e,r,o,a);n=i?n.projectionNext:n.next}}function zs(e,t,n,s,r,a){Ms(n,s,e.firstChild,t,r,a,!1)}function Ls(e,t,n,s,r,a){const i=n[16],o=i[6].projection[s.projection];if(Array.isArray(o))for(let u=0;u<o.length;u++)ks(t,e,r,o[u],a);else Ms(e,t,o,i[3],r,a,!0)}function Ps(e,t,n){gt(e)?e.setAttribute(t,"style",n):t.style.cssText=n}function js(e,t,n){gt(e)?""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n):t.className=n}function Vs(e,t,n){let s=e.length;for(;;){const r=e.indexOf(t,n);if(-1===r)return r;if(0===r||e.charCodeAt(r-1)<=32){const n=t.length;if(r+n===s||e.charCodeAt(r+n)<=32)return r}n=r+1}}const Ws="ng-template";function Bs(e,t,n){let s=0;for(;s<e.length;){let r=e[s++];if(n&&"class"===r){if(r=e[s],-1!==Vs(r.toLowerCase(),t,0))return!0}else if(1===r){for(;s<e.length&&"string"==typeof(r=e[s++]);)if(r.toLowerCase()===t)return!0;return!1}}return!1}function qs(e){return 4===e.type&&e.value!==Ws}function Us(e,t,n){return t===(4!==e.type||n?e.value:Ws)}function Hs(e,t,n){let s=4;const r=e.attrs||[],a=function(e){for(let t=0;t<e.length;t++)if(ln(e[t]))return t;return e.length}(r);let i=!1;for(let o=0;o<t.length;o++){const u=t[o];if("number"!=typeof u){if(!i)if(4&s){if(s=2|1&s,""!==u&&!Us(e,u,n)||""===u&&1===t.length){if(Gs(s))return!1;i=!0}}else{const l=8&s?u:t[++o];if(8&s&&null!==e.attrs){if(!Bs(e.attrs,l,n)){if(Gs(s))return!1;i=!0}continue}const c=Ks(8&s?"class":u,r,qs(e),n);if(-1===c){if(Gs(s))return!1;i=!0;continue}if(""!==l){let e;e=c>a?"":r[c+1].toLowerCase();const t=8&s?e:null;if(t&&-1!==Vs(t,l,0)||2&s&&l!==e){if(Gs(s))return!1;i=!0}}}}else{if(!i&&!Gs(s)&&!Gs(u))return!1;if(i&&Gs(u))continue;i=!1,s=u|1&s}}return Gs(s)||i}function Gs(e){return 0==(1&e)}function Ks(e,t,n,s){if(null===t)return-1;let r=0;if(s||!n){let n=!1;for(;r<t.length;){const s=t[r];if(s===e)return r;if(3===s||6===s)n=!0;else{if(1===s||2===s){let e=t[++r];for(;"string"==typeof e;)e=t[++r];continue}if(4===s)break;if(0===s){r+=4;continue}}r+=n?1:2}return-1}return function(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const s=e[n];if("number"==typeof s)return-1;if(s===t)return n;n++}return-1}(t,e)}function Xs(e,t,n=!1){for(let s=0;s<t.length;s++)if(Hs(e,t[s],n))return!0;return!1}function Ys(e,t){return e?":not("+t.trim()+")":t}function Zs(e){let t=e[0],n=1,s=2,r="",a=!1;for(;n<e.length;){let i=e[n];if("string"==typeof i)if(2&s){const t=e[++n];r+="["+i+(t.length>0?'="'+t+'"':"")+"]"}else 8&s?r+="."+i:4&s&&(r+=" "+i);else""===r||Gs(i)||(t+=Ys(a,r),r=""),s=i,a=a||!Gs(s);n++}return""!==r&&(t+=Ys(a,r)),t}const Js={};function Qs(e){er(At(),Tt(),Zt()+e,Mt())}function er(e,t,n,s){if(!s)if(3==(3&t[2])){const s=e.preOrderCheckHooks;null!==s&&en(t,s,n)}else{const s=e.preOrderHooks;null!==s&&tn(t,s,0,n)}Jt(n)}function tr(e,t){return e<<17|t<<2}function nr(e){return e>>17&32767}function sr(e){return 2|e}function rr(e){return(131068&e)>>2}function ar(e,t){return-131069&e|t<<2}function ir(e){return 1|e}function or(e,t){const n=e.contentQueries;if(null!==n)for(let s=0;s<n.length;s+=2){const r=n[s],a=n[s+1];if(-1!==a){const n=e.data[a];Wt(r),n.contentQueries(2,t[a],a)}}}function ur(e,t,n,s,r,a,i,o,u,l){const c=t.blueprint.slice();return c[0]=r,c[2]=140|s,St(c),c[3]=c[15]=e,c[8]=n,c[10]=i||e&&e[10],c[11]=o||e&&e[11],c[12]=u||e&&e[12]||null,c[9]=l||e&&e[9]||null,c[6]=a,c[16]=2==t.type?e[16]:c,c}function lr(e,t,n,s,r){let a=e.data[t];if(null===a)a=function(e,t,n,s,r){const a=Ft(),i=Ot(),o=e.data[t]=function(e,t,n,s,r,a){return{type:n,index:s,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:a,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?a:a&&a.parent,n,t,s,r);return null===e.firstChild&&(e.firstChild=o),null!==a&&(i?null==a.child&&null!==o.parent&&(a.child=o):null===a.next&&(a.next=o)),o}(e,t,n,s,r),Nt.lFrame.inI18n&&(a.flags|=64);else if(64&a.type){a.type=n,a.value=s,a.attrs=r;const e=function(){const e=Nt.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();a.injectorIndex=null===e?-1:e.injectorIndex}return Dt(a,!0),a}function cr(e,t,n,s){if(0===n)return-1;const r=t.length;for(let a=0;a<n;a++)t.push(s),e.blueprint.push(s),e.data.push(null);return r}function hr(e,t,n){Ut(t);try{const s=e.viewQuery;null!==s&&Pr(1,s,n);const r=e.template;null!==r&&fr(e,t,r,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&or(e,t),e.staticViewQueries&&Pr(2,e.viewQuery,n);const a=e.components;null!==a&&function(e,t){for(let n=0;n<t.length;n++)Dr(e,t[n])}(t,a)}catch(s){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),s}finally{t[2]&=-5,Yt()}}function dr(e,t,n,s){const r=t[2];if(256==(256&r))return;Ut(t);const a=Mt();try{St(t),Nt.lFrame.bindingIndex=e.bindingStartIndex,null!==n&&fr(e,t,n,2,s);const i=3==(3&r);if(!a)if(i){const n=e.preOrderCheckHooks;null!==n&&en(t,n,null)}else{const n=e.preOrderHooks;null!==n&&tn(t,n,0,null),nn(t,0)}if(function(e){for(let t=vs(e);null!==t;t=ws(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const n=e[t],s=n[3];0==(1024&n[2])&&Et(s,1),n[2]|=1024}}}(t),function(e){for(let t=vs(e);null!==t;t=ws(t))for(let e=tt;e<t.length;e++){const n=t[e],s=n[1];Ct(n)&&dr(s,n,s.template,n[8])}}(t),null!==e.contentQueries&&or(e,t),!a)if(i){const n=e.contentCheckHooks;null!==n&&en(t,n)}else{const n=e.contentHooks;null!==n&&tn(t,n,1),nn(t,1)}!function(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let e=0;e<n.length;e++){const s=n[e];if(s<0)Jt(~s);else{const r=s,a=n[++e],i=n[++e];Pt(a,r),i(2,t[r])}}}finally{Jt(-1)}}(e,t);const o=e.components;null!==o&&function(e,t){for(let n=0;n<t.length;n++)Rr(e,t[n])}(t,o);const u=e.viewQuery;if(null!==u&&Pr(2,u,s),!a)if(i){const n=e.viewCheckHooks;null!==n&&en(t,n)}else{const n=e.viewHooks;null!==n&&tn(t,n,2),nn(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),a||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,Et(t[3],-1))}finally{Yt()}}function pr(e,t,n,s){const r=t[10],a=!Mt(),i=It(t);try{a&&!i&&r.begin&&r.begin(),i&&hr(e,t,s),dr(e,t,n,s)}finally{a&&!i&&r.end&&r.end()}}function fr(e,t,n,s,r){const a=Zt(),i=2&s;try{Jt(-1),i&&t.length>et&&er(e,t,et,Mt()),n(s,r)}finally{Jt(a)}}function mr(e,t,n){$t()&&(function(e,t,n,s){const r=n.directiveStart,a=n.directiveEnd;e.firstCreatePass||vn(n,t),us(s,t);const i=n.initialInputs;for(let o=r;o<a;o++){const s=e.data[o],a=ot(s);a&&Nr(t,n,s);const u=An(t,e,o,n);us(u,t),null!==i&&$r(0,o-r,u,s,0,i),a&&(kt(n.index,t)[8]=u)}}(e,t,n,wt(n,t)),128==(128&n.flags)&&function(e,t,n){const s=n.directiveStart,r=n.directiveEnd,a=n.index,i=Nt.lFrame.currentDirectiveIndex;try{Jt(a);for(let n=s;n<r;n++){const s=e.data[n],r=t[n];jt(n),null===s.hostBindings&&0===s.hostVars&&null===s.hostAttrs||Ir(s,r)}}finally{Jt(-1),jt(i)}}(e,t,n))}function gr(e,t,n=wt){const s=t.localNames;if(null!==s){let r=t.index+1;for(let a=0;a<s.length;a+=2){const i=s[a+1],o=-1===i?n(t,e):e[i];e[r++]=o}}}function br(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=yr(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function yr(e,t,n,s,r,a,i,o,u,l){const c=et+s,h=c+r,d=function(e,t){const n=[];for(let s=0;s<t;s++)n.push(s<e?null:Js);return n}(c,h),p="function"==typeof l?l():l;return d[1]={type:e,blueprint:d,template:n,queries:null,viewQuery:o,declTNode:t,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof a?a():a,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:u,consts:p,incompleteFirstPass:!1}}function vr(e,t,n,s){const r=Vr(t);null===n?r.push(s):(r.push(n),e.firstCreatePass&&Wr(e).push(s,r.length-1))}function wr(e,t,n){for(let s in e)if(e.hasOwnProperty(s)){const r=e[s];(n=null===n?{}:n).hasOwnProperty(s)?n[s].push(t,r):n[s]=[t,r]}return n}function xr(e,t,n,s){let r=!1;if($t()){const a=function(e,t,n){const s=e.directiveRegistry;let r=null;if(s)for(let a=0;a<s.length;a++){const i=s[a];Xs(n,i.selectors,!1)&&(r||(r=[]),In(vn(n,t),e,i.type),ot(i)?(Cr(e,n),r.unshift(i)):r.push(i))}return r}(e,t,n),i=null===s?null:{"":-1};if(null!==a){r=!0,Sr(n,e.data.length,a.length);for(let e=0;e<a.length;e++){const t=a[e];t.providersResolver&&t.providersResolver(t)}let s=!1,o=!1,u=cr(e,t,a.length,null);for(let r=0;r<a.length;r++){const l=a[r];n.mergedAttrs=hn(n.mergedAttrs,l.hostAttrs),Er(e,n,t,u,l),_r(u,l,i),null!==l.contentQueries&&(n.flags|=8),null===l.hostBindings&&null===l.hostAttrs&&0===l.hostVars||(n.flags|=128);const c=l.type.prototype;!s&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n.index),s=!0),o||!c.ngOnChanges&&!c.ngDoCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n.index),o=!0),u++}!function(e,t){const n=t.directiveEnd,s=e.data,r=t.attrs,a=[];let i=null,o=null;for(let u=t.directiveStart;u<n;u++){const e=s[u],n=e.inputs,l=null===r||qs(t)?null:Tr(n,r);a.push(l),i=wr(n,u,i),o=wr(e.outputs,u,o)}null!==i&&(i.hasOwnProperty("class")&&(t.flags|=16),i.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=a,t.inputs=i,t.outputs=o}(e,n)}i&&function(e,t,n){if(t){const s=e.localNames=[];for(let e=0;e<t.length;e+=2){const r=n[t[e+1]];if(null==r)throw new ce("301",`Export of name '${t[e+1]}' not found!`);s.push(t[e],r)}}}(n,s,i)}return n.mergedAttrs=hn(n.mergedAttrs,n.attrs),r}function kr(e,t,n,s,r,a){const i=a.hostBindings;if(i){let n=e.hostBindingOpCodes;null===n&&(n=e.hostBindingOpCodes=[]);const a=~t.index;(function(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(n)!=a&&n.push(a),n.push(s,r,i)}}function Ir(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function Cr(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function _r(e,t,n){if(n){if(t.exportAs)for(let s=0;s<t.exportAs.length;s++)n[t.exportAs[s]]=e;ot(t)&&(n[""]=e)}}function Sr(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function Er(e,t,n,s,r){e.data[s]=r;const a=r.factory||(r.factory=ut(r.type)),i=new on(a,ot(r),null);e.blueprint[s]=i,n[s]=i,kr(e,t,0,s,cr(e,n,r.hostVars,Js),r)}function Nr(e,t,n){const s=wt(t,e),r=br(n),a=e[10],i=Or(e,ur(e,r,null,n.onPush?64:16,s,t,a,a.createRenderer(s,n),null,null));e[t.index]=i}function $r(e,t,n,s,r,a){const i=a[t];if(null!==i){const e=s.setInput;for(let t=0;t<i.length;){const r=i[t++],a=i[t++],o=i[t++];null!==e?s.setInput(n,o,r,a):n[a]=o}}}function Tr(e,t){let n=null,s=0;for(;s<t.length;){const r=t[s];if(0!==r)if(5!==r){if("number"==typeof r)break;e.hasOwnProperty(r)&&(null===n&&(n=[]),n.push(r,e[r],t[s+1])),s+=2}else s+=2;else s+=4}return n}function Ar(e,t,n,s){return new Array(e,!0,!1,t,null,0,s,n,null,null)}function Rr(e,t){const n=kt(t,e);if(Ct(n)){const e=n[1];80&n[2]?dr(e,n,e.template,n[8]):n[5]>0&&Fr(n)}}function Fr(e){for(let n=vs(e);null!==n;n=ws(n))for(let e=tt;e<n.length;e++){const t=n[e];if(1024&t[2]){const e=t[1];dr(e,t,e.template,t[8])}else t[5]>0&&Fr(t)}const t=e[1].components;if(null!==t)for(let n=0;n<t.length;n++){const s=kt(t[n],e);Ct(s)&&s[5]>0&&Fr(s)}}function Dr(e,t){const n=kt(t,e),s=n[1];!function(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(s,n),hr(s,n,n[8])}function Or(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function Mr(e){for(;e;){e[2]|=64;const t=ys(e);if(0!=(512&e[2])&&!t)return e;e=t}return null}function zr(e,t,n){const s=t[10];s.begin&&s.begin();try{dr(e,t,e.template,n)}catch(r){throw Br(t,r),r}finally{s.end&&s.end()}}function Lr(e){!function(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],s=ls(n),r=s[1];pr(r,s,r.template,n)}}(e[8])}function Pr(e,t,n){Wt(0),t(e,n)}const jr=(()=>Promise.resolve(null))();function Vr(e){return e[7]||(e[7]=[])}function Wr(e){return e.cleanup||(e.cleanup=[])}function Br(e,t){const n=e[9],s=n?n.get(ps,null):null;s&&s.handleError(t)}function qr(e,t,n,s,r){for(let a=0;a<n.length;){const i=n[a++],o=n[a++],u=t[i],l=e.data[i];null!==l.setInput?l.setInput(u,r,s,o):u[o]=r}}function Ur(e,t,n){let s=n?e.styles:null,r=n?e.classes:null,a=0;if(null!==t)for(let i=0;i<t.length;i++){const e=t[i];"number"==typeof e?a=e:1==a?r=ae(r,e):2==a&&(s=ae(s,e+": "+t[++i]+";"))}n?e.styles=s:e.stylesWithoutHost=s,n?e.classes=r:e.classesWithoutHost=r}const Hr=new Pn("INJECTOR",-1);class Gr{get(e,t=Xn){if(t===Xn){const t=new Error(`NullInjectorError: No provider for ${re(e)}!`);throw t.name="NullInjectorError",t}return t}}const Kr=new Pn("Set Injector scope."),Xr={},Yr={};let Zr;function Jr(){return void 0===Zr&&(Zr=new Gr),Zr}function Qr(e,t=null,n=null,s){return new ea(e,n,t||Jr(),s)}class ea{constructor(e,t,n,s=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const r=[];t&&Bn(t,n=>this.processProvider(n,e,t)),Bn([e],e=>this.processInjectorType(e,[],r)),this.records.set(Hr,sa(void 0,this));const a=this.records.get(Kr);this.scope=null!=a?a.value:null,this.source=s||("object"==typeof e?null:re(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=Xn,n=Ie.Default){this.assertNotDestroyed();const s=es(this);try{if(!(n&Ie.SkipSelf)){let t=this.records.get(e);if(void 0===t){const n=("function"==typeof(r=e)||"object"==typeof r&&r instanceof Pn)&&ge(e);t=n&&this.injectableDefInScope(n)?sa(ta(e),Xr):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(n&Ie.Self?Jr():this.parent).get(e,t=n&Ie.Optional&&t===Xn?null:t)}catch(a){if("NullInjectorError"===a.name){if((a.ngTempTokenPath=a.ngTempTokenPath||[]).unshift(re(e)),s)throw a;return function(e,t,n,s){const r=e.ngTempTokenPath;throw t[Zn]&&r.unshift(t[Zn]),e.message=function(e,t,n,s=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let r=re(t);if(Array.isArray(t))r=t.map(re).join(" -> ");else if("object"==typeof t){let e=[];for(let n in t)if(t.hasOwnProperty(n)){let s=t[n];e.push(n+":"+("string"==typeof s?JSON.stringify(s):re(s)))}r=`{${e.join(", ")}}`}return`${n}${s?"("+s+")":""}[${r}]: ${e.replace(Yn,"\n  ")}`}("\n"+e.message,r,n,s),e.ngTokenPath=r,e.ngTempTokenPath=null,e}(a,e,"R3InjectorError",this.source)}throw a}finally{es(s)}var r}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,n)=>e.push(re(n))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,n){if(!(e=ue(e)))return!1;let s=ye(e);const r=null==s&&e.ngModule||void 0,a=void 0===r?e:r,i=-1!==n.indexOf(a);if(void 0!==r&&(s=ye(r)),null==s)return!1;if(null!=s.imports&&!i){let e;n.push(a);try{Bn(s.imports,s=>{this.processInjectorType(s,t,n)&&(void 0===e&&(e=[]),e.push(s))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:n,providers:s}=e[t];Bn(s,e=>this.processProvider(e,n,s||Me))}}this.injectorDefTypes.add(a);const o=ut(a)||(()=>new a);this.records.set(a,sa(o,Xr));const u=s.providers;if(null!=u&&!i){const t=e;Bn(u,e=>this.processProvider(e,t,u))}return void 0!==r&&void 0!==e.providers}processProvider(e,t,n){let s=aa(e=ue(e))?e:ue(e&&e.provide);const r=function(e,t,n){return ra(e)?sa(void 0,e.useValue):sa(na(e),Xr)}(e);if(aa(e)||!0!==e.multi)this.records.get(s);else{let t=this.records.get(s);t||(t=sa(void 0,Xr,!0),t.factory=()=>ss(t.multi),this.records.set(s,t)),s=e,t.multi.push(e)}this.records.set(s,r)}hydrate(e,t){var n;return t.value===Xr&&(t.value=Yr,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(n=t.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){if(!e.providedIn)return!1;const t=ue(e.providedIn);return"string"==typeof t?"any"===t||t===this.scope:this.injectorDefTypes.has(t)}}function ta(e){const t=ge(e),n=null!==t?t.factory:ut(e);if(null!==n)return n;if(e instanceof Pn)throw new Error(`Token ${re(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const n=function(e,t){const n=[];for(let s=0;s<e;s++)n.push("?");return n}(t);throw new Error(`Can't resolve all parameters for ${re(e)}: (${n.join(", ")}).`)}const n=function(e){const t=e&&(e[ve]||e[xe]);if(t){const n=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Error("unreachable")}function na(e,t,n){let s;if(aa(e)){const t=ue(e);return ut(t)||ta(t)}if(ra(e))s=()=>ue(e.useValue);else if((r=e)&&r.useFactory)s=()=>e.useFactory(...ss(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))s=()=>ns(ue(e.useExisting));else{const t=ue(e&&(e.useClass||e.provide));if(!function(e){return!!e.deps}(e))return ut(t)||ta(t);s=()=>new t(...ss(e.deps))}var r;return s}function sa(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function ra(e){return null!==e&&"object"==typeof e&&Jn in e}function aa(e){return"function"==typeof e}const ia=function(e,t,n){return function(e,t=null,n=null,s){const r=Qr(e,t,n,s);return r._resolveInjectorDefTypes(),r}({name:n},t,e,n)};let oa=(()=>{class e{static create(e,t){return Array.isArray(e)?ia(e,t,""):ia(e.providers,e.parent,e.name||"")}}return e.THROW_IF_NOT_FOUND=Xn,e.NULL=new Gr,e.\u0275prov=fe({token:e,providedIn:"any",factory:()=>ns(Hr)}),e.__NG_ELEMENT_ID__=-1,e})();function ua(e,t){Qt(ls(e)[1],Rt())}function la(e){let t=Object.getPrototypeOf(e.type.prototype).constructor,n=!0;const s=[e];for(;t;){let r;if(ot(e))r=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Error("Directives cannot inherit Components");r=t.\u0275dir}if(r){if(n){s.push(r);const t=e;t.inputs=ca(e.inputs),t.declaredInputs=ca(e.declaredInputs),t.outputs=ca(e.outputs);const n=r.hostBindings;n&&pa(e,n);const a=r.viewQuery,i=r.contentQueries;if(a&&ha(e,a),i&&da(e,i),se(e.inputs,r.inputs),se(e.declaredInputs,r.declaredInputs),se(e.outputs,r.outputs),ot(r)&&r.data.animation){const t=e.data;t.animation=(t.animation||[]).concat(r.data.animation)}}const t=r.features;if(t)for(let s=0;s<t.length;s++){const r=t[s];r&&r.ngInherit&&r(e),r===la&&(n=!1)}}t=Object.getPrototypeOf(t)}!function(e){let t=0,n=null;for(let s=e.length-1;s>=0;s--){const r=e[s];r.hostVars=t+=r.hostVars,r.hostAttrs=hn(r.hostAttrs,n=hn(n,r.hostAttrs))}}(s)}function ca(e){return e===Oe?{}:e===Me?[]:e}function ha(e,t){const n=e.viewQuery;e.viewQuery=n?(e,s)=>{t(e,s),n(e,s)}:t}function da(e,t){const n=e.contentQueries;e.contentQueries=n?(e,s,r)=>{t(e,s,r),n(e,s,r)}:t}function pa(e,t){const n=e.hostBindings;e.hostBindings=n?(e,s)=>{t(e,s),n(e,s)}:t}let fa=null;function ma(){if(!fa){const e=De.Symbol;if(e&&e.iterator)fa=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const n=e[t];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(fa=n)}}}return fa}function ga(e){return!!ba(e)&&(Array.isArray(e)||!(e instanceof Map)&&ma()in e)}function ba(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function ya(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}function va(e,t=Ie.Default){const n=Tt();return null===n?ns(e,t):Sn(Rt(),n,ue(e),t)}function wa(e,t,n){const s=Tt();return ya(s,Lt(),t)&&function(e,t,n,s,r,a,i,o){const u=wt(t,n);let l,c=t.inputs;var h;null!=c&&(l=c[s])?(qr(e,n,l,s,r),at(t)&&function(e,t){const n=kt(t,e);16&n[2]||(n[2]|=64)}(n,t.index)):3&t.type&&(s="class"===(h=s)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,r=null!=i?i(r,t.value||"",s):r,gt(a)?a.setProperty(u,s,r):cn(s)||(u.setProperty?u.setProperty(s,r):u[s]=r))}(At(),function(){const e=Nt.lFrame;return xt(e.tView,e.selectedIndex)}(),s,e,t,s[11],n),wa}function xa(e,t,n,s,r){const a=r?"class":"style";qr(e,n,t.inputs[a],a,s)}function ka(e,t,n,s){const r=Tt(),a=At(),i=et+e,o=r[11],u=r[i]=Is(o,t,Nt.lFrame.currentNamespace),l=a.firstCreatePass?function(e,t,n,s,r,a,i){const o=t.consts,u=lr(t,e,2,r,_t(o,a));return xr(t,n,u,_t(o,i)),null!==u.attrs&&Ur(u,u.attrs,!1),null!==u.mergedAttrs&&Ur(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(i,a,r,0,t,n,s):a.data[i];Dt(l,!0);const c=l.mergedAttrs;null!==c&&un(o,u,c);const h=l.classes;null!==h&&js(o,u,h);const d=l.styles;null!==d&&Ps(o,u,d),64!=(64&l.flags)&&Rs(a,r,u,l),0===Nt.lFrame.elementDepthCount&&us(u,r),Nt.lFrame.elementDepthCount++,it(l)&&(mr(a,r,l),function(e,t,n){if(rt(t)){const s=t.directiveEnd;for(let r=t.directiveStart;r<s;r++){const t=e.data[r];t.contentQueries&&t.contentQueries(1,n[r],r)}}}(a,l,r)),null!==s&&gr(r,l)}function Ia(){let e=Rt();Ot()?Nt.lFrame.isParent=!1:(e=e.parent,Dt(e,!1));const t=e;Nt.lFrame.elementDepthCount--;const n=At();n.firstCreatePass&&(Qt(n,e),rt(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&xa(n,t,Tt(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&xa(n,t,Tt(),t.stylesWithoutHost,!1)}function Ca(e,t,n,s){ka(e,t,n,s),Ia()}function _a(e){return!!e&&"function"==typeof e.then}const Sa=function(e){return!!e&&"function"==typeof e.subscribe};function Ea(e,t,n,s){const r=Tt(),a=At(),i=Rt();return function(e,t,n,s,r,a,i,o){const u=it(s),l=e.firstCreatePass&&Wr(e),c=Vr(t);let h=!0;if(3&s.type||o){const d=wt(s,t),p=o?o(d):d,f=c.length,m=o?e=>o(yt(e[s.index])):s.index;if(gt(n)){let i=null;if(!o&&u&&(i=function(e,t,n,s){const r=e.cleanup;if(null!=r)for(let a=0;a<r.length-1;a+=2){const e=r[a];if(e===n&&r[a+1]===s){const e=t[7],n=r[a+2];return e.length>n?e[n]:null}"string"==typeof e&&(a+=2)}return null}(e,t,r,s.index)),null!==i)(i.__ngLastListenerFn__||i).__ngNextListenerFn__=a,i.__ngLastListenerFn__=a,h=!1;else{a=$a(s,t,0,a,!1);const e=n.listen(p,r,a);c.push(a,e),l&&l.push(r,m,f,f+1)}}else a=$a(s,t,0,a,!0),p.addEventListener(r,a,i),c.push(a),l&&l.push(r,m,f,i)}else a=$a(s,t,0,a,!1);const d=s.outputs;let p;if(h&&null!==d&&(p=d[r])){const e=p.length;if(e)for(let n=0;n<e;n+=2){const e=t[p[n]][p[n+1]].subscribe(a),i=c.length;c.push(a,e),l&&l.push(r,s.index,i,-(i+1))}}}(a,r,r[11],i,e,t,!!n,s),Ea}function Na(e,t,n,s){try{return!1!==n(s)}catch(r){return Br(e,r),!1}}function $a(e,t,n,s,r){return function n(a){if(a===Function)return s;const i=2&e.flags?kt(e.index,t):t;0==(32&t[2])&&Mr(i);let o=Na(t,0,s,a),u=n.__ngNextListenerFn__;for(;u;)o=Na(t,0,u,a)&&o,u=u.__ngNextListenerFn__;return r&&!1===o&&(a.preventDefault(),a.returnValue=!1),o}}function Ta(e,t,n,s,r){const a=e[n+1],i=null===t;let o=s?nr(a):rr(a),u=!1;for(;0!==o&&(!1===u||i);){const n=e[o+1];Aa(e[o],t)&&(u=!0,e[o+1]=s?ir(n):sr(n)),o=s?nr(n):rr(n)}u&&(e[n+1]=s?sr(a):ir(a))}function Aa(e,t){return null===e||null==t||(Array.isArray(e)?e[1]:e)===t||!(!Array.isArray(e)||"string"!=typeof t)&&Kn(e,t)>=0}function Ra(e,t){return function(e,t,n,s){const r=Tt(),a=At(),i=function(e){const t=Nt.lFrame,n=t.bindingIndex;return t.bindingIndex=t.bindingIndex+2,n}();a.firstUpdatePass&&function(e,t,n,s){const r=e.data;if(null===r[n+1]){const a=r[Zt()],i=function(e,t){return t>=e.expandoStartIndex}(e,n);(function(e,t){return 0!=(16&e.flags)})(a)&&null===t&&!i&&(t=!1),t=function(e,t,n,s){const r=function(e){const t=Nt.lFrame.currentDirectiveIndex;return-1===t?null:e[t]}(e);let a=t.residualClasses;if(null===r)0===t.classBindings&&(n=Da(n=Fa(null,e,t,n,s),t.attrs,s),a=null);else{const i=t.directiveStylingLast;if(-1===i||e[i]!==r)if(n=Fa(r,e,t,n,s),null===a){let n=function(e,t,n){const s=t.classBindings;if(0!==rr(s))return e[nr(s)]}(e,t);void 0!==n&&Array.isArray(n)&&(n=Fa(null,e,t,n[1],s),n=Da(n,t.attrs,s),function(e,t,n,s){e[nr(t.classBindings)]=s}(e,t,0,n))}else a=function(e,t,n){let s;const r=t.directiveEnd;for(let a=1+t.directiveStylingLast;a<r;a++)s=Da(s,e[a].hostAttrs,true);return Da(s,t.attrs,true)}(e,t)}return void 0!==a&&(t.residualClasses=a),n}(r,a,t,s),function(e,t,n,s,r,a){let i=t.classBindings,o=nr(i),u=rr(i);e[s]=n;let l,c=!1;if(Array.isArray(n)){const e=n;l=e[1],(null===l||Kn(e,l)>0)&&(c=!0)}else l=n;if(r)if(0!==u){const t=nr(e[o+1]);e[s+1]=tr(t,o),0!==t&&(e[t+1]=ar(e[t+1],s)),e[o+1]=131071&e[o+1]|s<<17}else e[s+1]=tr(o,0),0!==o&&(e[o+1]=ar(e[o+1],s)),o=s;else e[s+1]=tr(u,0),0===o?o=s:e[u+1]=ar(e[u+1],s),u=s;c&&(e[s+1]=sr(e[s+1])),Ta(e,l,s,!0),Ta(e,l,s,!1),function(e,t,n,s,r){const a=e.residualClasses;null!=a&&"string"==typeof t&&Kn(a,t)>=0&&(n[s+1]=ir(n[s+1]))}(t,l,e,s),i=tr(o,u),t.classBindings=i}(r,a,t,n,i)}}(a,e,i,true),t!==Js&&ya(r,i,t)&&function(e,t,n,s,r,a,i,o){if(!(3&t.type))return;const u=e.data,l=u[o+1];Ma(1==(1&l)?Oa(u,t,n,r,rr(l),i):void 0)||(Ma(a)||function(e){return 2==(2&e)}(l)&&(a=Oa(u,null,n,r,o,i)),function(e,t,n,s,r){const a=gt(e);r?a?e.addClass(n,s):n.classList.add(s):a?e.removeClass(n,s):n.classList.remove(s)}(s,0,vt(Zt(),n),r,a))}(a,a.data[Zt()],r,r[11],e,r[i+1]=function(e,t){return null==e||"object"==typeof e&&(e=re(function(e){return e instanceof class{constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}?e.changingThisBreaksApplicationSecurity:e}(e))),e}(t),true,i)}(e,t),Ra}function Fa(e,t,n,s,r){let a=null;const i=n.directiveEnd;let o=n.directiveStylingLast;for(-1===o?o=n.directiveStart:o++;o<i&&(a=t[o],s=Da(s,a.hostAttrs,r),a!==e);)o++;return null!==e&&(n.directiveStylingLast=o),s}function Da(e,t,n){const s=n?1:2;let r=-1;if(null!==t)for(let a=0;a<t.length;a++){const i=t[a];"number"==typeof i?r=i:r===s&&(Array.isArray(e)||(e=void 0===e?[]:["",e]),Hn(e,i,!!n||t[++a]))}return void 0===e?null:e}function Oa(e,t,n,s,r,a){const i=null===t;let o;for(;r>0;){const t=e[r],a=Array.isArray(t),u=a?t[1]:t,l=null===u;let c=n[r+1];c===Js&&(c=l?Me:void 0);let h=l?Gn(c,s):u===s?c:void 0;if(a&&!Ma(h)&&(h=Gn(t,s)),Ma(h)&&(o=h,i))return o;const d=e[r+1];r=i?nr(d):rr(d)}if(null!==t){let e=a?t.residualClasses:t.residualStyles;null!=e&&(o=Gn(e,s))}return o}function Ma(e){return void 0!==e}function za(e,t=""){const n=Tt(),s=At(),r=e+et,a=s.firstCreatePass?lr(s,r,1,t,null):s.data[r],i=n[r]=function(e,t){return gt(e)?e.createText(t):e.createTextNode(t)}(n[11],t);Rs(s,n,i,a),Dt(a,!1)}function La(e){return Pa("",e,""),La}function Pa(e,t,n){const s=Tt(),r=function(e,t,n,s){return ya(e,Lt(),n)?t+he(n)+s:Js}(s,e,t,n);return r!==Js&&function(e,t,n){const s=vt(t,e);!function(e,t,n){gt(e)?e.setValue(t,n):t.textContent=n}(e[11],s,n)}(s,Zt(),r),Pa}const ja=void 0;var Va=["en",[["a","p"],["AM","PM"],ja],[["AM","PM"],ja,ja],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],ja,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],ja,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",ja,"{1} 'at' {0}",ja],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===n?1:5}];let Wa={};function Ba(e){return e in Wa||(Wa[e]=De.ng&&De.ng.common&&De.ng.common.locales&&De.ng.common.locales[e]),Wa[e]}var qa=function(e){return e[e.LocaleId=0]="LocaleId",e[e.DayPeriodsFormat=1]="DayPeriodsFormat",e[e.DayPeriodsStandalone=2]="DayPeriodsStandalone",e[e.DaysFormat=3]="DaysFormat",e[e.DaysStandalone=4]="DaysStandalone",e[e.MonthsFormat=5]="MonthsFormat",e[e.MonthsStandalone=6]="MonthsStandalone",e[e.Eras=7]="Eras",e[e.FirstDayOfWeek=8]="FirstDayOfWeek",e[e.WeekendRange=9]="WeekendRange",e[e.DateFormat=10]="DateFormat",e[e.TimeFormat=11]="TimeFormat",e[e.DateTimeFormat=12]="DateTimeFormat",e[e.NumberSymbols=13]="NumberSymbols",e[e.NumberFormats=14]="NumberFormats",e[e.CurrencyCode=15]="CurrencyCode",e[e.CurrencySymbol=16]="CurrencySymbol",e[e.CurrencyName=17]="CurrencyName",e[e.Currencies=18]="Currencies",e[e.Directionality=19]="Directionality",e[e.PluralCase=20]="PluralCase",e[e.ExtraData=21]="ExtraData",e}({});const Ua="en-US";let Ha=Ua;function Ga(e){var t,n;n="Expected localeId to be defined",null==(t=e)&&function(e,t,n,s){throw new Error(`ASSERTION ERROR: ${e} [Expected=> null != ${t} <=Actual]`)}(n,t),"string"==typeof e&&(Ha=e.toLowerCase().replace(/_/g,"-"))}function Ka(e,t,n,s,r){if(e=ue(e),Array.isArray(e))for(let a=0;a<e.length;a++)Ka(e[a],t,n,s,r);else{const a=At(),i=Tt();let o=aa(e)?e:ue(e.provide),u=na(e);const l=Rt(),c=1048575&l.providerIndexes,h=l.directiveStart,d=l.providerIndexes>>20;if(aa(e)||!e.multi){const s=new on(u,r,va),p=Za(o,t,r?c:c+d,h);-1===p?(In(vn(l,i),a,o),Xa(a,e,t.length),t.push(o),l.directiveStart++,l.directiveEnd++,r&&(l.providerIndexes+=1048576),n.push(s),i.push(s)):(n[p]=s,i[p]=s)}else{const p=Za(o,t,c+d,h),f=Za(o,t,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(r&&!g||!r&&!m){In(vn(l,i),a,o);const c=function(e,t,n,s,r){const a=new on(e,n,va);return a.multi=[],a.index=t,a.componentProviders=0,Ya(a,r,s&&!n),a}(r?Qa:Ja,n.length,r,s,u);!r&&g&&(n[f].providerFactory=c),Xa(a,e,t.length,0),t.push(o),l.directiveStart++,l.directiveEnd++,r&&(l.providerIndexes+=1048576),n.push(c),i.push(c)}else Xa(a,e,p>-1?p:f,Ya(n[r?f:p],u,!r&&s));!r&&s&&g&&n[f].componentProviders++}}}function Xa(e,t,n,s){const r=aa(t);if(r||t.useClass){const a=(t.useClass||t).prototype.ngOnDestroy;if(a){const i=e.destroyHooks||(e.destroyHooks=[]);if(!r&&t.multi){const e=i.indexOf(n);-1===e?i.push(n,[s,a]):i[e+1].push(s,a)}else i.push(n,a)}}}function Ya(e,t,n){return n&&e.componentProviders++,e.multi.push(t)-1}function Za(e,t,n,s){for(let r=n;r<s;r++)if(t[r]===e)return r;return-1}function Ja(e,t,n,s){return ei(this.multi,[])}function Qa(e,t,n,s){const r=this.multi;let a;if(this.providerFactory){const e=this.providerFactory.componentProviders,t=An(n,n[1],this.providerFactory.index,s);a=t.slice(0,e),ei(r,a);for(let n=e;n<t.length;n++)a.push(t[n])}else a=[],ei(r,a);return a}function ei(e,t){for(let n=0;n<e.length;n++)t.push((0,e[n])());return t}function ti(e,t=[]){return n=>{n.providersResolver=(n,s)=>function(e,t,n){const s=At();if(s.firstCreatePass){const r=ot(e);Ka(n,s.data,s.blueprint,r,!0),Ka(t,s.data,s.blueprint,r,!1)}}(n,s?s(e):e,t)}}class ni{}class si{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${re(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}let ri=(()=>{class e{}return e.NULL=new si,e})();function ai(...e){}function ii(e,t){return new ui(wt(e,t))}const oi=function(){return ii(Rt(),Tt())};let ui=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=oi,e})();function li(e){return e instanceof ui?e.nativeElement:e}class ci{}let hi=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>di(),e})();const di=function(){const e=Tt(),t=kt(Rt().index,e);return function(e){return e[11]}(nt(t)?t:e)};let pi=(()=>{class e{}return e.\u0275prov=fe({token:e,providedIn:"root",factory:()=>null}),e})();class fi{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const mi=new fi("12.0.5");class gi{constructor(){}supports(e){return ga(e)}create(e){return new yi(e)}}const bi=(e,t)=>t;class yi{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||bi}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,n=this._removalsHead,s=0,r=null;for(;t||n;){const a=!n||t&&t.currentIndex<ki(n,s,r)?t:n,i=ki(a,s,r),o=a.currentIndex;if(a===n)s--,n=n._nextRemoved;else if(t=t._next,null==a.previousIndex)s++;else{r||(r=[]);const e=i-s,t=o-s;if(e!=t){for(let n=0;n<e;n++){const s=n<r.length?r[n]:r[n]=0,a=s+n;t<=a&&a<e&&(r[n]=s+1)}r[a.previousIndex]=t-e}}i!==o&&e(a,i,o)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!ga(e))throw new Error(`Error trying to diff '${re(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,n,s,r=this._itHead,a=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)n=e[t],s=this._trackByFn(t,n),null!==r&&Object.is(r.trackById,s)?(a&&(r=this._verifyReinsertion(r,n,s,t)),Object.is(r.item,n)||this._addIdentityChange(r,n)):(r=this._mismatch(r,n,s,t),a=!0),r=r._next}else t=0,function(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{const n=e[ma()]();let s;for(;!(s=n.next()).done;)t(s.value)}}(e,e=>{s=this._trackByFn(t,e),null!==r&&Object.is(r.trackById,s)?(a&&(r=this._verifyReinsertion(r,e,s,t)),Object.is(r.item,e)||this._addIdentityChange(r,e)):(r=this._mismatch(r,e,s,t),a=!0),r=r._next,t++}),this.length=t;return this._truncate(r),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,n,s){let r;return null===e?r=this._itTail:(r=e._prev,this._remove(e)),null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,r,s)):null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,s))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,r,s)):e=this._addAfter(new vi(t,n),r,s),e}_verifyReinsertion(e,t,n,s){let r=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==r?e=this._reinsertAfter(r,e._prev,s):e.currentIndex!=s&&(e.currentIndex=s,this._addToMoves(e,s)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const s=e._prevRemoved,r=e._nextRemoved;return null===s?this._removalsHead=r:s._nextRemoved=r,null===r?this._removalsTail=s:r._prevRemoved=s,this._insertAfter(e,t,n),this._addToMoves(e,n),e}_moveAfter(e,t,n){return this._unlink(e),this._insertAfter(e,t,n),this._addToMoves(e,n),e}_addAfter(e,t,n){return this._insertAfter(e,t,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,n){const s=null===t?this._itHead:t._next;return e._next=s,e._prev=t,null===s?this._itTail=e:s._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new xi),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,n=e._next;return null===t?this._itHead=n:t._next=n,null===n?this._itTail=t:n._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new xi),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class vi{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class wi{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===t||t<=n.currentIndex)&&Object.is(n.trackById,e))return n;return null}remove(e){const t=e._prevDup,n=e._nextDup;return null===t?this._head=n:t._nextDup=n,null===n?this._tail=t:n._prevDup=t,null===this._head}}class xi{constructor(){this.map=new Map}put(e){const t=e.trackById;let n=this.map.get(t);n||(n=new wi,this.map.set(t,n)),n.add(e)}get(e,t){const n=this.map.get(e);return n?n.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function ki(e,t,n){const s=e.previousIndex;if(null===s)return s;let r=0;return n&&s<n.length&&(r=n[s]),s+t+r}class Ii{constructor(){}supports(e){return e instanceof Map||ba(e)}create(){return new Ci}}class Ci{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||ba(e)))throw new Error(`Error trying to diff '${re(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,n)=>{if(t&&t.key===n)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const s=this._getOrCreateRecordForKey(n,e);t=this._insertBeforeOrAppend(t,s)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const n=e._prev;return t._next=e,t._prev=n,e._prev=t,n&&(n._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const n=this._records.get(e);this._maybeAddToChanges(n,t);const s=n._prev,r=n._next;return s&&(s._next=r),r&&(r._prev=s),n._next=null,n._prev=null,n}const n=new _i(e);return this._records.set(e,n),n.currentValue=t,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){Object.is(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(n=>t(e[n],n))}}class _i{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Si(){return new Ei([new gi])}let Ei=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(null!=n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Si()),deps:[[e,new os,new is]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);var n}}return e.\u0275prov=fe({token:e,providedIn:"root",factory:Si}),e})();function Ni(){return new $i([new Ii])}let $i=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Ni()),deps:[[e,new os,new is]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=fe({token:e,providedIn:"root",factory:Ni}),e})();function Ti(e,t,n,s,r=!1){for(;null!==n;){const a=t[n.index];if(null!==a&&s.push(yt(a)),st(a))for(let e=tt;e<a.length;e++){const t=a[e],n=t[1].firstChild;null!==n&&Ti(t[1],t,n,s)}const i=n.type;if(8&i)Ti(e,t,n.child,s);else if(32&i){const e=bs(n,t);let r;for(;r=e();)s.push(r)}else if(16&i){const e=Ds(t,n);if(Array.isArray(e))s.push(...e);else{const n=ys(t[16]);Ti(n[1],n,e,s,!0)}}n=r?n.projectionNext:n.next}return s}class Ai{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const e=this._lView,t=e[1];return Ti(t,e,t.firstChild,[])}get context(){return this._lView[8]}set context(e){this._lView[8]=e}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const e=this._lView[3];if(st(e)){const t=e[8],n=t?t.indexOf(this):-1;n>-1&&(_s(e,n),Un(t,n))}this._attachedToViewContainer=!1}Ss(this._lView[1],this._lView)}onDestroy(e){vr(this._lView[1],this._lView,null,e)}markForCheck(){Mr(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){zr(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,n){zt(!0);try{zr(e,t,n)}finally{zt(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var e;this._appRef=null,zs(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class Ri extends Ai{constructor(e){super(e),this._view=e}detectChanges(){Lr(this._view)}checkNoChanges(){!function(e){zt(!0);try{Lr(e)}finally{zt(!1)}}(this._view)}get context(){return null}}const Fi=function(e){return function(e,t,n){if(at(e)&&!n){const n=kt(e.index,t);return new Ai(n,n)}return 47&e.type?new Ai(t[16],t):null}(Rt(),Tt(),16==(16&e))};let Di=(()=>{class e{}return e.__NG_ELEMENT_ID__=Fi,e})();const Oi=[new Ii],Mi=new Ei([new gi]),zi=new $i(Oi),Li=function(){return Wi(Rt(),Tt())};let Pi=(()=>{class e{}return e.__NG_ELEMENT_ID__=Li,e})();const ji=Pi,Vi=class extends ji{constructor(e,t,n){super(),this._declarationLView=e,this._declarationTContainer=t,this.elementRef=n}createEmbeddedView(e){const t=this._declarationTContainer.tViews,n=ur(this._declarationLView,t,e,16,null,t.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const s=this._declarationLView[19];return null!==s&&(n[19]=s.createEmbeddedView(t)),hr(t,n,e),new Ai(n)}};function Wi(e,t){return 4&e.type?new Vi(t,e,ii(e,t)):null}class Bi{}class qi{}const Ui=function(){return Zi(Rt(),Tt())};let Hi=(()=>{class e{}return e.__NG_ELEMENT_ID__=Ui,e})();const Gi=Hi,Ki=class extends Gi{constructor(e,t,n){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=n}get element(){return ii(this._hostTNode,this._hostLView)}get injector(){return new Dn(this._hostTNode,this._hostLView)}get parentInjector(){const e=kn(this._hostTNode,this._hostLView);if(pn(e)){const t=mn(e,this._hostLView),n=fn(e);return new Dn(t[1].data[n+8],t)}return new Dn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){const t=Xi(this._lContainer);return null!==t&&t[e]||null}get length(){return this._lContainer.length-tt}createEmbeddedView(e,t,n){const s=e.createEmbeddedView(t||{});return this.insert(s,n),s}createComponent(e,t,n,s,r){const a=n||this.parentInjector;if(!r&&null==e.ngModule&&a){const e=a.get(Bi,null);e&&(r=e)}const i=e.create(a,s,void 0,r);return this.insert(i.hostView,t),i}insert(e,t){const n=e._lView,s=n[1];if(st(n[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=n[3],s=new Ki(t,t[6],t[3]);s.detach(s.indexOf(e))}}const r=this._adjustIndex(t),a=this._lContainer;!function(e,t,n,s){const r=tt+s,a=n.length;s>0&&(n[r-1][4]=t),s<a-tt?(t[4]=n[r],qn(n,tt+s,t)):(n.push(t),t[4]=null),t[3]=n;const i=t[17];null!==i&&n!==i&&function(e,t){const n=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===n?e[9]=[t]:n.push(t)}(i,t);const o=t[19];null!==o&&o.insertView(e),t[2]|=128}(s,n,a,r);const i=Os(r,a),o=n[11],u=As(o,a[7]);return null!==u&&function(e,t,n,s,r,a){s[0]=r,s[6]=t,zs(e,s,n,1,r,a)}(s,a[6],o,n,u,i),e.attachToViewContainerRef(),qn(Yi(a),r,e),e}move(e,t){return this.insert(e,t)}indexOf(e){const t=Xi(this._lContainer);return null!==t?t.indexOf(e):-1}remove(e){const t=this._adjustIndex(e,-1),n=_s(this._lContainer,t);n&&(Un(Yi(this._lContainer),t),Ss(n[1],n))}detach(e){const t=this._adjustIndex(e,-1),n=_s(this._lContainer,t);return n&&null!=Un(Yi(this._lContainer),t)?new Ai(n):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}};function Xi(e){return e[8]}function Yi(e){return e[8]||(e[8]=[])}function Zi(e,t){let n;const s=t[e.index];if(st(s))n=s;else{let r;if(8&e.type)r=yt(s);else{const n=t[11];r=n.createComment("");const s=wt(e,t);Ns(n,As(n,s),r,function(e,t){return gt(e)?e.nextSibling(t):t.nextSibling}(n,s),!1)}t[e.index]=n=Ar(s,t,r,e),Or(t,n)}return new Ki(n,e,t)}const Ji={};class Qi extends ri{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=Je(e);return new no(t,this.ngModule)}}function eo(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}const to=new Pn("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>fs});class no extends ni{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(Zs).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return eo(this.componentDef.inputs)}get outputs(){return eo(this.componentDef.outputs)}create(e,t,n,s){const r=(s=s||this.ngModule)?function(e,t){return{get:(n,s,r)=>{const a=e.get(n,Ji,r);return a!==Ji||s===Ji?a:t.get(n,s,r)}}}(e,s.injector):e,a=r.get(ci,bt),i=r.get(pi,null),o=a.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",l=n?function(e,t,n){if(gt(e))return e.selectRootElement(t,n===$e.ShadowDom);let s="string"==typeof t?e.querySelector(t):t;return s.textContent="",s}(o,n,this.componentDef.encapsulation):Is(a.createRenderer(null,this.componentDef),u,function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(u)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:fs,clean:jr,playerHandler:null,flags:0},d=yr(0,null,null,1,0,null,null,null,null,null),p=ur(null,d,h,c,null,null,a,o,i,r);let f,m;Ut(p);try{const e=function(e,t,n,s,r,a){const i=n[1];n[20]=e;const o=lr(i,20,2,"#host",null),u=o.mergedAttrs=t.hostAttrs;null!==u&&(Ur(o,u,!0),null!==e&&(un(r,e,u),null!==o.classes&&js(r,e,o.classes),null!==o.styles&&Ps(r,e,o.styles)));const l=s.createRenderer(e,t),c=ur(n,br(t),null,t.onPush?64:16,n[20],o,s,l,null,null);return i.firstCreatePass&&(In(vn(o,n),i,t.type),Cr(i,o),Sr(o,n.length,1)),Or(n,c),n[20]=c}(l,this.componentDef,p,a,o);if(l)if(n)un(o,l,["ng-version",mi.full]);else{const{attrs:e,classes:t}=function(e){const t=[],n=[];let s=1,r=2;for(;s<e.length;){let a=e[s];if("string"==typeof a)2===r?""!==a&&t.push(a,e[++s]):8===r&&n.push(a);else{if(!Gs(r))break;r=a}s++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);e&&un(o,l,e),t&&t.length>0&&js(o,l,t.join(" "))}if(m=xt(d,et),void 0!==t){const e=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const s=t[n];e.push(null!=s?Array.from(s):null)}}f=function(e,t,n,s,r){const a=n[1],i=function(e,t,n){const s=Rt();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Er(e,s,t,cr(e,t,1,null),n));const r=An(t,e,s.directiveStart,s);us(r,t);const a=wt(s,t);return a&&us(a,t),r}(a,n,t);if(s.components.push(i),e[8]=i,r&&r.forEach(e=>e(i,t)),t.contentQueries){const e=Rt();t.contentQueries(1,i,e.directiveStart)}const o=Rt();return!a.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(Jt(o.index),kr(n[1],o,0,o.directiveStart,o.directiveEnd,t),Ir(t,i)),i}(e,this.componentDef,p,h,[ua]),hr(d,p,null)}finally{Yt()}return new so(this.componentType,f,ii(m,p),p,m)}}class so extends class{}{constructor(e,t,n,s,r){super(),this.location=n,this._rootLView=s,this._tNode=r,this.instance=t,this.hostView=this.changeDetectorRef=new Ri(s),this.componentType=e}get injector(){return new Dn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}}const ro=new Map;class ao extends Bi{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Qi(this);const n=Qe(e),s=e[Ve]||null;s&&Ga(s),this._bootstrapComponents=ms(n.bootstrap),this._r3Injector=Qr(e,t,[{provide:Bi,useValue:this},{provide:ri,useValue:this.componentFactoryResolver}],re(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=oa.THROW_IF_NOT_FOUND,n=Ie.Default){return e===oa||e===Bi||e===Hr?this:this._r3Injector.get(e,t,n)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class io extends qi{constructor(e){super(),this.moduleType=e,null!==Qe(e)&&function(e){const t=new Set;!function e(n){const s=Qe(n,!0),r=s.id;null!==r&&(function(e,t,n){if(t&&t!==n)throw new Error(`Duplicate module registered for ${e} - ${re(t)} vs ${re(t.name)}`)}(r,ro.get(r),n),ro.set(r,n));const a=ms(s.imports);for(const i of a)t.has(i)||(t.add(i),e(i))}(e)}(e)}create(e){return new ao(this.moduleType,e)}}function oo(e,t,n,s,r){return function(e,t,n,s,r,a,i){const o=t+n;return function(e,t,n,s){const r=ya(e,t,n);return ya(e,t+1,s)||r}(e,o,r,a)?function(e,t,n){return e[t]=n}(e,o+2,i?s.call(i,r,a):s(r,a)):function(e,t){const n=e[t];return n===Js?void 0:n}(e,o+2)}(Tt(),function(){const e=Nt.lFrame;let t=e.bindingRootIndex;return-1===t&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}(),e,t,n,s,r)}function uo(e){return t=>{setTimeout(e,void 0,t)}}const lo=class extends E{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,n){var s,r,a;let i=e,o=t||(()=>null),u=n;if(e&&"object"==typeof e){const t=e;i=null===(s=t.next)||void 0===s?void 0:s.bind(t),o=null===(r=t.error)||void 0===r?void 0:r.bind(t),u=null===(a=t.complete)||void 0===a?void 0:a.bind(t)}this.__isAsync&&(o=uo(o),i&&(i=uo(i)),u&&(u=uo(u)));const l=super.subscribe({next:i,error:o,complete:u});return e instanceof m&&e.add(l),l}};function co(){return this._results[ma()]()}class ho{constructor(e=!1){this._emitDistinctChangesOnly=e,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const t=ma(),n=ho.prototype;n[t]||(n[t]=co)}get changes(){return this._changes||(this._changes=new lo)}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){const n=this;n.dirty=!1;const s=Wn(e);(this._changesDetected=!function(e,t,n){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++){let r=e[s],a=t[s];if(n&&(r=n(r),a=n(a)),a!==r)return!1}return!0}(n._results,s,t))&&(n._results=s,n.length=s.length,n.last=s[this.length-1],n.first=s[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class po{constructor(e){this.queryList=e,this.matches=null}clone(){return new po(this.queryList)}setDirty(){this.queryList.setDirty()}}class fo{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const n=null!==e.contentQueries?e.contentQueries[0]:t.length,s=[];for(let e=0;e<n;e++){const n=t.getByIndex(e);s.push(this.queries[n.indexInDeclarationView].clone())}return new fo(s)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==Io(e,t).matches&&this.queries[t].setDirty()}}class mo{constructor(e,t,n=null){this.predicate=e,this.flags=t,this.read=n}}class go{constructor(e=[]){this.queries=e}elementStart(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let n=0;n<this.length;n++){const s=null!==t?t.length:0,r=this.getByIndex(n).embeddedTView(e,s);r&&(r.indexInDeclarationView=n,null!==t?t.push(r):t=[r])}return null!==t?new go(t):null}template(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class bo{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new bo(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const t=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&8&n.type&&n.index!==t;)n=n.parent;return t===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,t){const n=this.metadata.predicate;if(Array.isArray(n))for(let s=0;s<n.length;s++){const r=n[s];this.matchTNodeWithReadOption(e,t,yo(t,r)),this.matchTNodeWithReadOption(e,t,Tn(t,e,r,!1,!1))}else n===Pi?4&t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Tn(t,e,n,!1,!1))}matchTNodeWithReadOption(e,t,n){if(null!==n){const s=this.metadata.read;if(null!==s)if(s===ui||s===Hi||s===Pi&&4&t.type)this.addMatch(t.index,-2);else{const n=Tn(t,e,s,!1,!1);null!==n&&this.addMatch(t.index,n)}else this.addMatch(t.index,n)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function yo(e,t){const n=e.localNames;if(null!==n)for(let s=0;s<n.length;s+=2)if(n[s]===t)return n[s+1];return null}function vo(e,t,n,s){return-1===n?function(e,t){return 11&e.type?ii(e,t):4&e.type?Wi(e,t):null}(t,e):-2===n?function(e,t,n){return n===ui?ii(t,e):n===Pi?Wi(t,e):n===Hi?Zi(t,e):void 0}(e,t,s):An(e,e[1],n,t)}function wo(e,t,n,s){const r=t[19].queries[s];if(null===r.matches){const s=e.data,a=n.matches,i=[];for(let e=0;e<a.length;e+=2){const r=a[e];i.push(r<0?null:vo(t,s[r],a[e+1],n.metadata.read))}r.matches=i}return r.matches}function xo(e,t,n,s){const r=e.queries.getByIndex(n),a=r.matches;if(null!==a){const i=wo(e,t,r,n);for(let e=0;e<a.length;e+=2){const n=a[e];if(n>0)s.push(i[e/2]);else{const r=a[e+1],i=t[-n];for(let e=tt;e<i.length;e++){const t=i[e];t[17]===t[3]&&xo(t[1],t,r,s)}if(null!==i[9]){const e=i[9];for(let t=0;t<e.length;t++){const n=e[t];xo(n[1],n,r,s)}}}}}return s}function ko(e){const t=Tt(),n=At(),s=Vt();Wt(s+1);const r=Io(n,s);if(e.dirty&&It(t)===(2==(2&r.metadata.flags))){if(null===r.matches)e.reset([]);else{const a=r.crossesNgTemplate?xo(n,t,s,[]):wo(n,t,r,s);e.reset(a,li),e.notifyOnChanges()}return!0}return!1}function Io(e,t){return e.queries.getByIndex(t)}const Co=new Pn("Application Initializer");let _o=(()=>{class e{constructor(e){this.appInits=e,this.resolve=ai,this.reject=ai,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const t=this.appInits[n]();if(_a(t))e.push(t);else if(Sa(t)){const n=new Promise((e,n)=>{t.subscribe({complete:e,error:n})});e.push(n)}}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(ns(Co,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const So=new Pn("AppId"),Eo={provide:So,useFactory:function(){return`${No()}${No()}${No()}`},deps:[]};function No(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const $o=new Pn("Platform Initializer"),To=new Pn("Platform ID"),Ao=new Pn("appBootstrapListener");let Ro=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const Fo=new Pn("LocaleId"),Do=new Pn("DefaultCurrencyCode");class Oo{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const Mo=function(e){return new io(e)},zo=Mo,Lo=function(e){return Promise.resolve(Mo(e))},Po=function(e){const t=Mo(e),n=ms(Qe(e).declarations).reduce((e,t)=>{const n=Je(t);return n&&e.push(new no(n)),e},[]);return new Oo(t,n)},jo=Po,Vo=function(e){return Promise.resolve(Po(e))};let Wo=(()=>{class e{constructor(){this.compileModuleSync=zo,this.compileModuleAsync=Lo,this.compileModuleAndAllComponentsSync=jo,this.compileModuleAndAllComponentsAsync=Vo}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const Bo=(()=>Promise.resolve(0))();function qo(e){"undefined"==typeof Zone?Bo.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class Uo{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new lo(!1),this.onMicrotaskEmpty=new lo(!1),this.onStable=new lo(!1),this.onError=new lo(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!n&&t,s.shouldCoalesceRunChangeDetection=n,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function(){let e=De.requestAnimationFrame,t=De.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const s=t[Zone.__symbol__("OriginalDelegate")];s&&(t=s)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=()=>{!function(e){e.isCheckStableRunning||-1!==e.lastRequestAnimationFrameId||(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(De,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,Ko(e),e.isCheckStableRunning=!0,Go(e),e.isCheckStableRunning=!1},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),Ko(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,s,r,a,i,o)=>{try{return Xo(e),n.invokeTask(r,a,i,o)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===a.type||e.shouldCoalesceRunChangeDetection)&&t(),Yo(e)}},onInvoke:(n,s,r,a,i,o,u)=>{try{return Xo(e),n.invoke(r,a,i,o,u)}finally{e.shouldCoalesceRunChangeDetection&&t(),Yo(e)}},onHasTask:(t,n,s,r)=>{t.hasTask(s,r),n===s&&("microTask"==r.change?(e._hasPendingMicrotasks=r.microTask,Ko(e),Go(e)):"macroTask"==r.change&&(e.hasPendingMacrotasks=r.macroTask))},onHandleError:(t,n,s,r)=>(t.handleError(s,r),e.runOutsideAngular(()=>e.onError.emit(r)),!1)})}(s)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Uo.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Uo.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,n){return this._inner.run(e,t,n)}runTask(e,t,n,s){const r=this._inner,a=r.scheduleEventTask("NgZoneEvent: "+s,e,Ho,ai,ai);try{return r.runTask(a,t,n)}finally{r.cancelTask(a)}}runGuarded(e,t,n){return this._inner.runGuarded(e,t,n)}runOutsideAngular(e){return this._outer.run(e)}}const Ho={};function Go(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function Ko(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&-1!==e.lastRequestAnimationFrameId)}function Xo(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function Yo(e){e._nesting--,Go(e)}class Zo{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new lo,this.onMicrotaskEmpty=new lo,this.onStable=new lo,this.onError=new lo}run(e,t,n){return e.apply(t,n)}runGuarded(e,t,n){return e.apply(t,n)}runOutsideAngular(e){return e()}runTask(e,t,n,s){return e.apply(t,n)}}let Jo=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Uo.assertNotInAngularZone(),qo(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())qo(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,n){let s=-1;t&&t>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==s),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:s,updateCb:n})}whenStable(e,t,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,t,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,n){return[]}}return e.\u0275fac=function(t){return new(t||e)(ns(Uo))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Qo=(()=>{class e{constructor(){this._applications=new Map,nu.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return nu.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class eu{addToWindow(e){}findTestabilityInTree(e,t,n){return null}}let tu,nu=new eu,su=!0,ru=!1;const au=new Pn("AllowMultipleToken");class iu{constructor(e,t){this.name=e,this.token=t}}function ou(e,t,n=[]){const s=`Platform: ${t}`,r=new Pn(s);return(t=[])=>{let a=uu();if(!a||a.injector.get(au,!1))if(e)e(n.concat(t).concat({provide:r,useValue:!0}));else{const e=n.concat(t).concat({provide:r,useValue:!0},{provide:Kr,useValue:"platform"});!function(e){if(tu&&!tu.destroyed&&!tu.injector.get(au,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");tu=e.get(lu);const t=e.get($o,null);t&&t.forEach(e=>e())}(oa.create({providers:e,name:s}))}return function(e){const t=uu();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(r)}}function uu(){return tu&&!tu.destroyed?tu:null}let lu=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const n=function(e,t){let n;return n="noop"===e?new Zo:("zone.js"===e?void 0:e)||new Uo({enableLongStackTrace:(ru=!0,su),shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),n}(t?t.ngZone:void 0,{ngZoneEventCoalescing:t&&t.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:t&&t.ngZoneRunCoalescing||!1}),s=[{provide:Uo,useValue:n}];return n.run(()=>{const t=oa.create({providers:s,parent:this.injector,name:e.moduleType.name}),r=e.create(t),a=r.injector.get(ps,null);if(!a)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const e=n.onError.subscribe({next:e=>{a.handleError(e)}});r.onDestroy(()=>{du(this._modules,r),e.unsubscribe()})}),function(e,t,n){try{const s=n();return _a(s)?s.catch(n=>{throw t.runOutsideAngular(()=>e.handleError(n)),n}):s}catch(s){throw t.runOutsideAngular(()=>e.handleError(s)),s}}(a,n,()=>{const e=r.injector.get(_o);return e.runInitializers(),e.donePromise.then(()=>(Ga(r.injector.get(Fo,Ua)||Ua),this._moduleDoBootstrap(r),r))})})}bootstrapModule(e,t=[]){const n=cu({},t);return function(e,t,n){const s=new io(n);return Promise.resolve(s)}(0,0,e).then(e=>this.bootstrapModuleFactory(e,n))}_moduleDoBootstrap(e){const t=e.injector.get(hu);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${re(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(ns(oa))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function cu(e,t){return Array.isArray(t)?t.reduce(cu,e):Object.assign(Object.assign({},e),t)}let hu=(()=>{class e{constructor(e,t,n,s,r){this._zone=e,this._injector=t,this._exceptionHandler=n,this._componentFactoryResolver=s,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const a=new k(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),i=new k(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{Uo.assertNotInAngularZone(),qo(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Uo.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),n.unsubscribe()}});this.isStable=function(...e){let t=Number.POSITIVE_INFINITY,n=null,s=e[e.length-1];return $(s)?(n=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof s&&(t=e.pop()),null===n&&1===e.length&&e[0]instanceof k?e[0]:G(t)(K(e,n))}(a,i.pipe(e=>{return X()((t=te,function(e){let n;n="function"==typeof t?t:function(){return t};const s=Object.create(e,Q);return s.source=e,s.subjectFactory=n,s})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=e instanceof ni?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(n.componentType);const s=n.isBoundToModule?void 0:this._injector.get(Bi),r=n.create(oa.NULL,[],t||n.selector,s),a=r.location.nativeElement,i=r.injector.get(Jo,null),o=i&&r.injector.get(Qo);return i&&o&&o.registerApplication(a,i),r.onDestroy(()=>{this.detachView(r.hostView),du(this.components,r),o&&o.unregisterApplication(a)}),this._loadComponent(r),r}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;du(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(Ao,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(ns(Uo),ns(oa),ns(ps),ns(ri),ns(_o))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function du(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class pu{}class fu{}const mu={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let gu=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||mu}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,s]=e.split("#");return void 0===s&&(s="default"),n(255)(t).then(e=>e[s]).then(e=>bu(e,t,s)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,s]=e.split("#"),r="NgFactory";return void 0===s&&(s="default",r=""),n(255)(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[s+r]).then(e=>bu(e,t,s))}}return e.\u0275fac=function(t){return new(t||e)(ns(Wo),ns(fu,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function bu(e,t,n){if(!e)throw new Error(`Cannot find '${n}' in '${t}'`);return e}const yu=ou(null,"core",[{provide:To,useValue:"unknown"},{provide:lu,deps:[oa]},{provide:Qo,deps:[]},{provide:Ro,deps:[]}]),vu=[{provide:hu,useClass:hu,deps:[Uo,oa,ps,ri,_o]},{provide:to,deps:[Uo],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:_o,useClass:_o,deps:[[new is,Co]]},{provide:Wo,useClass:Wo,deps:[]},Eo,{provide:Ei,useFactory:function(){return Mi},deps:[]},{provide:$i,useFactory:function(){return zi},deps:[]},{provide:Fo,useFactory:function(e){return Ga(e=e||"undefined"!=typeof $localize&&$localize.locale||Ua),e},deps:[[new as(Fo),new is,new os]]},{provide:Do,useValue:"USD"}];let wu=(()=>{class e{constructor(e){}}return e.\u0275fac=function(t){return new(t||e)(ns(hu))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:vu}),e})(),xu=null;function ku(){return xu}const Iu=new Pn("DocumentToken");let Cu=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:_u,token:e,providedIn:"platform"}),e})();function _u(){return ns(Eu)}const Su=new Pn("Location Initialized");let Eu=(()=>{class e extends Cu{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return ku().getBaseHref(this._doc)}onPopState(e){const t=ku().getGlobalEventTarget(this._doc,"window");return t.addEventListener("popstate",e,!1),()=>t.removeEventListener("popstate",e)}onHashChange(e){const t=ku().getGlobalEventTarget(this._doc,"window");return t.addEventListener("hashchange",e,!1),()=>t.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,n){Nu()?this._history.pushState(e,t,n):this.location.hash=n}replaceState(e,t,n){Nu()?this._history.replaceState(e,t,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(ns(Iu))},e.\u0275prov=fe({factory:$u,token:e,providedIn:"platform"}),e})();function Nu(){return!!window.history.pushState}function $u(){return new Eu(ns(Iu))}function Tu(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function Au(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function Ru(e){return e&&"?"!==e[0]?"?"+e:e}let Fu=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:Du,token:e,providedIn:"root"}),e})();function Du(e){const t=ns(Iu).location;return new Mu(ns(Cu),t&&t.origin||"")}const Ou=new Pn("appBaseHref");let Mu=(()=>{class e extends Fu{constructor(e,t){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Tu(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+Ru(this._platformLocation.search),n=this._platformLocation.hash;return n&&e?`${t}${n}`:t}pushState(e,t,n,s){const r=this.prepareExternalUrl(n+Ru(s));this._platformLocation.pushState(e,t,r)}replaceState(e,t,n,s){const r=this.prepareExternalUrl(n+Ru(s));this._platformLocation.replaceState(e,t,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(ns(Cu),ns(Ou,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),zu=(()=>{class e extends Fu{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=t&&(this._baseHref=t)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=Tu(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,n,s){let r=this.prepareExternalUrl(n+Ru(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.pushState(e,t,r)}replaceState(e,t,n,s){let r=this.prepareExternalUrl(n+Ru(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(ns(Cu),ns(Ou,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Lu=(()=>{class e{constructor(e,t){this._subject=new lo,this._urlChangeListeners=[],this._platformStrategy=e;const n=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=Au(ju(n)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+Ru(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,ju(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",n=null){this._platformStrategy.pushState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}replaceState(e,t="",n=null){this._platformStrategy.replaceState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformStrategy).historyGo)||void 0===n||n.call(t,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)}))}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(n=>n(e,t))}subscribe(e,t,n){return this._subject.subscribe({next:e,error:t,complete:n})}}return e.\u0275fac=function(t){return new(t||e)(ns(Fu),ns(Cu))},e.normalizeQueryParams=Ru,e.joinWithSlash=Tu,e.stripTrailingSlash=Au,e.\u0275prov=fe({factory:Pu,token:e,providedIn:"root"}),e})();function Pu(){return new Lu(ns(Fu),ns(Cu))}function ju(e){return e.replace(/\/index.html$/,"")}var Vu=function(e){return e[e.Zero=0]="Zero",e[e.One=1]="One",e[e.Two=2]="Two",e[e.Few=3]="Few",e[e.Many=4]="Many",e[e.Other=5]="Other",e}({});class Wu{}let Bu=(()=>{class e extends Wu{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return function(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let n=Ba(t);if(n)return n;const s=t.split("-")[0];if(n=Ba(s),n)return n;if("en"===s)return Va;throw new Error(`Missing locale data for the locale "${e}".`)}(e)[qa.PluralCase]}(t||this.locale)(e)){case Vu.Zero:return"zero";case Vu.One:return"one";case Vu.Two:return"two";case Vu.Few:return"few";case Vu.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(ns(Fo))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),qu=(()=>{class e{constructor(e,t,n,s){this._iterableDiffers=e,this._keyValueDiffers=t,this._ngEl=n,this._renderer=s,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(ga(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachChangedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachRemovedItem(e=>{e.previousValue&&this._toggleClass(e.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(e=>{if("string"!=typeof e.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${re(e.item)}`);this._toggleClass(e.item,!0)}),e.forEachRemovedItem(e=>this._toggleClass(e.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!0)):Object.keys(e).forEach(t=>this._toggleClass(t,!!e[t])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!1)):Object.keys(e).forEach(e=>this._toggleClass(e,!1)))}_toggleClass(e,t){(e=e.trim())&&e.split(/\s+/g).forEach(e=>{t?this._renderer.addClass(this._ngEl.nativeElement,e):this._renderer.removeClass(this._ngEl.nativeElement,e)})}}return e.\u0275fac=function(t){return new(t||e)(va(Ei),va($i),va(ui),va(hi))},e.\u0275dir=Ze({type:e,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),e})();class Uu{constructor(e,t,n,s){this.$implicit=e,this.ngForOf=t,this.index=n,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Hu=(()=>{class e{constructor(e,t,n){this._viewContainer=e,this._template=t,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(t){throw new Error(`Cannot find a differ supporting object '${n}' of type '${e=n,e.name||typeof e}'. NgFor only supports binding to Iterables such as Arrays.`)}}var e;if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const t=[];e.forEachOperation((e,n,s)=>{if(null==e.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new Uu(null,this._ngForOf,-1,-1),null===s?void 0:s),r=new Gu(e,n);t.push(r)}else if(null==s)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const r=this._viewContainer.get(n);this._viewContainer.move(r,s);const a=new Gu(e,r);t.push(a)}});for(let n=0;n<t.length;n++)this._perViewChange(t[n].view,t[n].record);for(let n=0,s=this._viewContainer.length;n<s;n++){const e=this._viewContainer.get(n);e.context.index=n,e.context.count=s,e.context.ngForOf=this._ngForOf}e.forEachIdentityChange(e=>{this._viewContainer.get(e.currentIndex).context.$implicit=e.item})}_perViewChange(e,t){e.context.$implicit=t.item}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(va(Hi),va(Pi),va(Ei))},e.\u0275dir=Ze({type:e,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),e})();class Gu{constructor(e,t){this.record=e,this.view=t}}let Ku=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:[{provide:Wu,useClass:Bu}]}),e})(),Xu=(()=>{class e{}return e.\u0275prov=fe({token:e,providedIn:"root",factory:()=>new Yu(ns(Iu),window)}),e})();class Yu{constructor(e,t){this.document=e,this.window=t,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(!this.supportsScrolling())return;const t=function(e,t){const n=e.getElementById(t)||e.getElementsByName(t)[0];if(n)return n;if("function"==typeof e.createTreeWalker&&e.body&&(e.body.createShadowRoot||e.body.attachShadow)){const n=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let s=n.currentNode;for(;s;){const e=s.shadowRoot;if(e){const n=e.getElementById(t)||e.querySelector(`[name="${t}"]`);if(n)return n}s=n.nextNode()}}return null}(this.document,e);t&&(this.scrollToElement(t),this.attemptFocus(t))}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),n=t.left+this.window.pageXOffset,s=t.top+this.window.pageYOffset,r=this.offset();this.window.scrollTo(n-r[0],s-r[1])}attemptFocus(e){return e.focus(),this.document.activeElement===e}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const e=Zu(this.window.history)||Zu(Object.getPrototypeOf(this.window.history));return!(!e||!e.writable&&!e.set)}catch(e){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(e){return!1}}}function Zu(e){return Object.getOwnPropertyDescriptor(e,"scrollRestoration")}class Ju extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var e;e=new Ju,xu||(xu=e)}onAndCancel(e,t,n){return e.addEventListener(t,n,!1),()=>{e.removeEventListener(t,n,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.parentNode&&e.parentNode.removeChild(e)}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getBaseHref(e){const t=(el=el||document.querySelector("base"),el?el.getAttribute("href"):null);return null==t?null:function(e){Qu=Qu||document.createElement("a"),Qu.setAttribute("href",e);const t=Qu.pathname;return"/"===t.charAt(0)?t:`/${t}`}(t)}resetBaseElement(){el=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return function(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const e=n.indexOf("="),[s,r]=-1==e?[n,""]:[n.slice(0,e),n.slice(e+1)];if(s.trim()===t)return decodeURIComponent(r)}return null}(document.cookie,e)}}let Qu,el=null;const tl=new Pn("TRANSITION_ID"),nl=[{provide:Co,useFactory:function(e,t,n){return()=>{n.get(_o).donePromise.then(()=>{const n=ku();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>n.remove(e))})}},deps:[tl,Iu,oa],multi:!0}];class sl{static init(){var e;e=new sl,nu=e}addToWindow(e){De.getAngularTestability=(t,n=!0)=>{const s=e.findTestabilityInTree(t,n);if(null==s)throw new Error("Could not find testability for element.");return s},De.getAllAngularTestabilities=()=>e.getAllTestabilities(),De.getAllAngularRootElements=()=>e.getAllRootElements(),De.frameworkStabilizers||(De.frameworkStabilizers=[]),De.frameworkStabilizers.push(e=>{const t=De.getAllAngularTestabilities();let n=t.length,s=!1;const r=function(t){s=s||t,n--,0==n&&e(s)};t.forEach(function(e){e.whenStable(r)})})}findTestabilityInTree(e,t,n){if(null==t)return null;const s=e.getTestability(t);return null!=s?s:n?ku().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}let rl=(()=>{class e{build(){return new XMLHttpRequest}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const al=new Pn("EventManagerPlugins");let il=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,n){return this._findPluginFor(t).addEventListener(e,t,n)}addGlobalEventListener(e,t,n){return this._findPluginFor(t).addGlobalEventListener(e,t,n)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const n=this._plugins;for(let s=0;s<n.length;s++){const t=n[s];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error(`No event manager plugin found for event ${e}`)}}return e.\u0275fac=function(t){return new(t||e)(ns(al),ns(Uo))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class ol{constructor(e){this._doc=e}addGlobalEventListener(e,t,n){const s=ku().getGlobalEventTarget(this._doc,e);if(!s)throw new Error(`Unsupported event target ${s} for event ${t}`);return this.addEventListener(s,t,n)}}let ul=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),ll=(()=>{class e extends ul{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,t,n){e.forEach(e=>{const s=this._doc.createElement("style");s.textContent=e,n.push(t.appendChild(s))})}addHost(e){const t=[];this._addStylesToHost(this._stylesSet,e,t),this._hostNodes.set(e,t)}removeHost(e){const t=this._hostNodes.get(e);t&&t.forEach(cl),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((t,n)=>{this._addStylesToHost(e,n,t)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(cl))}}return e.\u0275fac=function(t){return new(t||e)(ns(Iu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function cl(e){ku().remove(e)}const hl={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},dl=/%COMP%/g;function pl(e,t,n){for(let s=0;s<t.length;s++){let r=t[s];Array.isArray(r)?pl(e,r,n):(r=r.replace(dl,e),n.push(r))}return n}function fl(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let ml=(()=>{class e{constructor(e,t,n){this.eventManager=e,this.sharedStylesHost=t,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new gl(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case $e.Emulated:{let n=this.rendererByCompId.get(t.id);return n||(n=new bl(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,n)),n.applyToHost(e),n}case 1:case $e.ShadowDom:return new yl(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=pl(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(ns(il),ns(ll),ns(So))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class gl{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(hl[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,n){e&&e.insertBefore(t,n)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let n="string"==typeof e?document.querySelector(e):e;if(!n)throw new Error(`The selector "${e}" did not match any elements`);return t||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,n,s){if(s){t=s+":"+t;const r=hl[s];r?e.setAttributeNS(r,t,n):e.setAttribute(t,n)}else e.setAttribute(t,n)}removeAttribute(e,t,n){if(n){const s=hl[n];s?e.removeAttributeNS(s,t):e.removeAttribute(`${n}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,n,s){s&(gs.DashCase|gs.Important)?e.style.setProperty(t,n,s&gs.Important?"important":""):e.style[t]=n}removeStyle(e,t,n){n&gs.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,n){e[t]=n}setValue(e,t){e.nodeValue=t}listen(e,t,n){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,fl(n)):this.eventManager.addEventListener(e,t,fl(n))}}class bl extends gl{constructor(e,t,n,s){super(e),this.component=n;const r=pl(s+"-"+n.id,n.styles,[]);t.addStyles(r),this.contentAttr="_ngcontent-%COMP%".replace(dl,s+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(dl,s+"-"+n.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const n=super.createElement(e,t);return super.setAttribute(n,this.contentAttr,""),n}}class yl extends gl{constructor(e,t,n,s){super(e),this.sharedStylesHost=t,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const r=pl(s.id,s.styles,[]);for(let a=0;a<r.length;a++){const e=document.createElement("style");e.textContent=r[a],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,n){return super.insertBefore(this.nodeOrShadowRoot(e),t,n)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let vl=(()=>{class e extends ol{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,n){return e.addEventListener(t,n,!1),()=>this.removeEventListener(e,t,n)}removeEventListener(e,t,n){return e.removeEventListener(t,n)}}return e.\u0275fac=function(t){return new(t||e)(ns(Iu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const wl=["alt","control","meta","shift"],xl={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},kl={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Il={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let Cl=(()=>{class e extends ol{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,n,s){const r=e.parseEventName(n),a=e.eventCallback(r.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ku().onAndCancel(t,r.domEventName,a))}static parseEventName(t){const n=t.toLowerCase().split("."),s=n.shift();if(0===n.length||"keydown"!==s&&"keyup"!==s)return null;const r=e._normalizeKey(n.pop());let a="";if(wl.forEach(e=>{const t=n.indexOf(e);t>-1&&(n.splice(t,1),a+=e+".")}),a+=r,0!=n.length||0===r.length)return null;const i={};return i.domEventName=s,i.fullKey=a,i}static getEventFullKey(e){let t="",n=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&kl.hasOwnProperty(t)&&(t=kl[t]))}return xl[t]||t}(e);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),wl.forEach(s=>{s!=n&&(0,Il[s])(e)&&(t+=s+".")}),t+=n,t}static eventCallback(t,n,s){return r=>{e.getEventFullKey(r)===t&&s.runGuarded(()=>n(r))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(ns(Iu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const _l=ou(yu,"browser",[{provide:To,useValue:"browser"},{provide:$o,useValue:function(){Ju.makeCurrent(),sl.init()},multi:!0},{provide:Iu,useFactory:function(){return function(e){mt=e}(document),document},deps:[]}]),Sl=[[],{provide:Kr,useValue:"root"},{provide:ps,useFactory:function(){return new ps},deps:[]},{provide:al,useClass:vl,multi:!0,deps:[Iu,Uo,To]},{provide:al,useClass:Cl,multi:!0,deps:[Iu]},[],{provide:ml,useClass:ml,deps:[il,ll,So]},{provide:ci,useExisting:ml},{provide:ul,useExisting:ll},{provide:ll,useClass:ll,deps:[Iu]},{provide:Jo,useClass:Jo,deps:[Uo]},{provide:il,useClass:il,deps:[al,Uo]},{provide:class{},useClass:rl,deps:[]},[]];let El=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:So,useValue:t.appId},{provide:tl,useExisting:So},nl]}}}return e.\u0275fac=function(t){return new(t||e)(ns(e,12))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:Sl,imports:[Ku,wu]}),e})();function Nl(...e){let t=e[e.length-1];return $(t)?(e.pop(),P(e,t)):K(e)}"undefined"!=typeof window&&window;class $l extends E{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new C;return this._value}next(e){super.next(this._value=e)}}class Tl extends y{notifyNext(e,t,n,s,r){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}class Al extends y{constructor(e,t,n){super(),this.parent=e,this.outerValue=t,this.outerIndex=n,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function Rl(e,t,n,s,r=new Al(e,n,s)){if(!r.closed)return t instanceof k?t.subscribe(r):L(t)(r)}const Fl={};class Dl{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new Ol(e,this.resultSelector))}}class Ol extends Tl{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(Fl),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let n=0;n<t;n++)this.add(Rl(this,e[n],void 0,n))}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,n){const s=this.values,r=this.toRespond?s[n]===Fl?--this.toRespond:this.toRespond:0;s[n]=t,0===r&&(this.resultSelector?this._tryResultSelector(s):this.destination.next(s.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const Ml=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})();function zl(...e){return G(1)(Nl(...e))}const Ll=new k(e=>e.complete());function Pl(e){return e?function(e){return new k(t=>e.schedule(()=>t.complete()))}(e):Ll}function jl(e){return new k(t=>{let n;try{n=e()}catch(s){return void t.error(s)}return(n?j(n):Pl()).subscribe(t)})}function Vl(e,t){return"function"==typeof t?n=>n.pipe(Vl((n,s)=>j(e(n,s)).pipe(T((e,r)=>t(n,e,s,r))))):t=>t.lift(new Wl(e))}class Wl{constructor(e){this.project=e}call(e,t){return t.subscribe(new Bl(e,this.project))}}class Bl extends W{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(s){return void this.destination.error(s)}this._innerSub(t)}_innerSub(e){const t=this.innerSubscription;t&&t.unsubscribe();const n=new V(this),s=this.destination;s.add(n),this.innerSubscription=B(e,n),this.innerSubscription!==n&&s.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(e){this.destination.next(e)}}const ql=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function Ul(e){return t=>0===e?Pl():t.lift(new Hl(e))}class Hl{constructor(e){if(this.total=e,this.total<0)throw new ql}call(e,t){return t.subscribe(new Gl(e,this.total))}}class Gl extends y{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,n=++this.count;n<=t&&(this.destination.next(e),n===t&&(this.destination.complete(),this.unsubscribe()))}}function Kl(e,t){let n=!1;return arguments.length>=2&&(n=!0),function(s){return s.lift(new Xl(e,t,n))}}class Xl{constructor(e,t,n=!1){this.accumulator=e,this.seed=t,this.hasSeed=n}call(e,t){return t.subscribe(new Yl(e,this.accumulator,this.seed,this.hasSeed))}}class Yl extends y{constructor(e,t,n,s){super(e),this.accumulator=t,this._seed=n,this.hasSeed=s,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let n;try{n=this.accumulator(this.seed,e,t)}catch(s){this.destination.error(s)}this.seed=n,this.destination.next(n)}}function Zl(e,t){return function(n){return n.lift(new Jl(e,t))}}class Jl{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new Ql(e,this.predicate,this.thisArg))}}class Ql extends y{constructor(e,t,n){super(e),this.predicate=t,this.thisArg=n,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}t&&this.destination.next(e)}}function ec(e){return function(t){const n=new tc(e),s=t.lift(n);return n.caught=s}}class tc{constructor(e){this.selector=e}call(e,t){return t.subscribe(new nc(e,this.selector,this.caught))}}class nc extends W{constructor(e,t,n){super(e),this.selector=t,this.caught=n}error(e){if(!this.isStopped){let n;try{n=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const s=new V(this);this.add(s);const r=B(n,s);r!==s&&this.add(r)}}}function sc(e,t){return q(e,t,1)}function rc(e){return function(t){return 0===e?Pl():t.lift(new ac(e))}}class ac{constructor(e){if(this.total=e,this.total<0)throw new ql}call(e,t){return t.subscribe(new ic(e,this.total))}}class ic extends y{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,n=this.total,s=this.count++;t.length<n?t.push(e):t[s%n]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const n=this.count>=this.total?this.total:this.count,s=this.ring;for(let r=0;r<n;r++){const r=t++%n;e.next(s[r])}}e.complete()}}function oc(e=cc){return t=>t.lift(new uc(e))}class uc{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new lc(e,this.errorFactory))}}class lc extends y{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function cc(){return new Ml}function hc(e=null){return t=>t.lift(new dc(e))}class dc{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new pc(e,this.defaultValue))}}class pc extends y{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function fc(e,t){const n=arguments.length>=2;return s=>s.pipe(e?Zl((t,n)=>e(t,n,s)):x,Ul(1),n?hc(t):oc(()=>new Ml))}function mc(){}function gc(e,t,n){return function(s){return s.lift(new bc(e,t,n))}}class bc{constructor(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}call(e,t){return t.subscribe(new yc(e,this.nextOrObserver,this.error,this.complete))}}class yc extends y{constructor(e,t,n,s){super(e),this._tapNext=mc,this._tapError=mc,this._tapComplete=mc,this._tapError=n||mc,this._tapComplete=s||mc,o(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||mc,this._tapError=t.error||mc,this._tapComplete=t.complete||mc)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class vc{constructor(e){this.callback=e}call(e,t){return t.subscribe(new wc(e,this.callback))}}class wc extends y{constructor(e,t){super(e),this.add(new m(t))}}class xc{constructor(e,t){this.id=e,this.url=t}}class kc extends xc{constructor(e,t,n="imperative",s=null){super(e,t),this.navigationTrigger=n,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Ic extends xc{constructor(e,t,n){super(e,t),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Cc extends xc{constructor(e,t,n){super(e,t),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class _c extends xc{constructor(e,t,n){super(e,t),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Sc extends xc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ec extends xc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Nc extends xc{constructor(e,t,n,s,r){super(e,t),this.urlAfterRedirects=n,this.state=s,this.shouldActivate=r}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class $c extends xc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Tc extends xc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ac{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Rc{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Fc{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Dc{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Oc{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Mc{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class zc{constructor(e,t,n){this.routerEvent=e,this.position=t,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const Lc="primary";class Pc{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function jc(e){return new Pc(e)}function Vc(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function Wc(e,t,n){const s=n.path.split("/");if(s.length>e.length)return null;if("full"===n.pathMatch&&(t.hasChildren()||s.length<e.length))return null;const r={};for(let a=0;a<s.length;a++){const t=s[a],n=e[a];if(t.startsWith(":"))r[t.substring(1)]=n;else if(t!==n.path)return null}return{consumed:e.slice(0,s.length),posParams:r}}function Bc(e,t){const n=e?Object.keys(e):void 0,s=t?Object.keys(t):void 0;if(!n||!s||n.length!=s.length)return!1;let r;for(let a=0;a<n.length;a++)if(r=n[a],!qc(e[r],t[r]))return!1;return!0}function qc(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const n=[...e].sort(),s=[...t].sort();return n.every((e,t)=>s[t]===e)}return e===t}function Uc(e){return Array.prototype.concat.apply([],e)}function Hc(e){return e.length>0?e[e.length-1]:null}function Gc(e,t){for(const n in e)e.hasOwnProperty(n)&&t(e[n],n)}function Kc(e){return Sa(e)?e:_a(e)?j(Promise.resolve(e)):Nl(e)}const Xc={exact:function e(t,n,s){if(!rh(t.segments,n.segments))return!1;if(!eh(t.segments,n.segments,s))return!1;if(t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children){if(!t.children[r])return!1;if(!e(t.children[r],n.children[r],s))return!1}return!0},subset:Jc},Yc={exact:function(e,t){return Bc(e,t)},subset:function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>qc(e[n],t[n]))},ignored:()=>!0};function Zc(e,t,n){return Xc[n.paths](e.root,t.root,n.matrixParams)&&Yc[n.queryParams](e.queryParams,t.queryParams)&&!("exact"===n.fragment&&e.fragment!==t.fragment)}function Jc(e,t,n){return Qc(e,t,t.segments,n)}function Qc(e,t,n,s){if(e.segments.length>n.length){const r=e.segments.slice(0,n.length);return!!rh(r,n)&&!t.hasChildren()&&!!eh(r,n,s)}if(e.segments.length===n.length){if(!rh(e.segments,n))return!1;if(!eh(e.segments,n,s))return!1;for(const n in t.children){if(!e.children[n])return!1;if(!Jc(e.children[n],t.children[n],s))return!1}return!0}{const r=n.slice(0,e.segments.length),a=n.slice(e.segments.length);return!!rh(e.segments,r)&&!!eh(e.segments,r,s)&&!!e.children.primary&&Qc(e.children.primary,t,a,s)}}function eh(e,t,n){return t.every((t,s)=>Yc[n](e[s].parameters,t.parameters))}class th{constructor(e,t,n){this.root=e,this.queryParams=t,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=jc(this.queryParams)),this._queryParamMap}toString(){return oh.serialize(this)}}class nh{constructor(e,t){this.segments=e,this.children=t,this.parent=null,Gc(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return uh(this)}}class sh{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=jc(this.parameters)),this._parameterMap}toString(){return mh(this)}}function rh(e,t){return e.length===t.length&&e.every((e,n)=>e.path===t[n].path)}class ah{}class ih{parse(e){const t=new wh(e);return new th(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){var t;return`/${lh(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const n=e[t];return Array.isArray(n)?n.map(e=>`${hh(t)}=${hh(e)}`).join("&"):`${hh(t)}=${hh(n)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(e.queryParams)}${"string"==typeof e.fragment?`#${t=e.fragment,encodeURI(t)}`:""}`}}const oh=new ih;function uh(e){return e.segments.map(e=>mh(e)).join("/")}function lh(e,t){if(!e.hasChildren())return uh(e);if(t){const t=e.children.primary?lh(e.children.primary,!1):"",n=[];return Gc(e.children,(e,t)=>{t!==Lc&&n.push(`${t}:${lh(e,!1)}`)}),n.length>0?`${t}(${n.join("//")})`:t}{const t=function(e,t){let n=[];return Gc(e.children,(e,s)=>{s===Lc&&(n=n.concat(t(e,s)))}),Gc(e.children,(e,s)=>{s!==Lc&&(n=n.concat(t(e,s)))}),n}(e,(t,n)=>n===Lc?[lh(e.children.primary,!1)]:[`${n}:${lh(t,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children.primary?`${uh(e)}/${t[0]}`:`${uh(e)}/(${t.join("//")})`}}function ch(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function hh(e){return ch(e).replace(/%3B/gi,";")}function dh(e){return ch(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function ph(e){return decodeURIComponent(e)}function fh(e){return ph(e.replace(/\+/g,"%20"))}function mh(e){return`${dh(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${dh(e)}=${dh(t[e])}`).join("")}`;var t}const gh=/^[^\/()?;=#]+/;function bh(e){const t=e.match(gh);return t?t[0]:""}const yh=/^[^=?&#]+/,vh=/^[^?&#]+/;class wh{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new nh([],{}):new nh([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(n.primary=new nh(e,t)),n}parseSegment(){const e=bh(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new sh(ph(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=bh(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=bh(this.remaining);e&&(n=e,this.capture(n))}e[ph(t)]=ph(n)}parseQueryParam(e){const t=function(e){const t=e.match(yh);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(vh);return t?t[0]:""}(this.remaining);e&&(n=e,this.capture(n))}const s=fh(t),r=fh(n);if(e.hasOwnProperty(s)){let t=e[s];Array.isArray(t)||(t=[t],e[s]=t),t.push(r)}else e[s]=r}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=bh(this.remaining),s=this.remaining[n.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let r;n.indexOf(":")>-1?(r=n.substr(0,n.indexOf(":")),this.capture(r),this.capture(":")):e&&(r=Lc);const a=this.parseChildren();t[r]=1===Object.keys(a).length?a.primary:new nh([],a),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class xh{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=kh(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=kh(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=Ih(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return Ih(e,this._root).map(e=>e.value)}}function kh(e,t){if(e===t.value)return t;for(const n of t.children){const t=kh(e,n);if(t)return t}return null}function Ih(e,t){if(e===t.value)return[t];for(const n of t.children){const s=Ih(e,n);if(s.length)return s.unshift(t),s}return[]}class Ch{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function _h(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class Sh extends xh{constructor(e,t){super(e),this.snapshot=t,Rh(this,e)}toString(){return this.snapshot.toString()}}function Eh(e,t){const n=function(e,t){const n=new Th([],{},{},"",{},Lc,t,null,e.root,-1,{});return new Ah("",new Ch(n,[]))}(e,t),s=new $l([new sh("",{})]),r=new $l({}),a=new $l({}),i=new $l({}),o=new $l(""),u=new Nh(s,r,i,o,a,Lc,t,n.root);return u.snapshot=n.root,new Sh(new Ch(u,[]),n)}class Nh{constructor(e,t,n,s,r,a,i,o){this.url=e,this.params=t,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=a,this.component=i,this._futureSnapshot=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(T(e=>jc(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(T(e=>jc(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function $h(e,t="emptyOnly"){const n=e.pathFromRoot;let s=0;if("always"!==t)for(s=n.length-1;s>=1;){const e=n[s],t=n[s-1];if(e.routeConfig&&""===e.routeConfig.path)s--;else{if(t.component)break;s--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(s))}class Th{constructor(e,t,n,s,r,a,i,o,u,l,c){this.url=e,this.params=t,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=a,this.component=i,this.routeConfig=o,this._urlSegment=u,this._lastPathIndex=l,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=jc(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=jc(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Ah extends xh{constructor(e,t){super(t),this.url=e,Rh(this,t)}toString(){return Fh(this._root)}}function Rh(e,t){t.value._routerState=e,t.children.forEach(t=>Rh(e,t))}function Fh(e){const t=e.children.length>0?` { ${e.children.map(Fh).join(", ")} } `:"";return`${e.value}${t}`}function Dh(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,Bc(t.queryParams,n.queryParams)||e.queryParams.next(n.queryParams),t.fragment!==n.fragment&&e.fragment.next(n.fragment),Bc(t.params,n.params)||e.params.next(n.params),function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!Bc(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.url.next(n.url),Bc(t.data,n.data)||e.data.next(n.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function Oh(e,t){var n,s;return Bc(e.params,t.params)&&rh(n=e.url,s=t.url)&&n.every((e,t)=>Bc(e.parameters,s[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||Oh(e.parent,t.parent))}function Mh(e,t,n){if(n&&e.shouldReuseRoute(t.value,n.value.snapshot)){const s=n.value;s._futureSnapshot=t.value;const r=function(e,t,n){return t.children.map(t=>{for(const s of n.children)if(e.shouldReuseRoute(t.value,s.value.snapshot))return Mh(e,t,s);return Mh(e,t)})}(e,t,n);return new Ch(s,r)}{if(e.shouldAttach(t.value)){const n=e.retrieve(t.value);if(null!==n){const e=n.route;return zh(t,e),e}}const n=new Nh(new $l((s=t.value).url),new $l(s.params),new $l(s.queryParams),new $l(s.fragment),new $l(s.data),s.outlet,s.component,s),r=t.children.map(t=>Mh(e,t));return new Ch(n,r)}var s}function zh(e,t){if(e.value.routeConfig!==t.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==t.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");t.value._futureSnapshot=e.value;for(let n=0;n<e.children.length;++n)zh(e.children[n],t.children[n])}function Lh(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function Ph(e){return"object"==typeof e&&null!=e&&e.outlets}function jh(e,t,n,s,r){let a={};return s&&Gc(s,(e,t)=>{a[t]=Array.isArray(e)?e.map(e=>`${e}`):`${e}`}),new th(n.root===e?t:Vh(n.root,e,t),a,r)}function Vh(e,t,n){const s={};return Gc(e.children,(e,r)=>{s[r]=e===t?n:Vh(e,t,n)}),new nh(e.segments,s)}class Wh{constructor(e,t,n){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=n,e&&n.length>0&&Lh(n[0]))throw new Error("Root segment cannot have matrix parameters");const s=n.find(Ph);if(s&&s!==Hc(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Bh{constructor(e,t,n){this.segmentGroup=e,this.processChildren=t,this.index=n}}function qh(e,t,n){if(e||(e=new nh([],{})),0===e.segments.length&&e.hasChildren())return Uh(e,t,n);const s=function(e,t,n){let s=0,r=t;const a={match:!1,pathIndex:0,commandIndex:0};for(;r<e.segments.length;){if(s>=n.length)return a;const t=e.segments[r],i=n[s];if(Ph(i))break;const o=`${i}`,u=s<n.length-1?n[s+1]:null;if(r>0&&void 0===o)break;if(o&&u&&"object"==typeof u&&void 0===u.outlets){if(!Xh(o,u,t))return a;s+=2}else{if(!Xh(o,{},t))return a;s++}r++}return{match:!0,pathIndex:r,commandIndex:s}}(e,t,n),r=n.slice(s.commandIndex);if(s.match&&s.pathIndex<e.segments.length){const t=new nh(e.segments.slice(0,s.pathIndex),{});return t.children.primary=new nh(e.segments.slice(s.pathIndex),e.children),Uh(t,0,r)}return s.match&&0===r.length?new nh(e.segments,{}):s.match&&!e.hasChildren()?Hh(e,t,n):s.match?Uh(e,0,r):Hh(e,t,n)}function Uh(e,t,n){if(0===n.length)return new nh(e.segments,{});{const s=function(e){return Ph(e[0])?e[0].outlets:{[Lc]:e}}(n),r={};return Gc(s,(n,s)=>{"string"==typeof n&&(n=[n]),null!==n&&(r[s]=qh(e.children[s],t,n))}),Gc(e.children,(e,t)=>{void 0===s[t]&&(r[t]=e)}),new nh(e.segments,r)}}function Hh(e,t,n){const s=e.segments.slice(0,t);let r=0;for(;r<n.length;){const a=n[r];if(Ph(a)){const e=Gh(a.outlets);return new nh(s,e)}if(0===r&&Lh(n[0])){s.push(new sh(e.segments[t].path,Kh(n[0]))),r++;continue}const i=Ph(a)?a.outlets.primary:`${a}`,o=r<n.length-1?n[r+1]:null;i&&o&&Lh(o)?(s.push(new sh(i,Kh(o))),r+=2):(s.push(new sh(i,{})),r++)}return new nh(s,{})}function Gh(e){const t={};return Gc(e,(e,n)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[n]=Hh(new nh([],{}),0,e))}),t}function Kh(e){const t={};return Gc(e,(e,n)=>t[n]=`${e}`),t}function Xh(e,t,n){return e==n.path&&Bc(t,n.parameters)}class Yh{constructor(e,t,n,s){this.routeReuseStrategy=e,this.futureState=t,this.currState=n,this.forwardEvent=s}activate(e){const t=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,n,e),Dh(this.futureState.root),this.activateChildRoutes(t,n,e)}deactivateChildRoutes(e,t,n){const s=_h(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,s[t],n),delete s[t]}),Gc(s,(e,t)=>{this.deactivateRouteAndItsChildren(e,n)})}deactivateRoutes(e,t,n){const s=e.value,r=t?t.value:null;if(s===r)if(s.component){const r=n.getContext(s.outlet);r&&this.deactivateChildRoutes(e,t,r.children)}else this.deactivateChildRoutes(e,t,n);else r&&this.deactivateRouteAndItsChildren(t,n)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const n=t.getContext(e.value.outlet);if(n&&n.outlet){const t=n.outlet.detach(),s=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:s})}}deactivateRouteAndOutlet(e,t){const n=t.getContext(e.value.outlet),s=n&&e.value.component?n.children:t,r=_h(e);for(const a of Object.keys(r))this.deactivateRouteAndItsChildren(r[a],s);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(e,t,n){const s=_h(t);e.children.forEach(e=>{this.activateRoutes(e,s[e.value.outlet],n),this.forwardEvent(new Mc(e.value.snapshot))}),e.children.length&&this.forwardEvent(new Dc(e.value.snapshot))}activateRoutes(e,t,n){const s=e.value,r=t?t.value:null;if(Dh(s),s===r)if(s.component){const r=n.getOrCreateContext(s.outlet);this.activateChildRoutes(e,t,r.children)}else this.activateChildRoutes(e,t,n);else if(s.component){const t=n.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const e=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),Zh(e.route)}else{const n=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(s.snapshot),r=n?n.module.componentFactoryResolver:null;t.attachRef=null,t.route=s,t.resolver=r,t.outlet&&t.outlet.activateWith(s,r),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,n)}}function Zh(e){Dh(e.value),e.children.forEach(Zh)}class Jh{constructor(e,t){this.routes=e,this.module=t}}function Qh(e){return"function"==typeof e}function ed(e){return e instanceof th}const td=Symbol("INITIAL_VALUE");function nd(){return Vl(e=>function(...e){let t,n;return $(e[e.length-1])&&(n=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&d(e[0])&&(e=e[0]),K(e,n).lift(new Dl(t))}(e.map(e=>e.pipe(Ul(1),function(...e){const t=e[e.length-1];return $(t)?(e.pop(),n=>zl(e,n,t)):t=>zl(e,t)}(td)))).pipe(Kl((e,t)=>{let n=!1;return t.reduce((e,s,r)=>{if(e!==td)return e;if(s===td&&(n=!0),!n){if(!1===s)return s;if(r===t.length-1||ed(s))return s}return e},e)},td),Zl(e=>e!==td),T(e=>ed(e)?e:!0===e),Ul(1)))}let sd=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=Ue({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&Ca(0,"router-outlet")},directives:function(){return[Zd]},encapsulation:2}),e})();function rd(e,t=""){for(let n=0;n<e.length;n++){const s=e[n];ad(s,id(t,s))}}function ad(e,t){e.children&&rd(e.children,t)}function id(e,t){return t?e||t.path?e&&!t.path?`${e}/`:!e&&t.path?t.path:`${e}/${t.path}`:"":e}function od(e){const t=e.children&&e.children.map(od),n=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!n.component&&(t||n.loadChildren)&&n.outlet&&n.outlet!==Lc&&(n.component=sd),n}function ud(e){return e.outlet||Lc}function ld(e,t){const n=e.filter(e=>ud(e)===t);return n.push(...e.filter(e=>ud(e)!==t)),n}const cd={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function hd(e,t,n){var s;if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?Object.assign({},cd):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const r=(t.matcher||Wc)(n,e,t);if(!r)return Object.assign({},cd);const a={};Gc(r.posParams,(e,t)=>{a[t]=e.path});const i=r.consumed.length>0?Object.assign(Object.assign({},a),r.consumed[r.consumed.length-1].parameters):a;return{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:i,positionalParamSegments:null!==(s=r.posParams)&&void 0!==s?s:{}}}function dd(e,t,n,s,r="corrected"){if(n.length>0&&function(e,t,n){return n.some(n=>pd(e,t,n)&&ud(n)!==Lc)}(e,n,s)){const r=new nh(t,function(e,t,n,s){const r={};r.primary=s,s._sourceSegment=e,s._segmentIndexShift=t.length;for(const a of n)if(""===a.path&&ud(a)!==Lc){const n=new nh([],{});n._sourceSegment=e,n._segmentIndexShift=t.length,r[ud(a)]=n}return r}(e,t,s,new nh(n,e.children)));return r._sourceSegment=e,r._segmentIndexShift=t.length,{segmentGroup:r,slicedSegments:[]}}if(0===n.length&&function(e,t,n){return n.some(n=>pd(e,t,n))}(e,n,s)){const a=new nh(e.segments,function(e,t,n,s,r,a){const i={};for(const o of s)if(pd(e,n,o)&&!r[ud(o)]){const n=new nh([],{});n._sourceSegment=e,n._segmentIndexShift="legacy"===a?e.segments.length:t.length,i[ud(o)]=n}return Object.assign(Object.assign({},r),i)}(e,t,n,s,e.children,r));return a._sourceSegment=e,a._segmentIndexShift=t.length,{segmentGroup:a,slicedSegments:n}}const a=new nh(e.segments,e.children);return a._sourceSegment=e,a._segmentIndexShift=t.length,{segmentGroup:a,slicedSegments:n}}function pd(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path}function fd(e,t,n,s){return!!(ud(e)===s||s!==Lc&&pd(t,n,e))&&("**"===e.path||hd(t,e,n).matched)}function md(e,t,n){return 0===t.length&&!e.children[n]}class gd{constructor(e){this.segmentGroup=e||null}}class bd{constructor(e){this.urlTree=e}}function yd(e){return new k(t=>t.error(new gd(e)))}function vd(e){return new k(t=>t.error(new bd(e)))}function wd(e){return new k(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class xd{constructor(e,t,n,s,r){this.configLoader=t,this.urlSerializer=n,this.urlTree=s,this.config=r,this.allowRedirects=!0,this.ngModule=e.get(Bi)}apply(){const e=dd(this.urlTree.root,[],[],this.config).segmentGroup,t=new nh(e.segments,e.children);return this.expandSegmentGroup(this.ngModule,this.config,t,Lc).pipe(T(e=>this.createUrlTree(kd(e),this.urlTree.queryParams,this.urlTree.fragment))).pipe(ec(e=>{if(e instanceof bd)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof gd)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,Lc).pipe(T(t=>this.createUrlTree(kd(t),e.queryParams,e.fragment))).pipe(ec(e=>{if(e instanceof gd)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,n){const s=e.segments.length>0?new nh([],{[Lc]:e}):e;return new th(s,t,n)}expandSegmentGroup(e,t,n,s){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(e,t,n).pipe(T(e=>new nh([],e))):this.expandSegment(e,n,t,n.segments,s,!0)}expandChildren(e,t,n){const s=[];for(const r of Object.keys(n.children))"primary"===r?s.unshift(r):s.push(r);return j(s).pipe(sc(s=>{const r=n.children[s],a=ld(t,s);return this.expandSegmentGroup(e,a,r,s).pipe(T(e=>({segment:e,outlet:s})))}),Kl((e,t)=>(e[t.outlet]=t.segment,e),{}),function(e,t){const n=arguments.length>=2;return s=>s.pipe(e?Zl((t,n)=>e(t,n,s)):x,rc(1),n?hc(t):oc(()=>new Ml))}())}expandSegment(e,t,n,s,r,a){return j(n).pipe(sc(i=>this.expandSegmentAgainstRoute(e,t,n,i,s,r,a).pipe(ec(e=>{if(e instanceof gd)return Nl(null);throw e}))),fc(e=>!!e),ec((e,n)=>{if(e instanceof Ml||"EmptyError"===e.name){if(md(t,s,r))return Nl(new nh([],{}));throw new gd(t)}throw e}))}expandSegmentAgainstRoute(e,t,n,s,r,a,i){return fd(s,t,r,a)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(e,t,s,r,a):i&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a):yd(t):yd(t)}expandSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,s,a):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,n,s){const r=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?vd(r):this.lineralizeSegments(n,r).pipe(q(n=>{const r=new nh(n,{});return this.expandSegment(e,r,t,n,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a){const{matched:i,consumedSegments:o,lastChild:u,positionalParamSegments:l}=hd(t,s,r);if(!i)return yd(t);const c=this.applyRedirectCommands(o,s.redirectTo,l);return s.redirectTo.startsWith("/")?vd(c):this.lineralizeSegments(s,c).pipe(q(s=>this.expandSegment(e,t,n,s.concat(r.slice(u)),a,!1)))}matchSegmentAgainstRoute(e,t,n,s,r){if("**"===n.path)return n.loadChildren?(n._loadedConfig?Nl(n._loadedConfig):this.configLoader.load(e.injector,n)).pipe(T(e=>(n._loadedConfig=e,new nh(s,{})))):Nl(new nh(s,{}));const{matched:a,consumedSegments:i,lastChild:o}=hd(t,n,s);if(!a)return yd(t);const u=s.slice(o);return this.getChildConfig(e,n,s).pipe(q(e=>{const s=e.module,a=e.routes,{segmentGroup:o,slicedSegments:l}=dd(t,i,u,a),c=new nh(o.segments,o.children);if(0===l.length&&c.hasChildren())return this.expandChildren(s,a,c).pipe(T(e=>new nh(i,e)));if(0===a.length&&0===l.length)return Nl(new nh(i,{}));const h=ud(n)===r;return this.expandSegment(s,c,a,l,h?Lc:r,!0).pipe(T(e=>new nh(i.concat(e.segments),e.children)))}))}getChildConfig(e,t,n){return t.children?Nl(new Jh(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?Nl(t._loadedConfig):this.runCanLoadGuards(e.injector,t,n).pipe(q(n=>n?this.configLoader.load(e.injector,t).pipe(T(e=>(t._loadedConfig=e,e))):function(e){return new k(t=>t.error(Vc(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):Nl(new Jh([],e))}runCanLoadGuards(e,t,n){const s=t.canLoad;return s&&0!==s.length?Nl(s.map(s=>{const r=e.get(s);let a;if(function(e){return e&&Qh(e.canLoad)}(r))a=r.canLoad(t,n);else{if(!Qh(r))throw new Error("Invalid CanLoad guard");a=r(t,n)}return Kc(a)})).pipe(nd(),gc(e=>{if(!ed(e))return;const t=Vc(`Redirecting to "${this.urlSerializer.serialize(e)}"`);throw t.url=e,t}),T(e=>!0===e)):Nl(!0)}lineralizeSegments(e,t){let n=[],s=t.root;for(;;){if(n=n.concat(s.segments),0===s.numberOfChildren)return Nl(n);if(s.numberOfChildren>1||!s.children.primary)return wd(e.redirectTo);s=s.children.primary}}applyRedirectCommands(e,t,n){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,n)}applyRedirectCreatreUrlTree(e,t,n,s){const r=this.createSegmentGroup(e,t.root,n,s);return new th(r,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const n={};return Gc(e,(e,s)=>{if("string"==typeof e&&e.startsWith(":")){const r=e.substring(1);n[s]=t[r]}else n[s]=e}),n}createSegmentGroup(e,t,n,s){const r=this.createSegments(e,t.segments,n,s);let a={};return Gc(t.children,(t,r)=>{a[r]=this.createSegmentGroup(e,t,n,s)}),new nh(r,a)}createSegments(e,t,n,s){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,s):this.findOrReturn(t,n))}findPosParam(e,t,n){const s=n[t.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return s}findOrReturn(e,t){let n=0;for(const s of t){if(s.path===e.path)return t.splice(n),s;n++}return e}}function kd(e){const t={};for(const n of Object.keys(e.children)){const s=kd(e.children[n]);(s.segments.length>0||s.hasChildren())&&(t[n]=s)}return function(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new nh(e.segments.concat(t.segments),t.children)}return e}(new nh(e.segments,t))}class Id{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class Cd{constructor(e,t){this.component=e,this.route=t}}function _d(e,t,n){const s=e._root;return Ed(s,t?t._root:null,n,[s.value])}function Sd(e,t,n){const s=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(s?s.module.injector:n).get(e)}function Ed(e,t,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const a=_h(t);return e.children.forEach(e=>{!function(e,t,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const a=e.value,i=t?t.value:null,o=n?n.getContext(e.value.outlet):null;if(i&&a.routeConfig===i.routeConfig){const u=function(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!rh(e.url,t.url);case"pathParamsOrQueryParamsChange":return!rh(e.url,t.url)||!Bc(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Oh(e,t)||!Bc(e.queryParams,t.queryParams);case"paramsChange":default:return!Oh(e,t)}}(i,a,a.routeConfig.runGuardsAndResolvers);u?r.canActivateChecks.push(new Id(s)):(a.data=i.data,a._resolvedData=i._resolvedData),Ed(e,t,a.component?o?o.children:null:n,s,r),u&&o&&o.outlet&&o.outlet.isActivated&&r.canDeactivateChecks.push(new Cd(o.outlet.component,i))}else i&&Nd(t,o,r),r.canActivateChecks.push(new Id(s)),Ed(e,null,a.component?o?o.children:null:n,s,r)}(e,a[e.value.outlet],n,s.concat([e.value]),r),delete a[e.value.outlet]}),Gc(a,(e,t)=>Nd(e,n.getContext(t),r)),r}function Nd(e,t,n){const s=_h(e),r=e.value;Gc(s,(e,s)=>{Nd(e,r.component?t?t.children.getContext(s):null:t,n)}),n.canDeactivateChecks.push(new Cd(r.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,r))}class $d{}function Td(e){return new k(t=>t.error(e))}class Ad{constructor(e,t,n,s,r,a){this.rootComponentType=e,this.config=t,this.urlTree=n,this.url=s,this.paramsInheritanceStrategy=r,this.relativeLinkResolution=a}recognize(){const e=dd(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,Lc);if(null===t)return null;const n=new Th([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Lc,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new Ch(n,t),r=new Ah(this.url,s);return this.inheritParamsAndData(r._root),r}inheritParamsAndData(e){const t=e.value,n=$h(t,this.paramsInheritanceStrategy);t.params=Object.freeze(n.params),t.data=Object.freeze(n.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,n){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,n)}processChildren(e,t){const n=[];for(const r of Object.keys(t.children)){const s=t.children[r],a=ld(e,r),i=this.processSegmentGroup(a,s,r);if(null===i)return null;n.push(...i)}const s=Fd(n);return s.sort((e,t)=>e.value.outlet===Lc?-1:t.value.outlet===Lc?1:e.value.outlet.localeCompare(t.value.outlet)),s}processSegment(e,t,n,s){for(const r of e){const e=this.processSegmentAgainstRoute(r,t,n,s);if(null!==e)return e}return md(t,n,s)?[]:null}processSegmentAgainstRoute(e,t,n,s){if(e.redirectTo||!fd(e,t,n,s))return null;let r,a=[],i=[];if("**"===e.path){const s=n.length>0?Hc(n).parameters:{};r=new Th(n,s,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Md(e),ud(e),e.component,e,Dd(t),Od(t)+n.length,zd(e))}else{const s=hd(t,e,n);if(!s.matched)return null;a=s.consumedSegments,i=n.slice(s.lastChild),r=new Th(a,s.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Md(e),ud(e),e.component,e,Dd(t),Od(t)+a.length,zd(e))}const o=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:u,slicedSegments:l}=dd(t,a,i,o.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution);if(0===l.length&&u.hasChildren()){const e=this.processChildren(o,u);return null===e?null:[new Ch(r,e)]}if(0===o.length&&0===l.length)return[new Ch(r,[])];const c=ud(e)===s,h=this.processSegment(o,u,l,c?Lc:s);return null===h?null:[new Ch(r,h)]}}function Rd(e){const t=e.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function Fd(e){const t=[],n=new Set;for(const s of e){if(!Rd(s)){t.push(s);continue}const e=t.find(e=>s.value.routeConfig===e.value.routeConfig);void 0!==e?(e.children.push(...s.children),n.add(e)):t.push(s)}for(const s of n){const e=Fd(s.children);t.push(new Ch(s.value,e))}return t.filter(e=>!n.has(e))}function Dd(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function Od(e){let t=e,n=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,n+=t._segmentIndexShift?t._segmentIndexShift:0;return n-1}function Md(e){return e.data||{}}function zd(e){return e.resolve||{}}function Ld(e){return Vl(t=>{const n=e(t);return n?j(n).pipe(T(()=>t)):Nl(t)})}class Pd extends class{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}{}const jd=new Pn("ROUTES");class Vd{constructor(e,t,n,s){this.loader=e,this.compiler=t,this.onLoadStartListener=n,this.onLoadEndListener=s}load(e,t){if(t._loader$)return t._loader$;this.onLoadStartListener&&this.onLoadStartListener(t);const n=this.loadModuleFactory(t.loadChildren).pipe(T(n=>{this.onLoadEndListener&&this.onLoadEndListener(t);const s=n.create(e);return new Jh(Uc(s.injector.get(jd,void 0,Ie.Self|Ie.Optional)).map(od),s)}),ec(e=>{throw t._loader$=void 0,e}));return t._loader$=new J(n,()=>new E).pipe(X()),t._loader$}loadModuleFactory(e){return"string"==typeof e?j(this.loader.load(e)):Kc(e()).pipe(q(e=>e instanceof qi?Nl(e):j(this.compiler.compileModuleAsync(e))))}}class Wd{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new Bd,this.attachRef=null}}class Bd{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const n=this.getOrCreateContext(e);n.outlet=t,this.contexts.set(e,n)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new Wd,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}class qd{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function Ud(e){throw e}function Hd(e,t,n){return t.parse("/")}function Gd(e,t){return Nl(null)}const Kd={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Xd={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Yd=(()=>{class e{constructor(e,t,n,s,r,a,i,o){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=n,this.location=s,this.config=o,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new E,this.errorHandler=Ud,this.malformedUriErrorHandler=Hd,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Gd,afterPreactivation:Gd},this.urlHandlingStrategy=new qd,this.routeReuseStrategy=new Pd,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=r.get(Bi),this.console=r.get(Ro);const u=r.get(Uo);this.isNgZoneEnabled=u instanceof Uo&&Uo.isInAngularZone(),this.resetConfig(o),this.currentUrlTree=new th(new nh([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new Vd(a,i,e=>this.triggerEvent(new Ac(e)),e=>this.triggerEvent(new Rc(e))),this.routerState=Eh(this.currentUrlTree,this.rootComponentType),this.transitions=new $l({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(Zl(e=>0!==e.id),T(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),Vl(e=>{let n=!1,s=!1;return Nl(e).pipe(gc(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Vl(e=>{const n=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return Nl(e).pipe(Vl(e=>{const n=this.transitions.getValue();return t.next(new kc(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),n!==this.transitions.getValue()?Ll:Promise.resolve(e)}),function(e,t,n,s){return Vl(r=>function(e,t,n,s,r){return new xd(e,t,n,s,r).apply()}(e,t,n,r.extractedUrl,s).pipe(T(e=>Object.assign(Object.assign({},r),{urlAfterRedirects:e}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),gc(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,n,s,r){return q(a=>function(e,t,n,s,r="emptyOnly",a="legacy"){try{const i=new Ad(e,t,n,s,r,a).recognize();return null===i?Td(new $d):Nl(i)}catch(i){return Td(i)}}(e,t,a.urlAfterRedirects,n(a.urlAfterRedirects),s,r).pipe(T(e=>Object.assign(Object.assign({},a),{targetSnapshot:e}))))}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),gc(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,e),this.browserUrlTree=e.urlAfterRedirects);const n=new Sc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:s,source:r,restoredState:a,extras:i}=e,o=new kc(n,this.serializeUrl(s),r,a);t.next(o);const u=Eh(s,this.rootComponentType).snapshot;return Nl(Object.assign(Object.assign({},e),{targetSnapshot:u,urlAfterRedirects:s,extras:Object.assign(Object.assign({},i),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),Ll}),Ld(e=>{const{targetSnapshot:t,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:a,replaceUrl:i}}=e;return this.hooks.beforePreactivation(t,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!a,replaceUrl:!!i})}),gc(e=>{const t=new Ec(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),T(e=>Object.assign(Object.assign({},e),{guards:_d(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return q(n=>{const{targetSnapshot:s,currentSnapshot:r,guards:{canActivateChecks:a,canDeactivateChecks:i}}=n;return 0===i.length&&0===a.length?Nl(Object.assign(Object.assign({},n),{guardsResult:!0})):function(e,t,n,s){return j(e).pipe(q(e=>function(e,t,n,s,r){const a=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return a&&0!==a.length?Nl(a.map(a=>{const i=Sd(a,t,r);let o;if(function(e){return e&&Qh(e.canDeactivate)}(i))o=Kc(i.canDeactivate(e,t,n,s));else{if(!Qh(i))throw new Error("Invalid CanDeactivate guard");o=Kc(i(e,t,n,s))}return o.pipe(fc())})).pipe(nd()):Nl(!0)}(e.component,e.route,n,t,s)),fc(e=>!0!==e,!0))}(i,s,r,e).pipe(q(n=>n&&"boolean"==typeof n?function(e,t,n,s){return j(t).pipe(sc(t=>zl(function(e,t){return null!==e&&t&&t(new Fc(e)),Nl(!0)}(t.route.parent,s),function(e,t){return null!==e&&t&&t(new Oc(e)),Nl(!0)}(t.route,s),function(e,t,n){const s=t[t.length-1],r=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>jl(()=>Nl(t.guards.map(r=>{const a=Sd(r,t.node,n);let i;if(function(e){return e&&Qh(e.canActivateChild)}(a))i=Kc(a.canActivateChild(s,e));else{if(!Qh(a))throw new Error("Invalid CanActivateChild guard");i=Kc(a(s,e))}return i.pipe(fc())})).pipe(nd())));return Nl(r).pipe(nd())}(e,t.path,n),function(e,t,n){const s=t.routeConfig?t.routeConfig.canActivate:null;return s&&0!==s.length?Nl(s.map(s=>jl(()=>{const r=Sd(s,t,n);let a;if(function(e){return e&&Qh(e.canActivate)}(r))a=Kc(r.canActivate(t,e));else{if(!Qh(r))throw new Error("Invalid CanActivate guard");a=Kc(r(t,e))}return a.pipe(fc())}))).pipe(nd()):Nl(!0)}(e,t.route,n))),fc(e=>!0!==e,!0))}(s,a,e,t):Nl(n)),T(e=>Object.assign(Object.assign({},n),{guardsResult:e})))})}(this.ngModule.injector,e=>this.triggerEvent(e)),gc(e=>{if(ed(e.guardsResult)){const t=Vc(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}const t=new Nc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),Zl(e=>!!e.guardsResult||(this.cancelNavigationTransition(e,""),!1)),Ld(e=>{if(e.guards.canActivateChecks.length)return Nl(e).pipe(gc(e=>{const t=new $c(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),Vl(e=>{let t=!1;return Nl(e).pipe((n=this.paramsInheritanceStrategy,s=this.ngModule.injector,q(e=>{const{targetSnapshot:t,guards:{canActivateChecks:r}}=e;if(!r.length)return Nl(e);let a=0;return j(r).pipe(sc(e=>function(e,t,n,s){return function(e,t,n,s){const r=Object.keys(e);if(0===r.length)return Nl({});const a={};return j(r).pipe(q(r=>function(e,t,n,s){const r=Sd(e,t,s);return Kc(r.resolve?r.resolve(t,n):r(t,n))}(e[r],t,n,s).pipe(gc(e=>{a[r]=e}))),rc(1),q(()=>Object.keys(a).length===r.length?Nl(a):Ll))}(e._resolve,e,t,s).pipe(T(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),$h(e,n).resolve),null)))}(e.route,t,n,s)),gc(()=>a++),rc(1),q(t=>a===r.length?Nl(e):Ll))})),gc({next:()=>t=!0,complete:()=>{t||this.cancelNavigationTransition(e,"At least one route resolver didn't emit any value.")}}));var n,s}),gc(e=>{const t=new Tc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}))}),Ld(e=>{const{targetSnapshot:t,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:a,replaceUrl:i}}=e;return this.hooks.afterPreactivation(t,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!a,replaceUrl:!!i})}),T(e=>{const t=function(e,t,n){const s=Mh(e,t._root,n?n._root:void 0);return new Sh(s,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),gc(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,e),this.browserUrlTree=e.urlAfterRedirects)}),(a=this.rootContexts,i=this.routeReuseStrategy,o=e=>this.triggerEvent(e),T(e=>(new Yh(i,e.targetRouterState,e.currentRouterState,o).activate(a),e))),gc({next(){n=!0},complete(){n=!0}}),(r=()=>{n||s||this.cancelNavigationTransition(e,`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`),this.currentNavigation=null},e=>e.lift(new vc(r))),ec(n=>{if(s=!0,(r=n)&&r.ngNavigationCancelingError){const s=ed(n.url);s||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const r=new Cc(e.id,this.serializeUrl(e.extractedUrl),n.message);t.next(r),s?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const s=new _c(e.id,this.serializeUrl(e.extractedUrl),n);t.next(s);try{e.resolve(this.errorHandler(n))}catch(a){e.reject(a)}}var r;return Ll}));var r,a,i,o}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const t=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,t)&&setTimeout(()=>{const{source:e,state:n,urlTree:s}=t,r={replaceUrl:!0};if(n){const e=Object.assign({},n);delete e.navigationId,delete e.\u0275routerPageId,0!==Object.keys(e).length&&(r.state=e)}this.scheduleNavigation(s,e,n,r)},0),this.lastLocationChangeInfo=t}))}extractLocationChangeInfoFromEvent(e){var t;return{source:"popstate"===e.type?"popstate":"hashchange",urlTree:this.parseUrl(e.url),state:(null===(t=e.state)||void 0===t?void 0:t.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,t){if(!e)return!0;const n=t.urlTree.toString()===e.urlTree.toString();return!(t.transitionId===e.transitionId&&n&&("hashchange"===t.source&&"popstate"===e.source||"popstate"===t.source&&"hashchange"===e.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){rd(e),this.config=e.map(od),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,t={}){const{relativeTo:n,queryParams:s,fragment:r,queryParamsHandling:a,preserveFragment:i}=t,o=n||this.routerState.root,u=i?this.currentUrlTree.fragment:r;let l=null;switch(a){case"merge":l=Object.assign(Object.assign({},this.currentUrlTree.queryParams),s);break;case"preserve":l=this.currentUrlTree.queryParams;break;default:l=s||null}return null!==l&&(l=this.removeEmptyProps(l)),function(e,t,n,s,r){if(0===n.length)return jh(t.root,t.root,t,s,r);const a=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new Wh(!0,0,e);let t=0,n=!1;const s=e.reduce((e,s,r)=>{if("object"==typeof s&&null!=s){if(s.outlets){const t={};return Gc(s.outlets,(e,n)=>{t[n]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(s.segmentPath)return[...e,s.segmentPath]}return"string"!=typeof s?[...e,s]:0===r?(s.split("/").forEach((s,r)=>{0==r&&"."===s||(0==r&&""===s?n=!0:".."===s?t++:""!=s&&e.push(s))}),e):[...e,s]},[]);return new Wh(n,t,s)}(n);if(a.toRoot())return jh(t.root,new nh([],{}),t,s,r);const i=function(e,t,n){if(e.isAbsolute)return new Bh(t.root,!0,0);if(-1===n.snapshot._lastPathIndex){const e=n.snapshot._urlSegment;return new Bh(e,e===t.root,0)}const s=Lh(e.commands[0])?0:1;return function(e,t,n){let s=e,r=t,a=n;for(;a>r;){if(a-=r,s=s.parent,!s)throw new Error("Invalid number of '../'");r=s.segments.length}return new Bh(s,!1,r-a)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+s,e.numberOfDoubleDots)}(a,t,e),o=i.processChildren?Uh(i.segmentGroup,i.index,a.commands):qh(i.segmentGroup,i.index,a.commands);return jh(i.segmentGroup,o,t,s,r)}(o,this.currentUrlTree,e,l,null!=u?u:null)}navigateByUrl(e,t={skipLocationChange:!1}){const n=ed(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(n,this.rawUrlTree);let r=null;return"computed"===this.canceledNavigationResolution&&(0===this.currentPageId||t.skipLocationChange||t.replaceUrl)&&(r=this.location.getState()),this.scheduleNavigation(s,"imperative",r,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const n=e[t];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(n){t=this.malformedUriErrorHandler(n,this.urlSerializer,e)}return t}isActive(e,t){let n;if(n=!0===t?Object.assign({},Kd):!1===t?Object.assign({},Xd):t,ed(e))return Zc(this.currentUrlTree,e,n);const s=this.parseUrl(e);return Zc(this.currentUrlTree,s,n)}removeEmptyProps(e){return Object.keys(e).reduce((t,n)=>{const s=e[n];return null!=s&&(t[n]=s),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new Ic(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,n,s,r){if(this.disposed)return Promise.resolve(!1);const a=this.getTransition(),i="imperative"!==t&&"imperative"===(null==a?void 0:a.source),o=(this.lastSuccessfulId===a.id||this.currentNavigation?a.rawUrl:a.urlAfterRedirects).toString()===e.toString();if(i&&o)return Promise.resolve(!0);let u,l,c;r?(u=r.resolve,l=r.reject,c=r.promise):c=new Promise((e,t)=>{u=e,l=t});const h=++this.navigationId;let d;return d="computed"===this.canceledNavigationResolution?n&&n.\u0275routerPageId?n.\u0275routerPageId:this.currentPageId+1:0,this.setTransition({id:h,targetPageId:d,source:t,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:s,resolve:u,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(e=>Promise.reject(e))}setBrowserUrl(e,t){const n=this.urlSerializer.serialize(e),s=Object.assign(Object.assign({},t.extras.state),this.generateNgRouterState(t.id,t.targetPageId));this.location.isCurrentPathEqualTo(n)||t.extras.replaceUrl?this.location.replaceState(n,"",s):this.location.go(n,"",s)}resetStateAndUrl(e,t,n){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,t){"computed"===this.canceledNavigationResolution?"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy||this.location.historyGo(this.currentPageId-e.targetPageId):this.resetUrlToCurrentUrlTree();const n=new Cc(e.id,this.serializeUrl(e.extractedUrl),t);this.triggerEvent(n),e.resolve(!1)}generateNgRouterState(e,t){return"computed"===this.canceledNavigationResolution?{navigationId:e,"\u0275routerPageId":t}:{navigationId:e}}}return e.\u0275fac=function(t){return new(t||e)(ns(Vn),ns(ah),ns(Bd),ns(Lu),ns(oa),ns(pu),ns(Wo),ns(void 0))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Zd=(()=>{class e{constructor(e,t,n,s,r){this.parentContexts=e,this.location=t,this.resolver=n,this.changeDetector=r,this.activated=null,this._activatedRoute=null,this.activateEvents=new lo,this.deactivateEvents=new lo,this.name=s||Lc,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const n=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),s=this.parentContexts.getOrCreateContext(this.name).children,r=new Jd(e,s,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,r),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(va(Bd),va(Hi),va(ri),("name",function(e,t){const n=e.attrs;if(n){const e=n.length;let s=0;for(;s<e;){const r=n[s];if(ln(r))break;if(0===r)s+=2;else if("number"==typeof r)for(s++;s<e&&"string"==typeof n[s];)s++;else{if(r===t)return n[s+1];s+=2}}}return null}(Rt(),"name")),va(Di))},e.\u0275dir=Ze({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class Jd{constructor(e,t,n){this.route=e,this.childContexts=t,this.parent=n}get(e,t){return e===Nh?this.route:e===Bd?this.childContexts:this.parent.get(e,t)}}class Qd{}class ep{preload(e,t){return Nl(null)}}let tp=(()=>{class e{constructor(e,t,n,s,r){this.router=e,this.injector=s,this.preloadingStrategy=r,this.loader=new Vd(t,n,t=>e.triggerEvent(new Ac(t)),t=>e.triggerEvent(new Rc(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(Zl(e=>e instanceof Ic),sc(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(Bi);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,t){const n=[];for(const s of t)if(s.loadChildren&&!s.canLoad&&s._loadedConfig){const e=s._loadedConfig;n.push(this.processRoutes(e.module,e.routes))}else s.loadChildren&&!s.canLoad?n.push(this.preloadConfig(e,s)):s.children&&n.push(this.processRoutes(e,s.children));return j(n).pipe(G(),T(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>(t._loadedConfig?Nl(t._loadedConfig):this.loader.load(e.injector,t)).pipe(q(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(ns(Yd),ns(pu),ns(Wo),ns(oa),ns(Qd))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),np=(()=>{class e{constructor(e,t,n={}){this.router=e,this.viewportScroller=t,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof kc?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Ic&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof zc&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new zc(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(t){return new(t||e)(ns(Yd),ns(Xu),ns(void 0))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const sp=new Pn("ROUTER_CONFIGURATION"),rp=new Pn("ROUTER_FORROOT_GUARD"),ap=[Lu,{provide:ah,useClass:ih},{provide:Yd,useFactory:function(e,t,n,s,r,a,i,o={},u,l){const c=new Yd(null,e,t,n,s,r,a,Uc(i));return u&&(c.urlHandlingStrategy=u),l&&(c.routeReuseStrategy=l),function(e,t){e.errorHandler&&(t.errorHandler=e.errorHandler),e.malformedUriErrorHandler&&(t.malformedUriErrorHandler=e.malformedUriErrorHandler),e.onSameUrlNavigation&&(t.onSameUrlNavigation=e.onSameUrlNavigation),e.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=e.paramsInheritanceStrategy),e.relativeLinkResolution&&(t.relativeLinkResolution=e.relativeLinkResolution),e.urlUpdateStrategy&&(t.urlUpdateStrategy=e.urlUpdateStrategy)}(o,c),o.enableTracing&&c.events.subscribe(e=>{var t,n;null===(t=console.group)||void 0===t||t.call(console,`Router Event: ${e.constructor.name}`),console.log(e.toString()),console.log(e),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[ah,Bd,Lu,oa,pu,Wo,jd,sp,[class{},new is],[class{},new is]]},Bd,{provide:Nh,useFactory:function(e){return e.routerState.root},deps:[Yd]},{provide:pu,useClass:gu},tp,ep,class{preload(e,t){return t().pipe(ec(()=>Nl(null)))}},{provide:sp,useValue:{enableTracing:!1}}];function ip(){return new iu("Router",Yd)}let op=(()=>{class e{constructor(e,t){}static forRoot(t,n){return{ngModule:e,providers:[ap,hp(t),{provide:rp,useFactory:cp,deps:[[Yd,new is,new os]]},{provide:sp,useValue:n||{}},{provide:Fu,useFactory:lp,deps:[Cu,[new as(Ou),new is],sp]},{provide:np,useFactory:up,deps:[Yd,Xu,sp]},{provide:Qd,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:ep},{provide:iu,multi:!0,useFactory:ip},[dp,{provide:Co,multi:!0,useFactory:pp,deps:[dp]},{provide:mp,useFactory:fp,deps:[dp]},{provide:Ao,multi:!0,useExisting:mp}]]}}static forChild(t){return{ngModule:e,providers:[hp(t)]}}}return e.\u0275fac=function(t){return new(t||e)(ns(rp,8),ns(Yd,8))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({}),e})();function up(e,t,n){return n.scrollOffset&&t.setOffset(n.scrollOffset),new np(e,t,n)}function lp(e,t,n={}){return n.useHash?new zu(e,t):new Mu(e,t)}function cp(e){return"guarded"}function hp(e){return[{provide:jn,multi:!0,useValue:e},{provide:jd,multi:!0,useValue:e}]}let dp=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.resultOfPreactivationDone=new E}appInitializer(){return this.injector.get(Su,Promise.resolve(null)).then(()=>{let e=null;const t=new Promise(t=>e=t),n=this.injector.get(Yd),s=this.injector.get(sp);return"disabled"===s.initialNavigation?(n.setUpLocationChangeListener(),e(!0)):"enabled"===s.initialNavigation||"enabledBlocking"===s.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?Nl(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),n.initialNavigation()):e(!0),t})}bootstrapListener(e){const t=this.injector.get(sp),n=this.injector.get(tp),s=this.injector.get(np),r=this.injector.get(Yd),a=this.injector.get(hu);e===a.components[0]&&("enabledNonBlocking"!==t.initialNavigation&&void 0!==t.initialNavigation||r.initialNavigation(),n.setUpPreloading(),s.init(),r.resetRootComponentType(a.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return e.\u0275fac=function(t){return new(t||e)(ns(oa))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function pp(e){return e.appInitializer.bind(e)}function fp(e){return e.bootstrapListener.bind(e)}const mp=new Pn("Router Initializer");function gp(e,t,n,s,r,a,i){try{var o=e[a](i),u=o.value}catch(l){return void n(l)}o.done?t(u):Promise.resolve(u).then(s,r)}function bp(e){return function(){var t=this,n=arguments;return new Promise(function(s,r){var a=e.apply(t,n);function i(e){gp(a,s,r,i,o,"next",e)}function o(e){gp(a,s,r,i,o,"throw",e)}i(void 0)})}}class yp{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class vp{refCount(e){return wp("refCount")}incRef(e){return wp("incRef")}timerAvailable(){return!0}time(e){return wp("time")}read(e){return wp("read")}readSync(e){return wp("readSync")}numDataIds(){return wp("numDataIds")}disposeData(e,t){return wp("disposeData")}write(e,t,n){return wp("write")}move(e,t,n,s,r){return wp("move")}memory(){return wp("memory")}floatPrecision(){return wp("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return wp("dispose")}}function wp(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function xp(e){let t=e.length,n=0,s=0;for(;t>0;)s=Math.random()*t|0,t--,n=e[t],e[t]=e[s],e[s]=n}function kp(e,t,n){return Math.max(e,Math.min(t,n))}function Ip(e){return e%2==0?e:e+1}function Cp(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function _p(e,t,n=""){Cp($p(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Sp(e){Cp(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function Ep(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||jp(e)&&!n)for(let s=0;s<e.length;++s)Ep(e[s],t,n);else t.push(e);return t}function Np(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function $p(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Tp(e){return e%1==0}function Ap(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Rp(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Fp(e,t=(e=>0),n){return new Promise((s,r)=>{let a=0;const i=()=>{if(e())return void s();a++;const o=t(a);null!=n&&a>=n?r():setTimeout(i,o)};i()})}function Dp(e,t){let n=1,s=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===s){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[s]=t/n,r}function Op(e,t){const n=t.length;return Cp((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Cp(e.every(e=>Tp(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function Mp(e,t){const n=[],s=[],r=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||r?null:Op(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),s.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),s.push(o))}return{newShape:n,keptDims:s}}function zp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function Lp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Pp(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function jp(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function Vp(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Wp(e){return"string"==typeof e||e instanceof String}function Bp(e){return"number"==typeof e}function qp(e){return Array.isArray(e)?qp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":Bp(e)?"float32":Wp(e)?"string":"boolean"==typeof e?"bool":"float32"}function Up(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Hp(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Gp(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function Kp(e,t,n,s=!1){const r=new Array;if(1===t.length){const a=t[0]*(s?2:1);for(let t=0;t<a;t++)r[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(s?2:1);for(let t=0;t<a;t++)r[t]=Kp(e+t*o,i,n,s)}return r}function Xp(e,t,n=!1){if(0===e.length)return t[0];const s=e.reduce((e,t)=>e*t)*(n?2:1);if(0===s)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Kp(0,e,t,n)}function Yp(e,t){const n=Zp(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function Zp(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Jp(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return Xp(e,new Float32Array(n));if("int32"===t)return Xp(e,new Int32Array(n));if("bool"===t)return Xp(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Qp(e){e.forEach(t=>{Cp(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function ef(e,t,n){if(0===t)return 0;if(1===t)return e[0];let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=n[r]*e[r];return s}function tf(e,t,n){if(0===t)return[];if(1===t)return[e];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(e/n[r]),e-=s[r]*n[r];return s[s.length-1]=e,s}function nf(e){return e&&e.then&&"function"==typeof e.then}class sf{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=rf,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}getAsync(e){var t=this;return bp(function*(){return e in t.flags||(t.flags[e]=yield t.evaluateFlag(e)),t.flags[e]})()}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(nf(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)})}}function rf(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function af(){return uf}let of,uf=null;function lf(){if(null==of){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}of=e}return of}function cf(e,t){const n=function(){const e=lf();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const hf="Abs",df="Acos",pf="Acosh",ff="Add",mf="AddN",gf="All",bf="Any",yf="ArgMax",vf="ArgMin",wf="Asin",xf="Asinh",kf="Atan",If="Atanh",Cf="Atan2",_f="AvgPool",Sf="AvgPoolGrad",Ef="AvgPool3D",Nf="AvgPool3DGrad",$f="BatchMatMul",Tf="BatchToSpaceND",Af="Bincount",Rf="Cast",Ff="Ceil",Df="ClipByValue",Of="Complex",Mf="ComplexAbs",zf="Concat",Lf="Conv2D",Pf="Conv2DBackpropFilter",jf="Conv2DBackpropInput",Vf="Conv3D",Wf="Conv3DBackpropFilterV2",Bf="Conv3DBackpropInputV2",qf="Cos",Uf="Cosh",Hf="Cumsum",Gf="CropAndResize",Kf="DenseBincount",Xf="DepthToSpace",Yf="DepthwiseConv2dNative",Zf="DepthwiseConv2dNativeBackpropFilter",Jf="DepthwiseConv2dNativeBackpropInput",Qf="Diag",em="Dilation2D",tm="Dilation2DBackpropInput",nm="Dilation2DBackpropFilter",sm="RealDiv",rm="Einsum",am="Elu",im="EluGrad",om="Erf",um="Equal",lm="Exp",cm="ExpandDims",hm="Expm1",dm="FFT",pm="Fill",fm="FlipLeftRight",mm="Floor",gm="FloorDiv",bm="FusedBatchNorm",ym="GatherV2",vm="GatherNd",wm="Greater",xm="GreaterEqual",km="Identity",Im="IFFT",Cm="Imag",_m="IsFinite",Sm="IsInf",Em="IsNan",Nm="LeakyRelu",$m="Less",Tm="LessEqual",Am="LinSpace",Rm="Log",Fm="Log1p",Dm="LogicalAnd",Om="LogicalNot",Mm="LogicalOr",zm="LRN",Lm="LRNGrad",Pm="Max",jm="Maximum",Vm="MaxPool",Wm="MaxPoolGrad",Bm="MaxPool3D",qm="MaxPool3DGrad",Um="MaxPoolWithArgmax",Hm="Mean",Gm="Min",Km="Minimum",Xm="MirrorPad",Ym="Mod",Zm="Multinomial",Jm="Multiply",Qm="Neg",eg="NotEqual",tg="NonMaxSuppressionV3",ng="NonMaxSuppressionV4",sg="NonMaxSuppressionV5",rg="OnesLike",ag="OneHot",ig="Pack",og="PadV2",ug="Pow",lg="Prelu",cg="Prod",hg="Range",dg="Real",pg="Reciprocal",fg="Relu",mg="Reshape",gg="ResizeNearestNeighbor",bg="ResizeNearestNeighborGrad",yg="ResizeBilinear",vg="ResizeBilinearGrad",wg="Relu6",xg="Reverse",kg="Round",Ig="Rsqrt",Cg="ScatterNd",_g="Select",Sg="Selu",Eg="Slice",Ng="Sin",$g="Sinh",Tg="Sign",Ag="Sigmoid",Rg="Softplus",Fg="Sqrt",Dg="Sum",Og="SpaceToBatchND",Mg="SplitV",zg="Softmax",Lg="SparseFillEmptyRows",Pg="SparseReshape",jg="SparseToDense",Vg="SquaredDifference",Wg="Square",Bg="StridedSlice",qg="Sub",Ug="Tan",Hg="Tanh",Gg="Tile",Kg="TopK",Xg="Transform",Yg="Transpose",Zg="Unique",Jg="Unpack",Qg="UnsortedSegmentSum",eb="ZerosLike",tb="Step",nb="RotateWithOffset",sb="_FusedMatMul",rb="FusedConv2D",ab="FusedDepthwiseConv2D",ib=cf("kernelRegistry",()=>new Map),ob=cf("gradRegistry",()=>new Map);function ub(e,t){const n=pb(e,t);return ib.get(n)}function lb(e){return ob.get(e)}function cb(e){const t=ib.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[a,i]=r,[o]=a.split("_");o===e&&n.push(i)}return n}function hb(e){const{kernelName:t,backendName:n}=e,s=pb(t,n);ib.has(s)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),ib.set(s,e)}function db(e){const{kernelName:t}=e;ob.has(t)&&af().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),ob.set(t,e)}function pb(e,t){return`${t}_${e}`}function fb(e,t){return"string"===t?bb(e):mb([e],t)}function mb(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ep(e)),af().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function gb(){return af().platform.now()}function bb(e,t="utf-8"){return t=t||"utf-8",af().platform.encode(e,t)}function yb(e,t="utf-8"){return t=t||"utf-8",af().platform.decode(e,t)}class vb{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new xb)}profileKernel(e,t,n){let s;const r=()=>{s=n()};let a;const i=gb();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(r);else{r();for(const e of s)e.dataSync();a=Promise.resolve({kernelMs:gb()-i})}if(af().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<s.length;o++){const t=s[o];t.data().then(n=>{wb(n,t.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:s,inputs:r,extraInfo:a}=e;n.forEach(e=>{Promise.all([e.data(),s,a]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])})})}}function wb(e,t,n){if("float32"!==t)return!1;for(let s=0;s<e.length;s++){const t=e[s];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class xb{logKernelProfile(e,t,n,s,r,a){const i="number"==typeof s?Rp(`${s}ms`,9):s.error,o=Rp(e,25),u=t.rank,l=t.size,c=Rp(t.shape.toString(),14);let h="";for(const d in r){const e=r[d];if(null!=e){const n=e.shape||t.shape,s=n.length;h+=`${d}: ${s}D ${s>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function kb(e,t,n,s){const r=Gp(t),a=function(e,t,n,s){const r=Np(t),a=s[s.length-1],i=new Array(a).fill(0),o=t.length,u="complex64"===n?Sb(e):e;if(o>1)for(let l=0;l<r/a;l++){const e=l*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],Ib(u[e+t],0,n).length)}return i}(e,t,n,r),i=t.length,o=_b(e,t,n,r,a),u=["Tensor"];return s&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(e=>"    "+e).join("\n")),u.join("\n")}function Ib(e,t,n){let s;return s=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Wp(e)?`'${e}'`:"bool"===n?Cb(e):parseFloat(e.toFixed(7)).toString(),Rp(s,t)}function Cb(e){return 0===e?"false":"true"}function _b(e,t,n,s,r,a=!0){const i="complex64"===n?2:1,o=t[0],u=t.length;if(0===u)return"complex64"===n?[Ib(Sb(e)[0],0,n)]:"bool"===n?[Cb(e[0])]:[e[0].toString()];if(1===u){if(o>20){let t=Array.from(e.slice(0,3*i)),s=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(t=Sb(t),s=Sb(s)),["["+t.map((e,t)=>Ib(e,r[t],n)).join(", ")+", ..., "+s.map((e,t)=>Ib(e,r[o-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?Sb(e):Array.from(e)).map((e,t)=>Ib(e,r[t],n)).join(", ")+"]"]}const l=t.slice(1),c=s.slice(1),h=s[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const s=t*h;d.push(..._b(e.slice(s,s+h),l,n,c,r,!1))}d.push("...");for(let t=o-3;t<o;t++){const s=t*h;d.push(..._b(e.slice(s,s+h),l,n,c,r,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h;d.push(..._b(e.slice(t,t+h),l,n,c,r,m===o-1))}const p=2===u?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<u;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function Sb(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Eb{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Np(e),null!=n){const e=n.length;Cp(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Lp(t,this.size),this.strides=Gp(e)}set(e,...t){0===t.length&&(t=[0]),Cp(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t])throw new Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Nb().makeTensor(this.values,this.shape,this.dtype)}}let Nb=null,$b=null,Tb=null;class Ab{constructor(e,t,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Np(e),this.strides=Gp(e),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var e=this;return bp(function*(){const t=yield e.data();return $b.buffer(e.shape,e.dtype,t)})()}bufferSync(){return $b.buffer(this.shape,this.dtype,this.dataSync())}array(){var e=this;return bp(function*(){const t=yield e.data();return Xp(e.shape,t,"complex64"===e.dtype)})()}arraySync(){return Xp(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var e=this;return bp(function*(){e.throwIfDisposed();const t=Nb().read(e.dataId);if("string"===e.dtype){const e=yield t;try{return e.map(e=>yb(e))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataSync(){this.throwIfDisposed();const e=Nb().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>yb(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){var e=this;return bp(function*(){e.throwIfDisposed();const t=yield Nb().read(e.dataId);return"string"===e.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(Nb().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return $b.print(this,e)}clone(){return this.throwIfDisposed(),$b.clone(this)}toString(e=!1){return kb(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),$b.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Nb().makeVariable(this,e,t,n)}}function Rb(){return cf("Tensor",()=>Ab)}Object.defineProperty(Ab,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Rb();class Fb extends Ab{constructor(e,t,n,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!$p(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Nb().disposeTensor(this),this.dataId=e.dataId,Nb().incRef(this,null)}dispose(){Nb().disposeVariable(this),this.isDisposedInternal=!0}}var Db,Ob,Mb,zb,Lb;Object.defineProperty(Fb,Symbol.hasInstance,{value:e=>e instanceof Ab&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Db||(Db={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Ob||(Ob={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Mb||(Mb={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(zb||(zb={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Lb||(Lb={}));const Pb={float32:zb,int32:Ob,bool:Mb,complex64:Lb};function jb(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Pb[e][t]}function Vb(e){return jb(e,"int32")}function Wb(e,t){if(e.dtype===t.dtype)return[e,t];const n=jb(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Bb(e,t){return t.some(t=>t.id===e.id)}function qb(e){const t=[];return Ub(e,t,new Set),t}function Ub(e,t,n){if(null==e)return;if(e instanceof Ab)return void t.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const r=e;for(const a in r){const e=r[a];n.has(e)||(n.add(e),Ub(e,t,n))}}function Hb(e){return null!=e.kernelName}class Gb{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Kb{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Gb}ready(){var e=this;return bp(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const t=e.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(yield e.initializeBackend(s).success)return void(yield e.setBackend(s))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}setBackend(e){var t=this;return bp(function*(){if(null==t.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(t.backendName=e,null==t.registry[e]){t.backendInstance=null;const{success:n,asyncInit:s}=t.initializeBackend(e);if(!(s?yield n:n))return!1}return t.backendInstance=t.registry[e],t.setupRegisteredKernels(),t.profiler=new vb(t.backendInstance),!0})()}setupRegisteredKernels(){cb(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){cb(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof vp||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,s=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:s,asyncInit:r}=this.initializeBackend(n);if(r||s)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),s=n.backend,r=this.readSync(t),a=s.refCount(t);s.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,s=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(s){throw t(),s}}nextTensorId(){return Kb.nextTensorId++}nextVariableId(){return Kb.nextVariableId++}clone(e){const t=Yb.runKernel(km,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>Yb.runKernel(Rf,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==ub(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const s=this.backend.numDataIds();let r=0;n.forEach(e=>{r+="complex64"===e.dtype?3:1});const a=s-t-r-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const s=this.isTapeOn(),r=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=Hb(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Hb(e)){const{kernelName:t,inputs:r,attrs:a}=e,u=ub(t,this.backendName);Cp(null!=u,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),i=()=>{const e=this.backend.numDataIds();o=u.kernelFunc({inputs:r,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map(e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:s}=e;return this.makeTensorFromDataId(t,n,s)});if(s){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{s&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,r));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,h=Hb(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(u,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()}),s&&this.addTapeNode(u,l,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const s=lb(e);if(null!=s){const e=s.inputsToSave||[],r=s.outputsToSave||[];let a;s.saveAllInputs?(Cp(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);const i=n.filter((e,t)=>r[t]);return a.concat(i)}return[]}makeTensor(e,t,n,s){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let r=e;"string"===(n=n||"float32")&&Wp(e[0])&&(r=e.map(e=>bb(e)));const a=s.write(r,t,n),i=new Ab(t,n,a,this.nextTensorId());if(this.trackTensor(i,s),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,s){const r=new Ab(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(r,s),r}makeVariable(e,t=!0,n,s){n=n||this.nextVariableId().toString(),null!=s&&s!==e.dtype&&(e=e.cast(s));const r=new Fb(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Vp(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Fb||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Vp(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var t=this;return bp(function*(){t.state.profiling=!0;const n=t.state.numBytes,s=t.state.numTensors;t.state.activeProfile.kernels=[],t.state.activeProfile.result=yield e(),t.state.profiling=!1,t.state.activeProfile.peakBytes=Math.max(...t.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),t.state.activeProfile.newBytes=t.state.numBytes-n,t.state.activeProfile.newTensors=t.state.numTensors-s;for(const e of t.state.activeProfile.kernels)e.kernelTimeMs=yield e.kernelTimeMs,e.extraInfo=yield e.extraInfo;return t.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,s,r,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},o=lb(e);null!=o&&(s=o.gradFunc),null!=s&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],s=Zp(e.size,e.dtype);return this.makeTensor(s,e.shape,e.dtype)}return e}),s(e.length>1?e:e[0],r,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=qb(e),n=new Set(t.map(e=>e.id));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==s.id||this.track(e)})}gradients(e,t,n,s=!1){if(Cp(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Cp(r instanceof Ab,()=>"The result y returned by f() must be a tensor.");const a=function(e,t,n){const s={},r={};for(let u=0;u<t.length;u++)s[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(s[i.id]){n.outputs.forEach(e=>s[e.id]=!0),o=!0,r[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let u=0;u<e.length;u++){const t=e[u];if(r[t.id]&&i[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];s[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,r);if(!s&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[r.id]=null==n?function(e){const t=Yp(Np(e),"float32");return Yb.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,s){for(let r=t.length-1;r>=0;r--){const a=t[r],i=[];if(a.outputs.forEach(t=>{const n=e[t.id];i.push(null!=n?n:null)}),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const r=n(()=>o[t]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${r.dtype}'`);const i=a.inputs[t];if(!$p(r.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${r.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=r;else{const t=e[i.id];e[i.id]=s(t,r),t.dispose()}}}}(e,a,e=>this.tidy(e),Zb);const s=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:r,grads:s}})}customGrad(e){return Cp(Up(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;Cp(t.every(e=>e instanceof Ab),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return t.forEach((e,t)=>{s[t]=e}),this.runKernelFunc({forwardFunc:(s,r)=>(n=e(...t,r),Cp(n.value instanceof Ab,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Cp(Up(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,s)=>{const r=n.gradFunc(e,s),a=Array.isArray(r)?r:[r];Cp(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Cp(a.every(e=>e instanceof Ab),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return a.forEach((e,t)=>{i[t]=()=>e}),i},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var t=this;return bp(function*(){const n=gb(),s=yield t.backend.time(e);return s.wallMs=gb()-n,s})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Gb;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Xb(){const e=lf();if(null==e._tfengine){const t=new sf(e);e._tfengine=new Kb(t)}return uf=e._tfengine.ENV,Nb=()=>e._tfengine,e._tfengine}Kb.nextTensorId=0,Kb.nextVariableId=0;const Yb=Xb();function Zb(e,t){return Yb.runKernel(ff,{a:e,b:t})}function Jb(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Qb(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ey=af();function ty(e,t){let n=e;if(jp(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const s=[];for(;Array.isArray(n)||jp(n)&&"string"!==t;)s.push(n.length),n=n[0];return Array.isArray(e)&&af().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ny(e,s,[]),s}function ny(e,t,n){if(n=n||[],!Array.isArray(e)&&!jp(e))return void Cp(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Cp(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Cp(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r)ny(e[r],s,n.concat(r))}function sy(e,t,n,s){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function ry(e,t,n,s="numeric"){if(e instanceof Ab)return sy(s,e.dtype,t,n),e;let r=qp(e);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),sy(s,r,t,n),null==e||!jp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);const a=ty(e,r);jp(e)||Array.isArray(e)||(e=[e]);const i="string"!==r?mb(e,r):Ep(e,[],!0);return Yb.makeTensor(i,a,r)}function ay(e,t,n,s="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,r)=>ry(e,`${t}[${r}]`,n,s))}function iy(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...e)=>{Yb.startScope(n);try{const t=s(...e);return nf(t)&&console.error("Cannot return a Promise inside of tidy."),Yb.endScope(t),t}catch(t){throw Yb.endScope(null),t}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}ey.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ey.registerFlag("IS_BROWSER",()=>Qb()),ey.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),ey.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ey.registerFlag("PROD",()=>!1),ey.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ey.getBool("DEBUG")),ey.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ey.registerFlag("IS_TEST",()=>!1),ey.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ey.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const oy=iy({complex_:function(e,t){const n=ry(e,"real","complex"),s=ry(t,"imag","complex");return _p(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`),Yb.runKernel(Of,{real:n,imag:s})}});function uy(e,t,n,s){if(null==s&&(s=qp(e)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!jp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Qp(t);const e=Np(t),s=Np(n);Cp(e===s,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${s}`);for(let r=0;r<n.length;++r){const e=n[r],s=r!==n.length-1||e!==Np(t.slice(r));Cp(n[r]===t[r]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return jp(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==s?mb(e,s):Ep(e,[],!0),Yb.makeTensor(e,t,s)}function ly(e,t,n){return uy(e,t,ty(e,n),n)}const cy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function hy(e,t){return dy.apply(this,arguments)}function dy(){return(dy=bp(function*(e,t){const n=[],s=[],r=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let a=0;a<r.length;++a){const i=r[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const u={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(function(){var e=bp(function*(e){const t=yield o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+4*t.length,s=new Uint8Array(n);let r=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);s.set(n,r),r+=4,s.set(e,r),r+=e.length}e(s)});return function(t){return e.apply(this,arguments)}}());s.push(e)}else s.push(o.data());null!=t&&(u.group=t),n.push(u)}return{data:py(yield Promise.all(s)),specs:n}})).apply(this,arguments)}function py(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const s=new Uint8Array(t);let r=0;return n.forEach(e=>{s.set(new Uint8Array(e.buffer),r),r+=e.byteLength}),s.buffer}const fy="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function my(e){return fy?Buffer.byteLength(e):new Blob([e]).size}function gy(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let s=0;return e.forEach(e=>{n.set(new Uint8Array(e),s),s+=e.byteLength}),n.buffer}function by(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:my(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:my(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function yy(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let i=0;i<s.length;i++){const r=s[i];a[i]=e[n[r>>10]+(1023&r)]+t[r>>10]}return new Float32Array(r)}}class vy{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==vy.instance&&(vy.instance=new vy),vy.instance}static registerSaveRouter(e){vy.getInstance().saveRouters.push(e)}static registerLoadRouter(e){vy.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return vy.getHandlers(e,"save")}static getLoadHandlers(e,t){return vy.getHandlers(e,"load",t)}static getHandlers(e,t,n){const s=[];return("load"===t?vy.getInstance().loadRouters:vy.getInstance().saveRouters).forEach(t=>{const r=t(e,n);null!==r&&s.push(r)}),s}}const wy=(e,t)=>vy.getLoadHandlers(e,t),xy="tensorflowjs",ky="models_store",Iy="model_info_store";function Cy(){if(!af().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function _y(e){const t=e.result;t.createObjectStore(ky,{keyPath:"modelPath"}),t.createObjectStore(Iy,{keyPath:"modelPath"})}class Sy{constructor(e){if(this.indexedDB=Cy(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var t=this;return bp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return t.databaseAction(t.modelPath,e)})()}load(){var e=this;return bp(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,t){return new Promise((e,n)=>{const s=this.indexedDB.open(xy,1);s.onupgradeneeded=()=>_y(s),s.onsuccess=()=>{const r=s.result;if(null==t){const t=r.transaction(ky,"readonly"),s=t.objectStore(ky).get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(s.result.modelArtifacts)},s.onerror=e=>(r.close(),n(s.error)),t.oncomplete=()=>r.close()}else{const s=by(t),a=r.transaction(Iy,"readwrite");let i=a.objectStore(Iy);const o=i.put({modelPath:this.modelPath,modelArtifactsInfo:s});let u;o.onsuccess=()=>{u=r.transaction(ky,"readwrite");const o=u.objectStore(ky).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:s});o.onsuccess=()=>e({modelArtifactsInfo:s}),o.onerror=e=>{i=a.objectStore(Iy);const t=i.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(o.error)),t.onerror=e=>(r.close(),n(o.error))}},o.onerror=e=>(r.close(),n(o.error)),a.oncomplete=()=>{null==u?r.close():u.oncomplete=()=>r.close()}}},s.onerror=e=>n(s.error)})}}Sy.URL_SCHEME="indexeddb://";const Ey=e=>{return af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Sy.URL_SCHEME)?(t=e.slice(Sy.URL_SCHEME.length),new Sy(t)):null;var t};vy.registerSaveRouter(Ey),vy.registerLoadRouter(Ey);class Ny{constructor(){this.indexedDB=Cy()}listModels(){var e=this;return bp(function*(){return new Promise((t,n)=>{const s=e.indexedDB.open(xy,1);s.onupgradeneeded=()=>_y(s),s.onsuccess=()=>{const e=s.result,r=e.transaction(Iy,"readonly"),a=r.objectStore(Iy).getAll();a.onsuccess=()=>{const e={};for(const t of a.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},a.onerror=t=>(e.close(),n(a.error)),r.oncomplete=()=>e.close()},s.onerror=e=>n(s.error)})})()}removeModel(e){var t=this;return bp(function*(){var n;return e=(n=e).startsWith(Sy.URL_SCHEME)?n.slice(Sy.URL_SCHEME.length):n,new Promise((n,s)=>{const r=t.indexedDB.open(xy,1);r.onupgradeneeded=()=>_y(r),r.onsuccess=()=>{const t=r.result,a=t.transaction(Iy,"readwrite"),i=a.objectStore(Iy),o=i.get(e);let u;o.onsuccess=()=>{if(null==o.result)return t.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{u=t.transaction(ky,"readwrite");const r=u.objectStore(ky).delete(e);r.onsuccess=()=>n(o.result.modelArtifactsInfo),r.onerror=e=>s(o.error)};r.onsuccess=a,r.onerror=e=>(a(),t.close(),s(o.error))}},o.onerror=e=>(t.close(),s(o.error)),a.oncomplete=()=>{null==u?t.close():u.oncomplete=()=>t.close()}},r.onerror=e=>s(r.error)})})()}}const $y="/",Ty="tensorflowjs_models",Ay="info",Ry="model_topology",Fy="weight_specs",Dy="weight_data",Oy="model_metadata";function My(e){return{info:[Ty,e,Ay].join($y),topology:[Ty,e,Ry].join($y),weightSpecs:[Ty,e,Fy].join($y),weightData:[Ty,e,Dy].join($y),modelMetadata:[Ty,e,Oy].join($y)}}function zy(e){const t=e.split($y);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($y)}class Ly{constructor(e){if(!af().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=My(this.modelPath)}save(e){var t=this;return bp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=by(e);try{t.LS.setItem(t.keys.info,JSON.stringify(a)),t.LS.setItem(t.keys.topology,s),t.LS.setItem(t.keys.weightSpecs,r),t.LS.setItem(t.keys.weightData,function(e){if(fy)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}(e.weightData));const n={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),t.LS.setItem(t.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:a}}catch(n){throw t.LS.removeItem(t.keys.info),t.LS.removeItem(t.keys.topology),t.LS.removeItem(t.keys.weightSpecs),t.LS.removeItem(t.keys.weightData),t.LS.removeItem(t.keys.modelMetadata),new Error(`Failed to save model '${t.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}})()}load(){var e=this;return bp(function*(){const t=JSON.parse(e.LS.getItem(e.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(e.LS.getItem(e.keys.topology));if(null==s)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);n.weightSpecs=r;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);n.format=e.format,n.generatedBy=e.generatedBy,n.convertedBy=e.convertedBy,null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer)}const i=e.LS.getItem(e.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return n.weightData=function(e){if(fy){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}(i),n})()}}Ly.URL_SCHEME="localstorage://";const Py=e=>{return af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ly.URL_SCHEME)?(t=e.slice(Ly.URL_SCHEME.length),new Ly(t)):null;var t};vy.registerSaveRouter(Py),vy.registerLoadRouter(Py);class jy{constructor(){Cp(af().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Cp("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var e=this;return bp(function*(){const t={},n=Ty+$y,s=$y+Ay;for(let r=0;r<e.LS.length;++r){const a=e.LS.key(r);a.startsWith(n)&&a.endsWith(s)&&(t[zy(a)]=JSON.parse(e.LS.getItem(a)))}return t})()}removeModel(e){var t=this;return bp(function*(){var n;const s=My(e=(n=e).startsWith(Ly.URL_SCHEME)?n.slice(Ly.URL_SCHEME.length):n);if(null==t.LS.getItem(s.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(t.LS.getItem(s.info));return t.LS.removeItem(s.info),t.LS.removeItem(s.topology),t.LS.removeItem(s.weightSpecs),t.LS.removeItem(s.weightData),r})()}}class Vy{constructor(){this.managers={}}static getInstance(){return null==Vy.instance&&(Vy.instance=new Vy),Vy.instance}static registerManager(e,t){Cp(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Cp(e.length>0,()=>"scheme must not be an empty string.");const n=Vy.getInstance();Cp(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class Wy{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(af().get("IS_BROWSER")){af().setPlatform("browser",new Wy);try{Vy.registerManager(Ly.URL_SCHEME,new jy)}catch(sK){}try{Vy.registerManager(Sy.URL_SCHEME,new Ny)}catch(sK){}}let By;function qy(e,t="float32",n){return t=t||"float32",Qp(e),new Eb(e,t,n)}af().get("IS_NODE")&&af().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=af().global.fetch?af().global.fetch(e,t):(null==By&&(By=n(410)),By(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const Uy=iy({cast_:function(e,t){const n=ry(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return Yb.runKernel(Rf,{x:n},{dtype:t})}}),Hy=iy({clone_:function(e){const t=ry(e,"x","clone","string_or_numeric");return Yb.runKernel(km,{x:t})}});function Gy(e){return new Promise(e=>setTimeout(e)).then(e)}Xb(),$b={buffer:qy,cast:Uy,clone:Hy,print:function(e,t=!1){console.log(e.toString(t))}};class Ky{constructor(e){if(!af().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ky.URL_SCHEME)&&(e=e.slice(Ky.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var t=this;return bp(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+t.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(s.signature=e.signature),null!=e.userDefinedMetadata&&(s.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(s.modelInitializer=e.modelInitializer);const r=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),a=null==t.jsonAnchor?document.createElement("a"):t.jsonAnchor;if(a.download=t.modelTopologyFileName,a.href=r,yield Gy(()=>a.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==t.weightDataAnchor?document.createElement("a"):t.weightDataAnchor;e.download=t.weightDataFileName,e.href=n,yield Gy(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:by(e)}}})()}}function Xy(e,t,n,s){!function(e){Cp(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Cp(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),Cp(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),Cp(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,s=null==s?1:s);let r=0;return Promise.all(e.map(a=>(a.then(a=>{const i=n+ ++r/e.length*(s-n);return t(i),a}),a)))}function Yy(e,t){return Zy.apply(this,arguments)}function Zy(){return(Zy=bp(function*(e,t){null==t&&(t={});const n=null==t.fetchFunc?af().platform.fetch:t.fetchFunc,s=e.map(e=>n(e,t.requestInit,{isBinary:!0})),r=(null==t.onProgress?yield Promise.all(s):yield Xy(s,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?yield Promise.all(r):yield Xy(r,t.onProgress,.5,1)})).apply(this,arguments)}Ky.URL_SCHEME="downloads://",vy.registerSaveRouter(e=>af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ky.URL_SCHEME)?function(e="model"){return new Ky(e)}(e.slice(Ky.URL_SCHEME.length)):null);class Jy{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Cp("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=af().platform.fetch,Cp(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Cp(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}save(e){var t=this;return bp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:t.DEFAULT_METHOD},t.requestInit);n.body=new FormData;const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(s.signature=e.signature),null!=e.userDefinedMetadata&&(s.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(s.modelInitializer=e.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(s)],{type:"application/json"}),"model.json"),null!=e.weightData&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=yield t.fetch(t.path,n);if(r.ok)return{modelArtifactsInfo:by(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)})()}load(){var e=this;return bp(function*(){const t=yield e.fetch(e.path,e.requestInit);if(!t.ok)throw new Error(`Request to ${e.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield t.json()}catch(f){let t=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const s=n.modelTopology,r=n.weightsManifest,a=n.generatedBy,i=n.convertedBy,o=n.format,u=n.signature,l=n.userDefinedMetadata;if(null==s&&null==r)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let c,h;if(null!=r){const t=yield e.loadWeights(r);[c,h]=t}const d={modelTopology:s,weightSpecs:c,weightData:h,generatedBy:a,convertedBy:i,format:o};null!=u&&(d.signature=u),null!=l&&(d.userDefinedMetadata=l);const p=n.modelInitializer;return p&&(d.modelInitializer=p),d})()}loadWeights(e){var t=this;return bp(function*(){const n=Array.isArray(t.path)?t.path[1]:t.path,[s,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(n),a=t.weightPathPrefix||s,i=[];for(const t of e)i.push(...t.weights);const o=[],u=[];for(const l of e)for(const e of l.paths)null!=t.weightUrlConverter?u.push(t.weightUrlConverter(e)):o.push(a+e+r);return t.weightUrlConverter&&o.push(...yield Promise.all(u)),[i,gy(yield Yy(o,{requestInit:t.requestInit,fetchFunc:t.fetch,onProgress:t.onProgress}))]})()}}function Qy(e){return null!=e.match(Jy.URL_SCHEME_REGEX)}Jy.URL_SCHEME_REGEX=/^https?:\/\//;const ev=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>Qy(e)):Qy(e),n)return tv(e,t)}return null};function tv(e,t){return new Jy(e,t)}function nv(e,t){return tv(e,t)}function sv(e,t,n){const s=e.shape.length;Cp(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),Cp(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)Cp(t[r]+n[r]<=e.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function rv(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function av(e,t,n){const s=[];for(let r=0;r<e.length;r++)s[r]=Math.ceil((t[r]-e[r])/n[r]);return s}function iv(e,t,n,s){const r=[...e];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<n;a++)0===a?r[t]=1:(r.splice(t,0,1),r.pop());return r}function ov(e,t,n){return n<=e?n:n-(t-1)}function uv(e,t){const n=[];for(let s=0;s<e;s++)n.push(t+s);return n}function lv(e,t,n,s,r,a,i,o,u){const l=e.length;let c=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=cv(i,u,l,s,e),h=hv(o,u,l,r,e),d=iv(a,u,l,e)}else for(let p=0;p<l;p++)c[p]=pv(i,s,a,e,p,u),h[p]=fv(o,r,a,e,p,u),d[p]=dv(a,p,u);return{begin:c,end:h,strides:d}}function cv(e,t,n,s,r){const a=[...r],i=uv(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const r=ov(t,n,o);let i=s[r];e&1<<r&&(i=0),a[o]=i}return a}function hv(e,t,n,s,r){const a=[...r],i=uv(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const r=ov(t,n,o);let i=s[r];e&1<<r&&(i=Number.MAX_SAFE_INTEGER),a[o]=i}for(let o=0;o<a.length;o++){const e=r[o];a[o]<0&&(a[o]+=e),a[o]=kp(0,a[o],r[o])}return a}function dv(e,t,n){let s=e[t];return(n&1<<t||null==s)&&(s=1),s}function pv(e,t,n,s,r,a){let i=t[r];(e&1<<r||a&1<<r||null==i)&&(i=(n[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const o=s[r];return i<0&&(i+=o),i=kp(0,i,o-1),i}function fv(e,t,n,s,r,a){let i=t[r];const o=n[r]||1;(e&1<<r||a&1<<r||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=s[r];return i<0&&(i+=u),i=o>0?kp(0,i,u):kp(-1,i,u-1),i}function mv(e,t,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function gv(e,t){let n=e.length>0?e[e.length-1]:1;for(let s=0;s<e.length-1;s++)n+=e[s]*t[s];return n}function bv(e,t,n){let s;const r=e.shape.length;let a;return s="number"==typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),s.forEach(e=>{Cp(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,a=a.map((t,n)=>t>=0?t:(Cp(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-s[n])),[s,a]}function yv(e,t,n,s,r,a,i,o,u){let l=t.slice(),c=n.slice(),h=s;null==s&&(h=new Array(l.length));const d=rv(i);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==o)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=e.length-l.length,f=rv(o),m=e.slice();f.forEach(e=>{l[e]=0,c[e]=1,m.splice(e,0,1)});const{begin:g,end:b,strides:y}=lv(m,d,p,l,c,h,r,a,i);l=g,c=b,h=y;const v=rv(u);v.forEach(e=>{c[e]=l[e]+1,h[e]=1});const w=av(l,c,h),x=w.filter((e,t)=>-1===v.indexOf(t));return{nonStrided:h.every(e=>1===e),$begin:l,$end:c,$strides:h,size:w,newShape:m,outShape:x}}vy.registerSaveRouter(ev),vy.registerLoadRouter(ev);class vv{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class wv{constructor(){this.classNameMap={}}static getMap(){return null==wv.instance&&(wv.instance=new wv),wv.instance}static register(e){wv.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function xv(e){Cp(null!=e.className,()=>"Class being registered does not have the static className property defined."),Cp("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Cp(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),wv.register(e)}function kv(){return Yb}function Iv(){return Yb.memory()}function Cv(e,t){return Yb.tidy(e,t)}function _v(e){qb(e).forEach(e=>e.dispose())}function Sv(e){return Yb.keep(e)}function Ev(e,t,n=1){return Yb.registerBackend(e,t,n)}function Nv(e){return Yb.customGrad(e)}function $v(e,t){if((jp(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&jp(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return uy(e,[],[],t)}Tb=function(e){af().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class Tv extends vv{minimize(e,t=!1,n){const{value:s,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:r[e.name]}));this.applyGradients(e)}else this.applyGradients(r);return _v(r),t?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Cp(Up(e),()=>"The f passed in variableGrads(f) must be a function"),Cp(null==t||Array.isArray(t)&&t.every(e=>e instanceof Fb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in Yb.registeredVariables)t.push(Yb.registeredVariables[e])}const s=n?t.filter(e=>!e.trainable):null,r=t.length;Cp((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:a,grads:i}=Yb.gradients(e,t,null,!0);Cp(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Cp(0===a.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=s&&s.forEach(e=>o[e.name]=null),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&_v(this.iterations_)}saveIterations(){var e=this;return bp(function*(){return null==e.iterations_&&(e.iterations_=0),{name:"iter",tensor:$v(e.iterations_,"int32")}})()}getWeights(){return bp(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(e){var t=this;return bp(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${t.getClassName()}`)})()}extractIterations(e){var t=this;return bp(function*(){return t.iterations_=(yield e[0].tensor.data())[0],e.slice(1)})()}}Object.defineProperty(Tv,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});const Av=iy({abs_:function(e){const t=ry(e,"x","abs");return Yb.runKernel("complex64"===t.dtype?Mf:hf,{x:t})}}),Rv=iy({add_:function(e,t){let n=ry(e,"a","add"),s=ry(t,"b","add");return[n,s]=Wb(n,s),Yb.runKernel(ff,{a:n,b:s})}}),Fv=iy({all_:function(e,t=null,n=!1){const s=ry(e,"x","all","bool");return Yb.runKernel(gf,{x:s},{axis:t,keepDims:n})}}),Dv=iy({any_:function(e,t=null,n=!1){const s=ry(e,"x","any","bool");return Yb.runKernel(bf,{x:s},{axis:t,keepDims:n})}}),Ov=iy({argMax_:function(e,t=0){const n=ry(e,"x","argMax");return Yb.runKernel(yf,{x:n},{axis:t})}});function Mv(e,t,n,s,r="NHWC",a){return Pv(e,[...t,e[3]],n,a,s,null,null,Kv(r))}function zv(e,t,n,s,r,a,i="channelsLast"){const[o,u]=Wv(t);let l;if("channelsLast"===i)l=[o,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[o,u,e[1],e[1]]}return Pv(e,l,n,s,r,a,!1,i)}function Lv(e,t,n,s,r,a,i="NDHWC"){const[o,u,l]=Bv(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,u,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,u,l,e[1],e[1]]}return jv(e,c,n,s,r,!1,h,a)}function Pv(e,t,n,s,r,a,i=!1,o="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,h,l,c]=e}const[d,p,,f]=t,[m,g]=Wv(n),[b,y]=Wv(s),v=qv(d,b),w=qv(p,y),{padInfo:x,outHeight:k,outWidth:I}=function(e,t,n,s,r,a,i,o,u){let l,c,h;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,s,r){null==s&&(s=Vv(e,t,n));const a=e[1];return[Uv((e[0]-t+2*s)/n+1,r),Uv((a-t+2*s)/n+1,r)]}([t,n],a,s,e,o);c=r[0],h=r[1]}else if("same"===e){c=Math.ceil(t/s),h=Math.ceil(n/r);const e=Math.max(0,(c-1)*s+a-t),o=Math.max(0,(h-1)*r+i-n),u=Math.floor(e/2),d=e-u,p=Math.floor(o/2);l={top:u,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/s),h=Math.ceil((n-i+1)/r);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Uv((t-a+d+p)/s+1,o),h=Uv((n-i+f+m)/r+1,o)}}return{padInfo:l,outHeight:c,outWidth:h}}(r,l,c,m,g,v,w,a,o),C=i?f*h:f;let _;return"channelsFirst"===o?_=[u,C,k,I]:"channelsLast"===o&&(_=[u,k,I,C]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:c,inChannels:h,outHeight:k,outWidth:I,outChannels:C,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:e,outShape:_,filterShape:t}}function jv(e,t,n,s,r,a=!1,i="channelsLast",o){let[u,l,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c,h]=e}const[p,f,m,,g]=t,[b,y,v]=Bv(n),[w,x,k]=Bv(s),I=qv(p,w),C=qv(f,x),_=qv(m,k),{padInfo:S,outDepth:E,outHeight:N,outWidth:$}=function(e,t,n,s,r,a,i,o,u,l,c){let h,d,p,f;if("number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,s,r,a){null==r&&(r=Vv(e,t,s));const i=e[1],o=e[2];return[Uv((e[0]-t+2*r)/s+1,a),Uv((i-t+2*r)/s+1,a),Uv((o-t+2*r)/s+1,a),1]}([t,n,s,1],o,0,r,e,c);d=a[0],p=a[1],f=a[2]}else if("same"===e){d=Math.ceil(t/r),p=Math.ceil(n/a),f=Math.ceil(s/i);const e=(d-1)*r+o-t,c=(p-1)*a+u-n,m=(f-1)*i+l-s,g=Math.floor(e/2),b=e-g,y=Math.floor(c/2),v=c-y,w=Math.floor(m/2);h={top:y,bottom:v,left:w,right:m-w,front:g,back:b,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-o+1)/r),p=Math.ceil((n-u+1)/a),f=Math.ceil((s-l+1)/i)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,l,c,h,b,y,v,I,C,_,o),T=a?g*d:g;let A;return"channelsFirst"===i?A=[u,T,E,N,$]:"channelsLast"===i&&(A=[u,E,N,$,T]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:d,outDepth:E,outHeight:N,outWidth:$,outChannels:T,padInfo:S,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:C,effectiveFilterWidth:_,dilationDepth:w,dilationHeight:x,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function Vv(e,t,n,s=1){const r=qv(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function Wv(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Bv(e){return"number"==typeof e?[e,e,e]:e}function qv(e,t){return t<=1?e:e+(e-1)*(t-1)}function Uv(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Hv(e){const[t,n,s]=Wv(e);return 1===t&&1===n&&1===s}function Gv(e,t){return Hv(e)||Hv(t)}function Kv(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const Xv=iy({reshape_:function(e,t){const n=ry(e,"x","reshape","string_or_numeric");return Yb.runKernel(mg,{x:n},{shape:t})}}),Yv=iy({avgPool_:function(e,t,n,s,r){const a=ry(e,"x","avgPool","float32");Cp(Gv(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let i=a,o=!1;3===a.rank&&(o=!0,i=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Cp(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),null!=r&&Cp(Tp(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let u=Yb.runKernel(_f,{x:i},{filterSize:t,strides:n,pad:s,dimRoundingMode:r});return u=Uy(u,a.dtype),o?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Zv=iy({avgPool3d_:function(e,t,n,s,r,a="NDHWC"){const i=ry(e,"x","avgPool3d","float32");let o=i,u=!1;4===i.rank&&(u=!0,o=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Cp(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Cp("NDHWC"===a,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),null!=r&&Cp(Tp(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let l=Yb.runKernel(Ef,{x:o},{filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a});return l=Uy(l,o.dtype),u?Xv(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),Jv=iy({batchNorm_:function(e,t,n,s,r,a){null==a&&(a=.001);const i=ry(e,"x","batchNorm"),o=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Cp(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Cp(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Cp(null==l||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(e){let t;return t=0===e.rank||1===e.rank?Xv(e,[1,1,1,e.size]):2===e.rank?Xv(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),d=Yb.runKernel(bm,{x:h,scale:l,offset:c,mean:o,variance:u},{varianceEpsilon:a});return Xv(d,i.shape)}}),Qv=iy({batchNorm2d_:function(e,t,n,s,r,a){const i=ry(e,"x","batchNorm"),o=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;return null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Cp(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),Cp(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Cp(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=l&&Cp(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&Cp(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Jv(i,o,u,c,l,a)}}),ew=iy({batchNorm3d_:function(e,t,n,s,r,a){const i=ry(e,"x","batchNorm"),o=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;return null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Cp(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),Cp(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Cp(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=l&&Cp(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&Cp(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Jv(i,o,u,c,l,a)}}),tw=iy({batchNorm4d_:function(e,t,n,s,r,a){const i=ry(e,"x","batchNorm"),o=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;return null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Cp(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),Cp(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Cp(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=l&&Cp(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&Cp(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Jv(i,o,u,c,l,a)}}),nw=iy({clipByValue_:function(e,t,n){const s=ry(e,"x","clipByValue");return Cp(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),Yb.runKernel(Df,{x:s},{clipValueMin:t,clipValueMax:n})}}),sw=iy({concat_:function(e,t=0){Cp(e.length>=1,()=>"Pass at least one tensor to concat");const n=ay(e,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length?Hy(n[0]):Yb.runKernel(zf,n,{axis:t})}}),rw=iy({concat1d_:function(e){return sw(e,0)}}),aw=iy({concat2d_:function(e,t){return sw(e,t)}}),iw=iy({concat3d_:function(e,t){return sw(e,t)}}),ow=iy({concat4d_:function(e,t){return sw(e,t)}}),uw=iy({conv2d_:function(e,t,n,s,r="NHWC",a=[1,1],i){const o=ry(e,"x","conv2d"),u=ry(t,"filter","conv2d");let l=o,c=!1;3===o.rank&&(c=!0,l=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Cp(4===l.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),Cp(4===u.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),null!=i&&Cp(Tp(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const h="NHWC"===r?l.shape[3]:l.shape[1];Cp(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),Cp(Gv(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const d=Yb.runKernel(Lf,{x:l,filter:u},{strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i});return c?Xv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),lw=iy({conv1d_:function(e,t,n,s,r="NWC",a=1,i){const o=ry(e,"x","conv1d"),u=ry(t,"filter","conv1d");let l=o,c=!1;2===o.rank&&(c=!0,l=Xv(o,[1,o.shape[0],o.shape[1]])),Cp(3===l.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),Cp(3===u.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),null!=i&&Cp(Tp(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`),Cp(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),Cp(Gv(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Cp("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=Xv(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=Xv(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=uw(d,h,[1,n],s,"NHWC",[1,a],i);return Xv(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),cw=iy({conv2DBackpropInput_:function(e,t,n,s,r,a="NHWC",i){Cp(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,l=!1;3===t.rank&&(l=!0,u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Cp(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Cp(4===u.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),Cp(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?u.shape[3]:u.shape[1];Cp(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Cp(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=i&&Cp(Tp(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const d=Yb.runKernel(jf,{dy:u,filter:n},{strides:s,pad:r,dataFormat:a,dimRoundingMode:i,inputShape:o});return l?Xv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),hw=iy({conv2dTranspose_:function(e,t,n,s,r,a){const i=ry(e,"x","conv2dTranspose"),o=ry(t,"filter","conv2dTranspose");return cw(n,i,o,s,r,"NHWC",a)}}),dw=iy({conv3d_:function(e,t,n,s,r="NDHWC",a=[1,1,1]){const i=ry(e,"x","conv3d"),o=ry(t,"filter","conv3d");let u=i,l=!1;4===i.rank&&(l=!0,u=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Cp(5===u.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),Cp(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Cp(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Cp(Gv(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Cp("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c=Yb.runKernel(Vf,{x:u,filter:o},{strides:n,pad:s,dataFormat:r,dilations:a});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),pw=iy({conv3DBackpropInput_:function(e,t,n,s,r){Cp(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],l=i.shape[4];Cp(5===a.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Cp(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),Cp(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Cp(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),Cp(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c=Yb.runKernel(Bf,{dy:i,filter:n},{pad:r,strides:s,inputShape:a});return o?Xv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),fw=iy({conv3dTranspose_:function(e,t,n,s,r){const a=ry(e,"x","conv3dTranspose"),i=ry(t,"filter","conv3dTranspose");return pw(n,a,i,s,r)}}),mw=iy({depthwiseConv2d_:function(e,t,n,s,r="NHWC",a=[1,1],i){const o=ry(e,"x","depthwiseConv2d"),u=ry(t,"filter","depthwiseConv2d");let l=o,c=!1;3===o.rank&&(c=!0,l=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Cp(4===l.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),Cp(4===u.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),Cp(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),null!=i&&Cp(Tp(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const h=Yb.runKernel(Yf,{x:l,filter:u},{strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i});return c?Xv(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),gw=iy({floorDiv_:function(e,t){let n=ry(e,"a","floorDiv"),s=ry(t,"b","floorDiv");return[n,s]=Wb(n,s),Yb.runKernel(gm,{a:n,b:s})}}),bw=iy({div_:function(e,t){let n=ry(e,"a","div"),s=ry(t,"b","div");return[n,s]=Wb(n,s),"int32"===n.dtype&&"int32"===s.dtype?gw(n,s):Yb.runKernel(sm,{a:n,b:s},{})}}),yw=iy({elu_:function(e){const t=ry(e,"x","elu");return Yb.runKernel(am,{x:t})}});function vw(e,t){const n=e.length,s=[];for(let r=0;r<n;r++){const a=n-1-r,i=e[a]||1;(t[t.length-1-r]||1)>1&&1===i&&s.unshift(a)}return s}function ww(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],a=t.length-s-1,i=t[a];(null==r||1===r&&i>1)&&n.unshift(a)}return n}function xw(e,t){const n=[],s=Math.max(e.length,t.length);for(let r=0;r<s;r++){let s=e[e.length-r-1];null==s&&(s=1);let a=t[t.length-r-1];if(null==a&&(a=1),1===s)n.unshift(a);else if(1===a)n.unshift(s);else{if(s!==a)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(s)}}return n}const kw=iy({equal_:function(e,t){let n=ry(e,"a","equal"),s=ry(t,"b","equal");return[n,s]=Wb(n,s),xw(n.shape,s.shape),Yb.runKernel(um,{a:n,b:s})}}),Iw=iy({expandDims_:function(e,t=0){const n=ry(e,"x","expandDims","string_or_numeric");return Cp(t<=n.rank,()=>"Axis must be <= rank of the tensor"),Yb.runKernel(cm,{input:n},{dim:t})}}),Cw=iy({tile_:function(e,t){const n=ry(e,"x","tile","string_or_numeric");return Cp(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),Yb.runKernel(Gg,{x:n},{reps:t})}}),_w=iy({eye_:function(e,t,n,s="float32"){null==t&&(t=e);const r=qy([e,t],s),a=e<=t?e:t;for(let o=0;o<a;++o)r.set(1,o,o);const i=Xv(r.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return Cw(Iw(i,0),[n[0],1,1]);if(2===n.length)return Cw(Iw(Iw(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return Cw(Iw(Iw(Iw(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function Sw(e,t,n){return Yb.runKernel(pm,{},{shape:e,value:t,dtype:n})}const Ew=iy({floor_:function(e){const t=ry(e,"x","floor");return Yb.runKernel(mm,{x:t})}}),Nw=iy({gather_:function(e,t,n=0,s=0){const r=ry(e,"x","gather"),a=ry(t,"indices","gather","int32");return Yb.runKernel(ym,{x:r,indices:a},{axis:n,batchDims:s})}}),$w=iy({greater_:function(e,t){let n=ry(e,"a","greater"),s=ry(t,"b","greater");return[n,s]=Wb(n,s),xw(n.shape,s.shape),Yb.runKernel(wm,{a:n,b:s})}}),Tw=iy({greaterEqual_:function(e,t){let n=ry(e,"a","greaterEqual"),s=ry(t,"b","greaterEqual");return[n,s]=Wb(n,s),xw(n.shape,s.shape),Yb.runKernel(xm,{a:n,b:s})}}),Aw=iy({leakyRelu_:function(e,t=.2){const n=ry(e,"x","leakyRelu");return Yb.runKernel(Nm,{x:n},{alpha:t})}}),Rw=iy({log_:function(e){const t=ry(e,"x","log");return Yb.runKernel(Rm,{x:t})}}),Fw=iy({exp_:function(e){const t=ry(e,"x","exp");return Yb.runKernel(lm,{x:t})}}),Dw=iy({max_:function(e,t=null,n=!1){const s=ry(e,"x","max");return Yb.runKernel(Pm,{x:s},{reductionIndices:t,keepDims:n})}}),Ow=iy({mul_:function(e,t){let n=ry(e,"a","mul"),s=ry(t,"b","mul");return[n,s]=Wb(n,s),Yb.runKernel(Jm,{a:n,b:s})}}),Mw=iy({sub_:function(e,t){let n=ry(e,"a","sub"),s=ry(t,"b","sub");return[n,s]=Wb(n,s),Yb.runKernel(qg,{a:n,b:s})}}),zw=iy({sum_:function(e,t=null,n=!1){let s=ry(e,"x","sum");return"bool"===s.dtype&&(s=Uy(s,"int32")),Yb.runKernel(Dg,{x:s},{axis:t,keepDims:n})}}),Lw=iy({logSoftmax_:function(e,t=-1){const n=ry(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Nv((e,n)=>{const s=Dw(e,t,!0),r=Mw(e,s),a=Mw(Uy(r,"float32"),Rw(zw(Fw(r),t,!0)));return n([a]),{value:a,gradFunc:(e,n)=>{const[s]=n,r=Fw(s);return Mw(e,Ow(zw(e,t,!0),r))}}})(n)}}),Pw=iy({logicalAnd_:function(e,t){const n=ry(e,"a","logicalAnd","bool"),s=ry(t,"b","logicalAnd","bool");return xw(n.shape,s.shape),Yb.runKernel(Dm,{a:n,b:s})}}),jw=iy({maxPool_:function(e,t,n,s,r){const a=ry(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Cp(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),Cp(Gv(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=r&&Cp(Tp(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const u=Yb.runKernel(Vm,{x:i},{filterSize:t,strides:n,pad:s,dimRoundingMode:r});return o?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Vw=iy({maxPool3d_:function(e,t=[1,1,1],n,s,r,a="NDHWC"){const i=ry(e,"x","maxPool3d");let o=i,u=!1;4===i.rank&&(u=!0,o=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Cp(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Cp("NDHWC"===a,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),null!=r&&Cp(Tp(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l=Yb.runKernel(Bm,{x:o},{filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a});return u?Xv(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),Ww=iy({maximum_:function(e,t){let n=ry(e,"a","maximum"),s=ry(t,"b","maximum");return[n,s]=Wb(n,s),"bool"===n.dtype&&(n=Uy(n,"int32"),s=Uy(s,"int32")),xw(n.shape,s.shape),Yb.runKernel(jm,{a:n,b:s})}}),Bw=iy({mean_:function(e,t=null,n=!1){const s=ry(e,"x","mean");return Yb.runKernel(Hm,{x:s},{axis:t,keepDims:n})}}),qw=iy({min_:function(e,t=null,n=!1){const s=ry(e,"x","min");return Yb.runKernel(Gm,{x:s},{axis:t,keepDims:n})}}),Uw=iy({minimum_:function(e,t){let n=ry(e,"a","minimum"),s=ry(t,"b","minimum");return[n,s]=Wb(n,s),"bool"===n.dtype&&(n=Uy(n,"int32"),s=Uy(s,"int32")),xw(n.shape,s.shape),Yb.runKernel(Km,{a:n,b:s})}});function Hw(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Gw(e,t,n){const s=e.length+t.length,r=[];let a=0,i=0;for(let o=0;o<s;o++)-1===n.indexOf(o)?r.push(e[a++]):r.push(t[i++]);return r}function Kw(e,t){const n=[],s=e.length;for(let r=0;r<s;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map(t=>e[t])]}function Xw(e,t){return Gw(e,t.map(e=>1),t)}function Yw(e,t,n){Cp(Hw(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Zw(e,t){if(Hw(e,t))return null;const n=[];for(let s=0;s<t;++s)-1===e.indexOf(s)&&n.push(s);return e.forEach(e=>n.push(e)),n}function Jw(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Qw(e,t){const n=[];for(let s=t-e;s<t;++s)n.push(s);return n}const ex=iy({square_:function(e){const t=ry(e,"x","square");return Yb.runKernel("Square",{x:t},{})}}),tx=iy({moments_:function(e,t=null,n=!1){const s=Op(t,(e=ry(e,"x","moments")).shape),r=Bw(e,s,n);let a=r.shape;n||(a=Xw(r.shape,s));const i=ex(Mw(Uy(e,"float32"),Xv(r,a)));return{mean:r,variance:Bw(i,s,n)}}}),nx=iy({neg_:function(e){const t=ry(e,"x","neg");return Yb.runKernel(Qm,{x:t})}}),sx=iy({notEqual_:function(e,t){let n=ry(e,"a","notEqual"),s=ry(t,"b","notEqual");return[n,s]=Wb(n,s),xw(n.shape,s.shape),Yb.runKernel(eg,{a:n,b:s})}}),rx=iy({oneHot_:function(e,t,n=1,s=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const r=ry(e,"indices","oneHot","int32");return Yb.runKernel(ag,{indices:r},{depth:t,onValue:n,offValue:s})}});function ax(e,t="float32"){if("complex64"===t){const t=ax(e,"float32"),n=ax(e,"float32");return oy(t,n)}const n=Zp(Np(e),t);return Yb.makeTensor(n,e,t)}function ix(e,t="float32"){if("complex64"===t){const t=ix(e,"float32"),n=ax(e,"float32");return oy(t,n)}const n=Yp(Np(e),t);return Yb.makeTensor(n,e,t)}const ox=iy({onesLike_:function(e){const t=ry(e,"x","onesLike");return Yb.runKernel(rg,{x:t})}}),ux=iy({pad_:function(e,t,n=0){const s=ry(e,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return Yb.runKernel(og,{x:s},{paddings:t,constantValue:n})}}),lx=iy({prelu_:function(e,t){const n=ry(e,"x","prelu"),s=ry(t,"alpha","prelu");return Yb.runKernel(lg,{x:n,alpha:s})}});var cx=n(566);class hx{constructor(e,t,n,s,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=r||Math.random();this.random=cx.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let s,r,a;do{s=2*this.random()-1,r=2*this.random()-1,a=s*s+r*r}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*s*i,t=this.mean+this.stdDev*r*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class dx{constructor(e=0,t=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=cx.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const px=iy({randomNormal_:function(e,t=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const a=new hx(t,n,s,!1,r),i=qy(e,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),fx=iy({randomUniform_:function(e,t=0,n=1,s="float32",r){const a=qy(e,s),i=new dx(t,n,null,r);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),mx=iy({relu_:function(e){const t=ry(e,"x","relu");return Yb.runKernel(fg,{x:t})}}),gx=iy({reverse_:function(e,t){const n=ry(e,"x","reverse");return Yb.runKernel(xg,{x:n},{dims:t})}}),bx=iy({selu_:function(e){const t=ry(e,"x","selu");return Yb.runKernel(Sg,{x:t})}}),yx=iy({separableConv2d_:function(e,t,n,s,r,a=[1,1],i="NHWC"){const o=ry(e,"x","separableConv2d"),u=ry(t,"depthwiseFilter","separableConv2d"),l=ry(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Cp(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Cp(4===u.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),Cp(4===l.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),Cp(1===l.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),Cp(1===l.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=u.shape[2],p=u.shape[3];Cp(l.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${l.shape[2]}.`);const f=mw(c,u,s,r,i,a),m=uw(f,l,1,"valid",i);return h?Xv(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),vx=iy({sigmoid_:function(e){const t=ry(e,"x","sigmoid");return Yb.runKernel(Ag,{x:t})}}),wx=iy({slice_:function(e,t,n){const s=ry(e,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return Yb.runKernel(Eg,{x:s},{begin:t,size:n})}}),xx=iy({slice1d_:function(e,t,n){const s=ry(e,"x","slice1d");return Cp(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),wx(s,[t],[n])}}),kx=iy({slice2d_:function(e,t,n){const s=ry(e,"x","slice2d");return Cp(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),wx(s,t,n)}}),Ix=iy({slice3d_:function(e,t,n){const s=ry(e,"x","slice3d");return Cp(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),wx(s,t,n)}}),Cx=iy({slice4d_:function(e,t,n){const s=ry(e,"x","slice4d");return Cp(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),wx(s,t,n)}}),_x=iy({softmax_:function(e,t=-1){const n=ry(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return Yb.runKernel(zg,{logits:n},{dim:t})}}),Sx=iy({softplus_:function(e){const t=ry(e,"x","softplus");return Yb.runKernel(Rg,{x:t})}}),Ex=iy({split_:function(e,t,n=0){const s=ry(e,"x","split");return Yb.runKernel(Mg,{x:s},{numOrSizeSplits:t,axis:n})}}),Nx=iy({sqrt_:function(e){const t=ry(e,"x","sqrt");return Yb.runKernel(Fg,{x:t})}}),$x=iy({squeeze_:function(e,t){const n=ry(e,"x","squeeze");return Xv(n,Mp(n.shape,t).newShape)}}),Tx=iy({stack_:function(e,t=0){const n=ay(e,"tensors","stack","string_or_numeric");return Cp(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Cp(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),Yb.runKernel(ig,n,{axis:t})}}),Ax=iy({tanh_:function(e){const t=ry(e,"x","tanh");return Yb.runKernel(Hg,{x:t})}});function Rx(e,t){Sp(e);const n=ty(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return uy(e,null,n,t)}function Fx(e,t,n){if(Sp(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const s=ty(e,n);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return uy(e,t,s,n)}const Dx=iy({truncatedNormal_:function(e,t=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const a=new hx(t,n,s,!0,r),i=qy(e,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),Ox=iy({unstack_:function(e,t=0){const n=ry(e,"x","unstack","string_or_numeric");return Cp(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),Yb.runKernel(Jg,{value:n},{axis:t})}}),Mx=iy({broadcastTo_:function(e,t){let n=ry(e,"broadcastTo","x");const s=n.shape;if(t.some(e=>!(e>0)||e%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Xv(n,e)}const r=n.shape,a=Array.from(t);for(let i=t.length-1;i>=0;i--)if(r[i]===t[i])a[i]=1;else if(1!==n.shape[i])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);return 0===a.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length?Hy(n):Yb.runKernel(Gg,{x:n},{reps:a})}}),zx=iy({where_:function(e,t,n){const s=ry(t,"a","where"),r=ry(n,"b","where"),a=ry(e,"condition","where","bool"),i=xw(xw(a.shape,s.shape),r.shape),o=Mx(a,i),u=Mx(s,i),l=Mx(r,i);return Yb.runKernel(_g,{condition:o,t:u,e:l})}}),Lx=iy({zerosLike_:function(e){const t=ry(e,"x","zerosLike");return Yb.runKernel(eb,{x:t})}}),Px=iy({transpose_:function(e,t){const n=ry(e,"x","transpose");return null==t&&(t=n.shape.map((e,t)=>t).reverse()),Cp(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{Cp(e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`)}),n.rank<=1?n.clone():Yb.runKernel(Yg,{x:n},{perm:t})}}),jx=iy({dropout_:function(e,t,n,s){const r=ry(e,"x","dropout");if(Cp("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),Cp(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof Ab?r.clone():r;const a=function(e,t){if(null==t)return e.shape.slice();if($p(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++)n.push(null==t[s]&&null!=e.shape[s]?e.shape[s]:t[s]);return n}return t}(r,n),i=1-t,o=bw(Ew(Rv(fx(a,0,1,"float32",s),i)),i);return Ow(r,o)}}),Vx=iy({imag_:function(e){const t=ry(e,"input","imag");return Yb.runKernel(Cm,{input:t})}}),Wx=iy({real_:function(e){const t=ry(e,"input","real");return Yb.runKernel(dg,{input:t})}}),Bx=iy({fft_:function(e){return Cp("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),Yb.runKernel(dm,{input:e})}}),qx=iy({rfft_:function(e,t){Cp("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(null!=t&&t<n){const s=e.shape.map(e=>0),a=e.shape.map(e=>e);a[e.shape.length-1]=t,r=wx(e,s,a),n=t}else if(null!=t&&t>n){const s=e.shape.map(e=>e);s[e.shape.length-1]=t-n,r=sw([e,ax(s)],e.shape.length-1),n=t}else r=e;const a=Lx(r),i=Xv(oy(r,a),[s,n]),o=Bx(i),u=Math.floor(n/2)+1,l=Wx(o),c=Vx(o),h=Ex(l,[u,n-u],l.shape.length-1),d=Ex(c,[u,n-u],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=u,Xv(oy(h[0],d[0]),p)}}),Ux=iy({ifft_:function(e){return Cp("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),Yb.runKernel(Im,{input:e})}}),Hx=iy({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const r=Xv(e,[n,t]);s=Ux(r)}else{const r=[n,2*(t-1)],a=Xv(Wx(e),[n,t]),i=Xv(Vx(e),[n,t]),o=gx(wx(a,[0,1],[n,t-2]),1),u=Ow(gx(wx(i,[0,1],[n,t-2]),1),$v(-1)),l=sw([a,o],1),c=sw([i,u],1),h=Xv(oy(l,c),[r[0],r[1]]);s=Ux(h)}if(s=Wx(s),3===e.rank&&0!==e.shape[0]){const t=s,n=e.shape[0];s=Xv(s,[n,s.shape[0]/n,s.shape[1]]),t.dispose()}return s}}),Gx=iy({conv2DBackpropFilter_:function(e,t,n,s,r,a="NHWC",i){let o=e;3===e.rank&&(o=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Cp(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Cp(4===u.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),Cp(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?u.shape[3]:u.shape[1];return Cp(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),Cp(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=i&&Cp(Tp(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),Yb.runKernel(Pf,{x:o,dy:u},{strides:s,pad:r,dataFormat:a,dimRoundingMode:i,filterShape:n})}}),Kx=iy({relu6_:function(e){const t=ry(e,"x","relu6");return Yb.runKernel(wg,{x:t})}}),Xx=iy({step_:function(e,t=0){const n=ry(e,"x","step");return Yb.runKernel(tb,{x:n},{alpha:t})}});function Yx(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Ow(e,Xx(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Zx(e,t){let n=t;const s=ww(e.shape,t.shape);return s.length>0&&(n=zw(n,s)),Xv(n,e.shape)}function Jx(e,t,n,s){if("linear"===t)return e;if("relu"===t)return mx(e);if("elu"===t)return yw(e);if("relu6"===t)return Kx(e);if("prelu"===t)return lx(e,n);if("leakyrelu"===t)return Aw(e,s);if("sigmoid"===t)return vx(e);throw new Error(`Unknown fused activation ${t}.`)}const Qx=(e,t)=>!(e>0)||"linear"===t,ek=iy({fusedConv2d_:function({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Qx(Yb.state.gradientDepth,u=u||"linear")){let h=uw(e,t,n,s,r,a,i);return null!=o&&(h=Rv(h,o)),Jx(h,u,l,c)}const h=ry(e,"x","conv2d"),d=ry(t,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=Xv(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Cp(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Cp(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=i&&Cp(Tp(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`),Cp(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),Cp(Gv(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Cp("NHWC"===r,()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=Pv(p.shape,d.shape,n,a,s,i);let g,b;null!=o&&(g=ry(o,"bias","fused conv2d"),[g]=Wb(g,h),xw(m.outShape,g.shape)),null!=l&&(b=ry(l,"prelu weights","fused conv2d"));const y=(e,t)=>{const[r,i,o,l]=t,c=Yx(e,o,u);Cp(Hv(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const h=[cw(i.shape,c,r,n,s),Gx(i,c,r.shape,n,s)];if(null!=l){const e=Zx(l,c);h.push(e)}return h},v={x:p,filter:d,bias:g,preluActivationWeights:b},w={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return null==o?Nv((e,t,n)=>{let s=Yb.runKernel(rb,v,w);return n([t,e,s]),f&&(s=Xv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(p,d):Nv((e,t,n,s)=>{let r=Yb.runKernel(rb,v,w);return s([t,e,r,n]),f&&(r=Xv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(p,d,g)}}),tk=iy({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,s,r,a=[1,1],i){let o=e;3===e.rank&&(o=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;return 3===u.rank&&(u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Yb.runKernel(Zf,{x:o,dy:u},{strides:s,pad:r,dimRoundingMode:i,dilations:a,filterShape:n})}}),nk=iy({depthwiseConv2dNativeBackpropInput_:function(e,t,n,s,r,a=[1,1],i){let o=t,u=!1;3===t.rank&&(u=!0,o=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l=Yb.runKernel(Jf,{dy:o,filter:n},{strides:s,pad:r,dimRoundingMode:i,dilations:a,inputShape:e});return u?Xv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});iy({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Qx(Yb.state.gradientDepth,u)){let h=mw(e,t,n,s,r,a,i);return null!=o&&(h=Rv(h,o)),Jx(h,u,l,c)}const h=ry(e,"x","depthwiseConv2d"),d=ry(t,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=Xv(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Cp(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Cp(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),Cp(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==a&&(a=[1,1]),Cp(Gv(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),null!=i&&Cp(Tp(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${s}.`);const m=Pv(p.shape,d.shape,n,a,s,i,!0);let g,b;null!=o&&(g=ry(o,"bias","fused conv2d"),[g]=Wb(g,h),xw(m.outShape,g.shape)),null!=l&&(b=ry(l,"prelu weights","fused depthwiseConv2d"));const y=(e,t)=>{Cp(Hv(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[r,o,l,c]=t,h=Yx(e,l,u),d=nk(o.shape,h,r,n,s,a,i),p=tk(o,h,r.shape,n,s,a,i);return null!=c?[d,p,Zx(g,h)]:[d,p]},v={x:p,filter:d,bias:g,preluActivationWeights:b},w={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return null==o?Nv((e,t,n)=>{let s=Yb.runKernel(ab,v,w);return n([t,e,s]),f&&(s=Xv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(p,d):Nv((e,t,n,s)=>{let r=Yb.runKernel(ab,v,w);return s([t,e,r,n]),f&&(r=Xv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(p,d,g)}});const sk=iy({matMul_:function(e,t,n=!1,s=!1){let r=ry(e,"a","matMul"),a=ry(t,"b","matMul");return[r,a]=Wb(r,a),Yb.runKernel($f,{a:r,b:a},{transposeA:n,transposeB:s})}}),rk=iy({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o}){if(!1===Qx(Yb.state.gradientDepth,a)){let u=sk(e,t,n,s);return null!=r&&(u=Rv(u,r)),Jx(u,a,i,o)}let u=ry(e,"a","fused matMul"),l=ry(t,"b","fused matMul");[u,l]=Wb(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=s?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=s?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=Np(f),b=Np(m);Cp(u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),Cp($p(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`),Cp(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${s} must match.`);const y=u.shape.slice(0,-2).concat([d,p]),v=Xv(u,n?[g,c,d]:[g,d,c]),w=Xv(l,s?[b,p,h]:[b,h,p]);let x,k;null!=r&&(x=ry(r,"bias","fused matMul"),[x]=Wb(x,u),xw(y,x.shape)),null!=i&&(k=ry(i,"prelu weights","fused matMul"));const I=(e,t)=>{const[i,o,u,l]=t,c=Yx(Xv(e,u.shape),u,a);let h,d;return n||s?!n&&s?(h=sk(c,o,!1,!1),d=sk(c,i,!0,!1)):n&&!s?(h=sk(o,c,!1,!0),d=sk(i,c,!1,!1)):(h=sk(o,c,!0,!0),d=sk(c,i,!0,!0)):(h=sk(c,o,!1,!0),d=sk(i,c,!0,!1)),null!=r?[h,d,Zx(l,c)]:[h,d]},C={a:v,b:w,bias:x,preluActivationWeights:k},_={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:o};return null==r?Nv((e,t,n)=>{const s=Yb.runKernel(sb,C,_);return n([e,t,s]),{value:Xv(s,y),gradFunc:I}})(v,w):Nv((e,t,n,s)=>{const r=Yb.runKernel(sb,C,_);return s([e,t,r,n]),{value:Xv(r,y),gradFunc:I}})(v,w,x)}});function ak(e,t,n){const s=1-e%2,r=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+s-1);r[a]=t-n*Math.cos(i)}return Rx(r,"float32")}iy({hammingWindow_:function(e){return ak(e,.54,.46)}});const ik=iy({hannWindow_:function(e){return ak(e,.5,.5)}}),ok=iy({frame_:function(e,t,n,s=!1,r=0){let a=0;const i=[];for(;a+t<=e.size;)i.push(wx(e,a,t)),a+=n;if(s)for(;a<e.size;){const s=a+t-e.size,o=sw([wx(e,a,t-s),Sw([s],r)]);i.push(o),a+=n}return 0===i.length?Fx([],[0,t]):Xv(sw(i),[i.length,t])}});function uk(e,t,n,s,r,a){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Cp(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),Cp(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Cp(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Cp(1===t.rank,()=>"scores must be a 1D tensor"),Cp(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Cp(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}function lk(e,t,n){const s=function(e,t,n){return function(e,t,n){let s=0,r=e.length,a=0,i=!1;for(;s<r;){a=s+(r-s>>>1);const o=n(t,e[a]);o>0?s=a+1:(r=a,i=!o)}return i?s:-s-1}(e,t,n||ck)}(e,t,n);e.splice(s<0?-(s+1):s,0,t)}function ck(e,t){return e>t?1:e<t?-1:0}function hk(e,t,n,s,r){return fk(e,t,n,s,r,0)}function dk(e,t,n,s,r,a){return fk(e,t,n,s,r,0,!1,a,!0)}function pk(e,t,n,s,r,a){return fk(e,t,n,s,r,a,!0)}function fk(e,t,n,s,r,a,i=!1,o=!1,u=!1){const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(bk);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<r)break;let o=!1;for(let u=h.length-1;u>=i;--u){const n=mk(e,a,h[u]);if(n>=s){o=!0;break}if(t.score=t.score*gk(s,c,n),t.score<=r)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),d.push(t.score)):t.score>r&&lk(l,t,bk))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),u&&(m.validOutputs=p),m}function mk(e,t,n){const s=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),a=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(o-a)*(u-i),f=(h-l)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(i,c),b=Math.min(o,h),y=Math.min(u,d),v=Math.max(b-m,0)*Math.max(y-g,0);return v/(p+f-v)}function gk(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function bk(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}iy({stft_:function(e,t,n,s,r=ik){null==s&&(s=Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2)))));const a=ok(e,t,n),i=Ow(a,r(t));return qx(i,s)}}),iy({cropAndResize_:function(e,t,n,s,r="bilinear",a=0){const i=ry(e,"image","cropAndResize"),o=ry(t,"boxes","cropAndResize","float32"),u=ry(n,"boxInd","cropAndResize","int32"),l=o.shape[0];return Cp(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Cp(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`),Cp(1===u.rank&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`),Cp(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),Cp(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),Cp("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),Yb.runKernel(Gf,{image:i,boxes:o,boxInd:u},{method:r,extrapolationValue:a,cropSize:s})}}),iy({flipLeftRight_:function(e){const t=ry(e,"image","flipLeftRight","float32");return Cp(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),Yb.runKernel(fm,{image:t},{})}}),iy({rotateWithOffset_:function(e,t,n=0,s=.5){const r=ry(e,"image","rotateWithOffset","float32");return Cp(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),Yb.runKernel(nb,{image:r},{radians:t,fillValue:n,center:s})}}),iy({nonMaxSuppression_:function(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=ry(e,"boxes","nonMaxSuppression"),i=ry(t,"scores","nonMaxSuppression"),o=uk(a,i,n,s,r);return Yb.runKernel(tg,{boxes:a,scores:i},{maxOutputSize:n=o.maxOutputSize,iouThreshold:s=o.iouThreshold,scoreThreshold:r=o.scoreThreshold})}}),iy({nonMaxSuppressionWithScore_:function(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const i=ry(e,"boxes","nonMaxSuppression"),o=ry(t,"scores","nonMaxSuppression"),u=uk(i,o,n,s,r,a),l=Yb.runKernel(sg,{boxes:i,scores:o},{maxOutputSize:n=u.maxOutputSize,iouThreshold:s=u.iouThreshold,scoreThreshold:r=u.scoreThreshold,softNmsSigma:a=u.softNmsSigma});return{selectedIndices:l[0],selectedScores:l[1]}}}),iy({nonMaxSuppressionPadded_:function(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const i=ry(e,"boxes","nonMaxSuppression"),o=ry(t,"scores","nonMaxSuppression"),u=uk(i,o,n,s,r,null),l=Yb.runKernel(ng,{boxes:i,scores:o},{maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:a});return{selectedIndices:l[0],validOutputs:l[1]}}});const yk=iy({resizeBilinear_:function(e,t,n=!1,s=!1){const r=ry(e,"images","resizeBilinear");Cp(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),Cp(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Cp(!1===s||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;3===r.rank&&(i=!0,a=Xv(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,o=Yb.runKernel(yg,{images:a},{alignCorners:n,halfPixelCenters:s,size:t});return i?Xv(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),vk=iy({resizeNearestNeighbor_:function(e,t,n=!1,s=!1){const r=ry(e,"images","resizeNearestNeighbor");Cp(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),Cp(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Cp("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Cp(!1===s||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;3===r.rank&&(i=!0,a=Xv(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,o=Yb.runKernel(gg,{images:a},{alignCorners:n,halfPixelCenters:s,size:t});return i?Xv(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),wk=iy({bincount_:function(e,t,n){const s=ry(e,"x","bincount"),r=ry(t,"weights","bincount");return Cp("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),Cp(n>=0,()=>`size must be non-negative, but got ${n}.`),Cp(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),Yb.runKernel(Af,{x:s,weights:r},{size:n})}}),xk=iy({lessEqual_:function(e,t){let n=ry(e,"a","lessEqual"),s=ry(t,"b","lessEqual");return[n,s]=Wb(n,s),xw(n.shape,s.shape),Yb.runKernel(Tm,{a:n,b:s})}}),kk=iy({round_:function(e){const t=ry(e,"x","round");return Yb.runKernel(kg,{x:t})}});function Ik(e,t,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");return Yb.runKernel(hg,{},{start:e,stop:t,step:n,dtype:s})}iy({threshold_:function(e,t="binary",n=!1,s=.5){const r=ry(e,"image","threshold"),a=r.shape[0]*r.shape[1];let i,o,u,l,c=Ow(Rx([s]),255);if(Cp(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),Cp(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),Cp("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),Cp("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===r.shape[2]){[i,o,u]=Ex(r,[1,1,1],-1);const e=Ow(i,.2989),t=Ow(o,.587),n=Ow(u,.114);l=Rv(Rv(e,t),n)}else l=e;"otsu"===t&&(c=function(e,t){let n,s,r,a,i,o,u=Rx([-1]),l=Rx([0]),c=Rx([0]);for(let h=0;h<e.size-1;h++){n=wx(e,0,h+1),s=wx(e,h+1),i=bw(zw(n),t),o=bw(zw(s),t);const d=zw(Ow(n,Ik(0,n.size)));r=bw(d,zw(n));const p=Sw(s.shape,n.size),f=Rv(Ik(0,s.size),p),m=Ow(s,f);a=bw(zw(m),zw(s));const g=Mw(r,a),b=Mw(r,a),y=Ow(i,o);c=Ow(Ow(y,g),b);const v=$w(c,l);l=zx(v,c,l),u=zx(v,Rx([h]),u)}return u}(wk(Uy(kk(l),"int32"),ly([]),256),a));const h=n?xk(l,c):$w(l,c);return Uy(Ow(h,255),"int32")}}),iy({transform_:function(e,t,n="nearest",s="constant",r=0,a){const i=ry(e,"image","transform","float32"),o=ry(t,"transforms","transform","float32");return Cp(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Cp(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Cp(null==a||2===a.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`),Yb.runKernel(Xg,{image:i,transforms:o},{interpolation:n,fillMode:s,fillValue:r,outputShape:a})}});const Ck=iy({bandPart_:function(e,t,n){Cp(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Cp(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=ry(e,"a","bandPart");Cp(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,i]=s.shape.slice(-2);if(!(t<=a))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=a),n<0&&(n=i);const o=Xv(Ik(0,a,1,"int32"),[-1,1]),u=Ik(0,i,1,"int32"),l=Mw(o,u),c=Pw(xk(l,$v(+t,"int32")),Tw(l,$v(-n,"int32"))),h=ax([a,i],s.dtype);return Xv(Tx(Ox(Xv(s,[-1,a,i])).map(e=>zx(c,e,h))),r)}}),_k=iy({pow_:function(e,t){let n=ry(e,"base","pow"),s=ry(t,"exp","pow");return[n,s]=Wb(n,s),Yb.runKernel(ug,{a:n,b:s})}});function Sk(e,t,n=null){if(0===e.rank)return Av(e);if(1!==e.rank&&null===n)return Sk(Xv(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return zw(Av(e),n);if(t===1/0)return Dw(Av(e),n);if(t===-1/0)return qw(Av(e),n);if("euclidean"===t||2===t)return Nx(zw(_k(Av(e),$v(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Dw(zw(Av(e),n[0]),n[1]-1);if(t===1/0)return Dw(zw(Av(e),n[1]),n[0]);if(t===-1/0)return qw(zw(Av(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Nx(zw(ex(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ek=iy({norm_:function(e,t="euclidean",n=null,s=!1){const r=Sk(e=ry(e,"x","norm"),t,n);let a=r.shape;if(s){const t=Op(n,e.shape);a=Xw(r.shape,t)}return Xv(r,a)}}),Nk=iy({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Cp(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Cp(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=Ex(e,e.shape[0],0).map(e=>$x(e,[0]));Cp(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],s=e;for(let r=0;r<e.length;++r)n.push(Yb.tidy(()=>{let e=s[r];if(r>0)for(let t=0;t<r;++t){const s=Ow(zw(Ow(n[t],e)),n[t]);e=Mw(e,s)}return bw(e,Ek(e,"euclidean"))}));return t?Tx(n,0):n}});function $k(e,t=!1){return Yb.tidy(()=>{Cp(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],s=e.shape[1];let r=_w(n),a=Hy(e);const i=Fx([[1]],[1,1]);let o=Hy(i);const u=n>=s?s:n;for(let e=0;e<u;++e){const t=a,u=o,l=r;[o,a,r]=Yb.tidy(()=>{const t=wx(a,[e,e],[n-e,1]),u=Ek(t),l=wx(a,[e,e],[1,1]),c=zx($w(l,0),Fx([[-1]]),Fx([[1]])),h=Mw(l,Ow(c,u)),d=bw(t,h);o=1===d.shape[0]?Hy(i):sw([i,wx(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=nx(bw(sk(c,h),u)),f=wx(a,[e,0],[n-e,s]),m=Ow(p,o),g=Px(o);if(0===e)a=Mw(f,sk(m,sk(g,f)));else{const t=Mw(f,sk(m,sk(g,f)));a=sw([wx(a,[0,0],[e,s]),t],0)}const b=Px(m),y=wx(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=Mw(y,sk(sk(y,o),b));else{const t=Mw(y,sk(sk(y,o),b));r=sw([wx(r,[0,0],[n,e]),t],1)}return[o,a,r]}),_v([t,u,l])}return!t&&n>s&&(r=wx(r,[0,0],[n,s]),a=wx(a,[0,0],[s,s])),[r,a]})}const Tk=iy({qr_:function(e,t=!1){if(Cp(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return $k(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),s=Ox(Xv(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],a=[];return s.forEach(e=>{const[n,s]=$k(e,t);r.push(n),a.push(s)}),[Xv(Tx(r,0),e.shape),Xv(Tx(a,0),e.shape)]}}});var Ak;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Ak||(Ak={}));const Rk=iy({computeWeightedLoss_:function(e,t,n=Ak.SUM_BY_NONZERO_WEIGHTS){const s=ry(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=ry(t,"weights","computeWeightedLoss"));const a=null==r?s:Ow(s,r);if(n===Ak.NONE)return a;if(n===Ak.SUM)return zw(a);if(n===Ak.MEAN){if(null==r)return Bw(a);{const e=s.size/r.size,t=bw(zw(a),zw(r));return e>1?bw(t,$v(e)):t}}if(n===Ak.SUM_BY_NONZERO_WEIGHTS){if(null==r)return bw(zw(a),$v(s.size));{const e=Ow(r,ix(s.shape)),t=Uy(zw(sx(e,$v(0))),"float32");return bw(zw(a),t)}}throw Error(`Unknown reduction: ${n}`)}});iy({absoluteDifference_:function(e,t,n,s=Ak.SUM_BY_NONZERO_WEIGHTS){const r=ry(e,"labels","absoluteDifference"),a=ry(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=ry(n,"weights","absoluteDifference")),_p(r.shape,a.shape,"Error in absoluteDifference: ");const o=Av(Mw(r,a));return Rk(o,i,s)}}),iy({cosineDistance_:function(e,t,n,s,r=Ak.SUM_BY_NONZERO_WEIGHTS){const a=ry(e,"labels","cosineDistance"),i=ry(t,"predictions","cosineDistance");let o=null;null!=s&&(o=ry(s,"weights","cosineDistance")),_p(a.shape,i.shape,"Error in cosineDistance: ");const u=$v(1),l=Mw(u,zw(Ow(a,i),n,!0));return Rk(l,o,r)}}),iy({hingeLoss_:function(e,t,n,s=Ak.SUM_BY_NONZERO_WEIGHTS){let r=ry(e,"labels","hingeLoss");const a=ry(t,"predictions","hingeLoss");let i=null;null!=n&&(i=ry(n,"weights","hingeLoss")),_p(r.shape,a.shape,"Error in hingeLoss: ");const o=$v(1);r=Mw(Ow($v(2),r),o);const u=mx(Mw(o,Ow(r,a)));return Rk(u,i,s)}}),iy({huberLoss_:function(e,t,n,s=1,r=Ak.SUM_BY_NONZERO_WEIGHTS){const a=ry(e,"labels","huberLoss"),i=ry(t,"predictions","huberLoss");let o=null;null!=n&&(o=ry(n,"weights","huberLoss")),_p(a.shape,i.shape,"Error in huberLoss: ");const u=$v(s),l=Av(Mw(i,a)),c=Uw(l,u),h=Mw(l,c),d=Rv(Ow($v(.5),ex(c)),Ow(u,h));return Rk(d,o,r)}}),iy({logLoss_:function(e,t,n,s=1e-7,r=Ak.SUM_BY_NONZERO_WEIGHTS){const a=ry(e,"labels","logLoss"),i=ry(t,"predictions","logLoss");let o=null;null!=n&&(o=ry(n,"weights","logLoss")),_p(a.shape,i.shape,"Error in logLoss: ");const u=$v(1),l=$v(s),c=nx(Ow(a,Rw(Rv(i,l)))),h=Ow(Mw(u,a),Rw(Rv(Mw(u,i),l))),d=Mw(c,h);return Rk(d,o,r)}});const Fk=iy({squaredDifference_:function(e,t){let n=ry(e,"a","squaredDifference"),s=ry(t,"b","squaredDifference");return[n,s]=Wb(n,s),xw(n.shape,s.shape),Yb.runKernel(Vg,{a:n,b:s},{})}});iy({meanSquaredError_:function(e,t,n,s=Ak.SUM_BY_NONZERO_WEIGHTS){const r=ry(e,"labels","meanSquaredError"),a=ry(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=ry(n,"weights","meanSquaredError")),_p(r.shape,a.shape,"Error in meanSquaredError: ");const o=Fk(r,a);return Rk(o,i,s)}});const Dk=iy({log1p_:function(e){const t=ry(e,"x","log1p");return Yb.runKernel(Fm,{x:t})}});iy({sigmoidCrossEntropy_:function(e,t,n,s=0,r=Ak.SUM_BY_NONZERO_WEIGHTS){let a=ry(e,"multiClassLabels","sigmoidCrossEntropy");const i=ry(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=ry(n,"weights","sigmoidCrossEntropy")),_p(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const e=$v(s),t=$v(1),n=$v(.5);a=Rv(Ow(a,Mw(t,e)),Ow(n,e))}const u=function(e,t){const n=ry(e,"labels","sigmoidCrossEntropyWithLogits"),s=ry(t,"logits","sigmoidCrossEntropyWithLogits");_p(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=mx(s),a=Ow(s,n),i=Dk(Fw(nx(Av(s))));return Rv(Mw(r,a),i)}(a,i);return Rk(u,o,r)}});const Ok=iy({logSumExp_:function(e,t=null,n=!1){const s=ry(e,"x","logSumExp"),r=Op(t,s.shape),a=Dw(s,r,!0),i=Mw(s,a),o=Fw(i),u=zw(o,r),l=Rw(u),c=Rv(Xv(a,l.shape),l);if(n){const e=Xw(c.shape,r);return Xv(c,e)}return c}});iy({softmaxCrossEntropy_:function(e,t,n,s=0,r=Ak.SUM_BY_NONZERO_WEIGHTS){let a=ry(e,"onehotLabels","softmaxCrossEntropy");const i=ry(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=ry(n,"weights","softmaxCrossEntropy")),_p(a.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const e=$v(s),t=$v(1),n=$v(a.shape[1]);a=Rv(Ow(a,Mw(t,e)),bw(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Nv((e,t,s)=>{const r=Ok(t,[n],!0),a=Mw(Uy(t,"float32"),r);s([e,a]);const i=nx(Ow(a,e));return{value:zw(i,[n]),gradFunc:(e,t)=>{const[s,r]=t,a=Xw(e.shape,[n]);return[Ow(Xv(e,a),Mw(Uy(s,"float32"),Fw(r))),Ow(Xv(e,a),Mw(Fw(r),Uy(s,"float32")))]}}})(e,t)}(a,i);return Rk(u,o,r)}}),iy({sparseFillEmptyRows_:function(e,t,n,s){const r=ry(e,"indices","sparseFillEmptyRows"),a=ry(t,"values","sparseFillEmptyRows"),i=ry(n,"denseShape","sparseFillEmptyRows"),o=ry(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u=Yb.runKernel(Lg,{indices:r,values:a,denseShape:i,defaultValue:o});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),iy({sparseReshape_:function(e,t,n){const s=ry(e,"inputIndices","sparseReshape"),r=ry(t,"inputShape","sparseReshape"),a=ry(n,"newShape","sparseReshape");if(2!==s.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i=Yb.runKernel(Pg,{inputIndices:s,inputShape:r,newShape:a});return{outputIndices:i[0],outputShape:i[1]}}});const Mk={bandPart:Ck,gramSchmidt:Nk,qr:Tk};class zk extends Tv{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Yb.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Yb.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Cv(()=>Lx(s).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Cv(()=>Lx(s).variable(!1))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;Cv(()=>{const e=Rv(Ow(a,this.rho),Ow(ex(r),1-this.rho)),t=Ow(bw(Nx(Rv(i,this.epsilon)),Nx(Rv(a,this.epsilon))),r),n=Rv(Ow(i,this.rho),Ow(ex(t),1-this.rho));a.assign(e),i.assign(n);const o=Rv(Ow(t,-this.learningRate),s);s.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(_v(this.accumulatedGrads.map(e=>e.variable)),_v(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return bp(function*(){const t=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){const n=(e=yield t.extractIterations(e)).length/2;t.accumulatedGrads=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedUpdates=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}zk.className="Adadelta",xv(zk);class Lk extends Tv{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Yb.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Cv(()=>Sw(s.shape,this.initialAccumulatorValue).variable(e))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=this.accumulatedGrads[n].variable;Cv(()=>{const e=Rv(a,ex(r));a.assign(e);const t=Rv(Ow(bw(r,Nx(Rv(e,Yb.backend.epsilon()))),-this.learningRate),s);s.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&_v(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return bp(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e),t.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Lk.className="Adagrad",xv(Lk);class Pk extends Tv{constructor(e,t,n,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Cv(()=>{this.accBeta1=$v(t).variable(),this.accBeta2=$v(n).variable()}),null==s&&(this.epsilon=Yb.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Cv(()=>{const n=Mw(1,this.accBeta1),s=Mw(1,this.accBeta2);t.forEach((t,r)=>{const a=Yb.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:Cv(()=>Lx(a).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${t}/v`,variable:Cv(()=>Lx(a).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[r].variable,u=this.accumulatedSecondMoment[r].variable,l=Rv(Ow(o,this.beta1),Ow(i,1-this.beta1)),c=Rv(Ow(u,this.beta2),Ow(ex(i),1-this.beta2)),h=bw(l,n),d=bw(c,s);o.assign(l),u.assign(c);const p=Rv(Ow(bw(h,Rv(Nx(d),this.epsilon)),-this.learningRate),a);a.assign(p)}),this.accBeta1.assign(Ow(this.accBeta1,this.beta1)),this.accBeta2.assign(Ow(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&_v(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&_v(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return bp(function*(){const t=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e),Cv(()=>{t.accBeta1.assign(_k(t.beta1,t.iterations_+1)),t.accBeta2.assign(_k(t.beta2,t.iterations_+1))});const n=e.length/2;t.accumulatedFirstMoment=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedSecondMoment=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}Pk.className="Adam",xv(Pk);class jk extends Tv{constructor(e,t,n,s=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=s,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Cv(()=>{this.iteration=$v(0).variable(),this.accBeta1=$v(t).variable()}),null==s&&(this.epsilon=Yb.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Cv(()=>{const n=Mw(1,this.accBeta1),s=bw(-this.learningRate,Rv(Ow(this.iteration,this.decay),1));t.forEach((t,r)=>{const a=Yb.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:Lx(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${t}/v`,variable:Lx(a).variable(!1)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const o=this.accumulatedFirstMoment[r].variable,u=this.accumulatedWeightedInfNorm[r].variable,l=Rv(Ow(o,this.beta1),Ow(i,1-this.beta1)),c=Ow(u,this.beta2),h=Av(i),d=Ww(c,h);o.assign(l),u.assign(d);const p=Rv(Ow(bw(s,n),bw(l,Rv(d,this.epsilon))),a);a.assign(p)}),this.iteration.assign(Rv(this.iteration,1)),this.accBeta1.assign(Ow(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&_v(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&_v(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return bp(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return bp(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}jk.className="Adamax",xv(jk);class Vk extends Tv{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const r=Yb.registeredVariables[t];Cv(()=>{const e=Rv(Ow(this.c,s),r);r.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Sv($v(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return bp(function*(){return[yield e.saveIterations()]})()}setWeights(e){var t=this;return bp(function*(){if(0!==(e=yield t.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Vk.className="SGD",xv(Vk);class Wk extends Vk{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=$v(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Yb.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Cv(()=>Lx(s).variable(e))}}const r=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Cv(()=>{let e;const t=Rv(Ow(this.m,r),a);e=Rv(Ow(this.c,this.useNesterov?Rv(a,Ow(t,this.m)):t),s),r.assign(t),s.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&_v(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return bp(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e),t.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Wk.className="Momentum",xv(Wk);class Bk extends Tv{constructor(e,t=.9,n=0,s=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==s&&(this.epsilon=Yb.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Yb.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Cv(()=>Lx(s).variable(r))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Cv(()=>Lx(s).variable(r))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Cv(()=>Lx(s).variable(r))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Cv(()=>{const e=Rv(Ow(i,this.decay),Ow(ex(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=Rv(Ow(t,this.decay),Ow(a,1-this.decay)),u=bw(Ow(a,this.learningRate),Nx(Mw(e,Rv(ex(r),this.epsilon)))),l=Rv(Ow(o,this.momentum),u);i.assign(e),t.assign(r),o.assign(l);const c=Mw(s,l);s.assign(c)}else{const e=Rv(Ow(i,this.decay),Ow(ex(a),1-this.decay)),t=Rv(Ow(o,this.momentum),bw(Ow(a,this.learningRate),Nx(Rv(e,this.epsilon))));i.assign(e),o.assign(t);const n=Mw(s,t);s.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&_v(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&_v(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&_v(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return bp(function*(){const t=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&t.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e);const n=t.centered?e.length/3:e.length/2,s=!1;t.accumulatedMeanSquares=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(s)})),t.accumulatedMoments=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(s)})),t.centered&&(t.accumulatedMeanGrads=e.slice(2*n,3*n).map(e=>({originalName:e.name,variable:e.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Bk.className="RMSProp",xv(Bk);class qk{static sgd(e){return new Vk(e)}static momentum(e,t,n=!1){return new Wk(e,t,n)}static rmsprop(e,t=.9,n=0,s=null,r=!1){return new Bk(e,t,n,s,r)}static adam(e=.001,t=.9,n=.999,s=null){return new Pk(e,t,n,s)}static adadelta(e=.001,t=.95,n=null){return new zk(e,t,n)}static adamax(e=.002,t=.9,n=.999,s=null,r=0){return new jk(e,t,n,s,r)}static adagrad(e,t=.1){return new Lk(e,t)}}const Uk={sgd:qk.sgd,momentum:qk.momentum,adadelta:qk.adadelta,adagrad:qk.adagrad,rmsprop:qk.rmsprop,adamax:qk.adamax,adam:qk.adam},Hk="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Gk(){return new Promise(e=>Hk(()=>e()))}function Kk(e,t){const n=e[0].length;e.forEach((e,t)=>{Cp(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),Cp(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=e[0];e.forEach((e,r)=>{for(let a=0;a<n;a++)Cp(a===t||e[a]===s[a],()=>`Error in concat${n}D: Shape of tensors[${r}] (${e}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function Xk(e,t){const n=e[0].slice();for(let s=1;s<e.length;s++)n[t]+=e[s][t];return n}const Yk=30;function Zk(e){return e<=Yk?e:Hp(e,Math.floor(Math.sqrt(e)))}function Jk(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Qk(e,t,n,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)r=r.concat([e[s+1]/t[s],t[s]]);r=r.concat(e.slice(n+1))}return r}function eI(e,t,n=!0){const s=[];if(n){s.push(t);for(let n=t+1;n<e;++n)n<=2*t?(s.push(n),s.push(n-(t+1))):s.push(n)}else{const n=[],r=[];for(let s=1;s<e;++s)s>=2*t+1||s%2==1?r.push(s):n.push(s);s.push(...n),s.push(0),s.push(...r)}return s}function tI(e,t,n,s=!0){const r=[];r.push(s?e[0]/n:e[0]*n);for(let a=1;a<e.length;++a)r.push(a<=t.length?s?t[a-1]*e[a]:e[a]/t[a-1]:e[a]);return r}function nI(e,t){const n=[0];for(let s=0;s<t;++s)n.push(e[s][0]);return n}function sI(e,t,n){const s=e.slice(0,1);for(let r=0;r<n;++r)s.push(e[r+1]-t[r][0]-t[r][1]);return s}function rI(e,t){const n=e.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(0===Np(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,a=r[r.length-1];let i=1;for(let h=0;h<r.length-1;++h)i*=r[h];const o=e.shape,u=r.slice();u.pop();let l=1;for(let h=a;h<n;++h)l*=o[h],u.push(o[h]);const c=[...Gp(e.shape).map(e=>e/l),1].slice(0,a);return[u,i,l,c]}function aI(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(a+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(a+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(a+" update.rank != "+(r+e.length-s));for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+s])throw new Error(a+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function iI(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}aI(n,t,e)}function oI(e,t,n){const s=t.shape.length,r=s>1?t.shape[s-1]:1,a=n.length;let i=1;for(let u=r;u<a;++u)i*=n[u];const o=r<1?1:r;return{sliceRank:r,numUpdates:Np(t.shape)/o,sliceSize:i,strides:[...Gp(n.slice(0,r)),1],outputSize:Np(n)}}const uI=1.7580993408473768,lI=1.0507009873554805,cI=.3275911,hI=.254829592,dI=-.284496736,pI=1.421413741,fI=-1.453152027,mI=1.061405429;function gI(...e){af().getBool("IS_TEST")||console.warn(...e)}function bI(...e){af().getBool("IS_TEST")||console.log(...e)}function yI(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let s=0;s<n.length;s+=2)n[s]=e[s/2],n[s+1]=t[s/2];return n}function vI(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=e[s],n[s/2]=e[s+1];return{real:t,imag:n}}function wI(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function xI(e){const t=Math.floor(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function kI(e,t){return{real:e[2*t],imag:e[2*t+1]}}function II(e,t,n,s){e[2*s]=t,e[2*s+1]=n}function CI(e,t){const n=new Float32Array(e/2),s=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const a=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:n,imag:s}}function _I(e,t,n){const s=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(s),imag:Math.sin(s)}}const SI=/->/g;function EI(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(SI,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[s,r]=e.split("->");Cp(-1===s.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const a=s.split(","),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<r.length;++h){const e=r[h];if(!a.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<s.length;++h){const e=s[h];-1===o.indexOf(e)&&","!==e&&o.push(e)}const u=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let e=0;e<a[h].length;++e)u[h].push(o.indexOf(a[h][e]))}const l=o.length,c=[];for(let h=r.length;h<l;++h)c.push(h);return{allDims:o,summedDims:c,idDims:u}}function NI(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const s=[];for(let r=0;r<e;++r)-1===n[r]&&s.push(r);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:s}}function $I(e,t,n){const s=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===s[t[r][n]]?s[t[r][n]]=e[n]:Cp(s[t[r][n]]===e[n],()=>`Expected dimension ${s[t[r][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`)}}function TI(e,t){const n=e,s=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)s.push([]);const a=[];for(let i=0;i<n.length;++i){const e=RI(t,n[i]);for(const t of e)-1===a.indexOf(t)&&(s[i].push(t),a.push(t))}return{path:n,steps:s}}function AI(e){return e.every((e,t)=>e===t)}function RI(e,t){const n=[];for(let s=0;s<e.length;++s)0!==e[s].length&&-1===e[s].indexOf(t)&&-1!==t||n.push(s);return n}function FI(e,t,n=0){let s=[];if("number"==typeof t)Cp(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(e.shape[n]/t);else{Cp(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");const r=t.indexOf(-1);if(-1!==r){const s=t.reduce((e,t)=>t>0?e+t:e);t[r]=e.shape[n]-s}Cp(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function DI(e,t){let n,s=!1;for(e<=Yk?(n=e,s=!0):n=Hp(e,Math.floor(Math.sqrt(e)));!s;)n>t||n===e?s=!0:n=Hp(e,n+1);return n}function OI(e,t,n){const s=[],r=e.length;for(let a=0;a<r;a++)s.push(a!==t?e[a]:n);return s}function MI(e,t,n,s){const r=t.shape.length,a=e.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],o=[];let u=1,l=1,c=1;for(let h=0;h<s;++h)o.push(e.shape[h]),u*=e.shape[h];for(let h=s;h<n;h++)o.push(e.shape[h]),l*=e.shape[h];for(let h=s;h<r;h++)o.push(t.shape[h]);for(let h=n+1;h<a;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:o}}function zI(e){try{return e.map(e=>yb(e))}catch(sK){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${sK}`)}}function LI(e){return e.map(e=>bb(e))}function PI(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const s=qy(e,"int32"),r=qy([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=s.indexToLoc(n[a]);r.values.set(t,a*e.length)}return r.toTensor()}const jI={kernelName:hf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(e,Xx(Uy(n,"float32"),-1))}}},VI={kernelName:df,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ex(Uy(n,"float32")),s=Nx(Mw($v(1),t));return nx(bw(e,s))}}}},WI={kernelName:pf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Nx(Mw(ex(Uy(n,"float32")),1));return bw(e,t)}}}},BI={kernelName:ff,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=xw(n.shape,s.shape);return{a:()=>{let t=e;const s=ww(n.shape,r);return s.length>0&&(t=zw(t,s)),Xv(t,n.shape)},b:()=>{let t=e;const n=ww(s.shape,r);return n.length>0&&(t=zw(t,n)),Xv(t,s.shape)}}}},qI={kernelName:mf,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,s)=>{n[s]=()=>e.clone()}),n}},UI={kernelName:yf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Lx(n)}}},HI={kernelName:vf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Lx(n)}}},GI={kernelName:wf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,Nx(Mw($v(1),ex(Uy(n,"float32")))))}}},KI={kernelName:xf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Nx(Rv($v(1),ex(Uy(n,"float32"))));return bw(e,t)}}}},XI={kernelName:Cf,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=xw(n.shape,s.shape);return{a:()=>{const t=Rv(ex(n),ex(s));let a=Ow(e,bw(s,t));const i=ww(n.shape,r);return i.length>0&&(a=zw(a,i)),Xv(a,n.shape)},b:()=>{const t=Rv(ex(n),ex(s));let a=nx(Ow(e,bw(n,t)));const i=ww(s.shape,r);return i.length>0&&(a=zw(a,i)),Xv(a,s.shape)}}}},YI={kernelName:kf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,Rv(ex(Uy(n,"float32")),1))}}},ZI={kernelName:If,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,Mw($v(1),ex(Uy(n,"float32"))))}}},JI=iy({avgPool3dGrad_:function(e,t,n,s,r,a){const i=ry(e,"dy","avgPool3dGrad"),o=ry(t,"input","avgPool3dGrad");let u=i,l=o,c=!1;4===o.rank&&(c=!0,u=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Cp(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),Cp(5===l.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),null!=a&&Cp(Tp(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const h=Yb.runKernel(Nf,{dy:u,input:l},{filterSize:n,strides:s,pad:r,dimRoundingMode:a});return c?Xv(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),QI={kernelName:Ef,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>JI(e,s,r,a,i,o)}}},eC=iy({avgPoolGrad_:function(e,t,n,s,r){const a=ry(e,"dy","avgPoolGrad"),i=ry(t,"input","avgPoolGrad");Cp(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,u=a,l=!1;3===i.rank&&(l=!0,o=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Cp(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),Cp(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c=Yb.runKernel(Sf,{dy:u,input:o},{filterSize:n,strides:s,pad:r});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),tC={kernelName:_f,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:a,pad:i}=n;return{x:()=>eC(e,s,r,a,i)}}},nC={kernelName:$f,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[s,r]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>sk(e,r,!1,!1),b:()=>sk(e,s,!0,!1)}:a&&!i?{a:()=>sk(r,e,!1,!0),b:()=>sk(s,e,!1,!1)}:{a:()=>sk(r,e,!0,!0),b:()=>sk(e,s,!0,!0)}:{a:()=>sk(e,r,!1,!0),b:()=>sk(s,e,!0,!1)}}},sC=iy({spaceToBatchND_:function(e,t,n){const s=ry(e,"x","spaceToBatchND");return Cp(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),Cp(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Cp(s.shape.reduce((e,s,r)=>r>0&&r<=t.length?e&&(s+n[r-1][0]+n[r-1][1])%t[r-1]==0:e,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),Yb.runKernel(Og,{x:s},{blockShape:t,paddings:n})}}),rC={kernelName:Tf,gradFunc:(e,t,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>sC(e,s,r)}}},aC={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const s=n.inputShape,r=n.shape,a=Array.from(r);for(let o=s.length-1;o>=0;o--)if(s[o]===r[o])a[o]=1;else if(1!==s[o])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${r}].`);const i=[];for(let o=0;o<a.length;o++)a[o]>1&&i.push(o);return{x:()=>zw(e,i,!0)}}},iC={kernelName:Rf,gradFunc:e=>({x:()=>e.clone()})},oC={kernelName:Ff,gradFunc:e=>({x:()=>Lx(e)})},uC={kernelName:Df,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{clipValueMin:r,clipValueMax:a}=n;return{x:()=>zx(Pw(Tw(s,r),xk(s,a)),e,Lx(e))}}},lC={kernelName:Mf,inputsToSave:["x"],gradFunc:jI.gradFunc},cC={kernelName:zf,saveAllInputs:!0,gradFunc:(e,t,n)=>{const s=t.map(e=>e.shape),{axis:r}=n,a=Op(r,t[0].shape)[0],i=s.map(e=>e[a]);return Ex(e,i,a).map(e=>()=>e)}},hC={kernelName:Lf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{dilations:a,strides:i,pad:o,dataFormat:u}=n;return Cp(Hv(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>cw(s.shape,e,r,i,o,u),filter:()=>Gx(s,e,r.shape,i,o,u)}}},dC={kernelName:jf,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>uw(e,r,a,i,o,1,u),filter:()=>Gx(e,s,r.shape,a,i,o,u)}}},pC=iy({conv3DBackpropFilter_:function(e,t,n,s,r){let a=e;4===e.rank&&(a=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;return 4===i.rank&&(i=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Cp(5===a.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Cp(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),Cp(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Cp(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Cp(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`),Yb.runKernel(Wf,{x:a,dy:i},{strides:s,pad:r,filterShape:n})}}),fC={kernelName:Vf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:a}=n;Cp(Hv(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,o]=t;return{x:()=>pw(i.shape,e,o,r,a),filter:()=>pC(i,e,o.shape,r,a)}}},mC=iy({sin_:function(e){const t=ry(e,"x","sin");return Yb.runKernel(Ng,{x:t})}}),gC={kernelName:qf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(nx(mC(Uy(n,"float32"))),e)}}},bC=iy({sinh_:function(e){const t=ry(e,"x","sinh");return Yb.runKernel($g,{x:t})}}),yC={kernelName:Uf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(bC(Uy(n,"float32")),e)}}},vC=iy({cumsum_:function(e,t=0,n=!1,s=!1){const r=ry(e,"x","cumsum");return Yb.runKernel(Hf,{x:r},{axis:t,exclusive:n,reverse:s})}}),wC={kernelName:Hf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r,exclusive:a,reverse:i}=n;return{x:()=>{const t=Zw([r],s.rank);let n=vC(e,r,a,!i);return null!=t&&(n=Px(n,t)),n}}}},xC={kernelName:Yf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:a,dimRoundingMode:i}=n,o=null==s?[1,1]:s;Cp(Hv(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,l]=t;return Cp(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),Cp(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),Cp(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),Cp(Gv(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),null!=i&&Cp(Tp(a),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`),{x:()=>nk(u.shape,e,l,r,a,s,i),filter:()=>tk(u,e,l.shape,r,a,s,i)}}},kC={kernelName:em,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,a={x:s,filter:r,dy:e},i={x:s,filter:r,dy:e};return{x:()=>Yb.runKernel(tm,a,n),filter:()=>Yb.runKernel(nm,i,n)}}},IC={kernelName:am,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,s={dy:e,y:n};return{x:()=>Yb.runKernel(im,s)}}},CC={kernelName:om,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=Ow(Fw(nx(ex(n))),2/Math.sqrt(Math.PI));return{x:()=>Ow(e,s)}}},_C={kernelName:lm,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(e,n)}}},SC={kernelName:cm,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Xv(e,n.shape)}}},EC={kernelName:hm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(e,Fw(n))}}},NC={kernelName:mm,gradFunc:e=>({x:()=>Lx(e)})},$C={kernelName:gm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=xw(n.shape,s.shape);return{a:()=>{const t=bw(e,Uy(s,"float32")),a=ww(n.shape,r);return a.length>0?Xv(zw(t,a),n.shape):t},b:()=>{let t=Ow(e,Uy(n,"float32"));const a=ww(s.shape,r);a.length>0&&(t=Xv(zw(t,a),s.shape));const i=ex(s);return nx(bw(t,Uy(i,"float32")))}}}},TC=iy({rsqrt_:function(e){const t=ry(e,"x","rsqrt");return Yb.runKernel(Ig,{x:t})}}),AC={kernelName:bm,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:s}=n,[r,a,i,o]=t,u=null==o?$v(1):o,l=ww(a.shape,r.shape),c=[];if(1===a.rank){for(let e=0;e<r.shape.length-1;++e)c.push(r.shape[e]);c.push(1)}const h=Mw(r,a),d=Ow(e,u),p=TC(Rv(i,$v(s))),f=Ow(Ow(Ow(p,p),p),$v(-.5));return{x:()=>Xv(Ow(Ow(e,1===a.rank?Cw(Xv(p,[1,1,1,a.shape[0]]),c):p),u),r.shape),mean:()=>{let e=Ow(Ow(p,$v(-1)),d);return 1===a.rank&&(e=zw(e,l)),Xv(e,a.shape)},variance:()=>{let e=Ow(Ow(f,h),d);return 1===a.rank&&(e=zw(e,l)),Xv(e,a.shape)},scale:()=>{const t=Ow(h,p);let n=Ow(e,t);return 1===a.rank&&(n=zw(n,l)),Xv(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=zw(t,l)),Xv(t,a.shape)}}}},RC=iy({unsortedSegmentSum_:function(e,t,n){const s=ry(e,"x","unsortedSegmentSum"),r=ry(t,"segmentIds","unsortedSegmentSum","int32");return Cp(Tp(n),()=>"numSegments must be of dtype int"),Yb.runKernel(Qg,{x:s,segmentIds:r},{numSegments:n})}}),FC={kernelName:ym,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[s,r]=t,{axis:a}=n,i=Op(a,s.shape)[0];return{x:()=>{const t=s.shape,n=r.size,o=t.slice(0,i),u=o.length,l=t.slice(a,t.length).slice(1),c=l.length,h=DC(0,u),d=DC(u+1,u+1+c),p=OC([o,[n],l]),f=Xv(e,p),m=Xv(r,[n]),g=OC([[u],h,d]),b=Px(f,g);let y=RC(b,m,s.shape[i]);const v=Jw(g);return y=Px(y,v),y},indices:()=>r}}};function DC(e,t){const n=[];for(let s=e;s<t;++s)n.push(s);return n}function OC(e){const t=[];for(let n=0;n<e.length;++n)for(let s=0;s<e[n].length;++s)t.push(e[n][s]);return t}const MC={kernelName:xm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Lx(n),b:()=>Lx(s)}}},zC={kernelName:km,gradFunc:e=>({x:()=>Uy(e,"float32")})},LC={kernelName:_m,gradFunc:e=>({x:()=>Lx(e)})},PC={kernelName:Sm,gradFunc:e=>({x:()=>Lx(e)})},jC={kernelName:Em,gradFunc:e=>({x:()=>Lx(e)})},VC={kernelName:Nm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{alpha:r}=n,a=$w(s,0);return{x:()=>zx(a,e,Ow(e,r))}}},WC={kernelName:Fm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,Rv(n,1))}}},BC={kernelName:Rm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,Uy(n,"float32"))}}},qC={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n;return{logits:()=>{const t=Fw(s);return Mw(e,Ow(zw(e,r,!0),t))}}}},UC=iy({localResponseNormalizationBackprop_:function(e,t,n,s=5,r=1,a=1,i=.5){return Yb.runKernel(Lm,{x:e,y:t,dy:n},{depthRadius:s,bias:r,alpha:a,beta:i})}}),HC={kernelName:zm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{depthRadius:a,bias:i,alpha:o,beta:u}=n;return{x:()=>UC(s,r,e,a,i,o,u)}}};function GC(e,t,n,s){return t.rank<n.rank&&(t=Xv(t,Xw(t.shape,s))),e.rank<n.rank&&(e=Xv(e,Xw(e.shape,s))),{x:()=>Ow(e,Uy(kw(n,t),e.dtype))}}const KC={kernelName:Pm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{reductionIndices:r}=s,a=t[0],i=GC(e,t[1],a,Op(r,a.shape));return{x:()=>i.x()}}},XC=iy({less_:function(e,t){let n=ry(e,"a","less"),s=ry(t,"b","less");return[n,s]=Wb(n,s),xw(n.shape,s.shape),Yb.runKernel($m,{a:n,b:s})}}),YC={kernelName:jm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Ow(e,Uy(Tw(n,s),"float32")),b:()=>Ow(e,Uy(XC(n,s),"float32"))}}},ZC=iy({maxPool3dGrad_:function(e,t,n,s,r,a,i){const o=ry(e,"dy","maxPool3dGrad"),u=ry(t,"input","maxPool3dGrad"),l=ry(n,"output","maxPool3dGrad");let c=o,h=u,d=l,p=!1;4===u.rank&&(p=!0,c=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Xv(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=Xv(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Cp(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Cp(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),Cp(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=i&&Cp(Tp(a),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`);const f=Yb.runKernel(qm,{dy:c,input:h,output:d},{filterSize:s,strides:r,pad:a,dimRoundingMode:i});return p?Xv(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),JC={kernelName:Bm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>ZC(e,s,r,a,i,o,u)}}},QC=iy({maxPoolGrad_:function(e,t,n,s,r,a,i){const o=ry(e,"dy","maxPoolGrad"),u=ry(t,"input","maxPoolGrad"),l=ry(n,"output","maxPoolGrad");return Cp(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),Cp(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Cp(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),null!=i&&Cp(Tp(a),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${a}.`),Yb.runKernel(Wm,{dy:o,input:u,output:l},{filterSize:s,strides:r,pad:a,dimRoundingMode:i})}}),e_={kernelName:Vm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>QC(e,s,r,a,i,o)}}},t_={kernelName:Hm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n,a=Op(r,s.shape),i=Np(Kw(s.shape,a)[1]);return{x:()=>{const t=s.shape.slice();a.forEach(e=>{t[e]=1});const n=Xv(e,t);return bw(Ow(n,ix(s.shape,"float32")),i)}}}},n_={kernelName:Gm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{axis:r}=s,[a,i]=t,o=GC(e,i,a,Op(r,a.shape));return{x:()=>o.x()}}},s_={kernelName:Km,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Ow(e,Uy(xk(n,s),"float32")),b:()=>Ow(e,Uy($w(n,s),"float32"))}}},r_={kernelName:Xm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,a=r.map(e=>e[0]);return{x:()=>wx(e,a,s.shape)}}},a_={kernelName:Ym,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=xw(n.shape,s.shape);return{a:()=>{const t=ww(n.shape,r);return t.length>0?Xv(zw(e,t),n.shape):e},b:()=>{const t=Ow(e,nx(Ew(bw(n,s)))),a=ww(s.shape,r);return a.length>0?Xv(zw(t,a),s.shape):t}}}},i_={kernelName:Jm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=xw(n.shape,s.shape);return{a:()=>{const t=Ow(e,Uy(s,"float32")),a=ww(n.shape,r);return a.length>0?Xv(zw(t,a),n.shape):t},b:()=>{const t=Ow(e,Uy(n,"float32")),a=ww(s.shape,r);return a.length>0?Xv(zw(t,a),s.shape):t}}}},o_={kernelName:Qm,gradFunc:e=>({x:()=>nx(e)})},u_={kernelName:ag,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>ax(n.shape,"float32")}}},l_={kernelName:rg,gradFunc:e=>({x:()=>Lx(e)})},c_={kernelName:ig,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:s}=n;return Ox(e,s).map(e=>()=>e)}},h_={kernelName:og,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,a=r.map(e=>e[0]);return{x:()=>wx(e,a,s.shape)}}},d_={kernelName:ug,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,s,r]=t,a=n,i=s,o=xw(a.shape,i.shape);return{a:()=>{const t=Uy(i,"float32");let n=Ow(e,Ow(t,_k(a,Mw(t,$v(1)))));const s=ww(a.shape,o);return s.length>0&&(n=zw(n,s)),Xv(n,a.shape)},b:()=>{const t=$w(a,0),n=zx(t,Rw(a),Lx(a));let s=Ow(e,Ow(r,n));const u=ww(i.shape,o);return u.length>0&&(s=zw(s,u)),Xv(s,i.shape)}}}},p_={kernelName:lg,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,s]=t,r=$w(n,0);return{x:()=>zx(r,e,Ow(e,s)),alpha:()=>{let t=zx(r,Lx(e),Ow(e,n));const a=ww(s.shape,e.shape);return a.length>0&&(t=zw(t,a)),Xv(t,s.shape)}}}},f_={kernelName:sm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=xw(n.shape,s.shape);return{a:()=>{const t=bw(e,Uy(s,"float32")),a=ww(n.shape,r);return a.length>0?Xv(zw(t,a),n.shape):t},b:()=>{let t=Ow(e,Uy(n,"float32"));const a=ww(s.shape,r);a.length>0&&(t=Xv(zw(t,a),s.shape));const i=ex(s);return nx(bw(t,Uy(i,"float32")))}}}},m_={kernelName:pg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,nx(ex(n)))}}},g_={kernelName:wg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=Ow(xk(n,6),Xx(n));return{x:()=>Ow(e,Uy(s,"float32"))}}},b_={kernelName:fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(e,Uy(Xx(n),"float32"))}}},y_={kernelName:mg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xv(e,n.shape)}}},v_={kernelName:yg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>Yb.runKernel(vg,r,n)}}},w_={kernelName:gg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>Yb.runKernel(bg,r,n)}}},x_={kernelName:xg,gradFunc:(e,t,n)=>{const{dims:s}=n,r=Op(s,e.shape);return{x:()=>gx(e,r)}}},k_={kernelName:kg,gradFunc:e=>({x:()=>Lx(e)})},I_={kernelName:Ig,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nx(bw(e,Ow(_k(n,1.5),2)))}}},C_=iy({logicalNot_:function(e){const t=ry(e,"x","logicalNot","bool");return Yb.runKernel(Om,{x:t})}}),__={kernelName:_g,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Uy(Lx(n),"float32"),t:()=>Ow(e,Uy(n,e.dtype)),e:()=>Ow(e,Uy(C_(n),e.dtype))}}},S_={kernelName:Sg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=$w(n,$v(0)),s=$v(uI),r=$v(lI),a=Ow(e,r),i=Ow(Ow(e,s),Fw(Uy(n,"float32")));return zx(t,a,i)}}}},E_={kernelName:Ag,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(e,Ow(n,Mw($v(1),n)))}}},N_={kernelName:Tg,gradFunc:e=>({x:()=>Lx(e)})},$_=iy({cos_:function(e){const t=ry(e,"x","cos");return Yb.runKernel(qf,{x:t})}}),T_={kernelName:Ng,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow($_(Uy(n,"float32")),e)}}},A_=iy({cosh_:function(e){const t=ry(e,"x","cosh");return Yb.runKernel(Uf,{x:t})}}),R_={kernelName:$g,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(A_(Uy(n,"float32")),e)}}},F_={kernelName:Eg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{begin:r,size:a}=n,i=s.shape,[o,u]=bv(s,r,a),l=[];for(let c=0;c<e.rank;c++)l.push([o[c],i[c]-o[c]-u[c]]);return{x:()=>ux(e,l)}}},D_={kernelName:zg,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{dim:r}=n,a=Ow(e,s);return{logits:()=>Mw(a,Ow(zw(a,[r],!0),s))}}},O_={kernelName:Rg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(e,vx(n))}}},M_=iy({batchToSpaceND_:function(e,t,n){const s=ry(e,"x","batchToSpaceND"),r=t.reduce((e,t)=>e*t);return Cp(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),Cp(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Cp(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`),Yb.runKernel(Tf,{x:s},{blockShape:t,crops:n})}}),z_={kernelName:Og,gradFunc:(e,t,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>M_(e,s,r)}}},L_={kernelName:Mg,gradFunc:(e,t,n)=>{const{axis:s}=n;return{x:()=>sw(e,s)}}},P_=[jI,VI,WI,BI,qI,UI,HI,GI,KI,XI,YI,ZI,QI,tC,nC,rC,aC,iC,oC,uC,lC,cC,dC,hC,fC,gC,yC,wC,xC,kC,f_,IC,CC,_C,SC,EC,$C,NC,AC,FC,MC,zC,LC,PC,jC,VC,WC,BC,qC,HC,KC,KC,YC,JC,e_,t_,n_,s_,r_,a_,i_,o_,u_,l_,c_,h_,h_,d_,p_,m_,g_,b_,y_,v_,w_,x_,k_,I_,__,S_,E_,N_,T_,R_,F_,D_,O_,z_,z_,L_,L_,{kernelName:Fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,Ow(Nx(Uy(n,"float32")),2))}}},{kernelName:Vg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=$v(2);return{a:()=>Ow(e,Ow(r,Mw(n,s))),b:()=>Ow(e,Ow(r,Mw(s,n)))}}},{kernelName:Wg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(e,Ow(Uy(n,"float32"),2))}}},{kernelName:tb,gradFunc:e=>({x:()=>Lx(e)})},{kernelName:qg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=xw(n.shape,s.shape);return{a:()=>{let t=e;const s=ww(n.shape,r);return s.length>0&&(t=zw(t,s)),Xv(t,n.shape)},b:()=>{let t=e;const n=ww(s.shape,r);return n.length>0&&(t=zw(t,n)),Xv(nx(t),s.shape)}}}},{kernelName:Dg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,r=s.shape.slice(),{axis:a}=n;Op(a,s.shape).forEach(e=>{r[e]=1});const i=Xv(e,r),o=Ow(i,ix(s.shape,"float32"));return{x:()=>o}}},{kernelName:Ug,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,ex($_(n)))}}},{kernelName:Hg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ow(Mw($v(1),ex(n)),e)}}},{kernelName:Gg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{reps:r}=n;return{x:()=>{let t=Lx(s);if(1===s.rank)for(let n=0;n<r[0];++n)t=Rv(t,wx(e,[n*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let n=0;n<r[0];++n)for(let a=0;a<r[1];++a)t=Rv(t,wx(e,[n*s.shape[0],a*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let n=0;n<r[0];++n)for(let a=0;a<r[1];++a)for(let i=0;i<r[2];++i)t=Rv(t,wx(e,[n*s.shape[0],a*s.shape[1],i*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let a=0;a<r[1];++a)for(let i=0;i<r[2];++i)for(let o=0;o<r[3];++o)t=Rv(t,wx(e,[n*s.shape[0],a*s.shape[1],i*s.shape[2],o*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return t}}}},{kernelName:Yg,gradFunc:(e,t,n)=>{const s=n,{perm:r}=s,a=Jw(r);return{x:()=>Px(e,a)}}},{kernelName:Jg,gradFunc:(e,t,n)=>{const s=n,{axis:r}=s;return{value:()=>Tx(e,r)}}},{kernelName:Qg,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Ww(t,Lx(t)),s=Nw(e,n);let r=Tw(t,$v(0,"int32"));const a=s.rank-r.rank;for(let o=0;o<a;++o)r=Iw(r,o+1);r=Pw(r,ix(s.shape,"bool"));const i=Lx(s);return zx(r,s,i)}(e,n)}}},{kernelName:eb,gradFunc:e=>({x:()=>Lx(e)})}];for(const rK of P_)db(rK);Rb().prototype.abs=function(){return this.throwIfDisposed(),Av(this)};const j_=iy({acos_:function(e){const t=ry(e,"x","acos");return Yb.runKernel(df,{x:t})}});Rb().prototype.acos=function(){return this.throwIfDisposed(),j_(this)};const V_=iy({acosh_:function(e){const t=ry(e,"x","acosh");return Yb.runKernel(pf,{x:t})}});Rb().prototype.acosh=function(){return this.throwIfDisposed(),V_(this)},Rb().prototype.add=function(e){return this.throwIfDisposed(),Rv(this,e)},Rb().prototype.all=function(e,t){return this.throwIfDisposed(),Fv(this,e,t)},Rb().prototype.any=function(e,t){return this.throwIfDisposed(),Dv(this,e,t)},Rb().prototype.argMax=function(e){return this.throwIfDisposed(),Ov(this,e)};const W_=iy({argMin_:function(e,t=0){const n=ry(e,"x","argMin");return Yb.runKernel(vf,{x:n},{axis:t})}});Rb().prototype.argMin=function(e){return this.throwIfDisposed(),W_(this,e)},Rb().prototype.asScalar=function(){return this.throwIfDisposed(),Cp(1===this.size,()=>"The array must have only 1 element."),Xv(this,[])},Rb().prototype.asType=function(e){return this.throwIfDisposed(),Uy(this,e)},Rb().prototype.as1D=function(){return this.throwIfDisposed(),Xv(this,[this.size])},Rb().prototype.as2D=function(e,t){return this.throwIfDisposed(),Xv(this,[e,t])},Rb().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Xv(this,[e,t,n])},Rb().prototype.as4D=function(e,t,n,s){return this.throwIfDisposed(),Xv(this,[e,t,n,s])},Rb().prototype.as5D=function(e,t,n,s,r){return this.throwIfDisposed(),Xv(this,[e,t,n,s,r])};const B_=iy({asin_:function(e){const t=ry(e,"x","asin");return Yb.runKernel(wf,{x:t})}});Rb().prototype.asin=function(){return this.throwIfDisposed(),B_(this)};const q_=iy({asinh_:function(e){const t=ry(e,"x","asinh");return Yb.runKernel(xf,{x:t})}});Rb().prototype.asinh=function(){return this.throwIfDisposed(),q_(this)};const U_=iy({atan_:function(e){const t=ry(e,"x","atan");return Yb.runKernel(kf,{x:t})}});Rb().prototype.atan=function(){return this.throwIfDisposed(),U_(this)};const H_=iy({atan2_:function(e,t){let n=ry(e,"a","atan2"),s=ry(t,"b","atan2");return[n,s]=Wb(n,s),Yb.runKernel(Cf,{a:n,b:s})}});Rb().prototype.atan2=function(e){return this.throwIfDisposed(),H_(this,e)};const G_=iy({atanh_:function(e){const t=ry(e,"x","atanh");return Yb.runKernel(If,{x:t})}});Rb().prototype.atanh=function(){return this.throwIfDisposed(),G_(this)},Rb().prototype.avgPool=function(e,t,n,s){return this.throwIfDisposed(),Yv(this,e,t,n,s)},Rb().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),M_(this,e,t)},Rb().prototype.batchNorm=function(e,t,n,s,r){return this.throwIfDisposed(),Jv(this,e,t,n,s,r)},Rb().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Mx(this,e)},Rb().prototype.cast=function(e){return this.throwIfDisposed(),Uy(this,e)};const K_=iy({ceil_:function(e){const t=ry(e,"x","ceil");return Yb.runKernel(Ff,{x:t})}});Rb().prototype.ceil=function(){return this.throwIfDisposed(),K_(this)},Rb().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),nw(this,e,t)},Rb().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ab&&(e=[e]),sw([this,...e],t)},Rb().prototype.conv1d=function(e,t,n,s,r,a){return this.throwIfDisposed(),lw(this,e,t,n,s,r,a)},Rb().prototype.conv2dTranspose=function(e,t,n,s,r){return this.throwIfDisposed(),hw(this,e,t,n,s,r)},Rb().prototype.conv2d=function(e,t,n,s,r,a){return this.throwIfDisposed(),uw(this,e,t,n,s,r,a)},Rb().prototype.cos=function(){return this.throwIfDisposed(),$_(this)},Rb().prototype.cosh=function(){return this.throwIfDisposed(),A_(this)},Rb().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),vC(this,e,t,n)};const X_=iy({depthToSpace_:function(e,t,n="NHWC"){const s=ry(e,"x","depthToSpace"),r="NHWC"===n?s.shape[1]:s.shape[2],a="NHWC"===n?s.shape[2]:s.shape[3],i="NHWC"===n?s.shape[3]:s.shape[1];return Cp(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${s.shape}`),Cp(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${s.shape}`),Cp(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${s.shape}`),Yb.runKernel(Xf,{x:s},{blockSize:t,dataFormat:n})}});Rb().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),X_(this,e,t)},Rb().prototype.depthwiseConv2d=function(e,t,n,s,r,a){return this.throwIfDisposed(),mw(this,e,t,n,s,r,a)};const Y_=iy({dilation2d_:function(e,t,n,s,r=[1,1],a="NHWC"){const i=ry(e,"x","dilation2d"),o=ry(t,"filter","dilation2d");Cp(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Cp(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Cp("NHWC"===a,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=i,l=!1;3===i.rank&&(u=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);const c=Yb.runKernel(em,{x:u,filter:o},{strides:n,pad:s,dilations:r});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});Rb().prototype.dilation2d=function(e,t,n,s,r){return this.throwIfDisposed(),Y_(this,e,t,n,s,r)};const Z_=iy({divNoNan_:function(e,t){let n=ry(e,"a","div"),s=ry(t,"b","div");[n,s]=Wb(n,s);const r=bw(n,s),a=Lx(r),i=kw(s,a);return zx(i,a,r)}});Rb().prototype.divNoNan=function(e){return this.throwIfDisposed(),Z_(this,e)},Rb().prototype.div=function(e){return this.throwIfDisposed(),bw(this,e)};const J_=iy({dot_:function(e,t){const n=ry(e,"t1","dot"),s=ry(t,"t2","dot");Cp(!(1!==n.rank&&2!==n.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=1===n.rank?n.size:n.shape[1],a=1===s.rank?s.size:s.shape[0];if(Cp(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),1===n.rank&&1===s.rank){const e=Xv(n,[1,-1]),t=Xv(s,[-1,1]),r=sk(e,t);return Xv(r,[])}if(1===n.rank&&2===s.rank){const e=Xv(n,[1,-1]),t=Xv(s,[s.shape[0],s.shape[1]]),r=sk(e,t);return Xv(r,[r.size])}if(2===n.rank&&1===s.rank){const e=Xv(s,[-1,1]),t=sk(n,e);return Xv(t,[t.size])}{const e=Xv(s,[s.shape[0],s.shape[1]]);return sk(n,e)}}});Rb().prototype.dot=function(e){return this.throwIfDisposed(),J_(this,e)},Rb().prototype.elu=function(){return this.throwIfDisposed(),yw(this)},Rb().prototype.equal=function(e){return this.throwIfDisposed(),kw(this,e)};const Q_=iy({erf_:function(e){let t=ry(e,"x","erf");return Cp("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Uy(t,"float32")),Yb.runKernel(om,{x:t})}});Rb().prototype.erf=function(){return this.throwIfDisposed(),Q_(this)},Rb().prototype.exp=function(){return this.throwIfDisposed(),Fw(this)},Rb().prototype.expandDims=function(e){return this.throwIfDisposed(),Iw(this,e)};const eS=iy({expm1_:function(e){const t=ry(e,"x","expm1");return Yb.runKernel(hm,{x:t})}});Rb().prototype.expm1=function(){return this.throwIfDisposed(),eS(this)},Rb().prototype.fft=function(){return this.throwIfDisposed(),Bx(this)},Rb().prototype.flatten=function(){return this.throwIfDisposed(),Xv(this,[this.size])},Rb().prototype.floor=function(){return this.throwIfDisposed(),Ew(this)},Rb().prototype.floorDiv=function(e){return this.throwIfDisposed(),gw(this,e)},Rb().prototype.gather=function(e,t){return this.throwIfDisposed(),Nw(this,e,t)},Rb().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Tw(this,e)},Rb().prototype.greater=function(e){return this.throwIfDisposed(),$w(this,e)},Rb().prototype.ifft=function(){return this.throwIfDisposed(),Ux(this)},Rb().prototype.irfft=function(){return this.throwIfDisposed(),Hx(this)};const tS=iy({isFinite_:function(e){const t=ry(e,"x","isFinite");return Yb.runKernel(_m,{x:t})}});Rb().prototype.isFinite=function(){return this.throwIfDisposed(),tS(this)};const nS=iy({isInf_:function(e){const t=ry(e,"x","isInf");return Yb.runKernel(Sm,{x:t})}});Rb().prototype.isInf=function(){return this.throwIfDisposed(),nS(this)};const sS=iy({isNaN_:function(e){const t=ry(e,"x","isNaN");return Yb.runKernel(Em,{x:t})}});Rb().prototype.isNaN=function(){return this.throwIfDisposed(),sS(this)},Rb().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Aw(this,e)},Rb().prototype.lessEqual=function(e){return this.throwIfDisposed(),xk(this,e)},Rb().prototype.less=function(e){return this.throwIfDisposed(),XC(this,e)};const rS=iy({localResponseNormalization_:function(e,t=5,n=1,s=1,r=.5){const a=ry(e,"x","localResponseNormalization");Cp(4===a.rank||3===a.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`),Cp(Tp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;3===a.rank&&(o=!0,i=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u=Yb.runKernel(zm,{x:i},{depthRadius:t,bias:n,alpha:s,beta:r});return o?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Rb().prototype.localResponseNormalization=function(e,t,n,s){return this.throwIfDisposed(),rS(this,e,t,n,s)};const aS=iy({logSigmoid_:function(e){const t=ry(e,"x","logSigmoid");return Nv(e=>({value:nx(Sx(nx(e))),gradFunc:t=>Ow(t,vx(nx(e)))}))(t)}});Rb().prototype.logSigmoid=function(){return this.throwIfDisposed(),aS(this)},Rb().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Lw(this,e)},Rb().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Ok(this,e,t)},Rb().prototype.log=function(){return this.throwIfDisposed(),Rw(this)},Rb().prototype.log1p=function(){return this.throwIfDisposed(),Dk(this)},Rb().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Pw(this,e)},Rb().prototype.logicalNot=function(){return this.throwIfDisposed(),C_(this)};const iS=iy({logicalOr_:function(e,t){const n=ry(e,"a","logicalOr","bool"),s=ry(t,"b","logicalOr","bool");return xw(n.shape,s.shape),Yb.runKernel(Mm,{a:n,b:s})}});Rb().prototype.logicalOr=function(e){return this.throwIfDisposed(),iS(this,e)};const oS=iy({logicalXor_:function(e,t){const n=ry(e,"a","logicalXor","bool"),s=ry(t,"b","logicalXor","bool");return xw(n.shape,s.shape),Pw(iS(e,t),C_(Pw(e,t)))}});Rb().prototype.logicalXor=function(e){return this.throwIfDisposed(),oS(this,e)},Rb().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),sk(this,e,t,n)},Rb().prototype.maxPool=function(e,t,n,s){return this.throwIfDisposed(),jw(this,e,t,n,s)},Rb().prototype.max=function(e,t){return this.throwIfDisposed(),Dw(this,e,t)},Rb().prototype.maximum=function(e){return this.throwIfDisposed(),Ww(this,e)},Rb().prototype.mean=function(e,t){return this.throwIfDisposed(),Bw(this,e,t)},Rb().prototype.min=function(e,t){return this.throwIfDisposed(),qw(this,e,t)},Rb().prototype.minimum=function(e){return this.throwIfDisposed(),Uw(this,e)};const uS=iy({mirrorPad_:function(e,t,n){Cp("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=ry(e,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Cp(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r="reflect"===n?1:0;for(let a=0;a<s.rank;a++)Cp(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),Cp(t[a][0]>=0&&t[a][0]<=s.shape[a]-r&&t[a][1]>=0&&t[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);return Yb.runKernel(Xm,{x:s},{paddings:t,mode:n})}});Rb().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),uS(this,e,t)};const lS=iy({mod_:function(e,t){let n=ry(e,"a","mod"),s=ry(t,"b","mod");return[n,s]=Wb(n,s),Yb.runKernel(Ym,{a:n,b:s})}});Rb().prototype.mod=function(e){return this.throwIfDisposed(),lS(this,e)},Rb().prototype.mul=function(e){return this.throwIfDisposed(),Ow(this,e)},Rb().prototype.neg=function(){return this.throwIfDisposed(),nx(this)},Rb().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Ek(this,e,t,n)},Rb().prototype.notEqual=function(e){return this.throwIfDisposed(),sx(this,e)},Rb().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),rx(this,e,t,n)},Rb().prototype.onesLike=function(){return this.throwIfDisposed(),ox(this)},Rb().prototype.pad=function(e,t){return this.throwIfDisposed(),ux(this,e,t)};const cS=iy({pool_:function(e,t,n,s,r,a){null==r&&(r=[1,1]),null==a&&(a=1),0===s&&(s="valid");const i=ry(e,"x","maxPool");let o=i,u=!1;3===i.rank&&(u=!0,o=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Cp(Gv(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const l=zv(o.shape,t,a,r,s),c=[l.dilationHeight,l.dilationWidth];let h;h="same"===s?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),s=n.map(e=>Math.floor(e/2)),r=n.map((e,t)=>e-s[t]);return n.map((e,t)=>[s[t],r[t]])}([l.filterHeight,l.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(e,t,n){const s=n.map(e=>e[0]),r=n.map(e=>e[1]),a=e.concat(s,r),i=t.map((e,t)=>(e-a[t]%e)%e),o=r.map((e,t)=>e+i[t]);return[t.map((e,t)=>[s[t],o[t]]),t.map((e,t)=>[0,i[t]])]}([l.inHeight,l.inWidth],c,h),m=d?s:"valid",g=d?o:sC(o,c,p),b=("avg"===n?()=>Yv(g,t,a,m):()=>jw(g,t,a,m))(),y=d?b:M_(b,c,f);return u?Xv(y,[y.shape[1],y.shape[2],y.shape[3]]):y}});Rb().prototype.pool=function(e,t,n,s,r){return this.throwIfDisposed(),cS(this,e,t,n,s,r)},Rb().prototype.pow=function(e){return this.throwIfDisposed(),_k(this,e)},Rb().prototype.prelu=function(e){return this.throwIfDisposed(),lx(this,e)};const hS=iy({prod_:function(e,t=null,n=!1){let s=ry(e,"x","prod");return"bool"===s.dtype&&(s=Uy(s,"int32")),Yb.runKernel(cg,{x:s},{axis:t,keepDims:n})}});Rb().prototype.prod=function(e,t){return this.throwIfDisposed(),hS(this,e,t)};const dS=iy({reciprocal_:function(e){const t=ry(e,"x","reciprocal");return Yb.runKernel(pg,{x:t})}});Rb().prototype.reciprocal=function(){return this.throwIfDisposed(),dS(this)},Rb().prototype.relu=function(){return this.throwIfDisposed(),mx(this)},Rb().prototype.relu6=function(){return this.throwIfDisposed(),Kx(this)},Rb().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Xv(this,e.shape)},Rb().prototype.reshape=function(e){return this.throwIfDisposed(),Xv(this,e)},Rb().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),yk(this,e,t,n)},Rb().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),vk(this,e,t,n)},Rb().prototype.reverse=function(e){return this.throwIfDisposed(),gx(this,e)},Rb().prototype.rfft=function(){return this.throwIfDisposed(),qx(this)},Rb().prototype.round=function(){return this.throwIfDisposed(),kk(this)},Rb().prototype.rsqrt=function(){return this.throwIfDisposed(),TC(this)},Rb().prototype.selu=function(){return this.throwIfDisposed(),bx(this)},Rb().prototype.separableConv2d=function(e,t,n,s,r,a){return this.throwIfDisposed(),yx(this,e,t,n,s,r,a)},Rb().prototype.sigmoid=function(){return this.throwIfDisposed(),vx(this)};const pS=iy({sign_:function(e){const t=ry(e,"x","sign");return Yb.runKernel(Tg,{x:t})}});Rb().prototype.sign=function(){return this.throwIfDisposed(),pS(this)},Rb().prototype.sin=function(){return this.throwIfDisposed(),mC(this)},Rb().prototype.sinh=function(){return this.throwIfDisposed(),bC(this)},Rb().prototype.slice=function(e,t){return this.throwIfDisposed(),wx(this,e,t)},Rb().prototype.softmax=function(e){return this.throwIfDisposed(),_x(this,e)},Rb().prototype.softplus=function(){return this.throwIfDisposed(),Sx(this)},Rb().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),sC(this,e,t)},Rb().prototype.split=function(e,t){return this.throwIfDisposed(),Ex(this,e,t)},Rb().prototype.sqrt=function(){return this.throwIfDisposed(),Nx(this)},Rb().prototype.square=function(){return this.throwIfDisposed(),ex(this)},Rb().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Fk(this,e)},Rb().prototype.squeeze=function(e){return this.throwIfDisposed(),$x(this,e)},Rb().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Ab?[this,e]:[this,...e];return Tx(n,t)},Rb().prototype.step=function(e){return this.throwIfDisposed(),Xx(this,e)};const fS=iy({stridedSlice_:function(e,t,n,s,r=0,a=0,i=0,o=0,u=0){const l=ry(e,"x","stridedSlice");return Yb.runKernel(Bg,{x:l},{begin:t,end:n,strides:s,beginMask:r,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u})}});Rb().prototype.stridedSlice=function(e,t,n,s,r,a,i,o){return this.throwIfDisposed(),fS(this,e,t,n,s,r,a,i,o)},Rb().prototype.sub=function(e){return this.throwIfDisposed(),Mw(this,e)},Rb().prototype.sum=function(e,t){return this.throwIfDisposed(),zw(this,e,t)};const mS=iy({tan_:function(e){const t=ry(e,"x","tan");return Yb.runKernel(Ug,{x:t})}});Rb().prototype.tan=function(){return this.throwIfDisposed(),mS(this)},Rb().prototype.tanh=function(){return this.throwIfDisposed(),Ax(this)},Rb().prototype.tile=function(e){return this.throwIfDisposed(),Cw(this,e)},Rb().prototype.toBool=function(){return this.throwIfDisposed(),Uy(this,"bool")},Rb().prototype.toFloat=function(){return this.throwIfDisposed(),Uy(this,"float32")},Rb().prototype.toInt=function(){return this.throwIfDisposed(),Uy(this,"int32")};const gS=iy({topk_:function(e,t=1,n=!0){const s=ry(e,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const a={x:s},i={k:t,sorted:n},[o,u]=Yb.runKernel(Kg,a,i);return{values:o,indices:u}}});Rb().prototype.topk=function(e,t){return this.throwIfDisposed(),gS(this,e,t)},Rb().prototype.transpose=function(e){return this.throwIfDisposed(),Px(this,e)};const bS=iy({unique_:function(e,t=0){const n=ry(e,"x","unique","string_or_numeric");Cp(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:t},[a,i]=Yb.runKernel(Zg,s,r);return{values:a,indices:i}}});let yS;function vS(){return null==yS&&(yS=Yb.backend.epsilon()),yS}Rb().prototype.unique=function(e){return this.throwIfDisposed(),bS(this,e)},Rb().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),RC(this,e,t)},Rb().prototype.unstack=function(e){return this.throwIfDisposed(),Ox(this,e)},Rb().prototype.where=function(e,t){return this.throwIfDisposed(),zx(e,this,t)},Rb().prototype.zerosLike=function(){return this.throwIfDisposed(),Lx(this)};class wS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wS.prototype)}}class xS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xS.prototype)}}class kS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kS.prototype)}}class IS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,IS.prototype)}}class CS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,CS.prototype)}}function _S(e,t){if(Array.isArray(e)){let n=[];for(let s=0;s<t;s++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function SS(e,t){if(!e)throw new CS(t)}function ES(e,t){let n=0;for(const s of e)s===t&&n++;return n}function NS(e){return 1===e.length?e[0]:e}function $S(e){return Array.isArray(e)?e:[e]}function TS(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function AS(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}Error;let RS={};function FS(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function DS(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>DS(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?DS(t):e[n]=t.value)}}}function OS(e,t={},n={},s="object",r=!1){if("string"==typeof e){const r=e;let a;if(r in n)a=n[r];else if(r in RS)a=RS[r];else if(a=t[r],null==a)throw new kS(`Unknown ${s}: ${e}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new kS(`${s}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,u;if(i in n?[o,u]=n[i]:i in RS?[o,u]=RS.className:i in t&&([o,u]=t[i]),null==o)throw new kS(`Unknown ${s}: ${i}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const e={};for(const n of Object.keys(RS))e[n]=RS[n];for(const r of Object.keys(n))e[r]=n[r];a.config.customObjects=e;const t=Object.assign({},RS);for(const r of Object.keys(n))RS[r]=n[r];DS(a.config);const s=u(o,a.config,n,r);return RS=Object.assign({},t),s}{const e=Object.assign({},RS);for(const s of Object.keys(n))RS[s]=n[s];const t=new o(a.config);return RS=Object.assign({},e),t}}}function MS(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function zS(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function LS(e){if(null==e)throw new kS(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function PS(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new kS(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function jS(e,t,n=0,s=1/0){return SS(n>=0),SS(s>=n),Array.isArray(e)&&e.length>=n&&e.length<=s&&e.every(e=>typeof e===t)}function VS(e,t){Array.isArray(e)?(Cp(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>VS(e,`element ${n+1} of ${t}`))):Cp(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${WS(e)}.`)}function WS(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>WS(e)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function BS(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function qS(e,t){return Cv(()=>Nx(zw(Ow(e,e),t,!0)))}class US extends vv{getConfig(){return{}}}class HS extends US{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Cv(()=>{const t=qS(e,this.axis),n=nw(t,0,this.maxValue);return Ow(e,bw(n,Rv(vS(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}HS.className="MaxNorm",xv(HS);class GS extends US{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Cv(()=>bw(e,Rv(vS(),qS(e,this.axis))))}getConfig(){return{axis:this.axis}}}GS.className="UnitNorm",xv(GS);class KS extends US{apply(e){return mx(e)}}KS.className="NonNeg",xv(KS);class XS extends US{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Cv(()=>{const t=qS(e,this.axis),n=Rv(Ow(this.rate,nw(t,this.minValue,this.maxValue)),Ow(1-this.rate,t));return Ow(e,bw(n,Rv(vS(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}XS.className="MinMaxNorm",xv(XS);const YS={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ZS(e){return FS(e)}function JS(e,t={}){return OS(e,wv.getMap().classNameMap,t,"constraint")}function QS(e){return null==e?null:"string"==typeof e?JS({className:e in YS?YS[e]:e,config:{}}):e instanceof US?e:JS(e)}const eE=["channelsFirst","channelsLast"],tE=["nearest","bilinear"],nE=["valid","same","causal"],sE=["max","avg"],rE=["sum","mul","concat","ave"],aE=new Map;function iE(e){PS(eE,"DataFormat",e)}function oE(e){PS(nE,"PaddingMode",e)}function uE(e){PS(sE,"PoolMode",e)}const lE=[];function cE(e,t){lE.push(e);try{const e=t();return lE.pop(),e}catch(n){throw lE.pop(),n}}function hE(e){if(!fE(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===lE.length?"":lE.join("/")+"/")+e}function dE(e){if(!fE(e))throw new Error("Not a valid tensor name: '"+e+"'");aE.has(e)||aE.set(e,0);const t=aE.get(e);if(aE.set(e,aE.get(e)+1),t>0){const n=`${e}_${t}`;return aE.set(n,1),n}return e}const pE=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fE(e){return!!e.match(pE)}function mE(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let s=1;for(let r=t;r<n;++r)s*=e[r];return s}function gE(e){return Rx(e=Array.isArray(e)?new Float32Array(e):e)}function bE(e){return qw(gE(e)).dataSync()[0]}function yE(e){return Dw(gE(e)).dataSync()[0]}function vE(e,t){if(t<e)throw new kS(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let s=e;s<t;++s)n.push(s);return n}function wE(e,t){return e.asType(t)}function xE(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function kE(e,t,n){return Cv(()=>{switch(e.rank){case 1:return xx(e,t,n);case 2:return kx(e,[t,0],[n,e.shape[1]]);case 3:return Ix(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Cx(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return wx(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return wx(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new kS(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function IE(e,t,n){return Cv(()=>{switch(e.rank){case 1:return xx(e,t,n);case 2:return kx(e,[0,t],[e.shape[0],n]);case 3:return Ix(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Cx(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new kS(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function CE(e,t,n,s){return Cv(()=>{switch(e.rank){case 1:return xx(e,t,n);case 2:switch(s){case 1:return kE(e,t,n);case 2:return IE(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return kE(e,t,n);case 2:return Ix(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return IE(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return kE(e,t,n);case 2:return Cx(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Cx(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return IE(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${s}`)}default:throw new kS(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function _E(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),sw(e,t)}function SE(e,t){switch(e.rank){case 1:return rw([e,t]);case 2:return aw([e,t],0);case 3:return iw([e,t],0);case 4:return ow([e,t],0);default:throw new kS(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function EE(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new kS(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Cw(e,t)}function NE(e,t=0,n=1,s,r){return px(e,t,n,s,r)}function $E(e,t,n,s){if(e.rank<2||t.rank<2)throw new IS(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new IS(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return rk({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?RE(e.rank,s,"channelsLast"):null,activation:n});{const r=e.shape.slice(),a=r.pop();e=e.reshape([-1,a]);const i=t.shape.slice(),o=i.pop(),u=i.pop(),l=[...i,o],c=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=t.transpose(c).reshape([u,-1]);const h=[...r,...l];return rk({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?RE(e.rank,s,"channelsLast"):null,activation:n}).reshape(h)}}function TE(e,t,n){return Cv(()=>(t=Array.isArray(t)?Rx(t,"int32"):t.toInt(),Nw(e,t,n)))}function AE(e){return Ow(e,e)}function RE(e,t,n){const s=t.shape;if(1!==t.rank&&t.rank!==e)throw new kS(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return t.reshape(1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===n)return t.reshape(1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===e){if("channelsFirst"===n)return t.reshape(1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===n)return t.reshape(1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===e){if("channelsFirst"===n)return t.reshape(1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===n)return t.reshape(1===s.length?[1,1,s[0]]:[1].concat(s))}else if(e<3)return t;throw new kS(`Unsupported input rank by biasAdd: ${t.rank}`)}function FE(e,t,n){return Cv(()=>(null==n&&(n="channelsLast"),iE(n),e.add(RE(e.rank,t,n))))}function DE(e,t,n,s){return Cv(()=>jx(e,t,n,s))}function OE(e,t,n=!1){return n?e():t()}const ME=["fanIn","fanOut","fanAvg"],zE=["normal","uniform","truncatedNormal"];class LE extends vv{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class PE extends LE{apply(e,t){return ax(e,t)}}PE.className="Zeros",xv(PE);class jE extends LE{apply(e,t){return ix(e,t)}}jE.className="Ones",xv(jE);class VE extends LE{constructor(e){if(super(),"object"!=typeof e)throw new kS(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new kS(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Cv(()=>Ow($v(this.value),ix(e,t)))}getConfig(){return{value:this.value}}}VE.className="Constant",xv(VE);class WE extends LE{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return fx(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}WE.className="RandomUniform",xv(WE);class BE extends LE{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new IS(`randomNormal does not support dType ${t}.`);return NE(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}BE.className="RandomNormal",xv(BE);class qE extends LE{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new IS(`truncatedNormal does not support dType ${t}.`);return Dx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qE.className="TruncatedNormal",xv(qE);class UE extends LE{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Cv(()=>{if(2!==e.length||e[0]!==e[1])throw new kS("Identity matrix initializer can only be used for 2D square matrices.");return Ow(this.gain,_w(e[0]))})}getConfig(){return{gain:this.gain}}}UE.className="Identity",xv(UE);class HE extends LE{constructor(e){if(super(),e.scale<0)throw new kS(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,PS(ME,"FanMode",this.mode),this.distribution=null==e.distribution?"normal":e.distribution,PS(zE,"Distribution",this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,s;if(iE(t),2===e.length)n=e[0],s=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=mE(e,2);n=e[1]*t,s=e[0]*t}else if("channelsLast"===t){const t=mE(e,0,e.length-2);n=e[e.length-2]*t,s=e[e.length-1]*t}}else{const t=mE(e);n=Math.sqrt(t),s=Math.sqrt(t)}return[n,s]}(e),s=n[0],r=n[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,r):Math.max(1,(s+r)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new IS(`${this.getClassName()} does not support dType ${t}.`);return Dx(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return fx(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}HE.className="VarianceScaling",xv(HE);class GE extends HE{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return HE.className}}GE.className="GlorotUniform",xv(GE);class KE extends HE{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return HE.className}}KE.className="GlorotNormal",xv(KE);class XE extends HE{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return HE.className}}XE.className="HeNormal",xv(XE);class YE extends HE{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return HE.className}}YE.className="HeUniform",xv(YE);class ZE extends HE{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return HE.className}}ZE.className="LeCunNormal",xv(ZE);class JE extends HE{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return HE.className}}JE.className="LeCunNormal",xv(JE);class QE extends LE{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new IS("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return Cv(()=>{if(e.length<2)throw new IS("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=NE(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=Mk.gramSchmidt(t);return e[0]>e[1]&&(n=n.transpose()),Ow(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}QE.className="Orthogonal",xv(QE);const eN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function tN(e,t={}){return OS(e,wv.getMap().classNameMap,t,"initializer")}function nN(e){return FS(e)}function sN(e){if("string"==typeof e){const t=e in eN?eN[e]:e;if("GlorotNormal"===t)return new KE;if("GlorotUniform"===t)return new GE;if("HeNormal"===t)return new XE;if("HeUniform"===t)return new YE;if("LeCunNormal"===t)return new ZE;if("LeCunUniform"===t)return new JE;{const e={};return e.className=t,e.config={},tN(e)}}return e instanceof LE?e:tN(e)}let rN=0;function aN(){return rN++}const iN={};function oN(e=""){return e in iN||(iN[e]=0),iN[e]+=1,e+iN[e].toString()}function uN(e){return Array.isArray(e)&&Array.isArray(e[0])}function lN(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function cN(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new kS(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function hN(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new kS(`Expected exactly 1 Shape; got ${e.length}`)}return e}function dN(e){let t=0;for(const n of e)t+=0===n.shape.length?1:n.shape.reduce((e,t)=>e*t);return t}class pN{constructor(e,t="float32",n="Variable",s=!0,r=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=aN(),this.originalName=hE(n=null==n?"Variable":n),this.name=dE(this.originalName),this.trainable_=s,this.constraint=r,this.val=function(e,t=!0,n,s){return Yb.makeVariable(e,t,n,s)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function fN(e){return e.map(e=>e.read())}function mN(e){e.forEach(e=>{e[0].write(e[1])})}class gN{constructor(e){this.dtype=e.dtype,this.shape=e.shape,this.ndim=null!=e.shape?e.shape.length:e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class bN{constructor(e,t,n,s,r,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=s,this.callArgs=r,this.outputTensorIndex=i,this.id=aN(),null!=a&&(this.originalName=hE(a),this.name=dE(this.originalName)),this.rank=t.length}}let yN=0;class vN{constructor(e,t){this.callArgs=t,this.id=yN++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)e.push(null!=t?t.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let wN=0;class xN extends vv{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=wN++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=TS(e)+"_"+oN(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=e.weights?e.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new xS(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new kS(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return NS(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return NS(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new wS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new wS(`Layer ${this.name} is not connected, no input to return.`);return NS(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new wS(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new wS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return NS(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=$S(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=$S(this.inputSpec);if(e.length!==t.length)throw new kS(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const s=e[n],r=t[n];if(null==r)continue;const a=s.rank;if(null!=r.ndim&&a!==r.ndim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${a}`);if(null!=r.maxNDim&&a>r.maxNDim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${a}`);if(null!=r.minNDim&&a<r.minNDim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${a}.`);if(null!=r.dtype&&s.dtype!==r.dtype)throw new kS(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${s.dtype}.`);if(r.axes){const e=s.shape;for(const t in r.axes){const s=Number(t),a=r.axes[t],i=s>=0?e[s]:e[e.length+s];if(null!=a&&-1===[a,null].indexOf(i))throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected axis ${s} of input shape to have value ${a} but got shape ${e}.`)}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){const t=r.shape[e],a=s.shape[e];if(null!=t&&null!=a&&t!==a)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=$S(e);let s=!0;for(const a of n)if(!(a instanceof bN)){s=!1;break}let r=!0;for(const a of n)if(a instanceof bN){r=!1;break}if(s===r)throw new kS("Arguments to apply() must be all SymbolicTensors or all Tensors");return cE(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of $S(e))t.push(n.shape);this.build(NS(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);const r=$S(s),a=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(s=NS(a),null!=this.activityRegularizer)throw new IS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const n=function(e){e=$S(e);const t=[];for(const n of e)t.push(n.shape);return NS(t)}(e),s=this.computeOutputShape(n);let r;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((n,s)=>new bN(a,n,this,$S(e),t,this.name,s)):new bN(a,s,this,$S(e),t,this.name),this.addInboundNode(e,r,null,null,n,s,t),this._refCount++,null!=this.activityRegularizer)throw new IS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,s)=>{null!=n&&null!=e[s]&&e[s]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new wS(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new wS(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new xS(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return dN(this.weights)}build(e){this.built=!0}getWeights(e=!1){return fN(e?this.trainableWeights:this.weights)}setWeights(e){Cv(()=>{const t=this.weights;if(t.length!==e.length)throw new kS(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],s=fN(t);for(let r=0;r<s.length;++r){const a=s[r],i=t[r],o=e[r];if(!$p(a.shape,o.shape))throw new kS(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}mN(n)})}addWeight(e,t,n,s,r,a,i){if(-1!==this._addedWeightNames.indexOf(e))throw new kS(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(s=sN("zeros"));const o=s.apply(t,n),u=new pN(o,n,e,a,i);return o.dispose(),null!=r&&this.addLoss(()=>r.apply(u.read())),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=$S(e),null!=this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}addInboundNode(e,t,n,s,r,a,i=null){const o=$S(e);t=$S(t),n=$S(n),s=$S(s),r=lN(r),a=lN(a);const u=[],l=[],c=[];for(const h of o)u.push(h.sourceLayer),l.push(h.nodeIndex),c.push(h.tensorIndex);new vN({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:s,inputShapes:r,outputShapes:a},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function kN(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const s=kN(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of s)-1===t.indexOf(e)&&t.push(e)}return t}}}class IN extends xN{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:oN("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new kS("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new kS("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new kS("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const s=new bN(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new vN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new kS(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function CN(e){return _N.apply(this,arguments)}function _N(){return(_N=bp(function*(e){if(null==e)return;const t=[],n=[],s=[];for(const r in e){const a=e[r];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(r),s.push(e)}}if(t.length>0){const r=yield Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];_v(s)}})).apply(this,arguments)}function SN(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var EN;IN.className="InputLayer",xv(IN),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(EN||(EN={}));class NN{constructor(){this.validationData=null}setParams(e){this.params=e}onEpochBegin(e,t){return bp(function*(){})()}onEpochEnd(e,t){return bp(function*(){})()}onBatchBegin(e,t){return bp(function*(){})()}onBatchEnd(e,t){return bp(function*(){})()}onTrainBegin(e){return bp(function*(){})()}onTrainEnd(e){return bp(function*(){})()}setModel(e){}}class $N{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}onEpochBegin(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onEpochBegin(e,t)})()}onEpochEnd(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onEpochEnd(e,t)})()}onBatchBegin(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onBatchBegin(e,t)})()}onBatchEnd(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onBatchEnd(e,t)})()}onTrainBegin(e){var t=this;return bp(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainBegin(e)})()}onTrainEnd(e){var t=this;return bp(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainEnd(e)})()}}class TN extends NN{constructor(){super()}onEpochBegin(e){var t=this;return bp(function*(){t.seen=0,t.totals={}})()}onBatchEnd(e,t){var n=this;return bp(function*(){null==t&&(t={});const e=null==t.size?0:t.size;n.seen+=e;for(const s in t){const r=t[s];if("number"==typeof r)n.totals.hasOwnProperty(s)||(n.totals[s]=0),n.totals[s]=n.totals[s]+r*e;else{let t;s in n.totals?t=n.totals[s]:n.totals[s]=0;const a=Cv(()=>Rv(n.totals[s],Ow(r,e)));n.totals[s]=a,null!=t&&t.dispose()}}})()}onEpochEnd(e,t){var n=this;return bp(function*(){if(null!=t)for(const e of n.params.metrics)null!=n.totals[e]&&("number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:Cv(()=>{const s=Ow(bw(1,n.seen),n.totals[e]);t[e]=s,n.totals[e].dispose(),Sv(t[e])}))})()}}class AN extends NN{onTrainBegin(e){var t=this;return bp(function*(){t.epoch=[],t.history={}})()}onEpochEnd(e,t){var n=this;return bp(function*(){null==t&&(t={}),n.epoch.push(e);for(const e in t)null==n.history[e]&&(n.history[e]=[]),n.history[e].push(t[e])})()}syncData(){var e=this;return bp(function*(){const t=[],n=[],s=[];for(const a in e.history){const r=e.history[a];for(let e=0;e<r.length;++e)"number"!=typeof r[e]&&(t.push(r[e].data()),n.push(a),s.push(e))}const r=yield Promise.all(t);for(let a=0;a<r.length;++a)e.history[n[a]][s[a]].dispose(),e.history[n[a]][s[a]]=r[a][0]})()}}class RN extends NN{constructor(e,t){if(super(),this.currentEpoch=0,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Bp(this.yieldEvery)&&(this.maybeWait=function(e,t){let n,s=gb();return(...r)=>{const a=gb();return a-s<t||(s=a,n=e(...r)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}maybeWait(e,t,n){var s=this;return bp(function*(){const r=[];null!=s.yield&&(yield CN(n),r.push(s.yield(e,t,n))),r.push(Gk()),yield Promise.all(r)})()}onEpochBegin(e,t){var n=this;return bp(function*(){n.currentEpoch=e,null!=n.epochBegin&&(yield CN(t),yield n.epochBegin(e,t))})()}onEpochEnd(e,t){var n=this;return bp(function*(){const s=[];null!=n.epochEnd&&(yield CN(t),s.push(n.epochEnd(e,t))),"epoch"===n.yieldEvery&&s.push(Gk()),yield Promise.all(s)})()}onBatchBegin(e,t){var n=this;return bp(function*(){null!=n.batchBegin&&(yield CN(t),yield n.batchBegin(e,t))})()}onBatchEnd(e,t){var n=this;return bp(function*(){const s=[];null!=n.batchEnd&&(yield CN(t),s.push(n.batchEnd(e,t))),"batch"===n.yieldEvery?s.push(Gk()):Bp(n.yieldEvery)&&s.push(n.maybeWait(n.currentEpoch,e,t)),yield Promise.all(s)})()}onTrainBegin(e){var t=this;return bp(function*(){null!=t.trainBegin&&(yield CN(e),yield t.trainBegin(e))})()}onTrainEnd(e){var t=this;return bp(function*(){null!=t.trainEnd&&(yield CN(e),yield t.trainEnd(e))})()}}function FN(e,t){return null==e&&(e={}),e instanceof NN?[e]:Array.isArray(e)&&e[0]instanceof NN?e:$S(e).map(e=>new RN(e,t))}class DN{constructor(){}static registerCallbackConstructor(e,t){Cp(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),DN.checkForDuplicate(t),null==DN.constructors[e]&&(DN.constructors[e]=[]),DN.constructors[e].push(t)}static checkForDuplicate(e){for(const t in DN.constructors)DN.constructors[+t].forEach(t=>{if(t===e)throw new kS("Duplicate callback constructor.")})}static clear(){DN.constructors={}}static createCallbacks(e){const t=[];for(const n in DN.constructors){const s=+n;e>=s&&t.push(...DN.constructors[s])}return t.map(e=>new e)}}function ON(e,t,n,s,r,a,i,o,u){const l=new AN,c=[new TN,...DN.createCallbacks(t)];null!=e&&c.push(...e),c.push(l);const h=new $N(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:h,history:l}}function MN(e,t={},n=!1){return OS(e,wv.getMap().classNameMap,t,"layer",n)}function zN(e,t){return Cv(()=>{"float32"!==e.dtype&&(e=e.asType("float32"));const n=zw(AE(e),t,!0),s=Sw(n.shape,vS()),r=Nx(Ww(n,s));return bw(e,r)})}function LN(e,t){return Cv(()=>Bw(AE(Mw(t,e)),-1))}function PN(e,t){return Cv(()=>Bw(Av(Mw(t,e)),-1))}function jN(e,t){return Cv(()=>{const n=Mw(e,t),s=nw(Av(e),vS(),Number.MAX_VALUE),r=Av(bw(n,s));return Ow(100,Bw(r,-1))})}function VN(e,t,n=!1){return Cv(()=>{if(n)t=_x(t);else{const e=zw(t,t.shape.length-1,!0);t=bw(t,e)}return t=nw(t,vS(),1-vS()),nx(zw(Ow(e.toFloat(),Rw(t)),t.shape.length-1))})}function WN(e,t,n=!1){return Cv(()=>{const s=Ew(function(e){const t=[mE(e.shape)];return e.reshape(t)}(e)).toInt(),r=(t=nw(t,vS(),1-vS())).shape;return VN(rx(s,r[r.length-1]).reshape(r),t,n)})}function BN(e,t){return Cv(()=>{let n;return n=nw(t,vS(),1-vS()),n=Rw(bw(n,Mw(1,n))),Bw(function(e,t){if(!$p(e.shape,t.shape))throw new kS(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Cv(()=>{const n=t.relu(),s=t.abs().neg();return n.sub(t.mul(e)).add(s.exp().log1p())})}(e,n),-1)})}function qN(e,t){return Cv(()=>{const n=zN(e,-1),s=zN(t,-1),r=Ow(n,s);return nx(zw(r,-1))})}DN.constructors={};const UN={meanSquaredError:LN,meanAbsoluteError:PN,meanAbsolutePercentageError:jN,meanSquaredLogarithmicError:function(e,t){return Cv(()=>{const n=nw(t,vS(),Number.MAX_VALUE),s=Rw(Rv(1,n)),r=nw(e,vS(),Number.MAX_VALUE),a=Rw(Rv(1,r));return Bw(AE(Mw(s,a)),-1)})},squaredHinge:function(e,t){return Cv(()=>{const n=Ww(0,Mw(1,Ow(e,t)));return Bw(AE(n),-1)})},hinge:function(e,t){return Cv(()=>{const n=Ww(0,Mw(1,Ow(e,t)));return Bw(n,-1)})},categoricalHinge:function(e,t){return Cv(()=>{const n=zw(Ow(e,t),-1),s=Dw(Ow(Mw(1,e),t),-1);return Ww(0,Rv(1,Mw(s,n)))})},logcosh:function(e,t){return Cv(()=>{const n=Math.log(2),s=Mw(t,e),r=Mw(Rv(s,Sx(Ow(-2,s))),n);return Bw(r,-1)})},categoricalCrossentropy:VN,sparseCategoricalCrossentropy:WN,binaryCrossentropy:BN,kullbackLeiblerDivergence:function(e,t){return Cv(()=>{const n=nw(e,vS(),1),s=nw(t,vS(),1);return zw(Ow(e,Rw(bw(n,s))),-1)})},poisson:function(e,t){return Cv(()=>{const n=Rw(Rv(vS(),t));return Bw(Mw(t,Ow(e,n)),-1)})},cosineProximity:qN};function HN(e){if("string"==typeof e){if(e in UN)return UN[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new kS(t)}return e}function GN(e,t){return Cv(()=>{const n=Ow(.5,ox(t)),s=wE($w(t,n),e.dtype);return Bw(kw(e,s),-1)})}function KN(e,t){return Cv(()=>wE(kw(Ov(e,-1),Ov(t,-1)),"float32"))}function XN(e,t){return BN(e,t)}function YN(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),kw(e,t).asType("float32")}const ZN=VN,JN=WN,QN={binaryAccuracy:GN,categoricalAccuracy:KN,precision:function(e,t){return Cv(()=>{const n=function(e,t){return Cv(()=>Pw(e.equal(1),t.equal(1)).sum().cast("float32"))}(e,t),s=function(e,t){return Cv(()=>Pw(e.equal(0),t.equal(1)).sum().cast("float32"))}(e,t),r=n.add(s);return zx($w(r,0),n.div(r),0).cast("float32")})},categoricalCrossentropy:ZN,sparseCategoricalCrossentropy:JN,mse:LN,MSE:LN,mae:PN,MAE:PN,mape:jN,MAPE:jN,cosine:qN};function e$(e){if("string"==typeof e&&e in QN)return QN[e];if("string"!=typeof e&&null!=e)return e;throw new kS(`Unknown metric ${e}`)}function t$(e){if(SS(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(UN))if(UN[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(QN))if(QN[n]===e){t=n;break}return void 0!==t?t:e.name}}function n$(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!s$(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function s$(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!s$(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!s$(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function r$(e,t,n=console.log){let s="";for(let r=0;r<e.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=e[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);n(s)}function a$(e,t,n){let s;try{s=JSON.stringify(e.outputShape)}catch(sK){s="multiple"}r$([`${e.name} (${e.getClassName()})`,s,e.countParams().toString()],t,n)}function i$(e,t,n,s){let r;try{r=JSON.stringify(e.outputShape)}catch(sK){r="multiple"}const a=[];for(const l of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(let e=0;e<l.inboundLayers.length;++e)a.push(`${l.inboundLayers[e].name}[${l.nodeIndices[e]}][${l.tensorIndices[e]}]`);const i=e.name,o=e.getClassName(),u=0===a.length?"":a[0];r$([`${i} (${o})`,r,e.countParams().toString(),u],t,s);for(let l=1;l<a.length;++l)r$(["","","",a[l]],t,s)}function o$(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function u$(e,t){if(null===e)return null;if("string"==typeof e)return AS(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const s=e[r];o$(t,r,s)?n.push(s):n.push(u$(s,t))}return n}{const t={};for(const n of Object.keys(e)){const s=e[n];if("name"===n&&"string"==typeof s)t[n]=s;else{const e=AS(n);t[e]=u$(s,e)}}return t}}function l$(e,t){if(null==e)return null;if("string"==typeof e)return TS(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const s=e[r];o$(t,r,s)?n.push(s):n.push(l$(s,t))}return n}{const t={};for(const n of Object.keys(e)){const s=e[n];t[TS(n)]="name"!==n&&"className"!==n||"string"!=typeof s?l$(s,n):s}return t}}class c${constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof c$)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new kS(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Uy(t,e.dtype)}catch(sK){throw new kS(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof bN){if(null==this.id2Value[e.id])throw new kS(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new kS(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof bN){if(null==this.id2Value[e.id])throw new kS(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new kS(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&_v(this.id2Mask)}}const h$={},d$={};function p$(e,t,n,s){const r=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(e=>e.name),u=[],l=t.names();for(const f of o)-1!==l.indexOf(f)?u.push(t.getValue(f)):u.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().join(",");let h,d;if(null==h$[c]){const e=function(e,t){Cp(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(1===e.length){const r=m$(e[0],t);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const a of e){const{sorted:e,recipientMap:i}=m$(a,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in i)null==s[t]&&(s[t]=new Set),i[t].forEach(e=>s[t].add(e))}}return{sorted:n,recipientCounts:f$(s)}}(i,t);h=e.sorted,d=e.recipientCounts,h$[c]=h,d$[c]=d}h=h$[c],d={},r||Object.assign(d,d$[c]);const p=new c$(t);for(let f=0;f<h.length;++f){if(null!=s){const e=Iv().numTensors;e>s.maxNumTensors&&(s.maxNumTensors=e),e<s.minNumTensors&&(s.minNumTensors=e)}const e=h[f],a=e.sourceLayer;if(a instanceof IN)continue;const i=[],l=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),s=p.getMask(n);i.push(e),l.push(s),null!=s&&(m=!0),r||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=l[0]);const g=$S(a.apply(i,n));let b=null;a.supportsMasking&&(b=a.computeMask(i,l));const y=g$(e),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(b)?b[0]:b);const e=o.indexOf(v[t].name);-1!==e&&(u[e]=g[t])}r||_v(c)}return p.disposeMasks(),a?u:u[0]}function f$(e){const t={};for(const n in e)t[n]=e[n].size;return t}function m$(e,t){const n=new Set,s=[],r={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),s.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:s,recipientMap:r}}function g$(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const s of e.sourceLayer.inboundNodes[t].outputTensors)if(s.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}class b$ extends xN{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=oN(e)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(e.inputs)?e.inputs.slice():[e.inputs],this.outputs=Array.isArray(e.outputs)?e.outputs.slice():[e.outputs],zS(this.inputs).length!==this.inputs.length)throw new kS(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);zS(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.nodeIndex,t=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(t)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;SS(0===t,"input layer has >1 nodes"),SS(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof IN))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},s={},r={},a={},i=[],o=(e,t,n,s,r,u)=>{null!=s&&null!=r&&null!=u||(s=e.sourceLayer,r=e.nodeIndex,u=e.tensorIndex);const l=s.inboundNodes[r];if(-1!==n.indexOf(l))throw new xS(`The tensor ${e.name} at layer "${s.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(b$.nodeKey(s,r)),s.id in a||(a[s.id]=Object.keys(a).length),-1===n.indexOf(l)&&n.push(l);const c=l.inboundLayers.length;for(let a=0;a<c;a++)o(l.inputTensors[a],t,n,l.inboundLayers[a],l.nodeIndices[a],l.tensorIndices[a]);for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},u=[],l=[];for(const b of this.outputs)o(b,u,l);const c=i.slice().reverse();for(const b of c){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];e=Math.max(e,null==s[b.outboundLayer.id]?0:s[b.outboundLayer.id]),s[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let s=0;s<b.inboundLayers.length;s++){const r=b.inboundLayers[s].inboundNodes[b.nodeIndices[s]];t[r.id]=Math.max(e+1,null==t[r.id]?0:t[r.id]),n[r.id]=r}}const h={};for(const b in t){const e=t[b];e in h||(h[e]=[]),h[e].push(n[b])}const d={};for(const b in s){const e=s[b];e in d||(d[e]=[]),d[e].push(r[b])}let p=Object.keys(d).map(e=>parseInt(e,10)).sort(MS);this.layers=[];for(const b of p){const e=d[b];e.sort((e,t)=>{const n=a[e.id],s=a[t.id];return n<s?-1:n>s?1:0});for(const t of e)t instanceof b$&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map(e=>parseInt(e,10)).sort(MS);const f=this.inputs.slice(),m=[];for(const b of p)for(const e of h[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new xS(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map(e=>e.name);for(const b of g){const e=g.filter(e=>e===b).length;if(1!==e)throw new xS(`The name "${b}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new vN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new kS("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let s=0;for(const a of this.layers)for(const e of a.weights){if(null!=n[e.originalName])throw new kS(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,s++}const r=[];for(const a in e){let s=a;if(null==n[a]){const e=a.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])r.push([n[s],e[a]]);else if(t)throw new kS(`Provided weight data has no target variable: ${a}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new kS(`${e.length} of ${s} weights are not set: ${e}`)}mN(r)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers 3.6.0",t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=l$(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Cv(()=>{e=$S(e);const n=new c$;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return p$(this.outputs,n,t)})}computeMask(e,t){return Cv(()=>{let n;return e=$S(e),n=null==t?_S(null,e.length):$S(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=lN(e);if(t.length!==this.inputLayers.length)throw new kS(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++)n[this.inputLayers[i].name+"_0_0"]=t[i];const s=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(MS);if(s.length>1)for(const i of s){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;const s=[];for(let i=0;i<t.inboundLayers.length;i++)s.push(n[`${t.inboundLayers[i].name}_${t.nodeIndices[i]}_${t.tensorIndices[i]}`]);const r=lN(e.computeOutputShape(NS(s))),a=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++)n[`${e.name}_${a}_${t}`]=r[t]}}const r=[],a=[];for(let i=0;i<this.outputLayers.length;i++)a.push(`${this.outputLayers[i].name}_${this.outputLayersNodeIndices[i]}_${this.outputLayersTensorIndices[i]}`);for(let i=0;i<a.length;i++){const e=a[i];SS(e in n),r.push(n[e])}return NS(r)}runInternalGraph(e,t){null==t&&(t=_S(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o)n[this.inputs[o].id]=[e[o],t[o]];const s=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(MS);for(const o of s){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,s=t.inputTensors,r=t.outputTensors,a=new Array;for(const t of s)t.id in n&&a.push(n[t.id]);if(a.length===s.length){let s,i,o,u,l={};if(null!=t.callArgs&&(l=t.callArgs),1===a.length){const[t,n]=a[0];null==l.mask&&(l.mask=n),o=$S(e.call(t,l)),u=$S(e.computeMask(t,n)),s=[t],i=[n]}else s=a.map(e=>e[0]),i=a.map(e=>e[1]),null==l.mask&&(l.mask=i),o=$S(e.call(s,l)),u=$S(e.computeMask(s,i));if(e.activityRegularizer)throw new IS("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e)n[r[e].id]=[o[e],u[e]]}}}const r=[],a=[],i=[];for(const o of this.outputs){SS(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),r.push(e),a.push(t)}return[r,a,i]}buildNodeConversionMap(e){const t={};let n;for(const s of this.layers){n=s instanceof b$?1:0;for(let e=0;e<s.inboundNodes.length;e++){const r=b$.nodeKey(s,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new kS(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new kS("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===e)return n;throw new kS(`No such layer: ${e}`)}calculateLosses(){return Cv(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const s=b$.nodeKey(t,n);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),s=a.getConfig(),r=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],s=b$.nodeKey(a,n);let i={};if(this.containerNodes.has(s)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(sK){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let s=0;s<e.inboundLayers.length;s++){const r=e.inboundLayers[s],a=e.tensorIndices[s];let o=t[b$.nodeKey(r,e.nodeIndices[s])];null==o&&(o=0),n.push([r.name,o,a,i])}r.push(n)}}}const i={};i.name=a.name,i.className=e,i.config=s,i.inboundNodes=r,n.push(i)}e.layers=n;const s=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=b$.nodeKey(e,this.inputLayersNodeIndices[a]);if(!this.containerNodes.has(n))continue;let r=t[n];null==r&&(r=0),s.push([e.name,r,this.inputLayersTensorIndices[a]])}e.inputLayers=s;const r=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=b$.nodeKey(e,this.outputLayersNodeIndices[a]);if(!this.containerNodes.has(n))continue;let s=t[n];null==s&&(s=0),r.push([e.name,s,this.outputLayersTensorIndices[a]])}return e.outputLayers=r,e}static fromConfig(e,t,n={},s=!1){const r={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let s;for(const a of t){const o=a[0],u=a[1],l=a[2];if(s=null==a[3]?{}:a[3],!(o in r))return void i(e,t);const c=r[o];if(c.inboundNodes.length<=u)return void i(e,t);n.push(c.inboundNodes[u].outputTensors[l])}n.length>0&&e.apply(NS(n),s)}function u(e){const n=e.name,a=MN(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(s),r[n]=a,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new kS(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)})}const l=t.name,c=t.layers;for(const m of c)u(m);for(;!LS(a);)for(const e of c){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const h=[],d=[],p=t.inputLayers;for(const m of p){const e=m[0],t=m[1],n=m[2];SS(e in r),h.push(r[e].inboundNodes[t].outputTensors[n])}const f=t.outputLayers;for(const m of f){const e=m[0],t=m[1],n=m[2];SS(e in r),d.push(r[e].inboundNodes[t].outputTensors[n])}return new e({inputs:h,outputs:d,name:l})}get stateful(){if(this._stateful)throw new kS("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Cv(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function y$(e,t){return function(e,t,n){const s=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===s)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==s)throw new Error(`Provided classWeight is an array of ${e.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{n.push(t in e?e[t]:null)}),n}throw new Error(`The model has multiple (${s}) outputs, so classWeight must be either an array with ${s} elements or an object with ${t} keys. Provided classWeight not understood: ${JSON.stringify(e)}`)}(e,t)}function v$(e,t,n,s){return w$.apply(this,arguments)}function w$(){return(w$=bp(function*(e,t,n,s){if(null!=t||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Cv(()=>{if(1===e.shape.length)return e.clone();if(2===e.shape.length){if(e.shape[1]>1)return e.argMax(1);if(1===e.shape[1])return e.reshape([e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield t.data());_v(t);const r=[];return s.forEach(e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);r.push(n[e])}),Rx(r,"float32")}return null})).apply(this,arguments)}function x$(e,t){return Ow(e,t)}function k$(e,t){let n,s;n=t.xs,s=t.ys,Cp(null!=n&&null!=s,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const r=I$("input",e.inputNames,n),a=I$("output",e.outputNames,s),i=r[0].shape[0];Cp(r.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),Cp(a.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let o=0;o<r.length;o++)Cp(r[o].shape[0]===i,()=>`Batch size mismatch: input ${e.inputNames[o]} has ${r[o].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);for(let o=0;o<a.length;o++)Cp(a[o].shape[0]===i,()=>`Batch size mismatch: output ${e.outputNames[o]} has ${a[o].shape[0]}; expected  ${i} based on input ${e.inputNames[0]}.`);return{xs:r,ys:a}}function I$(e,t,n){if(n instanceof Ab)return[n];if(Array.isArray(n))return Cp(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const s=[];for(const r of t){if(null==n[r])throw new kS(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);s.push(n[r])}return s}}function C$(e){if(3===e.length)throw new IS("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function _$(){return(_$=bp(function*(e,t,n){const s=null!=n.batchesPerEpoch;if(Cp(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Cp(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Cp(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),Cp(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),Cp(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let a,i;if(r)if(E$(n.validationData))Cp(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const e=C$(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let l;l=r?u.slice().concat(u.map(e=>"val_"+e)):u.slice();const c=FN(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=ON(c,h,n.epochs,null,null,S$(t,n),null,r,l);d.setModel(e),e.history=p,yield d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=yield t.iterator();for(;f<n.epochs;){const l={};yield d.onEpochBegin(f);let c=0,h=0;for(s||(m=yield t.iterator());!s||c<n.batchesPerEpoch;){const t=yield m.next();if(s&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:s,ys:r}=k$(e,t.value),a={};a.batch=h,a.size=s[0].shape[0],yield d.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=y$(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(yield v$(r[e],null,t[e]))}const l=s.concat(r).concat(i),p=o(l);_v(l);for(let e=0;e<u.length;++e){const t=p[e];a[u[e]]=t,Sv(t)}yield d.onBatchEnd(h,a),SN(a),h++,c++}if(s?c>=n.batchesPerEpoch:t.done){if(r){let t;t=E$(n.validationData)?$S(yield e.evaluateDataset(n.validationData,{batches:n.validationBatches})):$S(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(yield d.onEpochEnd(f,l),f++,e.stopTraining_)break}return yield d.onTrainEnd(),yield e.history.syncData(),e.history}finally{e.isTraining=!1}})).apply(this,arguments)}function S$(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function E$(e){return"function"==typeof e.iterator}function N$(e){return"function"==typeof e.next}function $$(){return($$=bp(function*(e,t,n){const s=null!=(n=n||{}).batches,r=e.testFunction;let a=[];if(n.verbose>0)throw new IS("Verbose mode is not implemented yet.");Cp(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=N$(t)?t:yield t.iterator();let o=0,u=0;for(;!s||u<n.batches;){const t=yield i.next();if(a=Cv(()=>{if(t.value){const{xs:n,ys:s}=k$(e,t.value),i=n.concat(s),l=Cv(()=>r(i));if(_v(i),0===u)for(let e=0;e<l.length;++e)a.push($v(0));const c=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=a[e];a[e]=Cv(()=>Rv(a[e],Ow(c,t))),u>0&&_v(n)}_v(l),o+=c,++u}return a}),t.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<a.length;++l){const e=a[l];a[l]=bw(a[l],o),_v(e)}return NS(a)})).apply(this,arguments)}function T$(e){Cp(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function A$(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>kE(e,t,n-t)):kE(e,t,n-t)}function R$(e,t){return Cv(()=>null==e?null:Array.isArray(e)?e.map(e=>R$(e,t)):TE(e,"int32"===t.dtype?t:t.toInt()))}function F$(e,t){const n=[];let s=0,r=null;for(;s<e;)r=s+t,r>=e&&(r=e),n.push([s,r]),s=r;return n}function D$(e,t,n,s,r,a,i,o,u,l,c,h,d,p,f){return O$.apply(this,arguments)}function O$(){return(O$=bp(function*(e,t,n,s,r,a,i,o,u,l,c,h,d,p,f){null==r&&(r=32),null==a&&(a=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;if(null!=u&&null!=l&&(m=!0),null!=f&&(m=!0,null==p))throw new kS("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=e.checkNumSamples(n,r,p,"steps_per_epoch");let b;null!=g&&(b=vE(0,g)),null==i&&(i=1);const{callbackList:y,history:v}=ON(o,i,a,d,g,p,r,m,h);y.setModel(e),e.history=v,yield y.onTrainBegin(),e.stopTraining_=!1;for(let w=d;w<a;++w){yield y.onEpochBegin(w);const a={};if(null!=p)throw new IS("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new IS("batch shuffling is not implemneted yet");c&&xp(b);const i=Rx(b),o=F$(g,r);for(let c=0;c<o.length;++c){const h={};if(yield y.onBatchBegin(c,h),Cv(()=>{const d=o[c][0],p=o[c][1],f=kE(i,d,p-d);h.batch=c,h.size=p-d;const g=R$(n,f),b=t(g);for(let e=0;e<s.length;++e){const t=b[e];h[s[e]]=t,Sv(t)}if(c===o.length-1&&m){const t=e.testLoop(u,l,r);for(let e=0;e<s.length;++e){const n=s[e],r=t[e];Sv(r),a["val_"+n]=r}}}),yield y.onBatchEnd(c,h),SN(h),e.stopTraining_)break}i.dispose()}if(yield y.onEpochEnd(w,a),e.stopTraining_)break}return yield y.onTrainEnd(),yield e.history.syncData(),e.history})).apply(this,arguments)}function M$(){return(M$=bp(function*(e,t,n,s={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,a,i,o,u,l,c;e.isTraining=!0;try{const h=null==s.batchSize?32:s.batchSize;T$(h);const d=!1,p=yield e.standardizeUserData(t,n,s.sampleWeight,s.classWeight,d,h);r=p[0],a=p[1],c=p[2];let f,m=!1;if(null!=s.validationData&&s.validationData.length>0){if(m=!0,2!==s.validationData.length)throw 3===s.validationData.length?new IS("validationData including sample weights is not supported yet."):new kS(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);i=s.validationData[0],o=s.validationData[1];const t=!0,n=yield e.standardizeUserData(i,o,null,null,t,h);u=n[0],l=n[1],f=u.concat(l)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){m=!0;const e=Math.floor(r[0].shape[0]*(1-s.validationSplit)),t=r[0].shape[0];u=A$(r,e,t),r=A$(r,0,e),l=A$(a,e,t),a=A$(a,0,e),f=u.concat(l)}else null!=s.validationSteps&&(m=!0);const g=r.concat(a).concat(c);e.checkTrainableWeightsConsistency();const b=e.makeTrainFunction(),y=e.getDedupedMetricsNames();let v,w;m?(e.makeTestFunction(),v=e.testFunction,w=y.slice().concat(y.map(e=>"val_"+e))):(v=null,f=[],w=y.slice());const x=FN(s.callbacks,s.yieldEvery);return yield D$(e,b,g,y,h,s.epochs,s.verbose,x,v,f,s.shuffle,w,s.initialEpoch,null,null)}finally{e.isTraining=!1,L$(r,t),L$(a,n),L$(u,i),L$(l,o),null!=c&&_v(c)}})).apply(this,arguments)}function z$(e){const t=[];e instanceof Ab&&(e=[e]);for(let n=0;n<e.length;++n){const s=e[n];if(1===s.rank)t.push(xE(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function L$(e,t){if(null==e)return;const n=[];if(t instanceof Ab)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const r in t)n.push(t[r].id);const s=[];if(e instanceof Ab)-1===n.indexOf(e.id)&&s.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&s.push(e)});else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&s.push(t)}s.forEach(e=>{e.isDisposed||e.dispose()})}function P$(e){return Array.isArray(e)}function j$(e){return!function(e){return e instanceof Ab}(e)&&!P$(e)}function V$(e,t,n,s=!0,r=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(P$(e)&&e.length>0)t=!0;else if(j$(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new kS(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);let a;if(j$(e)){e=e,a=[];for(const n of t){if(null==e[n])throw new kS(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(P$(e)){if((e=e).length!==t.length)throw new kS(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new kS(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=z$(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new kS(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let a=0;a<n[i].length;++a){if(0===a&&!s)continue;const o=e.shape[a],u=n[i][a];if(null!=u&&u>=0&&o!==u)throw new kS(`Error when checking ${r}: expected ${t[i]} to have shape [${n[i]}], but got array with shape [${e.shape}].`)}}return a}function W$(e,t,n,s=!0,r=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new kS(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new kS(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new kS(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let a=0;a<n[i].length;++a){if(0===a&&!s)continue;const o=e.shape[a],u=n[i][a];if(null!=u&&u!==o)throw new kS(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class B$ extends b${constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new kS("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,s=console.log){const r=function(e){let t=!0;const n=[],s=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==s.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Output shape","Param #"];let i;if(r?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!r){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}s("_".repeat(t)),r$(a,n,s),s("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)r?a$(o[c],n,s):i$(o[c],n,i,s),s((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=function(e){let t;return t=dN(null!=e.collectedTrainableWeights?e.collectedTrainableWeights:e.trainableWeights),t}(e),l=dN(e.nonTrainableWeights);s(`Total params: ${u+l}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${l}`),s("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Uk.adagrad(.01),Adadelta:()=>Uk.adadelta(1,.95,vS()),Adam:()=>Uk.adam(.001,.9,.999,vS()),Adamax:()=>Uk.adamax(.002,.9,.999,vS(),0),RMSProp:()=>Uk.rmsprop(.001,.9,0,vS()),SGD:()=>Uk.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new kS(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Tv))throw new kS("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new kS(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(e=>HN(e))}else{const n=HN(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new kS(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(HN(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],cE("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const s=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const s of t){let t=n.hasOwnProperty(s)?n[s]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};cE("metric",()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,s,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===BN?-1!==["accuracy","acc"].indexOf(i)?s=GN:-1!==["crossentropy","ce"].indexOf(i)&&(s=XN):this.lossFunctions[e]===WN?-1!==["accuracy","acc"].indexOf(i)?s=YN:-1!==["crossentropy","ce"].indexOf(i)&&(s=JN):-1!==["accuracy","acc"].indexOf(i)?s=KN:-1!==["crossentropy","ce"].indexOf(i)&&(s=ZN),-1!==["accuracy","acc"].indexOf(i)?r="acc":-1!==["crossentropy","ce"].indexOf(i)&&(r="ce"),a=s,n=""+r}else{const e=e$(i);a=e,n=""+t$(i)}let t;cE(n,()=>{t=a}),r(e,n,t)}})(s[e])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const s=null==n.batchSize?32:n.batchSize;T$(s);const r=this.standardizeUserDataXY(e,t,!0,s);try{const a=r[0].concat(r[1]);return this.makeTestFunction(),NS(this.testLoop(this.testFunction,a,s,n.verbose,n.steps))}finally{L$(r[0],e),L$(r[1],t)}}evaluateDataset(e,t){var n=this;return bp(function*(){return n.makeTestFunction(),function(e,t,n){return $$.apply(this,arguments)}(n,e,t)})()}checkNumSamples(e,t,n,s="steps"){let r;if(null!=n){if(r=null,null!=t)throw new kS(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new kS(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new kS("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),s=this.retrieveSymbolicTensors(n?t:[t]),r=new c$;if(e instanceof Ab&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new kS(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)r.add(this.inputs[t],e[t])}else for(const i of this.inputs){const t=e[i.name];if(null==t)throw new kS(`No value is provided for the model's input ${i.name}`);r.add(i,t)}const a=p$(s,r);return n?a:a[0]}retrieveSymbolicTensors(e){const t=_S(null,e.length);let n=e.length;for(const s of this.layers){const r=Array.isArray(s.output)?s.output:[s.output],a=r.map(e=>e.name);for(let s=0;s<e.length;++s){const i=a.indexOf(e[s]);if(-1!==i&&(t[s]=r[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,s)=>{null==t&&n.push(e[s])}),new kS(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return Cv(()=>{const s=this.checkNumSamples(e);if(n)throw new IS("Verbose predictLoop() is not implemented yet.");const r=F$(s,t),a=this.outputs.map(e=>[]);for(let t=0;t<r.length;++t)Cv(()=>{const n=A$(e,r[t][0],r[t][1]),s=[];if(Array.isArray(n))for(let e=0;e<n.length;++e)s.push({key:this.inputs[e],value:n[e]});else s.push({key:this.inputs[0],value:n});const a=new c$(s);return p$(this.outputs,a)}).forEach((e,t)=>a[t].push(e));return NS(a.map(e=>sw(e,0)))})}predict(e,t={}){const n=z$(e);W$(n,this.inputNames,this.feedInputShapes,!1);try{const s=null==t.batchSize?32:t.batchSize;return T$(s),this.predictLoop(n,s)}finally{L$(n,e)}}predictOnBatch(e){W$(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,s){if(null==this.optimizer_)throw new xS("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];r.push(this.feedLossFns[a]===WN?e.slice(0,e.length-1).concat([1]):e)}if(function(e,t,n){const s=zS(e.map(e=>e.shape[0]));s.sort();const r=zS(t.map(e=>e.shape[0]));if(r.sort(),s.length>1)throw new kS(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(e=>e.shape))}`);if(r.length>1)throw new kS(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(e=>e.shape))}`);if(s.length>0&&r.length>0&&!$p(s,r))throw new kS(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=V$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=V$(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const s=[LN,BN,VN];for(let r=0;r<e.length;++r){const a=e[r],i=t[r],o=n[r];if(null!=i){if(i===VN&&1===a.shape[a.shape.length-1])throw new kS(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const s=e[n],r=t[n];if(null!=r&&s!==r)throw new kS(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&e[0].shape[0]%s!=0)throw new kS(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}standardizeUserData(e,t,n,s,r=!0,a){var i=this;return bp(function*(){const[o,u]=i.standardizeUserDataXY(e,t,r,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=s){const e=y$(s,i.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(yield v$(u[t],null,e[t]))}return[o,u,l]})()}testLoop(e,t,n,s=0,r){return Cv(()=>{const a=this.checkNumSamples(t,n,r,"steps"),i=[];if(s>0)throw new IS("Verbose mode is not implemented yet.");if(null!=r)throw new IS("steps mode in testLoop() is not implemented yet");{const s=F$(a,n),r=Rx(vE(0,a));for(let n=0;n<s.length;++n){const a=s[n][0],o=s[n][1],u=kE(r,a,o-a),l=R$(t,u),c=e(l);if(0===n)for(let e=0;e<c.length;++e)i.push($v(0));for(let e=0;e<c.length;++e)i[e]=Rv(i[e],Ow(o-a,c[e]))}for(let e=0;e<i.length;++e)i[e]=bw(i[e],a)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const s=e[n];let r=s;ES(e,s)>1&&(r+=`_${ES(e.slice(0,n),s)}`),t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new c$(e),o=p$(this.outputs,i,{training:!0});let u;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(s[n],o[n]);null!=r[n]&&(e=x$(e,r[n]));const a=Bw(e);t.push(a),u=0===n?e:Rv(u,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][1];e=Bw((0,this.metricsTensors[n][0])(s[t],o[t]))}Sv(e),a.push(e)}return u=Bw(u),this.calculateLosses().forEach(e=>{u=Rv(u,e)}),u},!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>Cv(()=>{const t=[];let n;const s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:s[e]});const i=new c$(a),o=p$(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const s=Bw((0,this.lossFunctions[e])(r[e],o[e]));n=0===e?s:Rv(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][1],s=Bw((0,this.metricsTensors[e][0])(r[n],o[n]));t.push(s)}return t})}fit(e,t,n={}){var s=this;return bp(function*(){return function(e,t,n){return M$.apply(this,arguments)}(s,e,t,n)})()}fitDataset(e,t){var n=this;return bp(function*(){return function(e,t,n){return _$.apply(this,arguments)}(n,e,t)})()}trainOnBatch(e,t){var n=this;return bp(function*(){const s=yield n.standardizeUserData(e,t),r=s[0],a=s[1],i=n.makeTrainFunction()(r.concat(a)),o=[];for(const e of i){const t=yield e.data();o.push(t[0])}return _v(i),NS(o)})()}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,s=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let a=0;a<s.length;++a)n&&!s[a].trainable||t.push({name:s[a].originalName,tensor:r[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Iv().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Iv().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=TS(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>TS(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const s of t){if("string"!=typeof n[s])throw new Error("Serialization of non-string loss is not supported.");e[s]=TS(n[s])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[TS(t$(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>TS(t$(e)));{const e={};for(const t in this.metrics)e[t]=TS(t$(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=MN(u$(e.optimizer_config));let n,s;if("string"==typeof e.loss)n=AS(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>AS(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=AS(e.loss[t])}if(Array.isArray(e.metrics))s=e.metrics.map(e=>AS(e));else if(null!=e.metrics){s={};for(const t in e.metrics)s[t]=AS(e.metrics[t])}this.compile({loss:n,metrics:s,optimizer:t})}save(e,t){var n=this;return bp(function*(){if("string"==typeof e){const t=vy.getSaveHandlers(e);if(0===t.length)throw new kS(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new kS(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new kS("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield hy(n.getNamedWeights(t)),r={modelTopology:n.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.6.0",convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=n.optimizer){r.trainingConfig=n.getTrainingConfig();const e="optimizer",{data:t,specs:a}=yield hy(yield n.optimizer.getWeights(),e);s.specs.push(...a),s.data=gy([s.data,t])}return null!=n.userDefinedMetadata&&(n$(n.userDefinedMetadata,n.name,!0),r.userDefinedMetadata=n.userDefinedMetadata),r.weightData=s.data,r.weightSpecs=s.specs,e.save(r)})()}setUserDefinedMetadata(e){n$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}B$.className="Model",xv(B$);class q$ extends B${}function U$(){return(U$=bp(function*(e,t){if(null==t&&(t={}),"string"==typeof e){const n=wy(e,t);if(0===n.length)n.push(nv(e,t));else if(n.length>1)throw new kS(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return H$(e,void 0,t)})).apply(this,arguments)}function H$(e,t,n){return G$.apply(this,arguments)}function G$(){return(G$=bp(function*(e,t,n){if(null==n&&(n={}),null==e.load)throw new kS("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=yield e.load();let r=s.modelTopology;null!=r.model_config&&(r=r.model_config);const a=null==n.strict||n.strict,i=null!=s.weightData&&null!=s.weightSpecs&&a,o=MN(u$(r),t,i),u=s.trainingConfig;if(null!=u&&o.loadTrainingConfig(u),null!=s.userDefinedMetadata&&o.setUserDefinedMetadata(s.userDefinedMetadata),null!=s.weightData){if(null==s.weightSpecs)throw new kS("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=K$(s.weightData,s.weightSpecs);o.loadWeights(e,a),null!=o.optimizer&&t.length>0&&(yield o.optimizer.setWeights(t)),_v(e),_v(t.map(e=>e.tensor))}return o})).apply(this,arguments)}function K$(e,t){const n=function(e,t){const n={};let s,r=0;for(const a of t){const t=a.name,i=a.dtype,o=a.shape,u=Np(o);let l;if("quantization"in a){const n=a.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${a.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${a.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==i)throw new Error(`Weight ${a.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)}const o=cy[n.dtype],c=e.slice(r,r+u*o),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===i)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++)l[e]=h[e]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===s&&(s=yy()),l=s(h)}else{if("int32"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(h.length);for(let e=0;e<h.length;e++)l[e]=Math.round(h[e]*n.scale+n.min)}r+=u*o}else if("string"===i){const t=Np(a.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(r,r+4))[0];r+=4;const n=new Uint8Array(e.slice(r,r+t));l.push(n),r+=t}}else{const s=cy[i],a=e.slice(r,r+u*s);if("float32"===i)l=new Float32Array(a);else if("int32"===i)l=new Int32Array(a);else if("bool"===i)l=new Uint8Array(a);else{if("complex64"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);{l=new Float32Array(a);const e=new Float32Array(l.length/2),s=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],s[t]=l[2*t+1];const r=ly(e,o,"float32"),i=ly(s,o,"float32");n[t]=oy(r,i),r.dispose(),i.dispose()}}r+=u*s}"complex64"!==i&&(n[t]=ly(l,o,i))}return n}(e,t),s={},r=[];return t.forEach(e=>{"optimizer"===e.group?r.push({name:e.name,tensor:n[e.name]}):s[e.name]=n[e.name]}),{modelWeights:s,optimizerWeights:r}}q$.className="Functional",xv(q$);class X$ extends B${constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:oN("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new kS(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof X$||e instanceof B$;let n;if(t){if(n=e,1!==n.outputs.length)throw new kS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new kS("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new kS("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new kS("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new IN({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new kS(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new kS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=kN(this.outputs[0])}this.inboundNodes=[],new vN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:_S(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(hN(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new B$({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new xS("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}evaluateDataset(e,t){var n=this;return bp(function*(){if(!n.built)throw new xS("The model needs to be compiled before being used.");return n.model.evaluateDataset(e,t)})()}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,t,n={}){var s=this;return bp(function*(){if(!s.built)throw new xS("The model needs to be compiled before being used.");return s.model.fit(e,t,n)})()}fitDataset(e,t){var n=this;return bp(function*(){if(!n.built)throw new xS("The model needs to be compiled before being used.");return n.model.fitDataset(e,t)})()}trainOnBatch(e,t){var n=this;return bp(function*(){return n.model.trainOnBatch(e,t)})()}static fromConfig(e,t,n={},s=!1){let r,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new kS("Legacy serialization format not supported yet.");r=t}else Cp(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof X$))throw new IS(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const o of r){const e=MN(o,void 0,s);s&&e.setFastWeightInitDuringBuild(!0),i.add(e)}return i}set stopTraining(e){if(null==this.model)throw new kS("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new kS("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function Y$(e,t){return null==t&&(t={}),function(e,t){return U$.apply(this,arguments)}(e,t)}X$.className="Sequential",xv(X$);class Z$ extends vv{getConfig(){return{}}}class J$ extends Z${apply(e,t=1){return function(e,t=1){if(1!==t)throw new IS(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return yw(e)}(e,t)}}J$.className="elu",xv(J$);class Q$ extends Z${apply(e){return bx(e)}}Q$.className="selu",xv(Q$);class eT extends Z${apply(e){return mx(e)}}eT.className="relu",xv(eT);class tT extends Z${apply(e){return Cv(()=>Uw(6,mx(e)))}}tT.className="relu6",xv(tT);class nT extends Z${apply(e){return e}}nT.className="linear",xv(nT);class sT extends Z${apply(e){return vx(e)}}sT.className="sigmoid",xv(sT);class rT extends Z${apply(e){return function(e){return Cv(()=>{const t=Rv(.5,Ow(.2,e));return nw(t,0,1)})}(e)}}rT.className="hardSigmoid",xv(rT);class aT extends Z${apply(e){return Sx(e)}}aT.className="softplus",xv(aT);class iT extends Z${apply(e){return function(e){return Cv(()=>bw(e,Av(e).add(1)))}(e)}}iT.className="softsign",xv(iT);class oT extends Z${apply(e){return Ax(e)}}oT.className="tanh",xv(oT);class uT extends Z${apply(e,t=-1){return _x(e,t)}}uT.className="softmax",xv(uT);class lT extends Z${apply(e,t=-1){return Lw(e,t)}}lT.className="logSoftmax",xv(lT);class cT extends Z${apply(e,t=1){return Cv(()=>vx(e.mul(t)).mul(e))}}cT.className="swish",xv(cT);class hT extends Z${apply(e){return Cv(()=>Ow(e,Ax(Sx(e))))}}function dT(e){return e.getClassName()}function pT(e,t={}){return OS(e,wv.getMap().classNameMap,t,"activation")}function fT(e){if(null==e)return pT({className:"linear",config:{}});if("string"==typeof e){const t={};return t.className=e,t.config={},pT(t)}return e instanceof Z$?e:pT(e)}hT.className="mish",xv(hT);class mT extends vv{}class gT extends mT{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Cv(()=>{let t=ax([1]);return this.hasL1&&(t=Rv(t,zw(Ow(this.l1,Av(e))))),this.hasL2&&(t=Rv(t,zw(Ow(this.l2,AE(e))))),t.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}gT.className="L1L2",xv(gT);const bT={l1l2:"L1L2"};function yT(e){return FS(e)}function vT(e,t={}){return OS(e,wv.getMap().classNameMap,t,"regularizer")}function wT(e){return null==e?null:"string"==typeof e?vT({className:e in bT?bT[e]:e,config:{}}):e instanceof mT?e:vT(e)}class xT extends xN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=cN(e);let n=mx(e);return null!=this.maxValue&&(n=nw(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}xT.className="ReLU",xv(xT);class kT extends xN{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=cN(e);return Aw(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}kT.className="LeakyReLU",xv(kT);class IT extends xN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=sN(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wT(e.alphaRegularizer),this.alphaConstraint=QS(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new kS(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=hN(e)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let s=1;s<e.length;++s)n[s]=e[s];this.inputSpec=[new gN({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=cN(e),lx(e,this.alpha.read())}getConfig(){const e={alphaInitializer:nN(this.alphaInitializer),alphaRegularizer:yT(this.alphaRegularizer),alphaConstraint:ZS(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}IT.className="PReLU",xv(IT);class CT extends xN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new IS(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=cN(e);return yw(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}CT.className="ELU",xv(CT);class _T extends xN{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=cN(e);return n.mul(wE(n.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}_T.className="ThresholdedReLU",xv(_T);class ST extends xN{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new uT).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=cN(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function ET(e,t,n){if("number"==typeof e)return _S(e,t);if(e.length!==t)throw new kS(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const a=e[r];if((s=a)!==parseInt(s.toString(),10))throw new kS(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var s}function NT(e,t,n,s,r=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(r-1))+1,Math.floor((a+s-1)/s)}function $T(e,t,n,s){if(null==e)return null;if("valid"===s)e=e*t+yE([n-t,0]);else{if("same"!==s)throw new kS(`Unsupport padding mode: ${s}.`);e*=t}return e}function TT(e,t){return Cv(()=>(iE(t),"channelsFirst"===t?Px(e,[0,2,3,1]):e))}function AT(e,t){return Cv(()=>(iE(t),"channelsFirst"===t?Px(e,[0,2,3,4,1]):e))}function RT(e,t,n,s=[1,1],r="valid",a,i,o=null){return Cv(()=>{if(null==a&&(a="channelsLast"),iE(a),3!==e.rank&&4!==e.rank)throw new kS(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new kS(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=TT(e,a);if("causal"===r)throw new IS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=ek({x:u,filter:t,strides:s,pad:"same"===r?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(u=Px(u,[0,3,1,2])),u})}ST.className="Softmax",xv(ST);class FT extends xN{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",FT.verifyArgs(t),this.rank=e,VS(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new IS(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ET(t.kernelSize,e,"kernelSize"),this.strides=ET(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,oE(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,iE(this.dataFormat),this.activation=fT(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=sN(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=QS(t.biasConstraint),this.biasRegularizer=wT(t.biasRegularizer),this.activityRegularizer=wT(t.activityRegularizer),this.dilationRate=ET(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new kS(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new kS(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new kS(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(SS("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!jS(e.kernelSize,"number",1,3))throw new kS(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:dT(this.activation),useBias:this.useBias,biasInitializer:nN(this.biasInitializer),biasRegularizer:yT(this.biasRegularizer),activityRegularizer:yT(this.activityRegularizer),biasConstraint:ZS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class DT extends FT{constructor(e,t){super(e,t),this.kernel=null,DT.verifyArgs(t),this.filters=t.filters,VS(this.filters,"filters"),this.kernelInitializer=sN(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=QS(t.kernelConstraint),this.kernelRegularizer=wT(t.kernelRegularizer)}build(e){e=hN(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Cv(()=>{let t;e=cN(e);const n=null==this.bias?null:this.bias.read(),s=BS(this.activation.getClassName());if(null!=s&&2===this.rank)t=RT(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)t=function(e,t,n,s=1,r="valid",a,i=1){return Cv(()=>{if(null==a&&(a="channelsLast"),iE(a),3!==e.shape.length)throw new kS(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new kS(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new kS(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===a&&(e=Px(e,[0,2,1])),"causal"===r)throw new IS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=lw(e,t,s,"same"===r?"same":"valid","NWC",i);return null!=n&&(o=FE(o,n)),o})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=RT(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new IS("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,s=[1,1,1],r="valid",a,i){return Cv(()=>{if(null==a&&(a="channelsLast"),iE(a),4!==e.rank&&5!==e.rank)throw new kS(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new kS(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=AT(e,a);if("causal"===r)throw new IS("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=dw(o,t,s,"same"===r?"same":"valid","NDHWC",i),null!=n&&(o=FE(o,n)),"channelsFirst"===a&&(o=Px(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=hN(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=NT(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let s=[e[0]];return"channelsLast"===this.dataFormat?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:nN(this.kernelInitializer),kernelRegularizer:yT(this.kernelRegularizer),kernelConstraint:ZS(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new kS(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class OT extends DT{constructor(e){super(2,e),OT.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jS(e.kernelSize,"number",1,2))throw new kS(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}OT.className="Conv2D",xv(OT);class MT extends DT{constructor(e){super(3,e),MT.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new kS(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}MT.className="Conv3D",xv(MT);class zT extends OT{constructor(e){if(super(e),this.inputSpec=[new gN({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new kS(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=hN(e)).length)throw new kS("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gN({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Cv(()=>{let t=cN(e);if(4!==t.shape.length)throw new kS(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const a=n[r],i=this.kernelSize[1],o=this.strides[1],u=[n[0],$T(n[s],this.strides[0],this.kernelSize[0],this.padding),$T(a,o,i,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Px(t,[0,2,3,1]));let l=hw(t,this.kernel.read(),u,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(l=Px(l,[0,3,1,2])),null!=this.bias&&(l=FE(l,this.bias.read(),this.dataFormat)),null!=this.activation&&(l=this.activation.apply(l)),l})}computeOutputShape(e){const t=(e=hN(e)).slice();let n,s,r;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3):(n=3,s=1,r=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[s]=$T(t[s],o,a,this.padding),t[r]=$T(t[r],u,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}zT.className="Conv2DTranspose",xv(zT);class LT extends MT{constructor(e){if(super(e),this.inputSpec=[new gN({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new kS(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=hN(e)).length)throw new kS("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gN({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Cv(()=>{let t=cN(e);if(5!==t.shape.length)throw new kS(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let s,r,a;"channelsFirst"===this.dataFormat?(a=2,s=3,r=4):(a=1,s=2,r=3);const i=n[s],o=n[r],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[1],h=this.strides[2],d=[n[0],$T(n[a],this.strides[0],this.kernelSize[0],this.padding),$T(i,c,u,this.padding),$T(o,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Px(t,[0,2,3,4,1]));let p=fw(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Px(p,[0,4,1,2,3])),null!==this.bias&&(p=FE(p,this.bias.read(),this.dataFormat)),null!==this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){const t=(e=hN(e)).slice();let n,s,r,a;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3,a=4):(n=4,s=1,r=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[s]=$T(t[s],l,i,this.padding),t[r]=$T(t[r],c,o,this.padding),t[a]=$T(t[a],h,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}LT.className="Conv3DTranspose",xv(LT);class PT extends DT{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new kS("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new kS("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new kS(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=sN(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wT(t.depthwiseRegularizer),this.depthwiseConstraint=QS(t.depthwiseConstraint),this.pointwiseInitializer=sN(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wT(t.pointwiseRegularizer),this.pointwiseConstraint=QS(t.pointwiseConstraint)}build(e){if((e=hN(e)).length<this.rank+2)throw new kS(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new kS(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],s=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new gN({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Cv(()=>{let t;if(e=cN(e),1===this.rank)throw new IS("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Px(e,[0,2,3,1])),t=yx(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=FE(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Px(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=nN(this.depthwiseInitializer),e.pointwiseInitializer=nN(this.pointwiseInitializer),e.depthwiseRegularizer=yT(this.depthwiseRegularizer),e.pointwiseRegularizer=yT(this.pointwiseRegularizer),e.depthwiseConstraint=ZS(this.depthwiseConstraint),e.pointwiseConstraint=ZS(this.pointwiseConstraint),e}}PT.className="SeparableConv";class jT extends PT{constructor(e){super(2,e)}}jT.className="SeparableConv2D",xv(jT);class VT extends DT{constructor(e){super(1,e),VT.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jS(e.kernelSize,"number",1,1))throw new kS(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}VT.className="Conv1D",xv(VT);class WT extends xN{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Cv(()=>{if(e=cN(e),"channelsLast"===this.dataFormat){const t=CE(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return CE(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=CE(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return CE(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}WT.className="Cropping2D",xv(WT);class BT extends xN{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,iE(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,PS(tE,"InterpolationFormat",this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,t){return Cv(()=>{let t=cN(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Px(t,[0,2,3,1]);const e=this.size[0]*n[2],s=this.size[1]*n[3],r="nearest"===this.interpolation?t.resizeNearestNeighbor([e,s]):t.resizeBilinear([e,s]);return Px(r,[0,3,1,2])}{const e=this.size[0]*n[1],s=this.size[1]*n[2];return"nearest"===this.interpolation?t.resizeNearestNeighbor([e,s]):t.resizeBilinear([e,s])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}BT.className="UpSampling2D",xv(BT);class qT extends FT{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=sN(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=QS(e.depthwiseConstraint),this.depthwiseRegularizer=wT(e.depthwiseRegularizer)}build(e){if((e=hN(e)).length<4)throw new kS(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new kS(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Cv(()=>{let t=function(e,t,n=[1,1],s="valid",r,a){return Cv(()=>{null==r&&(r="channelsLast"),iE(r);let i=TT(e,r);if(4!==e.rank)throw new kS(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new kS(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=mw(i,t,n,"same"===s?"same":"valid","NHWC",a),"channelsFirst"===r&&(i=Px(i,[0,3,1,2])),i})}(e=cN(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=FE(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=hN(e);const t="channelsFirst"===this.dataFormat?e[3]:e[2],n="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=NT("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),r=NT(t,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],n,s,r]:[e[0],s,r,n]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=nN(this.depthwiseInitializer),e.depthwiseRegularizer=yT(this.depthwiseRegularizer),e.depthwiseConstraint=ZS(this.depthwiseRegularizer),e}}function UT(e,t,n,s){if(Array.isArray(e)){if(null!=t||null!=n)throw new kS("When inputs is an array, neither initialState or constants should be provided");null!=s&&(n=e.slice(e.length-s,e.length),e=e.slice(0,e.length-s)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function HT(e,t,n,s=!1,r,a,i=!1,o=!1){return Cv(()=>{const u=t.shape.length;if(u<3)throw new kS(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(vE(2,u));if(t=Px(t,l),null!=a)throw new IS("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=r.asType("bool").asType("float32")).rank===u-1&&(r=Iw(r,-1)),r=Px(r,l)),s&&(t=gx(t,0),null!=r&&(r=gx(r,0)));const c=[];let h,d=n;const p=t.shape[0],f=Ox(t);let m,g;null!=r&&(m=Ox(r));for(let t=0;t<p;++t){const n=f[t],s=Cv(()=>e(n,d));if(null==r)h=s[0],d=s[1];else{const e=Cv(()=>{const e=m[t],n=ox(e).sub(e);return{output:s[0].mul(e).add(d[0].mul(n)),newStates:d.map((t,r)=>s[1][r].mul(e).add(t.mul(n)))}});h=e.output,d=e.newStates}o&&c.push(h)}return o&&(g=Tx(c,1)),[h,g,d]})}qT.className="DepthwiseConv2D",xv(qT);class GT extends xN{constructor(e){let t;if(super(e),null==e.cell)throw new kS("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new tA({cells:e.cell}):e.cell,null==t.stateSize)throw new kS("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new gN({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?vE(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){uN(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let s;if(s=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const s of t)n.push([e[0],s]);return[s].concat(n)}return s}computeMask(e,t){return Cv(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new IS("Constants support is not implemented in RNN yet.");uN(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new gN({shape:[t,null,...n]});const s=[e[0]].concat(e.slice(2));let r;if(this.cell.build(s),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!$p(this.stateSpec.map(e=>e.shape[e.shape.length-1]),r))throw new kS(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(e=>new gN({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Cv(()=>{if(!this.stateful)throw new wS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new kS("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>ax([n,e])):[ax([n,this.cell.stateSize])];else if(null==e)_v(this.states_),null!=this.keptStates&&(_v(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>ax([n,e])):this.states_[0]=ax([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new kS(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):_v(this.states_);for(let t=0;t<this.states_.length;++t){const s=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,r];if(!$p(s.shape,a))throw new kS(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[t]=s}}this.states_=this.states_.map(e=>Sv(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,s=null==t?null:t.constants;null==t&&(t={});const r=UT(e,n,s,this.numConstants);e=r.inputs,n=r.initialState,s=r.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new gN({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=s&&(t.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof bN){const n=[e].concat(a),s=this.inputSpec.concat(i),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return Cv(()=>{const n=null==t?null:t.mask,s=null==t?null:t.training;let r=null==t?null:t.initialState;e=cN(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==a)throw new kS(`RNN Layer has ${a} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:s},o=HT((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),u=o[0],l=o[1],c=o[2];this.stateful&&this.resetStates(c,s);const h=this.returnSequences?l:u;return this.returnState?[h].concat(c):h})}getInitialState(e){return Cv(()=>{let t=ax(e.shape);return t=zw(t,[1,2]),t=xE(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?EE(t,[1,e]):t):this.cell.stateSize>1?[EE(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===GT.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){const s=MN(t.cell,n);return new e(Object.assign(t,{cell:s}))}}GT.className="RNN",xv(GT);class KT extends xN{}class XT extends KT{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,VS(this.units,"units"),this.activation=fT(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wT(e.kernelRegularizer),this.recurrentRegularizer=wT(e.recurrentRegularizer),this.biasRegularizer=wT(e.biasRegularizer),this.kernelConstraint=QS(e.kernelConstraint),this.recurrentConstraint=QS(e.recurrentConstraint),this.biasConstraint=QS(e.biasConstraint),this.dropout=bE([1,yE([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bE([1,yE([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=hN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Cv(()=>{if(2!==(e=e).length)throw new kS(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const s=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nA({ones:()=>ox(e),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nA({ones:()=>ox(n),rate:this.recurrentDropout,training:s}));const a=this.dropoutMask,i=this.recurrentDropoutMask;r=$E(null!=a?Ow(e,a):e,this.kernel.read()),null!=this.bias&&(r=FE(r,this.bias.read())),null!=i&&(n=Ow(n,i));let o=Rv(r,$E(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:dT(this.activation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),recurrentInitializer:nN(this.recurrentInitializer),biasInitializer:nN(this.biasInitializer),kernelRegularizer:yT(this.kernelRegularizer),recurrentRegularizer:yT(this.recurrentRegularizer),biasRegularizer:yT(this.biasRegularizer),activityRegularizer:yT(this.activityRegularizer),kernelConstraint:ZS(this.kernelConstraint),recurrentConstraint:ZS(this.recurrentConstraint),biasConstraint:ZS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}XT.className="SimpleRNNCell",xv(XT);class YT extends GT{constructor(e){e.cell=new XT(e),super(e)}call(e,t){return Cv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return new e(t)}}YT.className="SimpleRNN",xv(YT);class ZT extends KT{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new kS("GRUCell does not support reset_after parameter set to true.");this.units=e.units,VS(this.units,"units"),this.activation=fT(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fT(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wT(e.kernelRegularizer),this.recurrentRegularizer=wT(e.recurrentRegularizer),this.biasRegularizer=wT(e.biasRegularizer),this.kernelConstraint=QS(e.kernelConstraint),this.recurrentConstraint=QS(e.recurrentConstraint),this.biasConstraint=QS(e.biasConstraint),this.dropout=bE([1,yE([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bE([1,yE([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=hN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Cv(()=>{if(2!==(e=e).length)throw new kS(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nA({ones:()=>ox(e),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nA({ones:()=>ox(s),rate:this.recurrentDropout,training:n,count:3}));const r=this.recurrentDropoutMask;let a,i,o;0<this.dropout&&this.dropout<1&&(e=Ow(e,this.dropoutMask[0]));let u=$E(e,this.kernel.read());this.useBias&&(u=FE(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Ow(s,r[0]));const l=this.recurrentKernel.read(),[c,h]=Ex(l,[2*this.units,this.units],l.rank-1),d=$E(s,c),[p,f,m]=Ex(u,3,u.rank-1),[g,b]=Ex(d,2,d.rank-1);a=this.recurrentActivation.apply(Rv(p,g)),i=this.recurrentActivation.apply(Rv(f,b));const y=$E(Ow(i,s),h);o=this.activation.apply(Rv(m,y));const v=Rv(Ow(a,s),Ow(Rv(1,nx(a)),o));return[v,v]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:dT(this.activation),recurrentActivation:dT(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),recurrentInitializer:nN(this.recurrentInitializer),biasInitializer:nN(this.biasInitializer),kernelRegularizer:yT(this.kernelRegularizer),recurrentRegularizer:yT(this.recurrentRegularizer),biasRegularizer:yT(this.biasRegularizer),activityRegularizer:yT(this.activityRegularizer),kernelConstraint:ZS(this.kernelConstraint),recurrentConstraint:ZS(this.recurrentConstraint),biasConstraint:ZS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}ZT.className="GRUCell",xv(ZT);class JT extends GT{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ZT(e),super(e)}call(e,t){return Cv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}JT.className="GRU",xv(JT);class QT extends KT{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,VS(this.units,"units"),this.activation=fT(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fT(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wT(e.kernelRegularizer),this.recurrentRegularizer=wT(e.recurrentRegularizer),this.biasRegularizer=wT(e.biasRegularizer),this.kernelConstraint=QS(e.kernelConstraint),this.recurrentConstraint=QS(e.recurrentConstraint),this.biasConstraint=QS(e.biasConstraint),this.dropout=bE([1,yE([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bE([1,yE([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n;if(e=hN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,s=this.units;n=new((t=class extends LE{apply(t,n){const r=e.apply([s]),a=(new jE).apply([s]),i=e.apply([2*s]);return SE(SE(r,a),i)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Cv(()=>{const n=null!=t.training&&t.training;if(3!==(e=e).length)throw new kS(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nA({ones:()=>ox(e),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nA({ones:()=>ox(s),rate:this.recurrentDropout,training:n,count:4}));const a=this.recurrentDropoutMask;let i,o,u,l;0<this.dropout&&this.dropout<1&&(e=Ow(e,this.dropoutMask[0]));let c=$E(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Ow(s,a[0])),c=Rv(c,$E(s,this.recurrentKernel.read())),this.useBias&&(c=FE(c,this.bias.read()));const[h,d,p,f]=Ex(c,4,c.rank-1);i=this.recurrentActivation.apply(h),o=this.recurrentActivation.apply(d),u=Rv(Ow(o,r),Ow(i,this.activation.apply(p))),l=this.recurrentActivation.apply(f);const m=Ow(l,this.activation.apply(u));return[m,m,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:dT(this.activation),recurrentActivation:dT(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),recurrentInitializer:nN(this.recurrentInitializer),biasInitializer:nN(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:yT(this.kernelRegularizer),recurrentRegularizer:yT(this.recurrentRegularizer),biasRegularizer:yT(this.biasRegularizer),activityRegularizer:yT(this.activityRegularizer),kernelConstraint:ZS(this.kernelConstraint),recurrentConstraint:ZS(this.recurrentConstraint),biasConstraint:ZS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}QT.className="LSTMCell",xv(QT);class eA extends GT{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new QT(e),super(e)}call(e,t){return Cv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}eA.className="LSTM",xv(eA);class tA extends KT{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Cv(()=>{let n=(e=e).slice(1);const s=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?s.push(n.splice(0,e.stateSize.length)):s.push(n.splice(0,1));s.reverse();const r=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=s[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),r.push(a.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[a[0]].concat(n)})}build(e){let t;uN(e)&&(e=e[0]),e=e,this.cells.forEach((n,s)=>{cE(`RNNCell_${s}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}));return Object.assign({},e,{cells:t})}static fromConfig(e,t,n={}){const s=[];for(const r of t.cells)s.push(MN(r,n));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return fN(e)}setWeights(e){const t=[];for(const n of this.cells){const s=e.splice(n.weights.length);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}mN(t)}}function nA(e){const{ones:t,rate:n,training:s=!1,count:r=1}=e,a=()=>DE(t(),n),i=()=>OE(a,t,s);return!r||r<=1?Sv(i().clone()):Array(r).fill(void 0).map(i).map(e=>Sv(e.clone()))}var sA,rA,aA,iA;tA.className="StackedRNNCells",xv(tA);class oA extends GT{constructor(e){if(e.unroll)throw new IS("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new IS("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new gN({ndim:5})]}call(e,t){return Cv(()=>{if(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new kS("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Cv(()=>{const{stateSize:t}=this.cell,n=this.computeSingleOutputShape(e.shape),s=ax([n[0],...n.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){Cv(()=>{if(!this.stateful)throw new wS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,s=this.computeSingleOutputShape(n),r=[s[0],...s.slice(2)];if(null==n[0])throw new kS("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>ax(r)):[ax(r)];else if(null==e)_v(this.states_),null!=this.keptStates&&(_v(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ax(r)):this.states_[0]=ax(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new kS(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_v(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],s=r;if(!$p(n.shape,s))throw new kS(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>Sv(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:s,padding:r,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,u=e[o?4:3],l=NT(e[o?3:2],s[0],r,a[0],i[0]),c=NT(u,s[1],r,a[1],i[1]);return[...e.slice(0,2),...o?[n,l,c]:[l,c,n]]}}oA.className="ConvRNN2D";class uA extends QT{constructor(e){const{filters:t,kernelSize:n,strides:s,padding:r,dataFormat:a,dilationRate:i}=e;super(Object.assign({},e,{units:t})),this.filters=t,VS(this.filters,"filters"),this.kernelSize=ET(n,2,"kernelSize"),this.kernelSize.forEach(e=>VS(e,"kernelSize")),this.strides=ET(s||1,2,"strides"),this.strides.forEach(e=>VS(e,"strides")),this.padding=r||"valid",oE(this.padding),this.dataFormat=a||"channelsLast",iE(this.dataFormat),this.dilationRate=ET(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>VS(e,"dilationRate"))}build(e){var t;e=hN(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new kS(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=this.kernelSize.concat([e[n],4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,s=this.filters;e=new((t=class extends LE{apply(e,t){return _E([n.apply([s]),ix([s]),n.apply([2*s])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Cv(()=>{if(3!==e.length)throw new kS(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,s=e[0],r=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nA({ones:()=>ox(s),rate:this.dropout,training:n,count:4}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?Ow(t[n],e):e;let u=o(s,i,0),l=o(s,i,1),c=o(s,i,2),h=o(s,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nA({ones:()=>ox(r),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=o(r,d,0),f=o(r,d,1),m=o(r,d,2),g=o(r,d,3);const[b,y,v,w]=Ex(this.kernel.read(),4,3),[x,k,I,C]=this.useBias?Ex(this.bias.read(),4):[null,null,null,null];u=this.inputConv(u,b,x,this.padding),l=this.inputConv(l,y,k,this.padding),c=this.inputConv(c,v,I,this.padding),h=this.inputConv(h,w,C,this.padding);const[_,S,E,N]=Ex(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,_),f=this.recurrentConv(f,S),m=this.recurrentConv(m,E),g=this.recurrentConv(g,N);const $=this.recurrentActivation.apply(Rv(u,p)),T=this.recurrentActivation.apply(Rv(l,f)),A=Rv(Ow(T,a),Ow($,this.activation.apply(Rv(c,m)))),R=Ow(this.recurrentActivation.apply(Rv(h,g)),this.activation.apply(A));return[R,R,A]})}getConfig(){const e=function(e,t){var n={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.indexOf(s)<0&&(n[s]=e[s]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(e);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(e,s[r])&&(n[s[r]]=e[s[r]])}return n}(super.getConfig(),["units"]);return Object.assign({},e,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(e,t,n,s){const r=uw(e,t,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?FE(r,n,this.dataFormat):r}recurrentConv(e,t){return uw(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}uA.className="ConvLSTM2DCell",xv(uA);class lA extends oA{constructor(e){const t=new uA(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}lA.className="ConvLSTM2D",xv(lA);class cA extends xN{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(null==this.noiseShape[s]?t[s]:this.noiseShape[s]);return n}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);const n=cN(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,s=this.getNoiseShape(n);return OE(()=>DE(n,this.rate,s,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}cA.className="Dropout",xv(cA);class hA extends cA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}hA.className="SpatialDropout1D",xv(hA);class dA extends xN{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,VS(this.units,"units"),this.activation=fT(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=QS(e.kernelConstraint),this.biasConstraint=QS(e.biasConstraint),this.kernelRegularizer=wT(e.kernelRegularizer),this.biasRegularizer=wT(e.biasRegularizer),this.activityRegularizer=wT(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=hN(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=hN(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);const n=cN(e),s=BS(this.activation.getClassName());let r;return null!=s?r=$E(n,this.kernel.read(),s,this.bias?this.bias.read():null):(r=$E(n,this.kernel.read()),null!=this.bias&&(r=FE(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:dT(this.activation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),biasInitializer:nN(this.biasInitializer),kernelRegularizer:yT(this.kernelRegularizer),biasRegularizer:yT(this.biasRegularizer),activityRegularizer:yT(this.activityRegularizer),kernelConstraint:ZS(this.kernelConstraint),biasConstraint:ZS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}dA.className="Dense",xv(dA);class pA extends xN{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=hN(e);for(const t of e.slice(1))if(null==t)throw new kS(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],mE(e,1)]}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);let n=cN(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=n.transpose(e)}return function(e){if(e.rank<=1)throw new kS(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],mE(e.shape,1)];return e.reshape(t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}pA.className="Flatten",xv(pA);class fA extends xN{constructor(e){super(e),this.supportsMasking=!0,this.activation=fT(e.activation)}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);const n=cN(e);return this.activation.apply(n)})}getConfig(){const e={activation:dT(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}fA.className="Activation",xv(fA);class mA extends xN{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Cv(()=>{return e=cN(e),t=e,n=this.n,Cv(()=>{if(2!==t.shape.length)throw new kS(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return EE(xE(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}mA.className="RepeatVector",xv(mA);class gA extends xN{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",s=t.slice();let r=1,a=null;for(let o=0;o<s.length;++o){const e=s[o];if(this.isUnknown(e)){if(null!==a)throw new kS("Can only specifiy one unknown dimension.");a=o}else r*=e}const i=mE(e);if(null!==a){if(0===r||i%r!=0)throw new kS(n);s[a]=i/r}else if(i!==r)throw new kS(n);return s}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);const n=cN(e),s=n.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return n.reshape(r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}gA.className="Reshape",xv(gA);class bA extends xN{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=vE(1,e.dims.length+1);if(!$p(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new gN({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=hN(e)).slice();return this.dims.forEach((n,s)=>{t[s+1]=e[n]}),t}call(e,t){return Px(cN(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}bA.className="Permute",xv(bA);class yA extends xN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=cN(e);return Dv(sx(n,this.maskValue),-1)}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);const n=cN(e),s=Dv(sx(n,this.maskValue),-1,!0);return n.mul(s.asType(n.dtype))})}}yA.className="Masking",xv(yA);class vA extends xN{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=null==e.inputLength?[t,null]:[t].concat($S(e.inputLength))}this.inputDim=e.inputDim,VS(this.inputDim,"inputDim"),this.outputDim=e.outputDim,VS(this.outputDim,"outputDim"),this.embeddingsInitializer=sN(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wT(e.embeddingsRegularizer),this.activityRegularizer=wT(e.activityRegularizer),this.embeddingsConstraint=QS(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Cv(()=>this.maskZero?(e=cN(e),sx(e,Lx(e))):null)}computeOutputShape(e){if(e=hN(e),null==this.inputLength)return[...e,this.outputDim];const t=$S(this.inputLength);if(t.length!==e.length-1)throw new kS(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let s=0;s<t.length;++s){const r=t[s],a=e[s+1];if(null!=r&&null!=a&&r!==a)throw new kS(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==r&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);let n=cN(e);return"int32"!==n.dtype&&(n=wE(n,"int32")),TE(this.embeddings.read(),n.as1D()).reshape(hN(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:nN(this.embeddingsInitializer),embeddingsRegularizer:yT(this.embeddingsRegularizer),activityRegularizer:yT(this.activityRegularizer),embeddingsConstraint:ZS(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}vA.className="Embedding",xv(vA);class wA extends xN{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new IS}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const r=e[e.length-t.length+s],a=t[s];if(null==r||null==a||r<0||a<0)n.push(null);else if(1===r)n.push(a);else if(1===a)n.push(r);else{if(r!==a)throw new kS("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[hN(e)]),(e=e).length<2)throw new kS(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=zS(t),t.length>1)throw new kS(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const s=e.map(e=>e.length);this.reshapeRequired=-1!==e.indexOf(null)||1!==zS(s).length}call(e,t){return Cv(()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const s=yE(n);for(let n of e){const e=n.rank;for(let t=0;t<s-e;++t)n=xE(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,s=e[0],r=e.slice(1).concat([s]);let i=a.reshape([s].concat(mE(e.slice(1))));i=Px(i,[1,0]),i=i.reshape(r),t.push(i),n=!0}else if(e>1){const s=vE(1,e).concat([0]);t.push(Px(a,s)),n=!0}else t.push(a)}let s=this.mergeFunction(t);const r=s.rank;if(n)if(null==r){const e=s.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));s=Px(s.reshape([-1,t]),[1,0]).reshape(n)}else if(r>1){const e=[r-1].concat(vE(0,r-1));s=Px(s,e)}return s}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const n=null==e[s]?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const s of e)null!=s&&null!==s[0]&&n.push(s[0]);return n=zS(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Cv(()=>{if(null==t)return null;if(!Array.isArray(t))throw new kS("`mask` should be an Array");if(!Array.isArray(e))throw new kS("`inputs` should be an Array");if(t.length!==e.length)throw new kS(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:Iw(e,0)))[0];for(let e=1;e<t.length-1;++e)n=Pw(n,t[e]);return n})}}class xA extends wA{constructor(e){super(e)}mergeFunction(e){return Cv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Rv(t,e[n]);return t})}}xA.className="Add",xv(xA);class kA extends wA{constructor(e){super(e)}mergeFunction(e){return Cv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ow(t,e[n]);return t})}}kA.className="Multiply",xv(kA);class IA extends wA{constructor(e){super(e)}mergeFunction(e){return Cv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Rv(t,e[n]);return Ow(1/e.length,t)})}}IA.className="Average",xv(IA);class CA extends wA{constructor(e){super(e)}mergeFunction(e){return Cv(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ww(t,e[n]);return t})}}CA.className="Maximum",xv(CA);class _A extends wA{constructor(e){super(e)}mergeFunction(e){return Cv(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Uw(t,e[n]);return t})}}_A.className="Minimum",xv(_A);class SA extends wA{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new kS("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const s of e)if(null!=s){t=!1;break}if(t)return;const n=[];for(let s=0;s<e.length;++s){const t=e[s].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if($p(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new kS("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Cv(()=>_E(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new kS("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[s]||null==r[s]){n[s]=null;break}n[s]+=r[s]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new kS("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new kS("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new kS(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Cv(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const s=[];for(let a=0;a<e.length;++a)s.push(null==t[a]?ox(e[a]).asType("bool"):t[a].rank<e[a].rank?Iw(t[a],-1):t[a]);const r=sw(s,this.axis);return Fv(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function EA(e,t){for(;e<0;)e+=t;return e}SA.className="Concatenate",xv(SA);class NA extends wA{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Cp(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new IS("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,n);if(t[s[0]]!==n[s[1]])throw new kS(`Dimension incompatibility: ${t[s[0]]} !== ${n[s[1]]}`)}mergeFunction(e){if(2!==e.length)throw new kS(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],s=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>EA(t,e[n].shape.length)):[EA(this.axes,n.shape.length),EA(this.axes,s.shape.length)],this.normalize&&(n=zN(n,t[0]),s=zN(s,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new IS("batchDot is not implemented for tensors of 4D or higher rank yet");if(Cp(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),Cp(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new IS("batchDot is not implemented for complex64-type Tensors yet.");const s=e.shape.length,r=t.shape.length;null==n&&(n=[s-1,r-2]);const a=n;return Cv(()=>{let n,i;if(s>r){n=s-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else if(r>s){n=r-s;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else n=0;if(i=2===e.shape.length&&2===t.shape.length?a[0]===a[1]?e.mul(t).sum(a[0]):e.transpose([1,0]).mul(t).sum(a[1]):e.matMul(t,a[0]!==e.shape.length-1,a[1]===t.shape.length-1),n>0){let e;e=s>r?s+r-3:s-1;const t=[];for(let s=e;s<e+n;++s)t.push(s);i=i.squeeze(t)}return 1===i.shape.length&&(i=i.expandDims(1)),i})}(n,s,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[EA(this.axes,e.length),EA(this.axes,t.length)],n}computeOutputShape(e){Cp(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new IS("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,n);t.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}NA.className="Dot",xv(NA);class $A extends xN{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);const n=cN(e);return OE(()=>NE(n.shape,0,this.stddev).add(n),()=>n,t.training||!1)})}}$A.className="GaussianNoise",xv($A);class TA extends xN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Cv(()=>{this.invokeCallHook(e,t);const n=cN(e);return this.rate>0&&this.rate<1?OE(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return n.mul(NE(n.shape,1,e))},()=>n,t.training||!1):n})}}TA.className="GaussianDropout",xv(TA);class AA extends xN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||cN(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Cv(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return OE(()=>{const t=cN(e),s=-1.7580993408473766;let r=Tw(fx(n),this.rate);r=wE(r,"float32");const a=((1-this.rate)*(1+this.rate*s**2))**-.5,i=-a*s*this.rate;return t.mul(r).add(r.add(-1).mul(s)).mul(a).add(i)},()=>cN(e),t.training||!1)}return e})}}function RA(e,t,n,s,r,a=.001){let i;if(2===e.rank)i=Qv(e,t,n,s,r,a);else if(3===e.rank)i=ew(e,t,n,s,r,a);else{if(4!==e.rank)throw new IS(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=tw(e,t,n,s,r,a)}return i}AA.className="AlphaDropout",xv(AA);class FA extends xN{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=sN(e.betaInitializer||"zeros"),this.gammaInitializer=sN(e.gammaInitializer||"ones"),this.movingMeanInitializer=sN(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=sN(e.movingVarianceInitializer||"ones"),this.betaConstraint=QS(e.betaConstraint),this.gammaConstraint=QS(e.gammaConstraint),this.betaRegularizer=wT(e.betaRegularizer),this.gammaRegularizer=wT(e.gammaRegularizer)}build(e){e=hN(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new kS(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new gN({ndim:e.length,axes:{[t]:n}})];const s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Cv(()=>{const n=null!=t.training&&t.training,s=cN(e),r=s.shape,a=r.length,i=vE(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const u=_S(1,a);u[o]=r[o];const l=i.slice();l.sort();const c=!$p(l,vE(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=this.movingMean.read().reshape(u),t=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,r=this.scale?this.gamma.read().reshape(u):null;return RA(s,e,t,n,r,this.epsilon)}return RA(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(e,t,n,s,r=.001){return $p(s.slice().sort(),vE(0,e.rank-1))?function(e,t,n,s,r=.001){return Cv(()=>{const a=tx(e,s),i=a.mean,o=a.variance;return[RA(e,i,o,n,t,r),i,o]})}(e,t,n,s,r):function(e,t,n,s,r=.001){return Cv(()=>{const a=tx(e,s),i=a.mean,o=a.variance,u=[];for(const t of vE(0,e.rank))-1!==s.indexOf(t)?u.push(1):u.push(e.shape[t]);const l=i.reshape(u),c=o.reshape(u),h=null==t?null:t.reshape(u),d=null==n?null:n.reshape(u);return[RA(e,l,c,d,h,r),i,o]})}(e,t,n,s,r)}(s,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{Cv(()=>{const s=1-n,r=e.read(),a=r.sub(t).mul(s);e.write(r.sub(a))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nN(this.betaInitializer),gammaInitializer:nN(this.gammaInitializer),movingMeanInitializer:nN(this.movingMeanInitializer),movingVarianceInitializer:nN(this.movingVarianceInitializer),betaRegularizer:yT(this.betaRegularizer),gammaRegularizer:yT(this.gammaRegularizer),betaConstraint:ZS(this.betaConstraint),gammaConstraint:ZS(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}FA.className="BatchNormalization",xv(FA);class DA extends xN{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=sN(e.betaInitializer||"zeros"),this.gammaInitializer=sN(e.gammaInitializer||"ones"),this.betaRegularizer=wT(e.betaRegularizer),this.gammaRegularizer=wT(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=hN(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==zS(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(t=>e[t]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,t){const n=cN(e),s=n.shape,r=s.length;return Cv(()=>{let{mean:e,variance:t}=tx(n,this.axis,!0);const a=_S(1,r);for(const n of this.axis)a[n]=s[n];const i=e=>null!=e&&e.shape.length!==r&&this.axis!==[r-1]?e.reshape(a):e;let o=i(this.gamma.read()),u=i(this.beta.read());const l=[],c=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(l.push(s[n]),c.push(1)):(l.push(1),c.push(s[n]));return e=e.tile(l),t=t.tile(l),o=o.tile(c),u=u.tile(c),RA(n,e,t,u,o,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nN(this.betaInitializer),gammaInitializer:nN(this.gammaInitializer),betaRegularizer:yT(this.betaRegularizer),gammaRegularizer:yT(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}DA.className="LayerNormalization",xv(DA);class OA extends xN{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new kS(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new kS(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new kS(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new gN({ndim:4})]}computeOutputShape(e){let t,n;return e=hN(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Cv(()=>{return t=cN(e),n=this.padding,s=this.dataFormat,Cv(()=>{if(4!==t.rank)throw new kS(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new kS("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s="channelsLast"),"channelsLast"!==s&&"channelsFirst"!==s)throw new kS(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===s?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],ux(t,e)});var t,n,s})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function MA(e,t,n,s,r,a){return Cv(()=>{let i;iE(r),uE(a),oE(s),null==n&&(n=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),e=TT(e,r);const o="same"===s?"same":"valid";return i="max"===a?jw(e,t,n,o):Yv(e,t,n,o),"channelsFirst"===r&&(i=Px(i,[0,3,1,2])),i})}function zA(e,t,n,s,r,a){return Cv(()=>{let i;iE(r),uE(a),oE(s),null==n&&(n=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),e=AT(e,r);const o="same"===s?"same":"valid";return i="max"===a?Vw(e,t,n,o):Zv(e,t,n,o),"channelsFirst"===r&&(i=Px(i,[0,4,1,2,3])),i})}OA.className="ZeroPadding2D",xv(OA);class LA extends xN{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new kS(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(VS(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new kS(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}VS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,oE(this.padding),this.inputSpec=[new gN({ndim:3})]}computeOutputShape(e){const t=NT((e=hN(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Cv(()=>{this.invokeCallHook(e,t),e=xE(cN(e),2);const n=this.poolingFunction(cN(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return $x(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class PA extends LA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return iE(r),oE(s),MA(e,t,n,s,r,"max")}}PA.className="MaxPooling1D",xv(PA);class jA extends LA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return iE(r),oE(s),MA(e,t,n,s,r,"avg")}}jA.className="AveragePooling1D",xv(jA);class VA extends xN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new kS(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];VS(this.poolSize,"poolSize"),VS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,iE(this.dataFormat),oE(this.padding),this.inputSpec=[new gN({ndim:4})]}computeOutputShape(e){e=hN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=NT(t,this.poolSize[0],this.padding,this.strides[0]),n=NT(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Cv(()=>(this.invokeCallHook(e,t),this.poolingFunction(cN(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class WA extends VA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return iE(r),oE(s),MA(e,t,n,s,r,"max")}}WA.className="MaxPooling2D",xv(WA);class BA extends VA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return iE(r),oE(s),MA(e,t,n,s,r,"avg")}}BA.className="AveragePooling2D",xv(BA);class qA extends xN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new kS(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];VS(this.poolSize,"poolSize"),VS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,iE(this.dataFormat),oE(this.padding),this.inputSpec=[new gN({ndim:5})]}computeOutputShape(e){e=hN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[4]:e[3];return t=NT(t,this.poolSize[0],this.padding,this.strides[0]),n=NT(n,this.poolSize[1],this.padding,this.strides[1]),s=NT(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,s]:[e[0],t,n,s,e[4]]}call(e,t){return Cv(()=>(this.invokeCallHook(e,t),this.poolingFunction(cN(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class UA extends qA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return iE(r),oE(s),zA(e,t,n,s,r,"max")}}UA.className="MaxPooling3D",xv(UA);class HA extends qA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return iE(r),oE(s),zA(e,t,n,s,r,"avg")}}HA.className="AveragePooling3D",xv(HA);class GA extends xN{constructor(e){super(e),this.inputSpec=[new gN({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new IS}}class KA extends GA{constructor(e){super(e||{})}call(e,t){return Cv(()=>{const t=cN(e);return Bw(t,1)})}}KA.className="GlobalAveragePooling1D",xv(KA);class XA extends GA{constructor(e){super(e||{})}call(e,t){return Cv(()=>{const t=cN(e);return Dw(t,1)})}}XA.className="GlobalMaxPooling1D",xv(XA);class YA extends xN{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,iE(this.dataFormat),this.inputSpec=[new gN({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new IS}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ZA extends YA{call(e,t){return Cv(()=>{const t=cN(e);return Bw(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}ZA.className="GlobalAveragePooling2D",xv(ZA);class JA extends YA{call(e,t){return Cv(()=>{const t=cN(e);return Dw(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}JA.className="GlobalMaxPooling2D",xv(JA);class QA extends xN{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const s=MN(t.layer,n);delete t.layer;const r={layer:s};return Object.assign(r,t),new e(r)}}class eR extends QA{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=hN(e)).length<3)throw new kS(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=hN(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t);return[n[0],e[1]].concat(n.slice(1))}call(e,t){return Cv(()=>HT((e,n)=>[cN(this.layer.call(e,t)),[]],e=cN(e),[],!1,null,null,!1,!0)[1])}}eR.className="TimeDistributed",xv(eR);class tR extends QA{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=MN(n),t.goBackwards=!0!==t.goBackwards;const s={};if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=MN(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,PS(rE,"BidirectionalMergeMode",this.mergeMode),e.weights)throw new IS("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,t)),this.backwardLayer.setWeights(e.slice(t))}computeOutputShape(e){let t,n,s,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(s=r.slice(1),t=r[0]):t=r[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(s).concat(s.slice()):[t].concat(s).concat(s.slice()):NS(n)}apply(e,t){let n=null==t?null:t.initialState,s=null==t?null:t.constants;null==t&&(t={});const r=UT(e,n,s,this.numConstants);if(e=r.inputs,n=r.initialState,s=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==s)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new kS("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const s=n.map(e=>new gN({shape:e.shape}));this.forwardLayer.stateSpec=s.slice(0,e/2),this.backwardLayer.stateSpec=s.slice(e/2),i.push(...s)}if(null!=s)throw new IS("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof bN;for(const u of a)if(u instanceof bN!==o)throw new kS("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),s=this.inputSpec.concat(i),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return Cv(()=>{const n=t.initialState;let s,r,a,i;if(null==n)s=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=gx(r,1)),"concat"===this.mergeMode?i=_E([s,r]):"sum"===this.mergeMode?i=Rv(s,r):"ave"===this.mergeMode?i=Ow(.5,Rv(s,r)):"mul"===this.mergeMode?i=Ow(s,r):null==this.mergeMode&&(i=[s,r]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){cE(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),cE(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=MN(t.layer);if(delete t.layer,null!=t.numConstants)throw new IS("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=n,new e(s)}}function nR(e){return new dA(e)}function sR(e,t,n=new Map,s=new Set){if(null==e)return null;if(s.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(oR(e)){const r=Array.isArray(e)?[]:{};s.add(e);for(const a in e){const i=sR(e[a],t,n,s);r[a]=i}return s.delete(e),r}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,r.value),r.value}function rR(e,t=iR){return aR(e,t)}function aR(e,t,n=new Set){const s=e[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(oR(s)){const r=Array.isArray(s)?[]:{};n.add(s);for(const a in s){const s=aR(e.map(e=>e[a]),t,n);r[a]=s}return n.delete(s),r}throw new Error(`Can't recurse into non-iterable type: ${s}`)}return r.value}function iR(e){return null===e?null:oR(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function oR(e){return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof Ab))}function uR(e){return sR(e,lR)}function lR(e){return e instanceof Ab?{value:e.clone(),recurse:!1}:oR(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}tR.className="Bidirectional",xv(tR),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(sA||(sA={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(rA||(rA={}));class cR{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class hR extends cR{constructor(){super(hR.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let s=0;s<n;s++)t[s]=this.get(this.wrap(this.begin+s));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}hR.INITIAL_CAPACITY=32;class dR{toArray(){var e=this;return bp(function*(){const t=[];let n=yield e.next();for(;!n.done;)t.push(n.value),n=yield e.next();return t})()}toArrayForTest(){var e=this;return bp(function*(){const t=e.prefetch(100),n=[];let s=yield t.next();for(;!s.done;)n.push(s.value),s=yield t.next();return n})()}resolveFully(){var e=this;return bp(function*(){let t=yield e.next();for(;!t.done;)t=yield e.next()})()}resolveWhile(e){var t=this;return bp(function*(){let n=yield t.next(),s=e(n.value);for(;!n.done&&s;)n=yield t.next(),s=e(n.value)})()}handleErrors(e){return new xR(this,e)}filter(e){return new vR(this,e)}map(e){return new wR(this,e)}mapAsync(e){return new kR(this,e)}serialMapAsync(e){return new kR(this,e).serial()}flatmap(e){return new CR(this,e)}forEachAsync(e){var t=this;return bp(function*(){return t.map(e).resolveFully()})()}serialForEach(e){var t=this;return bp(function*(){return t.serialMapAsync(e).resolveWhile(e=>!0===e)})()}rowMajorBatch(e,t=!0){return new yR(this,e,t)}columnMajorBatch(e,t=!0,n=iR){return this.rowMajorBatch(e,t).map(e=>rR(e,n))}concatenate(e,t){return new _R(new pR([this,e]),t)}take(e){return e<0||null==e?this:new bR(this,e)}skip(e){return e<0||null==e?this:new gR(this,e)}prefetch(e){return new SR(this,e)}shuffle(e,t){return new ER(this,e,t)}serial(){return new mR(this)}}class pR extends dR{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var e=this;return bp(function*(){if(e.trav>=e.items.length)return{value:null,done:!0};const t=e.items[e.trav];return e.trav++,{value:uR(t),done:!1}})()}}class fR extends dR{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}next(){var e=this;return bp(function*(){try{return e.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}})()}}class mR extends dR{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){return e.upstream.next()})()}}class gR extends dR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;e.count++<e.maxCount;){const t=yield e.upstream.next();if(t.done)return t;_v(t.value)}return e.upstream.next()})()}}class bR extends dR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var e=this;return bp(function*(){return e.count++>=e.maxCount?{value:null,done:!0}:e.upstream.next()})()}}class yR extends dR{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){const t=[];for(;t.length<e.batchSize;){const n=yield e.upstream.next();if(n.done)return e.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}})()}}class vR extends dR{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;;){const t=yield e.upstream.next();if(t.done||e.predicate(t.value))return t;_v(t.value)}})()}}class wR extends dR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}next(){var e=this;return bp(function*(){const t=yield e.upstream.next();if(t.done)return{value:null,done:!0};const n=qb(t.value),s=e.transform(t.value),r=qb(s);for(const e of n)Bb(e,r)||e.dispose();return{value:s,done:!1}})()}}class xR extends dR{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;;)try{return yield e.upstream.next()}catch(t){if(!e.handler(t))return{value:null,done:!0}}})()}}class kR extends dR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var e=this;return bp(function*(){const t=yield e.upstream.next();if(t.done)return{value:null,done:!0};const n=qb(t.value),s=yield e.transform(t.value),r=qb(s);for(const e of n)Bb(e,r)||e.dispose();return{value:s,done:!1}})()}}class IR extends dR{constructor(){super(),this.outputQueue=new hR,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;0===e.outputQueue.length();)if(!(yield e.pump()))return{value:null,done:!0};return{value:e.outputQueue.shift(),done:!1}})()}}class CR extends IR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var e=this;return bp(function*(){const t=yield e.upstream.next();if(t.done)return!1;const n=qb(t.value),s=e.transform(t.value),r=qb(s);e.outputQueue.pushAll(s);for(const e of n)Bb(e,r)||e.dispose();return!0})()}}class _R extends dR{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var e=this;return bp(function*(){return e.lastRead=e.readFromChain(e.lastRead),e.lastRead})()}readFromChain(e){var t=this;return bp(function*(){if(yield e,null==t.iterator){const e=yield t.moreIterators.next();if(e.done)return{value:null,done:!0};t.iterator=e.value,null!=t.baseErrorHandler&&(t.iterator=t.iterator.handleErrors(t.baseErrorHandler))}const n=yield t.iterator.next();return n.done?(t.iterator=null,t.readFromChain(e)):n})()}}(iA=aA||(aA={}))[iA.FAIL=0]="FAIL",iA[iA.SHORTEST=1]="SHORTEST",iA[iA.LONGEST=2]="LONGEST";class SR extends dR{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new cR(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class ER extends SR{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=cx.alea(n||gb().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var e=this;return bp(function*(){for(e.upstreamExhausted||e.refill();!e.buffer.isEmpty();){const t=e.chooseIndex(),n=yield e.buffer.shuffleExcise(t);if(!n.done)return e.refill(),n;e.upstreamExhausted=!0}return{value:null,done:!0}})()}}class NR{constructor(){this.size=null}batch(e,t=!0){const n=this;let s;return Cp(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),s=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),$R(bp(function*(){return(yield n.iterator()).columnMajorBatch(e,t,TR)}),s)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,$R(bp(function*(){return(yield t.iterator()).concatenate(yield e.iterator())}),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,$R(bp(function*(){return(yield t.iterator()).filter(t=>Cv(()=>e(t)))}),n)}forEachAsync(e){var t=this;return bp(function*(){return(yield t.iterator()).forEachAsync(e)})()}map(e){const t=this;return $R(bp(function*(){return(yield t.iterator()).map(t=>Cv(()=>e(t)))}),this.size)}mapAsync(e){const t=this;return $R(bp(function*(){return(yield t.iterator()).mapAsync(e)}),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return $R(bp(function*(){return(yield t.iterator()).prefetch(e)}),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,$R(bp(function*(){return n=(s=bp(function*(){return{value:yield t.iterator(),done:!1}}),new fR(s)).take(e),new _R(n,undefined);var n,s}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,$R(bp(function*(){return(yield t.iterator()).skip(e)}),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,r=cx.alea(t||gb().toString());return $R(bp(function*(){let t=r.int32();return n&&(t+=r.int32()),(yield s.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,$R(bp(function*(){return(yield t.iterator()).take(e)}),n)}toArray(){var e=this;return bp(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArray()})()}toArrayForTest(){var e=this;return bp(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArrayForTest()})()}}function $R(e,t=null){return new class extends NR{constructor(){super(...arguments),this.size=t}iterator(){return bp(function*(){return e()})()}}}function TR(e){return null===e?null:null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof Ab||jp(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ab?Tx(e):ly(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}function AR(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Cp("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}NR.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const RR=PI;class FR extends vp{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new yp(this,kv())}nextDataId(){return FR.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,af().get("IS_NODE")&&gI("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:n,refCount:1}),s}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&Wp(n[0])){const r=n.map(e=>bb(e));s=this.write(r,e,t)}else s=this.write(n,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,s,r){this.data.set(e,{values:t,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}read(e){var t=this;return bp(function*(){return t.readSync(e)})()}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?yI(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>yb(e))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return qy(e.shape,e.dtype,n)}makeOutput(e,t,n){const s=this.write(e,t,n);return kv().makeTensorFromDataId(s,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return bp(function*(){const t=gb();return e(),{kernelMs:gb()-t}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){AR([e],"where");const t=this.readSync(e.dataId);return RR(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function DR(e,t,n){return({inputs:s,attrs:r,backend:a})=>{const{x:i}=s;if(AR(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=a,u=o.data.get(i.dataId).values,l=Np(i.shape),c=n||i.dtype,h=Lp(c,l);for(let e=0;e<l;++e)h[e]=t(u[e],r);return o.makeTensorInfo(i.shape,c,h)}}function OR(e,t,n){return({inputs:s,attrs:r,backend:a})=>{const{x:i}=s;if(AR(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=a,u=o.data.get(i.dataId).values,l=n||i.dtype,c=t(u,l,r);return o.makeTensorInfo(i.shape,l,c)}}FR.nextDataId=0,Ev("cpu",()=>new FR,1);const MR=DR(am,e=>e>=0?e:Math.exp(e)-1),zR={kernelName:am,backendName:"cpu",kernelFunc:MR};function LR(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const PR={kernelName:km,backendName:"cpu",kernelFunc:LR};function jR(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:a}=s;AR([r],"leakyRelu");const i=Np(r.shape),o=n.data.get(r.dataId).values,u=zp("float32",i);for(let l=0;l<o.length;l++)u[l]=o[l]<0?a*o[l]:o[l];return n.makeTensorInfo(r.shape,"float32",u)}const VR={kernelName:Nm,backendName:"cpu",kernelFunc:jR};function WR(e){return(t,n,s,r,a)=>{const i=xw(t,n),o=i.length,u=Gp(i),l=zp(a,Np(i)),c=t.length,h=n.length,d=Gp(t),p=Gp(n),f=vw(t,i),m=vw(n,i);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(s[g%s.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=tf(g,o,u),n=t.slice(-c);f.forEach(e=>n[e]=0);const a=ef(n,c,d),i=t.slice(-h);m.forEach(e=>i[e]=0);const b=ef(i,h,p);l[g]=e(s[a],r[b])}return[l,i]}}const BR=WR((e,t)=>e<0?t*e:e);function qR(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t;AR([s,r],"prelu");const a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,[o,u]=BR(s.shape,r.shape,a,i,s.dtype);return n.makeTensorInfo(u,s.dtype,o)}const UR={kernelName:lg,backendName:"cpu",kernelFunc:qR},HR=DR(fg,e=>Math.max(0,e)),GR={kernelName:fg,backendName:"cpu",kernelFunc:HR},KR=DR(wg,e=>Math.min(Math.max(0,e),6)),XR={kernelName:wg,backendName:"cpu",kernelFunc:KR},YR=DR(Ag,e=>1/(1+Math.exp(-e))),ZR={kernelName:Ag,backendName:"cpu",kernelFunc:YR};function JR(e,t,n,s,r){if("linear"===n)return LR({inputs:{x:t},backend:e});if("relu"===n)return HR({inputs:{x:t},backend:e});if("elu"===n)return MR({inputs:{x:t},backend:e});if("relu6"===n)return KR({inputs:{x:t},backend:e});if("prelu"===n)return qR({inputs:{x:t,alpha:s},backend:e});if("leakyrelu"===n)return jR({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return YR({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function QR(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,a=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(s.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",a),imag:n.makeTensorInfo(r.shape,"float32",i)},o}const eF={kernelName:Of,backendName:"cpu",kernelFunc:QR};function tF(e,t,n="float32"){if("complex64"===n)return QR({inputs:{real:tF(e,t,"float32"),imag:tF(e,t,"float32")},backend:e});const s=Zp(Np(t),n);return e.makeTensorInfo(t,n,s)}function nF(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.real,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const sF={kernelName:dg,backendName:"cpu",kernelFunc:nF};function rF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dtype:a}=s;if("complex64"===a){if("complex64"===r.dtype)return LR({inputs:{x:r},backend:n});const e=tF(n,r.shape,r.dtype),t=rF({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),s=QR({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),s}if("complex64"===r.dtype){const e=nF({inputs:{input:r},backend:n}),t=rF({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Pp(r.dtype,a)){const e=LR({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}if("int32"===a){const e=n.data.get(r.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(r.shape,"int32",t)}if("bool"===a){const e=n.data.get(r.dataId).values,t=mb([0],r.dtype),[s,a]=WR((e,t)=>e!==t?1:0)(r.shape,[],e,t,"bool");return n.makeTensorInfo(a,"bool",s)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const aF={kernelName:Rf,backendName:"cpu",kernelFunc:rF};function iF(e,t,n,s){return null==n?({inputs:n,backend:r})=>{const{a:a,b:i}=n,o=r;AR([a,i],e);const u=o.data.get(a.dataId).values,l=o.data.get(i.dataId).values,c=s||a.dtype,[h,d]=t(a.shape,i.shape,u,l,c);return o.makeTensorInfo(d,c,h)}:({inputs:e,backend:r})=>{const{a:a,b:i}=e,o=r;if("complex64"===a.dtype||"complex64"===i.dtype){const e=rF({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),s=t.complexTensorInfos.imag,r=o.data.get(t.complexTensorInfos.real.dataId).values,u=o.data.get(s.dataId).values,l=rF({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),c=o.data.get(l.dataId),h=c.complexTensorInfos.imag,d=o.data.get(c.complexTensorInfos.real.dataId).values,p=o.data.get(h.dataId).values,[f,m,g]=n(a.shape,i.shape,r,u,d,p),b=o.makeTensorInfo(g,"float32",f),y=o.makeTensorInfo(g,"float32",m),v=QR({inputs:{real:b,imag:y},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(l),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(y),v}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,r=s||a.dtype,[u,l]=t(a.shape,i.shape,e,n,r);return o.makeTensorInfo(l,r,u)}}}function oF(e){return(t,n,s,r,a,i)=>{const o=xw(t,n),u=Np(o),l=o.length,c=Gp(o),h=zp("float32",u),d=zp("float32",u),p=vw(t,o),f=vw(n,o),m=yI(s,r),g=yI(a,i),b=t.length,y=Gp(t),v=n.length,w=Gp(n);if(p.length+f.length===0)for(let x=0;x<h.length;x++){const t=x%m.length,n=x%g.length,s=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[x]=s.real,d[x]=s.imag}else for(let x=0;x<h.length;x++){const t=tf(x,l,c),n=t.slice(-b);p.forEach(e=>n[e]=0);const s=ef(n,b,y),r=t.slice(-v);f.forEach(e=>r[e]=0);const a=ef(r,v,w),i=e(m[2*s],m[2*s+1],g[2*a],g[2*a+1]);h[x]=i.real,d[x]=i.imag}return[h,d,o]}}const uF=WR((e,t)=>e+t),lF=oF((e,t,n,s)=>({real:e+n,imag:t+s})),cF=iF(ff,uF,lF),hF={kernelName:ff,backendName:"cpu",kernelFunc:cF};function dF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:a}=s,i=Np(r.shape),o=Dp(a,i),u=Np(o);Cp(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.imag;l.complexTensorInfos.real.shape=o,e.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const pF={kernelName:mg,backendName:"cpu",kernelFunc:dF};function fF(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a}=t,{transposeA:i,transposeB:o}=s;AR([r,a],"matMul");const u=r.shape.length,l=a.shape.length,c=i?r.shape[u-2]:r.shape[u-1],h=o?a.shape[l-1]:a.shape[l-2],d=i?r.shape[u-1]:r.shape[u-2],p=o?a.shape[l-2]:a.shape[l-1],f=r.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Np(f),b=Np(m);Cp(u>=2&&l>=2&&(g===b||1===g||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);const y=(g>b?r.shape.slice(0,-2):a.shape.slice(0,-2)).concat([d,p]);Cp(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const v=o?[b,p,h]:[b,h,p],w=dF({inputs:{x:r},backend:n,attrs:{shape:i?[g,c,d]:[g,d,c]}}),x=dF({inputs:{x:a},backend:n,attrs:{shape:v}}),k=i?w.shape[1]:w.shape[2],I=i?w.shape[2]:w.shape[1],C=o?x.shape[1]:x.shape[2],_=Math.max(g,b),S=n.data.get(w.dataId).values,E=n.data.get(x.dataId).values,N=Gp(w.shape),$=Gp(x.shape),[T,A,R]=i?[N[0],1,N[1]]:[N[0],N[1],1],[F,D,O]=o?[1,$[1],$[0]]:[$[1],1,$[0]],M=I*C,z=qy([_,I,C],w.dtype),L=z.values,P=n.blockSize;for(let j=0;j<_;j++)for(let e=0;e<I;e+=P)for(let t=0;t<C;t+=P)for(let n=0;n<k;n+=P){const s=Math.min(e+P,I),r=Math.min(t+P,C),a=Math.min(n+P,k);for(let i=e;i<s;i++)for(let e=t;e<r;e++){let t=0;for(let s=n;s<a;s++){const n=Math.min(j,g-1)*T,r=Math.min(j,b-1)*O;t+=S[n+i*A+s*R]*E[s*F+e*D+r]}L[j*M+(i*C+e)]+=t}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(y,z.dtype,z.values)}const mF={kernelName:$f,backendName:"cpu",kernelFunc:fF},gF={kernelName:sb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=s;let d,p,f;const m=[];d=fF({inputs:{a:r,b:a},attrs:{transposeA:u,transposeB:l},backend:n}),i&&(p=cF({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),c&&(f=JR(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function bF(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const yF={kernelName:hf,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;AR(t,"abs");let s=new Float32Array(Np(t.shape));return s=bF(n.data.get(t.dataId).values),n.makeOutput(s,t.shape,"float32")}},vF=DR(df,e=>Math.acos(e)),wF={kernelName:df,backendName:"cpu",kernelFunc:vF},xF=DR(pf,e=>Math.acosh(e)),kF={kernelName:pf,backendName:"cpu",kernelFunc:xF},IF={kernelName:mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,s=t;AR(t,"addN");const r=s.map(e=>n.data.get(e.dataId).values),a=qy(s[0].shape,s[0].dtype),i=a.values;for(let o=0;o<s.length;o++){const e=r[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function CF(e,t,n,s,r){const a=t.length,i=Np(t),o=Gp(t),u=Gp(r),l=zp(n,Np(r));for(let c=0;c<i;++c){const t=tf(c,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[s[e]];l[ef(n,a,u)]=e[c]}return l}function _F(e){const{inputs:t,attrs:n,backend:s}=e,{x:r}=t,{perm:a}=n;AR(r,"transpose");const i=new Array(r.shape.length);for(let u=0;u<i.length;u++)i[u]=r.shape[a[u]];const o=CF(s.data.get(r.dataId).values,r.shape,r.dtype,a,i);return{dataId:s.write(o,i,r.dtype),shape:i,dtype:r.dtype}}const SF={kernelName:Yg,backendName:"cpu",kernelFunc:_F},EF={kernelName:gf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s;AR(r,"all");const o=Op(a,r.shape);let u=o;const l=Zw(u,r.shape.length);let c=r;null!=l&&(c=_F({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Qw(u.length,r.shape.length)),Yw("all",u,c.shape.length);const[h,d]=Kw(c.shape,u),p=Np(d),f=Zp(Np(h),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const s=m[e+n];t=t&&s}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=dF({inputs:{x:g},backend:n,attrs:{shape:Xw(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},NF={kernelName:bf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s;AR(r,"any");const o=Op(a,r.shape);let u=o;const l=Zw(u,r.shape.length);let c=r;null!=l&&(c=_F({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Qw(u.length,r.shape.length)),Yw("any",u,c.shape.length);const[h,d]=Kw(c.shape,u),p=Np(d),f=Zp(Np(h),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const s=m[e+n];t=t||s}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=dF({inputs:{x:g},backend:n,attrs:{shape:Xw(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},$F={kernelName:yf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;AR(r,"argMax");let i=Op(a,r.shape);const o=Zw(i,r.shape.length);let u=r;const l=[];null!=o&&(u=_F({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Qw(i.length,u.shape.length)),i=[i[0]],Yw("argMax",i,u.shape.length);const[c,h]=Kw(u.shape,i),d=Zp(Np(c),"int32"),p=Np(h),f=n.data.get(u.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let s=0;s<p;++s){const r=f[e+s];r>t&&(t=r,n=s)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},TF={kernelName:vf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;AR(r,"argMin");let i=Op(a,r.shape);const o=Zw(i,r.shape.length);let u=r;const l=[];null!=o&&(u=_F({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Qw(i.length,u.shape.length)),i=[i[0]],Yw("argMin",i,u.shape.length);const[c,h]=Kw(u.shape,i),d=Zp(Np(c),"int32"),p=Np(h),f=n.data.get(u.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let s=0;s<p;++s){const r=f[e+s];r<t&&(t=r,n=s)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},AF=DR(wf,e=>Math.asin(e)),RF={kernelName:wf,backendName:"cpu",kernelFunc:AF},FF=DR(xf,e=>Math.asinh(e)),DF={kernelName:xf,backendName:"cpu",kernelFunc:FF},OF=DR(kf,e=>Math.atan(e)),MF={kernelName:kf,backendName:"cpu",kernelFunc:OF},zF=WR((e,t)=>Math.atan2(e,t)),LF=iF(Cf,zF),PF={kernelName:Cf,backendName:"cpu",kernelFunc:LF},jF=DR(If,e=>Math.atanh(e)),VF={kernelName:If,backendName:"cpu",kernelFunc:jF};function WF(e,t,n,s,r,a){const i=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=qy(r.outShape,n),g=m.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let w=0;w<r.batchSize;++w){const t=w*b,n=w*s[0];for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){const w=b*i-d,x=Math.max(0,w),k=Math.min(r.inHeight,c+w),I=t+b*y;for(let t=0;t<r.outWidth;++t){const i=t*o-p,c=Math.max(0,i),d=Math.min(r.inWidth,h+i);let b=f,y=0,w=0;for(let t=x;t<k;t+=u){const r=n+t*s[1];for(let t=c;t<d;t+=l){const n=e[r+t*s[2]+m];"max"===a&&n>b?b=n:"avg"===a&&(y+=n,w++)}if(isNaN(b))break}g[I+t*v+m]="avg"===a?y/w:b}}}return m}function BF(e,t,n,s,r=!1,a=!1){const i=qy(s.outShape,"int32"),o=s.strideHeight,u=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m=qy(t,n,e);for(let g=0;g<s.batchSize;++g)for(let e=0;e<s.inChannels;++e)for(let t=0;t<s.outHeight;++t){const n=t*o-p;let b=n;for(;b<0;)b+=l;const y=Math.min(s.inHeight,h+n);for(let o=0;o<s.outWidth;++o){const h=o*u-f;let p=h;for(;p<0;)p+=c;const v=Math.min(s.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,x=-1;for(let t=b;t<y;t+=l){const i=t-n;for(let n=p;n<v;n+=c){const o=n-h,u=m.get(g,t,n,e);u>w&&(w=u,x=r?a?((g*s.inHeight+t)*s.inWidth+n)*s.inChannels+e:(t*s.inWidth+n)*s.inChannels+e:i*d+o)}}i.set(x,g,t,o,e)}}return i}function qF(e,t,n,s,r,a){const i=r.strideDepth,o=r.strideHeight,u=r.strideWidth,l=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=qy(r.outShape,n),w=v.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],C=r.outShape[4];for(let _=0;_<r.batchSize;++_){const t=_*x,n=_*s[0];for(let v=0;v<r.inChannels;++v)for(let x=0;x<r.outDepth;++x){const _=x*i-m;let S=_;for(;S<0;)S+=l;const E=Math.min(r.inDepth,d+_),N=t+x*k;for(let t=0;t<r.outHeight;++t){const i=t*o-g;let d=i;for(;d<0;)d+=c;const m=Math.min(r.inHeight,p+i),x=N+t*I;for(let t=0;t<r.outWidth;++t){const i=t*u-b;let o=i;for(;o<0;)o+=h;const p=Math.min(r.inWidth,f+i),g=x+t*C;let k=y,I=0,_=0;for(let t=S;t<E;t+=l){const r=n+t*s[1];for(let t=d;t<m;t+=c){const n=r+t*s[2];for(let t=o;t<p;t+=h){const r=e[n+t*s[3]+v];if("max"===a&&r>k?k=r:"avg"===a&&(I+=r,_++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}w[g+v]="avg"===a?I/_:k}}}}return v}const UF={kernelName:_f,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;AR(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;Cp(Gv(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=zv(r.shape,a,i,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))c=LR({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Gp(r.shape),s=WF(e,0,r.dtype,t,l,"avg");c=n.makeTensorInfo(l.outShape,r.dtype,s.values)}return c}},HF={kernelName:Ef,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=s;AR(r,"avgPool3d");const c=Lv(r.shape,a,i,1,o,u,l),h=qF(n.data.get(r.dataId).values,0,r.dtype,Gp(r.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},GF={kernelName:Nf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=s;AR([r,a],"avgPool3DGrad");const c=Lv(a.shape,i,o,1,u,l),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,k=c.effectiveFilterWidth,I=w-1-c.padInfo.front,C=k-1-c.padInfo.left,_=x-1-c.padInfo.top,S=qy(a.shape,"float32"),E=1/(f*m*g),N=n.bufferSync(r);for(let $=0;$<c.batchSize;++$)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=t-I,a=n-_,i=s-C;let o=0;for(let t=0;t<w;t+=b){const n=(r+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<x;t+=y){const s=(a+t)/d;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let t=0;t<k;t+=v){const r=(i+t)/p;r<0||r>=c.outWidth||Math.floor(r)!==r||(o+=N.get($,n,s,r,e))}}}S.set(o*E,$,t,n,s,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},KF={kernelName:Sf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,i=a;AR([r,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=s,c=zv(i.shape,o,u,1,l),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,y=c.effectiveFilterWidth,v=y-1-c.padInfo.left,w=b-1-c.padInfo.top,x=qy(i.shape,"float32"),k=1/(p*f),I=n.data.get(r.dataId).values,C=qy(r.shape,"float32",I);for(let _=0;_<c.batchSize;++_)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const s=t-w,r=n-v;let a=0;for(let t=0;t<b;t+=m){const n=(s+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const s=(r+t)/d;s<0||s>=c.outWidth||Math.floor(s)!==s||(a+=C.get(_,n,s,e))}}x.set(a*k,_,t,n,e)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},XF={kernelName:bm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,scale:a,offset:i,mean:o,variance:u}=t;Cp(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Cp(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Cp(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),AR([r,o,u,a,i],"batchNorm");let{varianceEpsilon:l}=s;null==l&&(l=.001);const c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(u.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,b=p.length,y=d.length,v=h.length;let w=0,x=0,k=0,I=0;for(let C=0;C<c.length;++C)m[C]=f[w++]+(c[C]-h[x++])*p[k++]/Math.sqrt(d[I++]+l),w>=g&&(w=0),x>=v&&(x=0),k>=b&&(k=0),I>=y&&(I=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function YF(e,t,n,s,r){const a=mv(s,t,n),i=Np(n),o=Gp(s);if(a){const n=gv(t,o);return"string"===r?e.slice(n,n+i):e.subarray(n,n+i)}const u=qy(s,r,"string"===r?zI(e):e),l=qy(n,r);for(let c=0;c<l.size;++c){const e=l.indexToLoc(c),n=e.map((e,n)=>e+t[n]);l.set(u.get(...n),...e)}return"string"===r?LI(l.values):l.values}function ZF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,size:i}=s;AR(r,"slice");const[o,u]=bv(r,a,i);sv(r,o,u);const l=YF(n.data.get(r.dataId).values,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,l)}const JF={kernelName:Eg,backendName:"cpu",kernelFunc:ZF},QF={kernelName:Tf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,crops:i}=s;AR([r],"batchToSpaceND");const o=a.reduce((e,t)=>e*t),u=Qk(r.shape,a,o),l=eI(u.length,a.length),c=tI(r.shape,a,o),h=nI(i,a.length),d=sI(c,i,a.length),p=dF({inputs:{x:r},backend:n,attrs:{shape:u}}),f=_F({inputs:{x:p},backend:n,attrs:{perm:l}}),m=dF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=ZF({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function eD(e,t,n,s,r){const a=Np(s),i=Zp(r,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(i[n]+=a>0?t[o]:1)}return i}function tD(e,t,n,s=!1){const r=e.shape[0],a=e.shape[1],i=qy([r,n],t.dtype);for(let o=0;o<r;o++)for(let r=0;r<a;r++){const a=e.get(o,r);if(a<0)throw new Error("Input x must be non-negative!");a>=n||i.set(s?1:t.size>0?i.get(o,a)+t.get(o,r):i.get(o,a)+1,o,a)}return i}const nD={kernelName:Af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:i}=s,o=eD(n.data.get(r.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}};function sD(e){return(t,n,s)=>{const r=zp(n,t.length);for(let a=0;a<t.length;++a)r[a]=e(t[a],s);return r}}const rD=sD(e=>Math.ceil(e)),aD=OR(Ff,rD),iD={kernelName:Ff,backendName:"cpu",kernelFunc:aD},oD=DR(Df,(e,t)=>e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e),uD={kernelName:Df,backendName:"cpu",kernelFunc:oD},lD={kernelName:Mf,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,s=new Float32Array(Np(t.shape)),r=n.data.get(t.dataId),a=r.complexTensorInfos.imag,i=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(a.dataId).values;for(let u=0;u<i.length;u++)s[u]=Math.hypot(i[u],o[u]);return n.makeOutput(s,t.shape,"float32")}};function cD(e,t,n,s){const r=Lp(n,Np(t));if(s&&"string"!==n){let t=0;e.forEach(e=>{const n=Np(e.shape);r.set(e.vals,t),t+=n})}else{let s=0;e.forEach(e=>{const a="string"===n?zI(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+s;for(let t=0;t<e.shape[1];++t)r[o+t]=a[i++]}s+=e.shape[1]})}return r}function hD(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.imag,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const dD={kernelName:Cm,backendName:"cpu",kernelFunc:hD};function pD(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,a=Op(r,t[0].shape)[0];let i=Xk(t.map(e=>e.shape),a);if(0===Np(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>Np(e.shape)>0);if(1===o.length)return LR({inputs:{x:o[0]},backend:n});if(Kk(o.map(e=>e.shape),a),"complex64"===o[0].dtype){const e=o.map(e=>nF({inputs:{input:e},backend:n})),t=o.map(e=>hD({inputs:{input:e},backend:n})),s=pD({inputs:e,backend:n,attrs:{axis:a}}),r=pD({inputs:t,backend:n,attrs:{axis:a}}),i=QR({inputs:{real:s,imag:r},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),i}const u=o.map(e=>{const t=Np(e.shape.slice(a));return dF({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),l=u.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));i=Xk(u.map(e=>e.shape),1);const c=cD(l,i,t[0].dtype,1===u[0].shape[0]),h=Xk(o.map(e=>e.shape),a),d=n.makeTensorInfo(h,t[0].dtype,c);return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}const fD={kernelName:zf,backendName:"cpu",kernelFunc:pD};function mD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=s;AR([r,a],"conv2d");const h=Kv(u),d=Pv(r.shape,a.shape,i,l,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,w=new Eb(d.outShape,r.dtype),x=Gp(r.shape),k=Gp(a.shape),I=x[0],C=v?x[1]:x[2],_=v?x[2]:1,S=v?1:x[1],E=w.strides[0],N=v?w.strides[1]:w.strides[2],$=v?w.strides[2]:1,T=v?1:w.strides[1],A=n.data.get(r.dataId).values,R=n.data.get(a.dataId).values,F=w.values;for(let D=0;D<d.batchSize;++D){const e=D*I,t=D*E;for(let n=0;n<d.outHeight;++n){const s=t+n*N,r=n*d.strideHeight-y;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=d.inHeight)continue;const a=t*k[0],i=e+n*C;for(let e=0;e<d.outWidth;++e){const t=s+e*$,n=e*d.strideWidth-b;for(let e=0;e<f;++e){const s=n+e*g;if(s<0||s>=d.inWidth)continue;const r=i+s*_;let o=a+e*k[1];for(let e=0;e<d.inChannels;++e){const n=A[r+e*S];for(let e=0;e<d.outChannels;++e)F[t+e*T]+=n*R[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,F)}const gD={kernelName:Lf,backendName:"cpu",kernelFunc:mD},bD={kernelName:Pf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=s;AR([r,a],"conv2dBackpropFilter");const h=Kv(u),d=Pv(r.shape,c,i,1,o,l,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,b="channelsLast"===d.dataFormat,y=new Eb(d.filterShape,"float32"),v=d.padInfo.left,w=d.padInfo.top,x=n.data.get(r.dataId).values,k=n.data.get(a.dataId).values,I=new Eb(r.shape,r.dtype,x),C=new Eb(a.shape,a.dtype,k);for(let _=0;_<m;++_){const e=Math.max(0,Math.ceil((w-_)/p)),t=Math.min(d.outHeight,(d.inHeight+w-_)/p);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let a=0;a<d.inChannels;++a)for(let i=0;i<d.outChannels;++i){let o=0;for(let u=0;u<d.batchSize;++u)for(let l=e;l<t;++l){const e=_+l*p-w;for(let t=s;t<r;++t){const s=n+t*f-v;o+=b?I.get(u,e,s,a)*C.get(u,l,t,i):I.get(u,a,e,s)*C.get(u,i,l,t)}}y.set(o,_,n,a,i)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},yD={kernelName:jf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=s;AR([r,a],"conv2dBackpropInput");const h=Gp(a.shape),d=Gp(r.shape);let p=Kv(l);const f=Pv(i,a.shape,o,1,u,c,!1,p),m=new Eb(f.inShape,"float32"),g=m.values,b=n.data.get(r.dataId).values,y=n.data.get(a.dataId).values,[v,w,x]=h,{batchSize:k,filterHeight:I,filterWidth:C,inChannels:_,inHeight:S,inWidth:E,outChannels:N,outHeight:$,outWidth:T,strideHeight:A,strideWidth:R}=f;p=f.dataFormat;const F=I-1-f.padInfo.top,D=C-1-f.padInfo.left,O="channelsLast"===p,M=m.strides[0],z=O?m.strides[1]:m.strides[2],L=O?m.strides[2]:1,P=O?1:m.strides[1],j=d[0],V=O?d[1]:d[2],W=O?d[2]:1,B=O?1:d[1];for(let q=0;q<k;++q)for(let e=0;e<_;++e)for(let t=0;t<S;++t){const n=t-F,s=Math.max(0,Math.ceil(n/A)),r=Math.min($,(I+n)/A);for(let a=0;a<E;++a){const i=a-D,o=Math.max(0,Math.ceil(i/R)),u=Math.min(T,(C+i)/R);let l=0;for(let t=s;t<r;++t){const s=t*A-n;for(let n=o;n<u;++n){const r=j*q+V*t+W*n,a=v*(I-1-s)+w*(C-1-(n*R-i))+x*e;for(let e=0;e<N;++e)l+=b[r+B*e]*y[a+e]}}g[M*q+z*t+L*a+P*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},vD={kernelName:Vf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u}=s;AR([r,a],"conv3d");const l=jv(r.shape,a.shape,i,u,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,v=g.top,w=new Eb(l.outShape,r.dtype),x=n.data.get(r.dataId).values,k=n.data.get(a.dataId).values,I=w.values,C=Gp(r.shape),_=Gp(a.shape);for(let S=0;S<l.batchSize;++S){const e=S*C[0],t=S*w.strides[0];for(let n=0;n<l.outDepth;++n){const s=t+n*w.strides[1],r=n*l.strideDepth-b;for(let t=0;t<c;++t){const n=r+t*p;if(n<0||n>=l.inDepth)continue;const a=t*_[0],i=e+n*C[1];for(let e=0;e<l.outHeight;++e){const t=s+e*w.strides[2],n=e*l.strideHeight-v;for(let e=0;e<h;++e){const s=n+e*f;if(s<0||s>=l.inHeight)continue;const r=a+e*_[1],o=i+s*C[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,s=e*l.strideWidth-y;for(let e=0;e<d;++e){const t=s+e*m;if(t<0||t>=l.inWidth)continue;const a=o+t*l.inChannels;let i=r+e*_[2];for(let e=0;e<l.inChannels;++e){const t=x[a+e];for(let e=0;e<l.outChannels;++e)I[n+e]+=t*k[i+e];i+=l.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},wD={kernelName:Wf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:i,pad:o,filterShape:u}=s;AR([r,a],"conv3dBackpropFilterV2");const l=Gp(r.shape),c=Gp(a.shape),h=jv(r.shape,u,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,b=h.filterWidth,y=new Eb(h.filterShape,"float32"),v=y.values,[w,x,k,I]=y.strides,C=n.data.get(a.dataId).values,[_,S,E,N]=c,$=n.data.get(r.dataId).values,[T,A,R,F]=l,D=h.padInfo.front,O=h.padInfo.left,M=h.padInfo.top;for(let z=0;z<m;++z){const e=Math.max(0,Math.ceil((D-z)/d)),t=Math.min(h.outDepth,(h.inDepth+D-z)/d),n=z*w;for(let s=0;s<g;++s){const r=Math.max(0,Math.ceil((M-s)/p)),a=Math.min(h.outHeight,(h.inHeight+M-s)/p),i=s*x+n;for(let n=0;n<b;++n){const o=Math.max(0,Math.ceil((O-n)/f)),u=Math.min(h.outWidth,(h.inWidth+O-n)/f),l=n*k+i;for(let i=0;i<h.inChannels;++i){const c=i*I+l;for(let l=0;l<h.outChannels;++l){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*T,g=c*_;for(let c=e;c<t;++c){const e=(z+c*d-D)*A+h,t=c*S+g;for(let c=r;c<a;++c){const r=(s+c*p-M)*R+e,a=c*E+t;for(let e=o;e<u;++e)m+=$[(n+e*f-O)*F+r+i]*C[e*N+a+l]}}}v[c+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},xD={kernelName:Bf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{pad:i,strides:o,inputShape:u}=s;AR([r],"conv3dBackpropInputV2");const l=Gp(r.shape),c=Gp(a.shape),h=jv(u,a.shape,o,1,i),d=new Eb(h.inShape,"float32"),p=d.values,[f,m,g,b]=d.strides,y=n.data.get(r.dataId).values,[v,w,x,k]=l,I=n.data.get(a.dataId).values,[C,_,S,E]=c,{batchSize:N,filterDepth:$,filterHeight:T,filterWidth:A,inChannels:R,inDepth:F,inHeight:D,inWidth:O,outChannels:M,outDepth:z,outHeight:L,outWidth:P,strideDepth:j,strideHeight:V,strideWidth:W}=h,B=$-1-h.padInfo.front,q=T-1-h.padInfo.top,U=A-1-h.padInfo.left;for(let H=0;H<N;++H)for(let e=0;e<R;++e)for(let t=0;t<F;++t){const n=t-B,s=Math.max(0,Math.ceil(n/j)),r=Math.min(z,($+n)/j);for(let a=0;a<D;++a){const i=a-q,o=Math.max(0,Math.ceil(i/V)),u=Math.min(L,(T+i)/V);for(let l=0;l<O;++l){const c=l-U,h=Math.max(0,Math.ceil(c/W)),d=Math.min(P,(A+c)/W);let N=0;for(let t=s;t<r;++t){const s=t*j-n;for(let n=o;n<u;++n){const r=n*V-i;for(let a=h;a<d;++a){const i=v*H+w*t+x*n+k*a,o=C*($-1-s)+_*(T-1-r)+S*(A-1-(a*W-c))+E*e;for(let e=0;e<M;++e)N+=y[i+e]*I[o+e]}}}p[f*H+m*t+g*a+b*l+e]=N}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},kD=DR(qf,e=>Math.cos(e)),ID={kernelName:qf,backendName:"cpu",kernelFunc:kD},CD=DR(Uf,e=>Math.cosh(e)),_D={kernelName:Uf,backendName:"cpu",kernelFunc:CD},SD={kernelName:Gf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=s,[c,h,d,p]=r.shape,f=a.shape[0],[m,g]=o,b=qy([f,m,g,p],"float32"),y=n.data.get(a.dataId).values,v=n.data.get(i.dataId).values,w=n.data.get(r.dataId).values,x=Gp(r.shape),k=Gp(b.shape);for(let I=0;I<f;I++){const e=4*I,t=y[e],n=y[e+1],s=y[e+2],r=y[e+3],a=v[I];if(a>=c)continue;const i=m>1?(s-t)*(h-1)/(m-1):0,o=g>1?(r-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(h-1)+c*i:.5*(t+s)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++)b.values[e+t*k[2]+c*k[1]+I*k[0]]=l;else if("bilinear"===u){const t=Math.floor(e),s=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const u=g>1?n*(d-1)+e*o:.5*(n+r)*(d-1);if(u<0||u>d-1){for(let t=0;t<p;t++)b.values[t+e*k[2]+c*k[1]+I*k[0]]=l;continue}const h=Math.floor(u),f=Math.ceil(u),m=u-h;for(let n=0;n<p;n++){let r=n+h*x[2]+t*x[1]+a*x[0];const o=w[r];r=n+f*x[2]+t*x[1]+a*x[0];const u=w[r];r=n+h*x[2]+s*x[1]+a*x[0];const l=w[r];r=n+f*x[2]+s*x[1]+a*x[0];const d=w[r],p=o+(u-o)*m;r=n+e*k[2]+c*k[1]+I*k[0],b.values[r]=p+(l+(d-l)*m-p)*i}}}else for(let t=0;t<g;++t){const s=g>1?n*(d-1)+t*o:.5*(n+r)*(d-1);if(s<0||s>d-1){for(let e=0;e<p;e++)b.values[e+t*k[2]+c*k[1]+I*k[0]]=l;continue}const i=Math.round(s),u=Math.round(e);for(let e=0;e<p;e++)b.values[e+t*k[2]+c*k[1]+I*k[0]]=w[e+i*x[2]+u*x[1]+a*x[0]]}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},ED={kernelName:Hf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,exclusive:i,reverse:o}=s;AR(r,"cumsum");const u=Zw([a],r.shape.length);let l=r;null!=u&&(l=_F({inputs:{x:r},backend:n,attrs:{perm:u}}));const c=Qw(1,r.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=jb(l.dtype,"int32"),d=Zp(Np(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)d[t]=i?0:p[t];else{const n=m(b,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=u){const e=_F({inputs:{x:g},backend:n,attrs:{perm:Jw(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}},ND={kernelName:Kf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:i,binaryOutput:o}=s;if(1===r.shape.length){const e=eD(n.data.get(r.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===r.shape.length){const e=tD(n.bufferSync(r),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},$D={kernelName:Xf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:a,dataFormat:i}=s;Cp("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`),Cp(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const o=r.shape[0],u=r.shape[1],l=r.shape[2],c=r.shape[3],h=u*a,d=l*a,p=c/(a*a),f=n.data.get(r.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let b=0;b<o;++b)for(let e=0;e<h;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<d;++e){const s=Math.floor(e/a),r=(n*a+e%a)*p;for(let e=0;e<p;++e)m[g++]=f[e+r+c*(s+l*(t+u*b))]}}return n.makeTensorInfo([o,h,d,p],r.dtype,m)}};function TD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=s;AR([r,a],"depthwiseConv2DNative");const c=Gp(r.shape),h=Gp(a.shape);let d=u;null==d&&(d=[1,1]),Cp(Gv(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const p=Pv(r.shape,a.shape,i,d,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,v=y.left,w=y.top,x=p.outChannels/p.inChannels,k=new Eb(p.outShape,r.dtype),I=n.data.get(r.dataId).values,C=n.data.get(a.dataId).values,_=k.values;for(let S=0;S<p.batchSize;++S){const e=S*c[0],t=S*k.strides[0];for(let n=0;n<p.outHeight;++n){const s=t+n*k.strides[1],r=n*p.strideHeight-w;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const a=t*h[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=s+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const s=n+e*b;if(s<0||s>=p.inWidth)continue;const r=i+s*p.inChannels;let o=t,u=a+e*h[1];for(let e=0;e<p.inChannels;++e){const t=I[r+e];for(let e=0;e<x;++e)_[o+e]+=t*C[u+e];o+=x,u+=x}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const AD={kernelName:Yf,backendName:"cpu",kernelFunc:TD},RD={kernelName:Zf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=s;AR([r,a],"depthwiseConv2dNativeBackpropFilter");const h=Pv(r.shape,c,i,o,u,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Eb(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,w=n.data.get(r.dataId).values,x=new Eb(r.shape,r.dtype,w),k=n.data.get(a.dataId).values,I=new Eb(a.shape,a.dtype,k);for(let C=0;C<f;++C){const e=Math.max(0,Math.ceil((y-C)/d)),t=Math.min(h.outHeight,(h.inHeight+y-C)/d);for(let n=0;n<m;++n){const s=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let a=0;a<h.outChannels;++a){const i=Math.trunc(a/v),o=a%v;let u=0;for(let l=0;l<h.batchSize;++l)for(let o=e;o<t;++o){const e=C+o*d-y;for(let t=s;t<r;++t)u+=x.get(l,e,n+t*p-b,i)*I.get(l,o,t,a)}g.set(u,C,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},FD={kernelName:Jf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=s;AR([r,a],"depthwiseConv2DNativeBackpropInput");const h=Gp(r.shape),d=Gp(a.shape),p=Pv(c,a.shape,i,o,u,l,!0),f=new Eb(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,v=n.data.get(r.dataId).values,[w,x,k]=h,I=n.data.get(a.dataId).values,[C,_,S]=d,{batchSize:E,filterHeight:N,filterWidth:$,inChannels:T,inHeight:A,inWidth:R,outChannels:F,outHeight:D,outWidth:O,strideHeight:M,strideWidth:z}=p,L=N-1-p.padInfo.top,P=$-1-p.padInfo.left,j=F/T;for(let V=0;V<E;++V)for(let e=0;e<T;++e)for(let t=0;t<A;++t){const n=t-L,s=Math.max(0,Math.ceil(n/M)),r=Math.min(D,(N+n)/M);for(let a=0;a<R;++a){const i=a-P,o=Math.max(0,Math.ceil(i/z)),u=Math.min(O,($+i)/z);let l=0;for(let t=s;t<r;++t){const s=t*M-n;for(let n=o;n<u;++n){const r=w*V+x*t+k*n,a=C*(N-1-s)+_*($-1-(n*z-i))+S*e;for(let t=0;t<j;++t)l+=v[r+(e*j+t)]*I[a+t]}}m[g*V+b*t+y*a+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},DD={kernelName:Qf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=Np(s.shape),a=n.data.get(s.dataId).values,i=qy([r,r],s.dtype),o=i.values;for(let l=0;l<a.length;l++)o[l*r+l]=a[l];const u=[...s.shape,...s.shape];return n.makeTensorInfo(u,i.dtype,i.values)}},OD={kernelName:em,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r}=e,{strides:a,pad:i,dilations:o}=n,u=t,l=u.data.get(s.dataId).values,c=s.shape.length,h=u.data.get(r.dataId).values,d=r.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:v,strideHeight:w,strideWidth:x,filterHeight:k,filterWidth:I,dilationHeight:C,dilationWidth:_,outShape:S}=Mv(s.shape,r.shape,a,i,"NHWC",o),E=Np(S),N=S.length,$=Lp(s.dtype,E);for(let T=0;T<p;++T)for(let e=0;e<b;++e){const t=e*w-v.top;for(let n=0;n<y;++n){const a=n*x-v.left;for(let i=0;i<g;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const n=t+e*C;if(n>=0&&n<f)for(let t=0;t<I;++t){const u=a+t*_;if(u>=0&&u<m){const a=ef([T,n,u,i],c,Gp(s.shape)),p=ef([e,t,i],d,Gp(r.shape)),f=l[a]+h[p];f>o&&(o=f)}}}$[ef([T,e,n,i],N,Gp(S))]=o}}}return{dataId:u.write(mb($,s.dtype),S,s.dtype),shape:S,dtype:s.dtype}}},MD={kernelName:nm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=Xp(s.shape,l.data.get(s.dataId).values),h=Xp(r.shape,l.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:w,filterHeight:x,filterWidth:k,dilationHeight:I,dilationWidth:C,outShape:_}=Mv(s.shape,r.shape,i,o,"NHWC",u);Cp(a.rank===_.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${_.length}, but got ${a.rank}`);const S=Xp(_,l.data.get(a.dataId).values),E=Jp(r.shape,r.dtype);for(let N=0;N<d;++N)for(let e=0;e<g;++e){const t=e*v-y.top;for(let n=0;n<b;++n){const s=n*w-y.left;for(let r=0;r<m;++r){let a=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<x;++e){const n=t+e*I;if(n>=0&&n<p)for(let t=0;t<k;++t){const u=s+t*C;if(u>=0&&u<f){const s=c[N][n][u][r]+h[e][t][r];s>a&&(a=s,i=e,o=t)}}}E[i][o][r]+=S[N][e][n][r]}}}return{dataId:l.write(mb(E,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},zD={kernelName:tm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=Xp(s.shape,l.data.get(s.dataId).values),h=Xp(r.shape,l.data.get(r.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:w,filterHeight:x,filterWidth:k,dilationHeight:I,dilationWidth:C,outShape:_}=Mv(s.shape,r.shape,i,o,"NHWC",u);Cp(a.rank===_.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${_.length}, but got ${a.rank}`);const S=Xp(_,l.data.get(a.dataId).values),E=Jp(s.shape,s.dtype);for(let N=0;N<d;++N)for(let e=0;e<g;++e){const t=e*v-y.top;for(let n=0;n<b;++n){const s=n*w-y.left;for(let r=0;r<m;++r){let a=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=s<0?0:s;for(let e=0;e<x;++e){const n=t+e*I;if(n>=0&&n<p)for(let t=0;t<k;++t){const u=s+t*C;if(u>=0&&u<f){const s=c[N][n][u][r]+h[e][t][r];s>a&&(a=s,i=n,o=u)}}}E[N][i][o][r]+=S[N][e][n][r]}}}return{dataId:l.write(mb(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},LD=WR((e,t)=>e*t),PD=oF((e,t,n,s)=>({real:e*n-t*s,imag:e*s+t*n})),jD=iF(Jm,LD,PD),VD={kernelName:Jm,backendName:"cpu",kernelFunc:jD};function WD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s;let o;AR(r,"sum"),o="bool"===r.dtype?rF({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):LR({inputs:{x:r},backend:n});const u=o.shape.length,l=Op(a,o.shape),c=Zw(l,u);let h=l,d=o;null!=c&&(d=_F({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Qw(h.length,u)),Yw("sum",h,d.shape.length);const[p,f]=Kw(d.shape,h);let m=tF(n,p,jb(d.dtype,"int32"));const g=Np(f),b=n.data.get(m.dataId).values,y=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[v]=t}if(i){const e=m;m=dF({inputs:{x:m},backend:n,attrs:{shape:Xw(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const BD={kernelName:Dg,backendName:"cpu",kernelFunc:WD},qD={kernelName:rm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,a=t,{allDims:i,summedDims:o,idDims:u}=EI(r,a.length);$I(i.length,u,a);const{path:l,steps:c}=TI(o,u),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:s}=NI(p,u[e]);let r;AI(t)?r=a[e]:(r=_F({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(r));const i=r.shape.slice();for(let e=0;e<s.length;++e)i.splice(s[e],0,1);$p(r.shape,i)||(r=dF({inputs:{x:r},backend:n,attrs:{shape:i}}),f.push(r)),null===d?d=r:(d=jD({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=WD({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},UD={kernelName:im,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:s,y:r}=t;AR([s,r],"eluGrad");const a=new Float32Array(Np(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values;for(let u=0;u<i.length;++u){const e=i[u];a[u]=e>=1?o[u]:o[u]*(e+1)}return n.makeTensorInfo(r.shape,"float32",a)}},HD=WR((e,t)=>e===t?1:0),GD=iF(um,HD,null,"bool"),KD={kernelName:um,backendName:"cpu",kernelFunc:GD},XD=cI,YD=hI,ZD=dI,JD=pI,QD=fI,eO=mI,tO=DR(om,e=>{const t=Math.sign(e),n=Math.abs(e),s=1/(1+XD*n);return t*(1-((((eO*s+QD)*s+JD)*s+ZD)*s+YD)*s*Math.exp(-n*n))}),nO={kernelName:om,backendName:"cpu",kernelFunc:tO},sO=sD(e=>Math.exp(e)),rO=OR(lm,sO),aO={kernelName:lm,backendName:"cpu",kernelFunc:rO};function iO(e){const{inputs:t,backend:n,attrs:s}=e,{input:r}=t,{dim:a}=s,i=r.shape.length,o=r.shape.slice();let u=a;return a<0&&(Cp(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),dF({inputs:{x:r},backend:n,attrs:{shape:o}})}const oO={kernelName:cm,backendName:"cpu",kernelFunc:iO},uO=sD(e=>Math.expm1(e)),lO=OR(hm,uO),cO={kernelName:hm,backendName:"cpu",kernelFunc:lO},hO=WR((e,t)=>e/t),dO=iF(sm,hO),pO={kernelName:sm,backendName:"cpu",kernelFunc:dO},fO=WR((e,t)=>e-t),mO=oF((e,t,n,s)=>({real:e-n,imag:t-s})),gO=iF(qg,fO,mO),bO={kernelName:qg,backendName:"cpu",kernelFunc:gO};function yO(e,t,n){const s=e.shape,r=s[0],a=s[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[r,a],c=Np(l),h=zp("float32",c),d=zp("float32",c);for(let g=0;g<r;g++){const e=ZF({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),s=ZF({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,a]}}),r=QR({inputs:{real:e,imag:s},backend:n}),{real:i,imag:l}=vO(r,t,n),c=yI(i,l);for(let t=0;t<a;t++){const e=kI(c,t);h[g*a+t]=e.real,d[g*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",d),m=QR({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function vO(e,t,n){const s=Np(e.shape),r=n.data.get(e.dataId),a=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((o=s)&o-1)){const r=wO(a,i,s,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",r.real),t=n.makeTensorInfo(o,"float32",r.imag),a=n.makeTensorInfo([],"float32",fb(s,"float32")),i=LR({inputs:{x:a},backend:n}),u=pO.kernelFunc({inputs:{a:e,b:a},backend:n}),l=pO.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(u.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),{real:c,imag:h}}return r}return vI(function(e,t,n){const s=new Float32Array(2*t);for(let r=0;r<t;r++){let a=0,i=0;for(let s=0;s<t;s++){const o=_I(r*s,t,n),u=kI(e,s);a+=u.real*o.real-u.imag*o.imag,i+=u.real*o.imag+u.imag*o.real}n&&(a/=t,i/=t),II(s,a,i,r)}return s}(yI(a,i),s,t));var o}function wO(e,t,n,s,r){if(1===n)return{real:e,imag:t};const a=yI(e,t),i=n/2,o=wI(a),u=o.real,l=o.imag,c=[u.length],h=r.makeTensorInfo(c,"float32",u),d=r.makeTensorInfo(c,"float32",l),p=QR({inputs:{real:h,imag:d},backend:r}),f=xI(a),m=f.real,g=f.imag,b=[m.length],y=r.makeTensorInfo(b,"float32",m),v=r.makeTensorInfo(b,"float32",g),w=QR({inputs:{real:y,imag:v},backend:r}),x=wO(u,l,i,s,r),k=x.real,I=x.imag,C=[k.length],_=r.makeTensorInfo(C,"float32",k),S=r.makeTensorInfo(C,"float32",I),E=QR({inputs:{real:_,imag:S},backend:r}),N=wO(m,g,i,s,r),$=N.real,T=N.imag,A=[$.length],R=r.makeTensorInfo(A,"float32",$),F=r.makeTensorInfo(A,"float32",T),D=QR({inputs:{real:R,imag:F},backend:r}),O=CI(n,s),M=[O.real.length],z=r.makeTensorInfo(M,"float32",O.real),L=r.makeTensorInfo(M,"float32",O.imag),P=QR({inputs:{real:z,imag:L},backend:r}),j=jD({inputs:{a:P,b:D},backend:r}),V=cF({inputs:{a:E,b:j},backend:r}),W=gO({inputs:{a:E,b:j},backend:r}),B=nF({inputs:{input:V},backend:r}),q=nF({inputs:{input:W},backend:r}),U=hD({inputs:{input:V},backend:r}),H=hD({inputs:{input:W},backend:r}),G=pD({inputs:[B,q],backend:r,attrs:{axis:0}}),K=pD({inputs:[U,H],backend:r,attrs:{axis:0}}),X=r.data.get(G.dataId).values,Y=r.data.get(K.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const xO={kernelName:dm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,r=Np(s.shape),a=s.shape[s.shape.length-1],i=dF({inputs:{x:s},backend:n,attrs:{shape:[r/a,a]}}),o=yO(i,!1,n),u=dF({inputs:{x:o},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}};function kO(e){const{backend:t,attrs:n}=e,{shape:s,value:r,dtype:a}=n,i=a||qp(r),o=Lp(i,Np(s));return function(e,t,n){e.fill(t)}(o,r),t.makeTensorInfo(s,i,o)}const IO={kernelName:pm,backendName:"cpu",kernelFunc:kO},CO={kernelName:fm,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,s=t,r=zp(n.dtype,Np(n.shape)),[a,i,o,u]=n.shape,l=s.data.get(n.dataId).values;for(let c=0;c<a;c++){const e=c*o*i*u;for(let t=0;t<i;t++){const n=t*(o*u);for(let s=0;s<o;s++){const i=s*u;for(let c=0;c<u;c++){const h=Math.round(o-[a,t,s,c][2]),d=e+n+i+c;let p=l[d];h>=0&&h<o&&(p=l[e+n+h*u+c]),r[d]=p}}}}return{dataId:s.write(r,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},_O=sD(e=>Math.floor(e)),SO=OR(mm,_O),EO={kernelName:mm,backendName:"cpu",kernelFunc:SO},NO=WR((e,t)=>Math.floor(e/t)),$O=iF(gm,NO,null,"int32"),TO={kernelName:gm,backendName:"cpu",kernelFunc:$O},AO={kernelName:rb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=mD({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=cF({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=JR(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}},RO={kernelName:ab,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let m=TD({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=cF({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=JR(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}},FO={kernelName:vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,a=Np(s.shape),i=r.shape,o=i[i.length-1],[u,l,c,h]=rI(s,r);if(0===l)return n.makeTensorInfo(u,s.dtype,[]);const d=qy([l,c],s.dtype),p=n.data.get(r.dataId).values,f=n.data.get(s.dataId).values;for(let m=0;m<l;m++){const e=[];let t=0;for(let n=0;n<o;n++){const s=p[m*o+n];t+=s*h[n],e.push(s)}if(t<0||t>=a/c)throw new Error(`Invalid indices: ${e} does not index into ${s.shape}`);for(let n=0;n<c;n++)d.values[m*c+n]=f[t*c+n]}return n.makeTensorInfo(u,d.dtype,d.values)}};function DO(e,t,n){const s=qy(n,e.dtype);for(let r=0;r<s.size;++r){const n=s.indexToLoc(r).slice(),a=t.locToIndex([n[0],n[2]]);n[2]=t.values[a];const i=e.locToIndex(n);s.values[r]=e.values[i]}return s}const OO={kernelName:ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:a}=t,{axis:i,batchDims:o}=s;AR([r,a],"gatherV2");let u=o;null==o&&(u=0);const l=Np(a.shape),c=MI(r,a,Op(i,r.shape)[0],u),h=dF({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=dF({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}}),p=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize],f=n.bufferSync(d),m=DO(n.bufferSync(h),f,p);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},MO=WR((e,t)=>e>t?1:0),zO=iF(wm,MO,null,"bool"),LO={kernelName:wm,backendName:"cpu",kernelFunc:zO},PO=WR((e,t)=>e>=t?1:0),jO=iF(xm,PO,null,"bool"),VO={kernelName:xm,backendName:"cpu",kernelFunc:jO},WO={kernelName:Im,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,r=Np(s.shape),a=s.shape[s.shape.length-1],i=dF({inputs:{x:s},backend:n,attrs:{shape:[r/a,a]}}),o=yO(i,!0,n),u=dF({inputs:{x:o},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}},BO=DR(_m,e=>Number.isFinite(e)?1:0,"bool"),qO={kernelName:_m,backendName:"cpu",kernelFunc:BO},UO=DR(Sm,e=>Math.abs(e)===1/0?1:0,"bool"),HO={kernelName:Sm,backendName:"cpu",kernelFunc:UO},GO=DR(Em,e=>Number.isNaN(e)?1:0,"bool"),KO={kernelName:Em,backendName:"cpu",kernelFunc:GO},XO=WR((e,t)=>e<t?1:0),YO=iF($m,XO,null,"bool"),ZO={kernelName:$m,backendName:"cpu",kernelFunc:YO},JO=WR((e,t)=>e<=t?1:0),QO=iF(Tm,JO,null,"bool"),eM={kernelName:Tm,backendName:"cpu",kernelFunc:QO};function tM(e,t,n){const s=(t-e)/(n-1),r=Zp(n,"float32");r[0]=e;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}const nM={kernelName:Am,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:a}=n,i=tM(s,r,a);return t.makeTensorInfo([i.length],"float32",i)}},sM=sD(e=>Math.log(e)),rM=OR(Rm,sM),aM={kernelName:Rm,backendName:"cpu",kernelFunc:rM},iM=DR(Fm,e=>Math.log1p(e)),oM={kernelName:Fm,backendName:"cpu",kernelFunc:iM},uM=WR((e,t)=>e&&t),lM=iF(Dm,uM,null,"bool"),cM={kernelName:Dm,backendName:"cpu",kernelFunc:lM},hM=DR(Om,e=>e?0:1,"bool"),dM={kernelName:Om,backendName:"cpu",kernelFunc:hM},pM=WR((e,t)=>e||t),fM=iF(Mm,pM,null,"bool"),mM={kernelName:Mm,backendName:"cpu",kernelFunc:fM},gM={kernelName:zm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=s;AR(r,"LRN");const l=r.shape[3],c=l-1,h=n.data.get(r.dataId).values,d=Np(r.shape),p=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-a);const s=e-t+Math.min(t+a,c);let r=0;for(;n<=s;n++){const e=h[n];r+=e*e}return r}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(i+o*e,-u);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}},bM={kernelName:Lm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=s;AR(i,"LRNGrad");const h=Np(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(h),b=h;for(let y=0;y<b;y++){const e=y%d,t=y-e+Math.max(0,e-o),n=y-e+Math.min(d,e+o+1);let s=0;for(let r=t;r<n;r++)s+=Math.pow(f[r],2);s=l*s+u;for(let r=t;r<n;r++){let e=-2*l*c*f[r]*m[y]/s;y===r&&(e+=Math.pow(s,-c)),e*=p[y],g[r]+=e}}return n.makeTensorInfo(i.shape,r.dtype,g)}};function yM(e,t,n,s){const r=zp(s,Np(n));for(let a=0;a<r.length;++a){const n=a*t;let s=e[n];for(let r=0;r<t;++r){const t=e[n+r];t>s&&(s=t)}r[a]=s}return r}function vM(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:a,keepDims:i}=s,o=n;let u=r.shape;const l=u.length,c=Op(a,u);let h=c;const d=Zw(h,l);let p=o.data.get(r.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=u[d[t]];p=CF(p,u,r.dtype,d,e),h=Qw(h.length,l),u=e}AR(r,"max"),Yw("max",h,l);const[f,m]=Kw(u,h),g=yM(p,Np(m),f,r.dtype),b=o.write(g,f,r.dtype);let y=f;return i&&(y=Xw(f,c)),{dataId:b,shape:y,dtype:r.dtype}}const wM={kernelName:Pm,backendName:"cpu",kernelFunc:vM},xM=WR((e,t)=>Math.max(e,t)),kM=iF(jm,xM),IM={kernelName:jm,backendName:"cpu",kernelFunc:kM},CM={kernelName:Vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;AR(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;Cp(Gv(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=zv(r.shape,a,i,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))c=LR({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Gp(r.shape),s=WF(e,0,r.dtype,t,l,"max");c=n.makeTensorInfo(l.outShape,r.dtype,s.values)}return c}},_M={kernelName:Bm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=s;AR(r,"maxPool3d");const c=Lv(r.shape,a,i,1,o,u,l),h=qF(n.data.get(r.dataId).values,0,r.dtype,Gp(r.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},SM={kernelName:qm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=s;AR([r,a],"maxPool3DGrad");const c=Lv(a.shape,i,o,1,u,l),h=function(e,t){const n=qy(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*s-d;let v=y;for(;v<0;)v+=i;const w=Math.min(t.inDepth,l+y);for(let s=0;s<t.outHeight;++s){const l=s*r-p;let d=l;for(;d<0;)d+=o;const x=Math.min(t.inHeight,c+l);for(let r=0;r<t.outWidth;++r){const p=r*a-f;let k=p;for(;k<0;)k+=u;const I=Math.min(t.inWidth,h+p);let C=Number.NEGATIVE_INFINITY,_=-1;for(let t=v;t<w;t+=i){const n=t-y;for(let s=d;s<x;s+=o){const r=s-l;for(let a=k;a<I;a+=u){const i=a-p,o=e.get(m,t,s,a,g);o>=C&&(C=o,_=n*c*h+r*c+i)}}}n.set(_,m,b,s,r,g)}}}return n}(n.bufferSync(a),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,y=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,x=y-1-c.padInfo.front,k=w-1-c.padInfo.left,I=v-1-c.padInfo.top,C=qy(a.shape,"float32"),_=n.bufferSync(r);for(let S=0;S<c.batchSize;++S)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=t-x,a=n-I,i=s-k;let o=0;for(let t=0;t<y;t+=m){const n=(r+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let s=0;s<v;s+=g){const r=(a+s)/p;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let a=0;a<w;a+=b){const u=(i+a)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const l=y*v*w-1-h.get(S,n,r,u,e)===t*v*w+s*w+a?1:0;0!==l&&(o+=_.get(S,n,r,u,e)*l)}}}C.set(o,S,t,n,s,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},EM={kernelName:Wm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a,output:i}=t,o=a;AR([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=zv(o.shape,u,l,1,c,h),p=n.data.get(o.dataId).values,f=qy(d.outShape,o.dtype,BF(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,w=d.effectiveFilterWidth,x=w-1-d.padInfo.left,k=v-1-d.padInfo.top,I=qy(o.shape,"float32"),C=n.data.get(r.dataId).values,_=qy(r.shape,"float32",C);for(let S=0;S<d.batchSize;++S)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const s=t-k,r=n-x;let a=0;for(let t=0;t<v;t+=b){const n=(s+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let s=0;s<w;s+=y){const i=(r+s)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const o=v*w-1-f.get(S,n,i,e)===t*w+s?1:0;0!==o&&(a+=_.get(S,n,i,e)*o)}}I.set(a,S,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},NM={kernelName:Um,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;AR(s,"MaxPoolWithArgmax");const l=u.data.get(s.dataId).values,c=zv(s.shape,r,a,[1,1],i),[h,d]=function(e,t,n,s,r){const a=WF(e,0,n,Gp(t),r,"max"),i=BF(e,t,n,r,!0,s);return[a.values,i.values]}(l,s.shape,s.dtype,o,c),p=u.write(h,c.outShape,s.dtype),f=u.write(d,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},$M={kernelName:Hm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s,o=Op(a,r.shape),u=Np(Kw(r.shape,o)[1]),l=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));l.push(c);const h=rF({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(h);const d=dO({inputs:{a:h,b:c},backend:n});l.push(d);const p=WD({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:i}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}},TM={kernelName:Gm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s;AR(r,"min");const o=Op(a,r.shape);let u=o;const l=Zw(u,r.shape.length);let c=r;null!=l&&(c=_F({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Qw(u.length,r.shape.length)),Yw("min",u,c.shape.length);const[h,d]=Kw(c.shape,u),p=Np(d),f=Zp(Np(h),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const s=m[e+n];s<t&&(t=s)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=dF({inputs:{x:g},backend:n,attrs:{shape:Xw(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},AM=WR((e,t)=>Math.min(e,t)),RM=iF(Km,AM),FM={kernelName:Km,backendName:"cpu",kernelFunc:RM},DM={kernelName:Xm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,mode:i}=s;AR(r,"mirrorPad");const o=a.map((e,t)=>e[0]+r.shape[t]+e[1]),u=a.map(e=>e[0]),l=a.map((e,t)=>e[0]+r.shape[t]),c="reflect"===i?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=Gp(r.shape),f=Np(o),m=o.length,g=Gp(o),b=zp(r.dtype,f);for(let y=0;y<f;y++){let e=tf(y,m,g);for(let n=0;n<m;n++)e[n]<u[n]?e[n]=2*u[n]-e[n]-c:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+c);e=e.map((e,t)=>e-u[t]);const t=ef(e,d,p);b[y]=h[t]}return{dataId:n.write(b,o,r.dtype),shape:o,dtype:r.dtype}}},OM=WR((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),MM=iF(Ym,OM),zM={kernelName:Ym,backendName:"cpu",kernelFunc:MM};function LM(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:a}=s,i=r.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const u=Op([o],r.shape),l=vM({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=Xw(l.shape,u),h=dF({inputs:{x:l},backend:n,attrs:{shape:c}}),d=gO({inputs:{a:r,b:h},backend:n}),p=rO({inputs:{x:d},backend:n}),f=WD({inputs:{x:p},backend:n,attrs:{axis:u,keepDims:!1}}),m=dF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=dO({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const PM={kernelName:zg,backendName:"cpu",kernelFunc:LM},jM={kernelName:Zm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:a,seed:i,normalized:o}=s;AR(r,"multinomial");const u=o?r:LM({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],h=n.data.get(u.dataId).values,d=[l,a],p=Zp(Np(d),"int32");for(let f=0;f<l;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+h[e+r];const n=cx.alea(i.toString()),s=f*a;for(let r=0;r<a;++r){const e=n();p[s+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[s+r]=n;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(d,"int32",p)}};function VM(e,t,n){const s=fb(-1,n);return LD([],t,s,e,n)}const WM={kernelName:Qm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;AR(s,"neg");const r=n.data.get(s.dataId).values,[a,i]=VM(r,s.shape,s.dtype);return n.makeTensorInfo(i,s.dtype,a)}},BM=hk,qM={kernelName:tg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=s;AR(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=BM(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},UM=dk,HM={kernelName:ng,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=s;AR(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:p}=UM(c,h,i,o,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},GM=pk,KM={kernelName:sg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=s;AR(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(a.dataId).values,d=i,p=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=GM(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},XM=WR((e,t)=>e!==t?1:0),YM=iF(eg,XM,null,"bool"),ZM={kernelName:eg,backendName:"cpu",kernelFunc:YM},JM={kernelName:ag,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{depth:a,onValue:i,offValue:o}=s;AR(r,"oneHot");const u=Np(r.shape),l=new Float32Array(u*a);l.fill(o);const c=n.data.get(r.dataId).values;for(let h=0;h<u;++h)c[h]>=0&&c[h]<a&&(l[h*a+c[h]]=i);return n.makeTensorInfo([...r.shape,a],"int32",l)}};function QM(e){const{inputs:t,backend:n}=e,{x:s}=t;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const e=nF({inputs:{input:s},backend:n}),t=QM({inputs:{x:e},backend:n}),r=hD({inputs:{input:s},backend:n}),a=QM({inputs:{x:r},backend:n}),i=QR({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}return kO({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const ez={kernelName:eb,backendName:"cpu",kernelFunc:QM},tz={kernelName:rg,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:s}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=nF({inputs:{input:r},backend:s}),n=e({inputs:{x:t},backend:s}),a=hD({inputs:{input:r},backend:s}),i=QM({inputs:{x:a},backend:s}),o=QR({inputs:{real:n,imag:i},backend:s});return s.disposeIntermediateTensorInfo(t),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(i),o}return kO({backend:s,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function nz(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return iO({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{_p(a,e.shape,"All tensors passed to stack must have matching shapes"),Cp(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=pD({inputs:t.map(e=>{const t=iO({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(t),t}),backend:n,attrs:{axis:r}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}const sz={kernelName:ig,backendName:"cpu",kernelFunc:nz},rz={kernelName:og,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,constantValue:i}=s;AR(r,"pad");const o=a.map((e,t)=>e[0]+r.shape[t]+e[1]),u=a.map(e=>e[0]),l=n.data.get(r.dataId).values,c=Np(r.shape),h=r.shape.length,d=Gp(r.shape),p=Np(o),f=o.length,m=Gp(o),g=zp(r.dtype,p);0!==i&&g.fill(i);for(let b=0;b<c;b++)g[ef(tf(b,h,d).map((e,t)=>e+u[t]),f,m)]=l[b];return{dataId:n.write(g,o,r.dtype),shape:o,dtype:r.dtype}}},az=WR((e,t)=>Math.pow(e,t)),iz=iF(ug,az),oz={kernelName:ug,backendName:"cpu",kernelFunc:iz};function uz(e,t,n,s){const[r,a]=Kw(e,s),i=jb(t,"int32"),o=Zp(Np(r),i),u=Np(a);for(let l=0;l<o.length;++l){const e=l*u;let t=1;for(let s=0;s<u;++s)t*=n[e+s];o[l]=t}return{outVals:o,outShape:r,outDtype:i}}const lz={kernelName:cg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s;AR(r,"prod");const o=r.shape.length,u=Op(a,r.shape),l=Zw(u,o);let c=u,h=r;const d=[];null!=l&&(h=_F({inputs:{x:r},backend:n,attrs:{perm:l}}),d.push(h),c=Qw(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=uz(h.shape,h.dtype,p,c);let b=m;return i&&(b=Xw(m,u)),d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(b,g,f)}};function cz(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return Zp(0,s);const r=Zp(Math.abs(Math.ceil((t-e)/n)),s);t<e&&1===n&&(n=-1),r[0]=e;for(let a=1;a<r.length;a++)r[a]=r[a-1]+n;return r}const hz={kernelName:hg,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,dtype:a,step:i}=n,o=cz(s,r,i,a);return t.makeTensorInfo([o.length],a,o)}},dz=DR(pg,e=>1/e),pz={kernelName:pg,backendName:"cpu",kernelFunc:dz},fz={kernelName:yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s;AR(r,"resizeBilinear");const u=Gp(r.shape),[l,c]=o,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(Np([h,l,c,f])),b=[a&&l>1?d-1:d,a&&c>1?p-1:p],y=[a&&l>1?l-1:l,a&&c>1?c-1:c];let v=0;const w=b[0]/y[0],x=b[1]/y[1];for(let k=0;k<h;k++)for(let e=0;e<l;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,r=Math.min(d-1,Math.ceil(t)),a=k*u[0]+n*u[1],o=k*u[0]+r*u[1];for(let e=0;e<c;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),c=a+n*u[2],h=o+n*u[2],d=a+l*u[2],b=o+l*u[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],a=t+(m[d+e]-t)*r;g[v++]=a+(n+(m[b+e]-n)*r-a)*s}}}return n.makeTensorInfo([h,l,c,f],"float32",g)}},mz={kernelName:vg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:i}=s;AR([a,r],"resizeBilinearGrad");const o=Gp(r.shape),[u,l,c,h]=r.shape,[,d,p]=a.shape,f=new Float32Array(u*l*c*h),m=[i&&d>1?l-1:l,i&&p>1?c-1:c],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],v=n.data.get(a.dataId).values;let w=0;for(let x=0;x<u;x++){const e=x*o[0];for(let t=0;t<d;t++){const n=t*b,s=Math.floor(n),r=Math.min(Math.ceil(n),l-1),a=e+s*o[1],i=e+r*o[1],u=n-s,d=1-u;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),s=Math.min(Math.ceil(t),c-1),r=t-n,l=1-r,p=a+n*o[2],m=a+s*o[2],g=i+n*o[2],b=i+s*o[2],x=d*l,k=d*r,I=u*l,C=u*r;for(let e=0;e<h;e++){const t=v[w++];f[p+e]+=t*x,f[m+e]+=t*k,f[g+e]+=t*I,f[b+e]+=t*C}}}}return n.makeTensorInfo([u,c,l,h],"float32",f)}},gz={kernelName:gg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s;AR(r,"resizeNearestNeighbor");const u=Gp(r.shape),[l,c]=o,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(h*l*c*f),b=[a&&l>1?d-1:d,a&&c>1?p-1:p],y=[a&&l>1?l-1:l,a&&c>1?c-1:c],v=b[0]/y[0],w=b[1]/y[1];let x=0;for(let k=0;k<h;k++){const e=k*u[0];for(let t=0;t<l;t++){const n=i?v*(t+.5):v*t;let s=Math.min(d-1,a?Math.round(n):Math.floor(n));i&&(s=Math.max(0,s));const r=e+s*u[1];for(let e=0;e<c;e++){const t=i?w*(e+.5):w*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const s=r+n*u[2];for(let e=0;e<f;e++)g[x++]=m[s+e]}}}return n.makeTensorInfo([h,l,c,f],r.dtype,g)}},bz={kernelName:bg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:i}=s;AR([a,r],"resizeNearestNeighborGrad");const o=Gp(r.shape),u=Gp(a.shape),[l,c,h,d]=r.shape,[,p,f]=a.shape,m=new Float32Array(l*c*h*d),g=n.data.get(a.dataId).values,b=[i&&p>1?c-1:c,i&&f>1?h-1:h],y=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=b[0]/y[0],w=b[1]/y[1],x=1/v,k=1/w,I=2*Math.ceil(x)+2,C=2*Math.ceil(k)+2;for(let _=0;_<l;_++){const e=_*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],s=Math.floor(t*x),r=Math.floor(s-I/2);for(let a=0;a<h;a++){const s=n+a*o[2],l=Math.floor(a*k),b=Math.floor(l-C/2);for(let n=0;n<d;n++){let o=0;for(let s=0;s<I;s++){const l=s+r;if(l<0||l>=p)continue;const d=e+l*u[1],m=l*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<C;e++){const t=e+b;if(t<0||t>=f)continue;const s=d+t*u[2],r=t*w;a===Math.min(h-1,i?Math.round(r):Math.floor(r))&&(o+=g[s+n])}}m[s+n]=o}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}},yz={kernelName:xg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:a}=s;AR(r,"reverse");const i=r.shape.length,o=Op(a,r.shape);if(0===i)return LR({inputs:{x:r},backend:n});const u=new Eb(r.shape,r.dtype),l=n.bufferSync(r);for(let c=0;c<u.size;c++){const e=u.indexToLoc(c),t=e.slice();o.forEach(e=>t[e]=r.shape[e]-1-t[e]),u.set(l.get(...t),...e)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},vz={kernelName:nb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:r,fillValue:a,center:i}=t,o=n,u=zp(s.dtype,Np(s.shape)),[l,c,h,d]=s.shape,[p,f]=Jk(i,c,h),m=Math.sin(r),g=Math.cos(r),b=o.data.get(s.dataId).values;for(let y=0;y<l;y++){const e=y*h*c*d;for(let t=0;t<c;t++){const n=t*(h*d);for(let s=0;s<h;s++){const r=s*d;for(let i=0;i<d;i++){const o=[l,t,s,i],y=o[2],v=o[1];let w=(y-p)*g-(v-f)*m,x=(y-p)*m+(v-f)*g;w=Math.round(w+p),x=Math.round(x+f);let k=a;"number"!=typeof a&&(k=3===i?255:a[i]),w>=0&&w<h&&x>=0&&x<c&&(k=b[e+x*(h*d)+w*d+i]),u[e+n+r+i]=k}}}}return{dataId:o.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},wz=DR(kg,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),xz={kernelName:kg,backendName:"cpu",kernelFunc:wz},kz=sD(e=>1/Math.sqrt(e)),Iz=OR(Ig,kz),Cz={kernelName:Ig,backendName:"cpu",kernelFunc:Iz};function _z(e,t,n,s,r,a,i,o,u,l){const c=[s/r,r],h=e.values,d=t.values;if(0===s)return qy(n,t.dtype);const p=qy(c,t.dtype);p.values.fill(u);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=s/r)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<r;n++)l?p.values[a*r+n]+=d[f*r+n]:p.values[a*r+n]=0===t.rank?d[0]:d[f*r+n]}return p}const Sz={kernelName:Cg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:a}=t,{shape:i}=s,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=oI(0,r,i),d=_z(n.bufferSync(r),n.bufferSync(a),i,h,l,u,o,c,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}},Ez={kernelName:_g,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:a}=t;AR([s,r,a],"select");const i=s.shape.length,o=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=jb(r.dtype,a.dtype),h=Zp(Np(r.shape),c);let d=0;const p=0===i||i>1||1===r.shape.length?1:Np(r.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)h[d++]=1===o[f]?u[f]:l[f];return n.makeTensorInfo(r.shape,c,h)}},Nz=uI,$z=lI,Tz=DR(Sg,e=>e>=0?$z*e:Nz*(Math.exp(e)-1)),Az={kernelName:Sg,backendName:"cpu",kernelFunc:Tz},Rz=DR(Tg,e=>e<0?-1:e>0?1:0),Fz={kernelName:Tg,backendName:"cpu",kernelFunc:Rz},Dz=DR(Ng,e=>Math.sin(e)),Oz={kernelName:Ng,backendName:"cpu",kernelFunc:Dz},Mz=DR($g,e=>Math.sinh(e)),zz={kernelName:$g,backendName:"cpu",kernelFunc:Mz},Lz=Math.log(1.1920928955078125e-7)+2,Pz=DR(Rg,e=>{const t=e>-Lz,n=e<Lz,s=Math.exp(e);let r;return r=n?s:t?e:Math.log(1+s),r}),jz={kernelName:Rg,backendName:"cpu",kernelFunc:Pz},Vz={kernelName:Og,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,paddings:i}=s;AR([r],"spaceToBatchND");const o=Np(a),u=[[0,0]];u.push(...i);for(let g=1+a.length;g<r.shape.length;++g)u.push([0,0]);const l=rz.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=Qk(l.shape,a,o,!1),h=eI(c.length,a.length,!1),d=tI(l.shape,a,o,!1),p=dF({inputs:{x:l},backend:n,attrs:{shape:c}}),f=_F({inputs:{x:p},backend:n,attrs:{perm:h}}),m=dF({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function Wz(e,t,n,s,r,a,i){const o=t[0],u=a[0],l=new Array(u),c=new Array(o),h=t[1];if(0===u){if(0!==o)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${o}`);return[Lp(n,0),[0,h],Lp(r,0),l,c]}let d=!0,p=0;const f=new Array(u).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(`indices(${g}, 0) is invalid: ${t} < 0`);if(t>=u)throw new Error(`indices(${g}, 0) is invalid: ${t} >= ${u}`);++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<u;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=s;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,l,c]}{const t=f[u-1],a=Lp(n,t*h),d=Lp(r,t),p=new Array(u).fill(0);for(let n=0;n<o;++n){const t=e[n*h],r=(0===t?0:f[t-1])+p[t];p[t]++;for(let s=0;s<h;++s)a[r*h+s]=e[n*h+s];d[r]=s[n],c[n]=r}for(let e=0;e<u;++e)if(0===p[e]){const t=0===e?0:f[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;d[t]=i}return[a,[o,h],d,l,c]}}const Bz={kernelName:Lg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,p,f,m]=Wz(o,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}};function qz(e,t,n,s,r){const a=Np(s),i=t[0],o=r.length,u=[];let l=1,c=-1;for(let g=0;g<o;++g){const e=r[g];if(-1===e){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,u.push(1)}else{if(e<0)throw new Error(`size ${g} must be non-negative, not ${e}`);l*=e,u.push(e)}}if(-1!==c){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/l);if(l*e!==a)throw new Error(`Input to reshape is a SparseTensor with ${a}\n          dense values, but the requested shape requires a multiple of ${l}. inputShape=${s} outputShape= ${u}`);u[c]=e}const h=Np(u);if(h!==a)throw new Error(`Input to reshape is a tensor with ${a} dense values, but the requested shape has ${h}. inputShape=${s} outputShape=${u}`);const d=s.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*s[e+1]}const f=[];if(o>0){f[o-1]=1;for(let e=o-2;e>=0;--e)f[e]=f[e+1]*u[e+1]}const m=Lp(n,i*o);for(let g=0;g<i;++g){let t=0;for(let n=0;n<d;++n)t+=e[g*d+n]*p[n];for(let e=0;e<o;++e)m[g*o+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[i,o],u]}const Uz={kernelName:Pg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(r.dataId).values),o=n.data.get(s.dataId).values,u=Array.from(n.data.get(a.dataId).values),[l,c,h]=qz(o,s.shape,s.dtype,i,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}},Hz={kernelName:jg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:a,defaultValue:i}=t,{outputShape:o}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=oI(0,r,o),p=_z(n.bufferSync(r),n.bufferSync(a),o,d,c,l,u,h,n.data.get(i.dataId).values[0],!1);return n.makeTensorInfo(o,p.dtype,p.values)}},Gz={kernelName:Mg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:a,axis:i}=s,o=Op(i,r.shape)[0],u=FI(r,a,o),l=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(e=>{const t=[...c];t[o]=e;const s=ZF({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,s})}},Kz=DR(Fg,e=>Math.sqrt(e)),Xz={kernelName:Fg,backendName:"cpu",kernelFunc:Kz},Yz={kernelName:Wg,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,s=t;AR(n,"square");const r=s.data.get(n.dataId).values,a=new Float32Array(r.length);for(let i=0;i<r.length;++i){const e=r[i];a[i]=e*e}return{dataId:s.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Zz=WR((e,t)=>{const n=e-t;return n*n}),Jz=iF(Vg,Zz),Qz={kernelName:Vg,backendName:"cpu",kernelFunc:Jz},eL=DR(tb,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),tL={kernelName:tb,backendName:"cpu",kernelFunc:eL};function nL(e,t,n,s){const r=qy(e,t.dtype);for(let a=0;a<r.size;a++){const e=r.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+s[t];r.set(t.get(...i),...e)}return r}const sL={kernelName:Bg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;AR(r,"stridedSlice");const{nonStrided:p,$begin:f,$strides:m,size:g,newShape:b,outShape:y}=yv(r.shape,a,i,o,u,l,c,h,d),v=dF({inputs:{x:r},backend:n,attrs:{shape:b}});let w;if(p){const e=ZF({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});w=dF({inputs:{x:e},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(e)}else if(y.some(e=>0===e))w=n.makeTensorInfo(y,r.dtype,[]);else{const e=nL(y,n.bufferSync(v),m,f);w=n.makeTensorInfo(e.shape,e.dtype,e.values)}const x=dF({inputs:{x:w},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),x}},rL=DR(Ug,e=>Math.tan(e)),aL={kernelName:Ug,backendName:"cpu",kernelFunc:rL},iL=DR(Hg,e=>Math.tanh(e));function oL(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const s=qy(n,e.dtype);for(let r=0;r<s.values.length;++r){const t=s.indexToLoc(r),n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=t[s]%e.shape[s];const a=e.locToIndex(n);s.values[r]=e.values[a]}return s}function uL(e,t,n,s,r){const a=t[t.length-1],[i,o]=[e.length/a,a],u=zp(n,i*s),l=zp("int32",i*s);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o),r=[];for(let e=0;e<n.length;e++)r.push({value:n[e],index:e});r.sort((e,t)=>t.value-e.value);const a=h*s,i=u.subarray(a,a+s),c=l.subarray(a,a+s);for(let e=0;e<s;e++)i[e]=r[e].value,c[e]=r[e].index}const c=t.slice();return c[c.length-1]=s,[qy(c,n,u),qy(c,"int32",l)]}function lL(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return kp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;return n<0?t<=1?n=0:n+=t*(Math.trunc(-n/(t-1))+1):n>t-1&&(t<=1?n=0:n-=t*Math.trunc(n/(t-1))),kp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return kp(0,e,t-1)}(e,t);case"constant":default:return function(e,t){return e}(e)}}function cL(e,t,n,s,r,a,i,o,u,l,c){return 0<=o&&o<t&&0<=u&&u<n?e[i*s+o*r+u*a+l]:c}function hL(e,t,n,s,r,a,i,o,u,l,c){return cL(e,t,n,s,r,a,i,Math.round(o),Math.round(u),l,c)}function dL(e,t,n,s,r,a,i,o,u,l,c){const h=Math.floor(o),d=Math.floor(u),p=h+1,f=d+1;return(p-o)*((f-u)*cL(e,t,n,s,r,a,i,h,d,l,c)+(u-d)*cL(e,t,n,s,r,a,i,h,f,l,c))+(o-h)*((f-u)*cL(e,t,n,s,r,a,i,p,d,l,c)+(u-d)*cL(e,t,n,s,r,a,i,p,f,l,c))}function pL(e,t,n,s){const r=Op(t,n)[0],a=[1,n[0],1];for(let f=0;f<r;f++)a[0]*=n[f];a[1]=n[r];for(let f=r+1;f<n.length;f++)a[2]*=n[f];const i={},o=new Int32Array(n[r]),u=new Eb(a,s,e),l=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[r];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(u.get(t,f,n));t=e.join(",")}if(void 0!==i[t])o[f]=i[t];else{const e=Object.keys(i).length;i[t]=e,o[f]=e,l.push(f)}}const h=a.slice();h[1]=Object.keys(i).length;const d=new Eb(h,s);l.forEach((e,t)=>{for(let n=0;n<a[0];n++)for(let s=0;s<a[2];s++)d.set(u.get(n,e,s),n,t,s)});const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const fL=[gF,yF,wF,kF,hF,IF,EF,NF,$F,TF,RF,DF,MF,PF,VF,UF,HF,GF,KF,mF,XF,QF,nD,aF,iD,uD,eF,lD,fD,bD,yD,gD,wD,xD,vD,ID,_D,SD,ED,ND,$D,AD,RD,FD,DD,OD,zD,MD,pO,qD,zR,UD,KD,nO,aO,oO,cO,xO,IO,CO,EO,TO,AO,RO,FO,OO,LO,VO,PR,WO,dD,qO,HO,KO,VR,ZO,eM,nM,aM,oM,cM,dM,mM,gM,bM,IM,CM,_M,SM,EM,NM,wM,$M,TM,FM,DM,zM,jM,VD,WM,qM,HM,KM,ZM,JM,tz,sz,rz,oz,UR,lz,hz,sF,pz,GR,XR,pF,fz,mz,gz,bz,yz,vz,xz,Cz,Sz,Ez,Az,ZR,Fz,Oz,zz,JF,PM,jz,Vz,Bz,Uz,Hz,Gz,Xz,Yz,Qz,tL,sL,bO,BD,aL,{kernelName:Hg,backendName:"cpu",kernelFunc:iL},{kernelName:Gg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:a}=s;AR(r,"tile");const i=oL(n.bufferSync(r),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:Kg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:a}=s;AR(r,"topk");const i=n.data.get(r.dataId).values,[o,u]=uL(i,r.shape,r.dtype,a);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},SF,{kernelName:Xg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{image:r,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=n,[c,h,d,p]=r.shape,[f,m]=null!=l?l:[h,d],g=[c,f,m,p],b=Gp(r.shape),y=b[0],v=b[1],w=b[2],x=zp(r.dtype,Np(g));x.fill(u);const k=s.data.get(r.dataId).values,I=s.data.get(a.dataId).values;for(let C=0;C<c;++C){const e=1===a.shape[0]?I:I.subarray(8*C,8*C+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let s=0;s<p;++s){let r;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const l=(e[3]*n+e[4]*t+e[5])/a,c=lL((e[0]*n+e[1]*t+e[2])/a,d,o),p=lL(l,h,o);switch(i){case"nearest":r=hL(k,h,d,y,v,w,C,p,c,s,u);break;case"bilinear":r=dL(k,h,d,y,v,w,C,p,c,s,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}x[C*y+t*v+n*w+s]=r}return s.makeTensorInfo(g,r.dtype,x)}return{dataId:s.write(x,g,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:Zg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:a}=t;AR(a,"unique");const i=s.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:l}=pL(i,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,o),s.makeTensorInfo([l.length],"int32",l)]}},{kernelName:Jg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r.shape.length,o=r.shape[a],u=new Array(i-1);let l=0;for(let p=0;p<i;p++)p!==a&&(u[l++]=r.shape[p]);const c=new Array(i).fill(0),h=r.shape.slice();h[a]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[a]=p;const e=ZF({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[p]=dF({inputs:{x:e},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(e)}return d}},{kernelName:Qg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:a}=t,{numSegments:i}=s;AR(r,"unsortedSegmentSum");const o=[],u=[],l=r.shape.length-a.shape.length;let c=a;for(let d=0;d<l;++d){const e=iO({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=e,u.push(e)}for(let d=0;d<i;++d){const e=fb(d,"int32"),t=n.makeTensorInfo([],"int32",e),s=GD({inputs:{a:t,b:c},backend:n}),a=rF({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),i=jD({inputs:{a:a,b:r},backend:n}),l=WD({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(l),u.push(t),u.push(s),u.push(a),u.push(i),u.push(l)}const h=nz({inputs:o,backend:n,attrs:{axis:0}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},ez];for(const rK of fL)hb(rK);const mL={},gL={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function bL(e){if(!(e in mL)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete mL[e]},!1),1===e?t.getContext("webgl",gL)||t.getContext("experimental-webgl",gL):t.getContext("webgl2",gL)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;mL[e]=t}const t=mL[e];return t.isContextLost()?(delete mL[e],bL(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),mL[e])}var yL,vL,wL;function xL(e,t){return[t,e]}function kL(e){const t=Np(e);return Ap(Math.ceil(t/4))}function IL(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function CL(e,t){const n=e;let s,r,a,i,o,u,l,c,h,d;return 2===af().getNumber("WEBGL_VERSION")?(s=n.R32F,r=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,l=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(s=e.RGBA,r=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,l=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT),u=e.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function _L(e,t){const n=t();return af().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function SL(e){return!!(af().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function EL(e,t){return DL(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(yL||(yL={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(vL||(vL={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(wL||(wL={}));const NL=/ERROR: [0-9]+:([0-9]+):/g;function $L(e,t){if(_L(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function TL(e,t,n,s,r,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(_L(e,()=>e.bindBuffer(e.ARRAY_BUFFER,s)),_L(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,a,i)),_L(e,()=>e.enableVertexAttribArray(o)),!0)}function AL(e,t,n){_L(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),_L(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function RL(e,t){_L(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),_L(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function FL(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function DL(e,t,n){const s=_L(e,()=>t());if(null==s)throw new Error(n);return s}function OL(e,t=2){return Np(e.slice(0,e.length-t))}function ML(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function zL(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[OL(e),...ML(e)]),t}function LL(e){return e%2==0}function PL(e,t){if($p(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],s=t.slice(-1)[0];if(n===s)return!0;if(LL(n)&&LL(s)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&LL(e[0])&&LL(t[0])}let jL,VL;function WL(e,t){return null!=e.getExtension(t)}function BL(e){try{if(null!=bL(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function qL(e){const t=CL(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),r}function UL(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Cp("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const HL=af();function GL(){let e,t,n,s,r,a,i,o,u,l;return 2===af().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",s="in",r="texture",a="outputColor",i="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",s="varying",r="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:s,texture2D:r,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:l}}function KL(e,t,n="index"){const s=Gp(t);return s.map((t,r)=>`int ${e[r]} = ${n} / ${t}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${t}`:`index -= ${e[r]} * ${t}`};`).join("")}function XL(e){const t=Gp(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}HL.registerFlag("HAS_WEBGL",()=>HL.getNumber("WEBGL_VERSION")>0),HL.registerFlag("WEBGL_VERSION",()=>BL(2)?2:BL(1)?1:0),HL.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),HL.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===HL.get("WEBGL_VERSION")),HL.registerFlag("WEBGL_CPU_FORWARD",()=>!0),HL.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),HL.registerFlag("WEBGL_PACK",()=>HL.getBool("HAS_WEBGL")),HL.registerFlag("WEBGL_PACK_NORMALIZATION",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_PACK_CLIP",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_PACK_REDUCE",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_LAZILY_UNPACK",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_CONV_IM2COL",()=>HL.getBool("WEBGL_PACK")),HL.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==jL){const t=bL(e);jL=t.getParameter(t.MAX_TEXTURE_SIZE)}return jL}(HL.getNumber("WEBGL_VERSION"))),HL.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==VL){const t=bL(e);VL=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,VL)}(HL.getNumber("WEBGL_VERSION"))),HL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=HL.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=bL(e);return t=WL(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:WL(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),HL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>HL.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Jb()),HL.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=bL(e);if(1===e){if(!WL(t,"OES_texture_float"))return!1}else if(!WL(t,"EXT_color_buffer_float"))return!1;return qL(t)}(HL.getNumber("WEBGL_VERSION"))),HL.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!HL.getBool("WEBGL_FORCE_F16_TEXTURES")&&HL.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),HL.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(e){if(0===e)return!1;const t=bL(e);if(1!==e){if(WL(t,"EXT_color_buffer_float"))return qL(t);const e="EXT_color_buffer_half_float";if(WL(t,e)){const n=t.getExtension(e);return function(e,t){const n=CL(e,t),s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(s),e.deleteFramebuffer(r),a}(t,n)}return!1}return!!WL(t,"OES_texture_float")&&!!WL(t,"WEBGL_color_buffer_float")&&qL(t)}(HL.getNumber("WEBGL_VERSION"))),HL.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=HL.getNumber("WEBGL_VERSION"))&&null!=bL(e).fenceSync;var e}),HL.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>HL.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),HL.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),HL.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Jb()&&HL.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});const YL="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class ZL{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=yL.DENSE;const t=kL(e),n=GL();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${KL(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class JL{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=yL.DENSE;const t=kL(e),n=GL();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${KL(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class QL{constructor(e){this.variableNames=["A"],this.outTexUsage=vL.DOWNLOAD;const t=GL();this.outputShape=e,this.userCode=`\n      ${YL}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class eP{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=vL.DOWNLOAD;const t=GL();this.outputShape=e,this.userCode=`\n      ${YL}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class tP{constructor(e,t,n=!1){this.variableNames=["A"];const s=GL(),[r,a]=t;this.outputShape=e;let i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode=`\n      ${XL(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${a};\n        int c = imod(flatIndex, ${a});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${r}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class nP{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=GL(),[r,a]=t;this.outputShape=e;let i="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let t=0;t<=1;t++){const n=2*u+t;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${e[2]}) {\n            localCoords[2] += ${t};\n            if(localCoords[1] + ${u} < ${e[1]}) {\n              localCoords[1] += ${u};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${a};\n              c = imod(flatIndex, ${a});\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${r}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${XL(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${i}\n\n        ${s.output} = ${o};\n      }\n    `}}function sP(e,t,n,s,r,a){!function(e,t){const n=af().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return DL(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return _L(e,()=>e.bindTexture(o,i)),_L(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),_L(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),_L(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),_L(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),_L(e,()=>e.texImage2D(o,0,s,t,n,0,r,a,null)),_L(e,()=>e.bindTexture(e.TEXTURE_2D,null)),i}function rP(e){return e.internalFormatFloat}function aP(e){return e.internalFormatHalfFloat}function iP(e){return e.downloadTextureFormat}function oP(e){return e.internalFormatPackedFloat}function uP(e){return e.internalFormatPackedHalfFloat}class lP{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=af().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){mL[e]=t}(t,e)):this.gl=bL(t);let n="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(1===af().getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=EL(this.gl,"OES_texture_float"),WL(this.gl,e))this.textureHalfFloatExtension=EL(this.gl,e);else if(af().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),WL(this.gl,s))this.colorBufferHalfFloatExtension=EL(this.gl,s);else if(af().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",WL(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!WL(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function(e){return function(e,t){const n=DL(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return _L(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),_L(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=DL(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return _L(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),_L(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return DL(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=CL(this.gl,this.textureHalfFloatExtension)}get debug(){return af().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;_L(e,()=>e.finish()),_L(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),_L(e,()=>e.deleteFramebuffer(this.framebuffer)),_L(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),_L(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),_L(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=xL(t,n);return sP(e,r,a,rP(s),s.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=xL(t,n);return sP(e,r,a,aP(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=xL(t,n);return sP(e,r,a,iP(s),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){_L(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?_L(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):_L(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),_L(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,s){this.throwIfDisposed(),function(e,t,n,s,r,a){let i,o,u;_L(e,()=>e.bindTexture(e.TEXTURE_2D,t)),r instanceof Uint8Array?(i=new Uint8Array(n*s*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*s*4),o=e.FLOAT,u=a.internalFormatPackedFloat),i.set(r),_L(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,s,0,e.RGBA,o,i)),_L(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=IL(t,n);return sP(e,r,a,uP(s),e.RGBA,s.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=IL(t,n);return sP(e,r,a,oP(s),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(RL(this.gl,this.framebuffer),this.outputTexture=null),_L(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,s){const[r,a]=xL(t,n),i=new Uint8Array(t*n*4);return _L(e,()=>e.readPixels(0,0,r,a,s.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,s,r,a){return function(e,t,n,s,r,a,i,o){const u=e,l=new Float32Array(function(e,t){const[n,s]=IL(e,t);return n*s*4}(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,r,a)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const s=e,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const s=function(e,t,n,s){const r=e.createBuffer();_L(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));const a=16*t*n;return _L(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),_L(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),_L(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}(this.gl,t,n);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(af().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,r=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=s.clientWaitSync(r,0,0);return e===s.ALREADY_SIGNALED||e===s.CONDITION_SATISFIED},t=r}else af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const s=new Float32Array(t*n*4);return _L(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,s)),s}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=DL(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(_L(e,()=>e.shaderSource(n,t)),_L(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=NL.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const s=+n[1],r=e.split("\n"),a=r.length.toString().length+2,i=r.map((e,t)=>Rp((t+1).toString(),a)+e);let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const u=i.slice(0,s-1),l=i.slice(s-1,s),c=i.slice(s);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Rp(l[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e);null==this.vertexShader&&(this.vertexShader=function(e){const t=GL();return function(e,t){const n=DL(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(_L(e,()=>e.shaderSource(n,t)),_L(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const s=function(e){return DL(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return _L(t,()=>t.attachShader(s,this.vertexShader)),_L(t,()=>t.attachShader(s,n)),function(e,t){if(_L(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,s),this.debug&&$L(t,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(e,t,n){return _L(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),TL(e,t,"clipSpacePos",n,3,20,0)&&TL(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&_L(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&$L(this.gl,this.program),_L(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return DL(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),_L(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,s){_L(e,()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+e.TEXTURE0;if(s<e.TEXTURE0||s>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),_L(e,()=>e.activeTexture(e.TEXTURE0+n)),_L(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,s)),_L(e,()=>e.uniform1i(n,s))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[s,r]=IL(t,n);this.setOutputMatrixTextureDriver(e,s,r)}setOutputMatrixWriteRegion(e,t,n,s){this.setOutputMatrixWriteRegionDriver(n,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&$L(this.gl,this.program),FL(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),_L(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),_L(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=EL(this.gl,2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){var t=this;return bp(function*(){return yield Fp(()=>t.disposed||t.isQueryAvailable(e,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(e,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||Fp(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),AL(this.gl,e,this.framebuffer),this.debug&&FL(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(AL(this.gl,this.outputTexture,this.framebuffer),this.debug&&FL(this.gl)):RL(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const s=this.gl;AL(s,e,this.framebuffer),this.debug&&FL(s),this.outputTexture=e,_L(s,()=>s.viewport(0,0,t,n)),_L(s,()=>s.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,s){this.throwIfDisposed(),_L(this.gl,()=>this.gl.scissor(e,t,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:cP}=a;function hP(e,t,n,s){const r=[];e.forEach(e=>{const t=Np(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`))});const a=r.join("\n"),i=e.map(e=>function(e,t,n=!1){let s="";return s+=n?pP(e):dP(e),e.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=n?function(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=cP(e.shapeInfo.logicalShape,t.logicalShape),u=wP(i),l=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", ");let p="return outputValue;";const f=1===Np(e.shapeInfo.logicalShape),m=1===Np(t.logicalShape);if(1!==a||f||m){if(f&&!m)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length;if(!e.shapeInfo.isUniform&&a===i&&null==e.shapeInfo.flatOffset&&$p(e.shapeInfo.texShape,t.texShape))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const o=wP(i),u=cP(e.shapeInfo.logicalShape,t.logicalShape),l=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&u.length>=1?"coords = 0;":u.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";return d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", "),`\n    float ${r}() {\n      ${o} coords = getOutputCoords();\n      ${c}\n      return get${s}(${d});\n    }\n  `}(e,t)),s}(e,t,s)).join("\n"),o=t.texShape,u=GL(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,h,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${fP}\n    ${mP}\n    ${gP}\n  `}(u);return t.isPacked?(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if($p(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),r=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),r=s*Math.ceil(e[e.length-2]/2);let a=r,i="",o="b, r, c";for(let u=2;u<e.length-1;u++)a*=e[e.length-u-1],i=`\n      int b${u} = index / ${a};\n      index -= b${u} * ${a};\n    `+i,o=`b${u}, `+o;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${o});\n    }\n  `}(e,t)}}(t.logicalShape,o),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return $p(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=KL(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=KL(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=KL(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=KL(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}var n}(t.logicalShape,o),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),s&&(d+=bP),[d,l,h,a,c,i,n].join("\n")}function dP(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[s,r]=e.shapeInfo.texShape;if(1===s&&1===r)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[a,i]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${a}, ${i}, ${yP(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${vP(e)}\n      }\n    `;const s=e.shapeInfo.texShape,r=s[0],a=s[1];if(1===a&&1===r)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const i=yP(t);return 1===a?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${r}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===r?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${a}, index + ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape;if(null!=r&&$p(t,r))return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:a,keptDims:i}=Mp(t);if(a.length<t.length){const t=["row","col"];return`\n      ${dP(xP(e,a))}\n      float ${s}(int row, int col) {\n        return ${s}(${kP(t,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${vP(e)}\n      }\n    `;const o=r[0],u=r[1],l=yP(n);return 1===u?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${o}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===o?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${l};\n    vec2 uv = uvFromFlat(${o}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[1]*t[2],a=t[2],{newShape:i,keptDims:o}=Mp(t);if(i.length<t.length){const t=["row","col","depth"];return`\n        ${dP(xP(e,i))}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${kP(t,o)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${a}, 1)));\n        ${vP(e)}\n      }\n    `;const u=e.shapeInfo.texShape,l=u[0],c=u[1],h=e.shapeInfo.flatOffset;return c===r&&null==h?`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${l}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===a&&null==h?`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${a} + depth + ${yP(n)};\n        vec2 uv = uvFromFlat(${l}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[3],a=t[2]*r,i=t[1]*a,{newShape:o,keptDims:u}=Mp(t);if(o.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${dP(xP(e,o))}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${kP(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${a}, ${r}, 1)));\n        ${vP(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],d=c[1];return d===i&&null==l?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:d===r&&null==l?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${a} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${yP(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],a=t[3]*r,i=t[2]*a,o=t[1]*i,{newShape:u,keptDims:l}=Mp(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${dP(xP(e,u))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${kP(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${r})) +\n          depth3;\n        ${vP(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];return p===o&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===r&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${r} + depth3 + ${yP(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:a}=Mp(t);if(r.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${dP(xP(e,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${kP(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,u=t[3]*o,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${vP(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===i&&null==h?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${yP(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function pP(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${GL().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e.shapeInfo.texShape,r=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],a=GL();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,a=r[0],i=r[1],o=GL();if(null!=r&&$p(t,r))return`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);\n\n        return ${o.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===t[0]){const n=[1,2],r=["b","row","col"];return`\n        ${pP(xP(e,t.slice(1)))}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${kP(r,n)});\n        }\n      `}const i=a[0],o=a[1],u=Math.ceil(t[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${o}, ${u*Math.ceil(t[1]/2)}, ${u}, b, row, col);\n      return ${GL().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],o=i[0],u=i[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=t[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${r}(${h}) {\n      int index = ${d};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${o});\n      return ${GL().texture2D}(${s}, uv);\n    }\n  `}(e)}}const fP="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",mP="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",gP="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",bP="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function yP(e){return`offset${e}`}function vP(e){const t=e.name,n=Np(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function wP(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function xP(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function kP(e,t){return t.map(t=>e[t]).join(", ")}function IP(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const s=e.logicalShape,r=t[n],a=r.shape;if(!$p(s,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);if(e.isUniform&&r.isUniform)return;const i=e.texShape,o=r.isUniform?null:r.texData.texShape;if(!$p(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)})}const{addImpl:CP,bincountImpl:_P,bincountReduceImpl:SP,ceilImpl:EP,concatImpl:NP,expImpl:$P,expm1Impl:TP,floorImpl:AP,gatherV2Impl:RP,greaterImpl:FP,lessImpl:DP,linSpaceImpl:OP,logImpl:MP,maxImpl:zP,maximumImpl:LP,minimumImpl:PP,multiplyImpl:jP,negImpl:VP,prodImpl:WP,rangeImpl:BP,rsqrtImpl:qP,simpleAbsImpl:UP,sliceImpl:HP,sparseFillEmptyRowsImpl:GP,sparseReshapeImpl:KP,stridedSliceImpl:XP,subImpl:YP,tileImpl:ZP,topKImpl:JP,transposeImpl:QP,uniqueImpl:ej}=i;function tj(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function nj(e,t){return 1===t?[e]:tj(e,t)}class sj{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=nj("rc",t),s=wP(t),r=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let s="";for(let r=e-2;r<e;r++)s+=`${n[r]} >= ${t[r]}`,r<e-1&&(s+="||");return s}(t,e,n),a=function(e,t,n,s){if(1===e)return"";const r=s.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),i=function(e,t){const n=e.length,s=function(e,t){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<e;n++)a=`${t[t.length-1-n]},`+a;n.push(a)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${s[0]}),\n          cEdge ? 0. : getA(${s[1]}),\n          rEdge ? 0. : getA(${s[2]}),\n          rEdge || cEdge ? 0. : getA(${s[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}}class rj{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2==1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}var s;this.userCode=`\n      ${s=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${KL(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${XL(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class aj{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const s=oj(t,n),r=uj(e,s,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const a=ij(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let i;return s===wL.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===wL.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===wL.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===wL.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===wL.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,s){if(null==this.freeTextures)return;const r=oj(n,s),a=uj(t,r,s);a in this.freeTextures||(this.freeTextures[a]=[]);const i=ij(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s),o=af().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[a],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function ij(e,t,n,s,r){const a=function(e,t){switch(e){case wL.PACKED_2X2_FLOAT32:return oP(t);case wL.PACKED_2X2_FLOAT16:return uP(t);case wL.UNPACKED_FLOAT32:return rP(t);case wL.UNPACKED_FLOAT16:return aP(t);case wL.PACKED_4X1_UNSIGNED_BYTE:return iP(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,s);let i;if(r){const[t,n]=IL(e[0],e[1]);i=t*n}else{const[t,n]=xL(e[0],e[1]);i=t*n}return i*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,a)}function oj(e,t){if(e===vL.UPLOAD)return wL.PACKED_2X2_FLOAT32;if(e===vL.RENDER||null==e)return function(e){return af().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?wL.PACKED_2X2_FLOAT32:wL.UNPACKED_FLOAT32:e?wL.PACKED_2X2_FLOAT16:wL.UNPACKED_FLOAT16}(t);if(e===vL.DOWNLOAD||e===vL.PIXELS)return wL.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function uj(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class lj{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const cj="return abs(x);",hj="return x;";class dj{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class pj{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=nj("rc",t),s=wP(t),r=function(e,t){if(1===e)return"rc";let n="";for(let s=0;s<e;s++)n+=t[s],s<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const fj=PI,mj={};class gj extends vp{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!af().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=bL(af().getNumber("WEBGL_VERSION"));this.binaryCache=((t=af().getNumber("WEBGL_VERSION"))in mj||(mj[t]={}),mj[t]),this.gpgpu=new lP(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new aj(this.gpgpu),this.numMBBeforeWarning=null==af().global.screen?1024:af().global.screen.height*af().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new yp(this,kv())}nextDataId(){return gj.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((af().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||af().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:n,values:e,usage:vL.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,s,r){if(af().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:s,values:t,usage:vL.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:s,complexTensorInfos:r,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new dj(i,hj):new lj(i,hj);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:s}],s),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=gb()),c="complex64"===s?yI(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=gb()-l),this.convertAndCacheOnCPU(e,c)}read(e){var t=this;return bp(function*(){if(t.pendingRead.has(e)){const n=t.pendingRead.get(e);return new Promise(e=>n.push(e))}const n=t.texData.get(e),{values:s,shape:r,slice:a,dtype:i,complexTensorInfos:o,isPacked:u}=n;if(null!=a){let n;n=u?new dj(r,hj):new lj(r,hj);const s=t.runWebGLProgram(n,[{dataId:e,shape:r,dtype:i}],i),a=t.read(s.dataId);return t.disposeIntermediateTensorInfo(s),a}if(null!=s)return t.convertAndCacheOnCPU(e);if(!af().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===af().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,h=null;if("complex64"!==i&&af().get("WEBGL_BUFFER_SUPPORTED")){l=t.decode(e);const n=t.texData.get(l.dataId);h=t.gpgpu.createBufferFromTexture(n.texture,...kL(r))}if(t.pendingRead.set(e,[]),"complex64"!==i&&(yield t.gpgpu.createAndWaitForFence()),"complex64"===i){const e=yield Promise.all([t.read(o.real.dataId),t.read(o.imag.dataId)]);c=yI(e[0],e[1])}else if(null==h)c=t.getValuesFromTexture(e);else{const e=Np(r);c=t.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}null!=l&&t.disposeIntermediateTensorInfo(l);const d=t.convertAndCacheOnCPU(e,c),p=t.pendingRead.get(e);return t.pendingRead.delete(e),p.forEach(e=>e(d)),t.pendingDisposal.has(e)&&(t.pendingDisposal.delete(e),t.disposeData(e)&&kv().removeDataId(e,t),t.pendingDeletes--),d})()}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>yb(e))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return qy(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!SL(n)){if(af().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:s}=this.texData.get(e),r=Np(t);if(af().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),s=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(s.texture,...kL(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),a}const a=af().getBool("WEBGL_PACK")&&!0===s,i=a?zL(t):t,o=a?new eP(i):new QL(i),u=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var t=this;return bp(function*(){const n=t.activeTimers,s=[];let r=!1;null==t.programTimersStack?(t.programTimersStack=s,r=!0):t.activeTimers.push(s),t.activeTimers=s,e();const a=Ep(t.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=Ep(t.activeTimers.map(e=>e.name)).filter(e=>null!=e);t.activeTimers=n,r&&(t.programTimersStack=null);const o={uploadWaitMs:t.uploadWaitMs,downloadWaitMs:t.downloadWaitMs,kernelMs:null,wallMs:null};if(af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=yield Promise.all(a);o.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),o.getExtraProfileInfo=()=>e.map((e,t)=>({name:i[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return t.uploadWaitMs=0,t.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:gb(),endMs:null}}endTimer(e){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=gb(),e)}getQueryTime(e){var t=this;return bp(function*(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?t.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:s,usage:r,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,u=this.dataRefCount.get(o);u>1?this.dataRefCount.set(o,u-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(t,s,r,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=128){return af().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&Np(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gI("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return fj(e.shape,t)}packedUnaryOp(e,t,n){const s=new dj(e.shape,t),r=this.compileAndRun(s,[e],n);return kv().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=UP(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(af().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,cj,e.dtype);const t=new lj(e.shape,cj),n=this.compileAndRun(t,[e]);return kv().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&Wp(n[0])){const r=n.map(e=>bb(e));s=this.write(r,e,t)}else s=this.write(n,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:s}=this.makeTensorInfo(e,t,n);return kv().makeTensorFromDataId(s,e,t,this)}unpackTensor(e){const t=new pj(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new sj(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[OL(e.shape),...ML(e.shape)],s={dtype:e.dtype,shape:n,dataId:e.dataId},r=[OL(t),...ML(t)],a=new rj(r,n),i=this.runWebGLProgram(a,[s],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:s,dtype:r}=t,a=zL(s);let i;return i=n?new JL(a):new ZL(a),{dtype:r,shape:s,dataId:this.runWebGLProgram(i,[{shape:a,dtype:r,dataId:e}],r,null,!0).dataId}}runWebGLProgram(e,t,n,s,r=!1){const a=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===yL.DENSE){const t=kL(e.outputShape);i.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===Np(a.shape))return i.values=zp(a.dtype,0),a;const o=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Np(t.shape)<=af().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),o.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!PL(n.shape,t.shape)){const e=t,s=t.shape;t.shape=n.shape,t=this.packedReshape(t,s),o.push(t),n=this.texData.get(t.dataId),e.shape=s}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(a.dataId);const l={shape:a.shape,texData:i,isUniform:!1},c=function(e,t,n){let s="";t.concat(n).forEach(e=>{s+=`${e.shape}_${e.isUniform?"uniform":e.texData.texShape}_${null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0}`});let r=e.constructor.name;return r+="_"+s+"_"+e.userCode,r}(e,u,l),h=this.getAndSaveBinary(c,()=>function(e,t,n,s){const r=t.userCode,a=n.map((e,n)=>{const s={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(s.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:s}}),i=a.map(e=>e.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},u=hP(a,o,r,t.packedInputs),l=e.createProgram(u);let c=null;const h=e.getUniformLocation(l,"NAN",!1);1===af().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(l,"INFINITY",!1));const d={};for(let p=0;p<t.variableNames.length;p++){const n=t.variableNames[p],s=!1;d[n]=e.getUniformLocation(l,n,s),d[`offset${n}`]=e.getUniformLocation(l,`offset${n}`,s)}return{program:t,source:u,webGLProgram:l,uniformLocations:d,inShapeInfos:i,outShapeInfo:o,infLoc:c,nanLoc:h}}(this.gpgpu,e,u,l)),d=null!=this.activeTimers;let p;d&&(p=this.startTimer()),function(e,t,n,s,r){IP(t.inShapeInfos,n),IP([t.outShapeInfo],[s]);const a=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?e.setOutputPackedMatrixTexture(a,i[0],i[1]):e.setOutputMatrixTexture(a,i[0],i[1]),e.setProgram(t.webGLProgram),1===af().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,s)=>{const r=t.program.variableNames[s],a=t.uniformLocations[r],i=t.uniformLocations[`offset${r}`];if(null!=a)if(n.isUniform)if(Np(n.shape)<2)e.gl.uniform1f(a,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,a,s)}),null!=r&&r(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,h,u,l,s),o.forEach(e=>this.disposeIntermediateTensorInfo(e)),d&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));const f=af().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=gb();e-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!af().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),e}return a}compileAndRun(e,t,n,s,r=!1){return this.runWebGLProgram(e,t,n=n||t[0].dtype,s,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(af().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Cv(()=>{if(!af().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=af().getBool("DEBUG");af().set("DEBUG",!1);const t=this.abs($v(1e-8)).dataSync()[0];if(af().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:s,values:r,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const u=null!=this.activeTimers;let l;u&&(l=gb());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=af().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map((t,n)=>n>=e.length-2?Ip(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=Mp(e);e=t.newShape}let s=Np(e);if(e.length<=1&&s<=n)return[1,s];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=OL(e);let n=2,r=2;return e.length&&([n,r]=ML(e)),s=t*(n/2)*(r/2),Ap(s).map(e=>2*e)}return Ap(s)}(n,o),t.texShape=c),null!=r){const e=zL(n);let a,i=c[1],h=c[0];const d=r instanceof Uint8Array;o?([i,h]=IL(c[0],c[1]),a=new nP(e,[h,i],d)):a=new tP(e,[h,i],d);const p=this.makeTensorInfo([h,i],s);this.texData.get(p.dataId).usage=d?vL.PIXELS:vL.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),i,h,r);const f=this.runWebGLProgram(a,[p],s,null,!0),m=this.texData.get(f.dataId);t.texture=m.texture,t.texShape=m.texShape,t.isPacked=m.isPacked,t.usage=m.usage,this.disposeIntermediateTensorInfo(p),this.texData.delete(f.dataId),t.values=null,u&&(this.uploadWaitMs+=gb()-l)}else{const e=this.acquireTexture(c,i,s,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:s}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,s)),n.values}acquireTexture(e,t,n,s){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*Vp(t)}}gj.nextDataId=0,Qb()&&Ev("webgl",()=>new gj,2);class bj{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=xw(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class yj{constructor(e,t,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=xw(t,n);const r=this.outputShape.length;let a="";if(s)if(0===r||1===Np(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${wP(r)} coords = getOutputCoords();\n        `,1===r)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=nj("coords",r);a+=`\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function vj(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const wj={kernelName:km,backendName:"webgl",kernelFunc:vj};function xj(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,a=n.makeTensorInfo(s.shape,"complex64"),i=n.texData.get(a.dataId),o=vj({inputs:{x:s},backend:n}),u=vj({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:u},a}const kj={kernelName:Of,backendName:"webgl",kernelFunc:xj},Ij="return (a < 0.) ? b * a : a;",Cj="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",_j={kernelName:Nm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:a}=s,i=n.makeTensorInfo([],"float32",fb(a,"float32")),o=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yj(Cj,r.shape,i.shape):new bj(Ij,r.shape,i.shape),u=n.runWebGLProgram(o,[r,i],r.dtype);return n.disposeIntermediateTensorInfo(i),u}},Sj="return (a < 0.) ? b * a : a;",Ej="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Nj={kernelName:lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t,a=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yj(Ej,s.shape,r.shape):new bj(Sj,s.shape,r.shape);return n.runWebGLProgram(a,[s,r],s.dtype)}};function $j({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:a})=>{const{x:i}=r,o=a,u=s||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,u);return o.makeTensorInfo(i.shape,u,t)}let l;return l=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new dj(i.shape,t):new lj(i.shape,e),o.runWebGLProgram(l,[i],u)}}function Tj({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:i,backend:o})=>{const{a:u,b:l}=i,c=o;if(s&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[s,r]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,s]=t,r={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:s.dataId,dtype:s.dtype,shape:l.shape},i=new bj(e,u.shape,l.shape);return c.runWebGLProgram(i,[r,a],jb(n.dtype,s.dtype))}),a=xj({inputs:{real:s,imag:r},backend:c});return c.disposeIntermediateTensorInfo(s),c.disposeIntermediateTensorInfo(r),a}const h=a||jb(u.dtype,l.dtype);if(c.shouldExecuteOnCPU([u,l])&&null!=r){const e=c.texData.get(u.dataId),t=c.texData.get(l.dataId),[n,s]=r(u.shape,l.shape,e.values,t.values,h),a=c.makeTensorInfo(s,h);return c.texData.get(a.dataId).values=n,a}let d;return d=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new yj(t,u.shape,l.shape,n):new bj(e,u.shape,l.shape),c.runWebGLProgram(d,[u,l],h)}}function Aj(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?Ej:Sj;if("leakyrelu"===e)return t?Cj:Ij;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Rj{constructor(e,t,n,s=!1,r=!1,a=!1,i=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const l=Math.ceil((s?e[1]:e[2])/2),c=s?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",d=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";i&&(f=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,m="result = activation(result);");const g=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",y="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(y=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${b};\n          int batchB = ${y};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class Fj{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=xw(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Dj="return a * b;";function Oj(e){const{inputs:t,backend:n}=e,{a:s,b:r}=t,a=jb(s.dtype,r.dtype);if("complex64"===s.dtype){const e=n.texData.get(s.dataId),t=n.texData.get(r.dataId),a=new Fj("return areal * breal - aimag * bimag;",s.shape,r.shape),i=new Fj("return areal * bimag + aimag * breal;",s.shape,r.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:s.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],u=n.runWebGLProgram(a,o,"float32"),l=n.runWebGLProgram(i,o,"float32"),c=xj({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([s,r])){const e=n.texData.get(s.dataId),t=n.texData.get(r.dataId),[i,o]=jP(s.shape,r.shape,e.values,t.values,a),u=n.makeTensorInfo(o,a);return n.texData.get(u.dataId).values=i,u}let i;return i=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yj(Dj,s.shape,r.shape):new bj(Dj,s.shape,r.shape),n.runWebGLProgram(i,[s,r],a)}const Mj={kernelName:Jm,backendName:"webgl",kernelFunc:Oj};function zj(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:a}=s,i=n,o=Np(r.shape),u=Dp(a,o),l=Np(u);Cp(o===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(r.dataId);return!c.isPacked||PL(r.shape,u)||null!==c.texture&&PL(c.shape,u)?(i.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype}):function(e,t,n){const s=[OL(e.shape),...ML(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},a=[OL(t),...ML(t)],i=new rj(a,s),o=n.runWebGLProgram(i,[r],e.dtype,null,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}(r,u,i)}const Lj={kernelName:mg,backendName:"webgl",kernelFunc:zj};class Pj{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:a}=e;this.outputShape=[s,a];const i=4*Math.floor(n/4),o=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${Tp(e)?e.toPrecision(2):e}, ones);`}let l="";r%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class jj{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:a}=e;this.outputShape=[s,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function Vj(e,t,n,s){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],s=Zk(n);t.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return t}(e.shape);let a=e;for(let i=0;i<r.length;i++){const{inSize:o,windowSize:u,outSize:l}=r[i];let c,h;c="mean"===n?0===i?new Pj({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},o):new Pj({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l}):new jj({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},n),h=a,a=s.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&s.disposeIntermediateTensorInfo(h)}return a}class Wj{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const s=wP(this.rank),r=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<e.length;r++)s[e[r]]=n[r];return s.join()}(t);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class Bj{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=wP(this.rank),r=tj("rc",this.rank),a=new Array(this.rank);for(let l=0;l<t.length;l++)a[t[l]]=r[l];const i=`vec2(${a.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${o}) {\n        result[1] = ${u};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${o}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function qj(e,t,n){const s=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bj(e.shape,t):new Wj(e.shape,t);return n.runWebGLProgram(s,[e],e.dtype)}function Uj(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s;return function(e,t,n,s){const r=e.shape.length,a=Op(t,e.shape);let i=a;const o=Zw(i,r),u=null!=o;let l=e;u&&(l=qj(e,o,s),i=Qw(i.length,r)),Yw("sum",i,r);const[c,h]=Kw(l.shape,i);let d=c;n&&(d=Xw(c,a));const p=Np(h),f=zj({inputs:{x:l},attrs:{shape:[Np(e.shape)/p,p]},backend:s}),m=Vj(f,Vb(e.dtype),"sum",s),g=zj({inputs:{x:m},attrs:{shape:d},backend:s});return s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(m),u&&s.disposeIntermediateTensorInfo(l),g}(r,a,i,n)}const Hj={kernelName:Dg,backendName:"webgl",kernelFunc:Uj};function Gj(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{perm:a}=s,i=n,o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[a[l]];let u;if(i.shouldExecuteOnCPU([r])){const e=i.texData.get(r.dataId),t=QP(e.values,r.shape,r.dtype,a,o);u=i.makeTensorInfo(o,r.dtype),i.texData.get(u.dataId).values=t}else u=qj(r,a,i);return u}const Kj={kernelName:Yg,backendName:"webgl",kernelFunc:Gj};function Xj({a:e,b:t,transposeA:n,transposeB:s,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,h=n?e.shape[l-2]:e.shape[l-1],d=s?t.shape[c-1]:t.shape[c-2],p=n?e.shape[l-1]:e.shape[l-2],f=s?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=Np(m),y=Np(g);Cp(l>=2&&c>=2&&(b===y||1===b||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const v=(b>y?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([p,f]);Cp(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${s} must match.`);const w=n?[b,h,p]:[b,p,h],x=s?[y,f,d]:[y,d,f],k=zj({inputs:{x:e},backend:r,attrs:{shape:w}}),I=zj({inputs:{x:t},backend:r,attrs:{shape:x}}),C=[k,I],_=Math.max(b,y),S=n?k.shape[1]:k.shape[2],E=null!=a,N=null!=i,$="leakyrelu"===u,T=null!=u?Aj(u,!0):null;let A;if((1===p||1===f)&&S>1e3&&!1===(E||N||$||null!=T)){let e=k,t=I;n&&(e=Gj({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),C.push(e)),s&&(t=Gj({inputs:{x:I},backend:r,attrs:{perm:[0,2,1]}}),C.push(t));const a=1===f;let i=e;1!==f&&(i=zj({inputs:{x:e},backend:r,attrs:{shape:[_,S,1]}}),C.push(i));const o=1===f?2:1;let u=t;a&&(u=zj({inputs:{x:t},backend:r,attrs:{shape:[_,1,S]}}),C.push(u));const l=Oj({inputs:{a:i,b:u},backend:r});A=Uj({inputs:{x:l},backend:r,attrs:{axis:o,keepDims:!0}}),C.push(l)}else{const u=jb(e.dtype,t.dtype),l=new Rj(w,x,[_,p,f],n,s,E,T,N,$),c=[k,I];if(null!=a&&c.push(a),N&&c.push(i),$){const e=r.makeTensorInfo([],"float32",fb(o,"float32"));c.push(e),C.push(e)}A=r.runWebGLProgram(l,c,u)}const R=zj({inputs:{x:A},backend:r,attrs:{shape:v}});C.push(A);for(const F of C)r.disposeIntermediateTensorInfo(F);return R}const Yj={kernelName:sb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=s;return Xj({a:r,b:a,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},Zj="return abs(x);",Jj={kernelName:hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const e=n.texData.get(s.dataId),t=UP(e.values);return n.makeTensorInfo(s.shape,s.dtype,t)}let r;return r=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new dj(s.shape,Zj):new lj(s.shape,Zj),n.runWebGLProgram(r,[s],s.dtype)}},Qj=$j({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),eV={kernelName:df,backendName:"webgl",kernelFunc:Qj},tV=$j({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),nV={kernelName:pf,backendName:"webgl",kernelFunc:tV},sV="return a + b;",rV=Tj({opSnippet:sV,packedOpSnippet:sV,supportsComplex:!0,cpuKernelImpl:CP}),aV={kernelName:ff,backendName:"webgl",kernelFunc:rV};class iV{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const s=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class oV{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const s=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const uV={kernelName:mf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s}=t,r=n;if(1===r.length)return vj({inputs:{x:r[0]},backend:s});if(r.length>af().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:s}),a=e({inputs:r.slice(t),backend:s});return e({inputs:[n,a],backend:s})}const a=r.map(e=>e.dtype).reduce((e,t)=>jb(e,t)),i=r.map(e=>e.shape),o=af().getBool("WEBGL_PACK")?new oV(r[0].shape,i):new iV(r[0].shape,i);return s.runWebGLProgram(o,r,a)}},lV={kernelName:gf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=Op(a,r.shape);let l=u;const c=Zw(l,o);let h=r;null!=c&&(h=Gj({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Qw(l.length,o)),Yw("all",l,o);const[d,p]=Kw(h.shape,l),f=zj({inputs:{x:h},backend:n,attrs:{shape:[-1,Np(p)]}}),m=Vj(f,f.dtype,"all",n);let g;return g=zj(i?{inputs:{x:m},backend:n,attrs:{shape:Xw(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},cV={kernelName:bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=Op(a,r.shape);let l=u;const c=Zw(l,o);let h=r;null!=c&&(h=Gj({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Qw(l.length,o)),Yw("any",l,o);const[d,p]=Kw(h.shape,l),f=zj({inputs:{x:h},backend:n,attrs:{shape:[-1,Np(p)]}}),m=Vj(f,f.dtype,"any",n);let g;return g=zj(i?{inputs:{x:m},backend:n,attrs:{shape:Xw(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class hV{constructor(e,t,n){this.variableNames=["A"];const{windowSize:s,batchSize:r,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,a],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class dV{constructor(e,t,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Cp(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const r=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),r>1&&this.outputShape.push(r),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,i=a.length,o=wP(i),u=nj("coords",i);let l,c;if(1===r){c=i+1;const e=wP(c);l=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[i-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[i-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[i-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[i-2]};`}else c=i,l=`\n        ${o} sourceLocR = coords;\n        ++${u[i-1]};\n        ${o} sourceLocG = coords;\n        ++${u[i-2]};\n        ${o} sourceLocA = coords;\n        --${u[i-1]};\n        ${o} sourceLocB = coords;\n        --${u[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,c),d="."+h[c-1],p=h.map(e=>"int "+e),f=nj("sourceLocR",c-1).concat("inIdx.r"),m=nj("sourceLocG",c-1).concat("inIdx.g"),g=nj("sourceLocB",c-1).concat("inIdx.b"),b=nj("sourceLocA",c-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",v=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,x=s?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${x}\n      void main() {\n        ${o} coords = getOutputCoords();\n        bool hasNextCol = ${u[i-1]} < ${a[i-1]-1};\n        bool hasNextRow = ${u[i-2]} < ${a[i-2]-1};\n        ${l}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function pV(e,t,n,s=null){let r=t.shape[0],a=t.shape[1];null!=s&&(r=s.shape[0],a=s.shape[1]);const i=Zk(a),o={windowSize:i,inSize:a,batchSize:r,outSize:Math.ceil(a/i)},u=new hV(o,n,null==s),l=[t];null!=s&&l.push(s);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const h=pV(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function fV(e,t,n,s=null){const r=null!=s?s.shape:t.shape,a=Zk(r[r.length-1]),i=new dV(r,a,n,null==s),o=e.runWebGLProgram(i,null==s?[t]:[t,s],"int32");if(o.shape.length===t.shape.length){const s=fV(e,t,n,o);return e.disposeIntermediateTensorInfo(o),s}return o}function mV(e,t,n,s){const r=[n];if(Yw("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!af().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[a,i]=Kw(t.shape,r),o=Np(i),u=zj({inputs:{x:t},backend:e,attrs:{shape:[-1,o]}});n.push(u);const l=pV(e,u,s);n.push(l);const c=zj({inputs:{x:l},backend:e,attrs:{shape:a}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),c}return fV(e,t,s)}const gV={kernelName:yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;let i=Op(a,r.shape);const o=Zw(i,r.shape.length);let u=r;const l=[];null!=o&&(u=Gj({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Qw(i.length,u.shape.length)),Yw("argMax",[i[0]],u.shape.length);const c=mV(n,u,i[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},bV={kernelName:vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;let i=Op(a,r.shape);const o=Zw(i,r.shape.length);let u=r;const l=[];null!=o&&(u=Gj({inputs:{x:r},backend:n,attrs:{perm:o}}),l.push(u),i=Qw(i.length,u.shape.length)),Yw("argMin",[i[0]],u.shape.length);const c=mV(n,u,i[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},yV=$j({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),vV={kernelName:wf,backendName:"webgl",kernelFunc:yV},wV=$j({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),xV={kernelName:xf,backendName:"webgl",kernelFunc:wV},kV=$j({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),IV={kernelName:kf,backendName:"webgl",kernelFunc:kV},CV=Tj({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),_V={kernelName:Cf,backendName:"webgl",kernelFunc:CV},SV=$j({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),EV={kernelName:If,backendName:"webgl",kernelFunc:SV};class NV{constructor(e,t,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`:`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / count");const b=4*Math.floor(a/4),y=a%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${b}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${b};\n          if (${1===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class $V{constructor(e,t,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let v="0.0";if(y||(v="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / count");const x=4*Math.floor(a/4),k=a%4,I=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${I}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${I}\n            }\n          }\n          setOutput(${w});\n        }\n      }\n    `}}const TV={kernelName:_f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;UL(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;Cp(Gv(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=zv(r.shape,a,i,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))return vj({inputs:{x:r},backend:n});const c=new NV(l,"avg",!1);return n.runWebGLProgram(c,[r],"float32")}},AV={kernelName:Ef,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=s,c=Lv(r.shape,a,i,[1,1,1],o,u,l),h=new $V(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class RV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n            wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${e.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,s=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${s-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterDepth*e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n            wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const DV={kernelName:Nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s,h=Lv(i.shape,o,u,[1,1,1],l,c),d=new FV(h);return n.runWebGLProgram(d,[r],i.dtype)}},OV={kernelName:Sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,i=a;UL([r,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=s,c=zv(i.shape,o,u,1,l),h=new RV(c);return n.runWebGLProgram(h,[r],i.dtype)}},MV={kernelName:$f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a}=t,{transposeA:i,transposeB:o}=s;return Xj({a:r,b:a,transposeA:i,transposeB:o,backend:n})}};class zV{constructor(e,t,n,s,r,a){this.outputShape=[],this.variableNames=["x","mean","variance"],xw(e,t),xw(e,n);let i="0.0";null!=s&&(xw(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=r&&(xw(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class LV{constructor(e,t,n,s,r,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],xw(e,t),xw(e,n);let i="vec4(0.0)";null!=s&&(xw(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=r&&(xw(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const PV={kernelName:bm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,mean:r,variance:a,offset:i,scale:o}=e;Cp(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Cp(null==i||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Cp(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[s,r,a];let c=null;null!=i&&(c=i.shape,l.push(i));let h=null;null!=o&&(h=o.shape,l.push(o));const d=af().getBool("WEBGL_PACK_NORMALIZATION")?new LV(s.shape,r.shape,a.shape,c,h,u):new zV(s.shape,r.shape,a.shape,c,h,u);return t.runWebGLProgram(d,l,l[0].dtype)}};class jV{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=wP(this.rank),n=`uniform int start[${this.rank}];`,s=function(e){if(1===e)return"sourceLoc";if(e<=6)return VV.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${VV[t]} = start[${t}] + coords.${VV[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const VV=["x","y","z","w","u","v"];class WV{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=wP(this.rank),n=nj("coords",this.rank),s=nj("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,a=`getChannel(getSource(${s.join()}), ${r})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${a};\n        --${s[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${s[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function BV(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,size:i}=s,[o,u]=bv(r,a,i);if(sv(r,o,u),0===Np(u))return n.makeTensorInfo(u,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=HP(e.values,o,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),c=mv(r.shape,o,u);if(l||!c){const e=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WV(u):new jV(u),t=e.getCustomSetupFunc(o);return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,s){const r=s.texData.get(e.dataId),a=s.makeTensorInfo(n,e.dtype),i=s.texData.get(a.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=gv(t,Gp(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};const u=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,u+1),a}(r,o,u,n)}const qV={kernelName:Eg,backendName:"webgl",kernelFunc:BV},UV={kernelName:Tf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,crops:i}=s;Cp(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),u=Qk(r.shape,a,o),l=eI(u.length,a.length),c=tI(r.shape,a,o),h=nI(i,a.length),d=sI(c,i,a.length),p=[],f=zj({inputs:{x:r},backend:n,attrs:{shape:u}}),m=Gj({inputs:{x:f},backend:n,attrs:{perm:l}}),g=zj({inputs:{x:m},backend:n,attrs:{shape:c}}),b=BV({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},HV={kernelName:Af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:i}=s,o=n.readSync(r.dataId),u=n.readSync(a.dataId),l=_P(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}},GV=Tj({opSnippet:"return float(a != b);",dtype:"bool"}),KV={kernelName:eg,backendName:"webgl",kernelFunc:GV};function XV(e){const{inputs:t,backend:n}=e,{input:s}=t;return vj({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.real},backend:n})}const YV={kernelName:dg,backendName:"webgl",kernelFunc:XV},ZV={kernelName:Rf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s,attrs:r}=t,{x:a}=n,{dtype:i}=r;if("complex64"===i){if("complex64"===a.dtype)return vj({inputs:{x:a},backend:s});const t=ax(a.shape),n=e({inputs:{x:a},backend:s,attrs:{dtype:"float32"}}),r=xj({inputs:{real:n,imag:t},backend:s});return t.dispose(),s.disposeIntermediateTensorInfo(n),r}if("complex64"===a.dtype){const t=XV({inputs:{input:a},backend:s}),n=e({inputs:{x:t},backend:s,attrs:{dtype:i}});return s.disposeIntermediateTensorInfo(t),n}if(!Pp(a.dtype,i)){const e=vj({inputs:{x:a},backend:s});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i)return function(e,t){const n=new lj(e.shape,"return float(int(x));"),s=t.runWebGLProgram(n,[e],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(a,s);if("bool"===i){const e=s.makeTensorInfo([],"bool",zp("bool",1)),t=GV({inputs:{a:a,b:e},backend:s});return s.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},JV="return ceil(x);",QV=$j({opSnippet:JV,packedOpSnippet:JV,cpuKernelImpl:EP}),eW={kernelName:Ff,backendName:"webgl",kernelFunc:QV};class tW{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class nW{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const sW={kernelName:Df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{clipValueMin:a,clipValueMax:i}=s;let o;o=af().getBool("WEBGL_PACK_CLIP")?new nW(r.shape):new tW(r.shape);const u=o.getCustomSetupFunc(a,i);return n.runWebGLProgram(o,[r],r.dtype,u)}};class rW{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function aW(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const iW={kernelName:Mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=n.texData.get(s.dataId),a=new rW(s.shape),i=[aW(s,r.complexTensorInfos.real),aW(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class oW{constructor(e){this.outputShape=[],this.outputShape=Xk(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++)n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${t[s-1]}));`);n.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class uW{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Xk(e,t);const n=this.outputShape,s=n.length,r=wP(s),a=nj("coords",s),i=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((e,t)=>`T${t}`);const o=new Array(e.length-1);o[0]=e[0][t];for(let p=1;p<o.length;p++)o[p]=o[p-1]+e[p][t];const u=i[t],l=i.slice(-2),c=i.join();let h=`if (${u} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let p=1;p<o.length;p++){const e=o[p-1];h+=`\n        if (${u} < ${o[p]}  && ${u} >= ${o[p-1]}) {\n          return getChannel(\n            getT${p}(${lW(i,u,e)}),\n            vec2(${lW(l,u,e)}));\n        }`}const d=o[o.length-1];h+=`\n        return getChannel(\n          getT${o.length}(${lW(i,u,d)}),\n          vec2(${lW(l,u,d)}));`,this.userCode=`\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[s-1]} = ${a[s-1]} + 1;\n        if (${a[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[s-2]} = ${a[s-2]} + 1;\n        if (${a[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[s-1]} = ${a[s-1]} - 1;\n        if (${a[s-2]} < ${n[s-2]} &&\n            ${a[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function lW(e,t,n){const s=e.indexOf(t);return e.map((e,t)=>t===s?`${e} - ${n}`:e).join()}function cW(e){const{inputs:t,backend:n}=e,{input:s}=t;return vj({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.imag},backend:n})}const hW={kernelName:Cm,backendName:"webgl",kernelFunc:cW};function dW(e,t,n){const s=e[0].dtype;if("complex64"===s){const s=e.map(e=>XV({inputs:{input:e},backend:n})),r=e.map(e=>cW({inputs:{input:e},backend:n})),a=dW(s,t,n),i=dW(r,t,n),o=xj({inputs:{real:a,imag:i},backend:n});return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),r.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let r=n.shouldExecuteOnCPU(e);if("string"===s&&(r=!0),r){const r=e.map(e=>{const s=Np(e.shape.slice(t));return zj({inputs:{x:e},backend:n,attrs:{shape:[-1,s]}})}),a=r.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=Xk(r.map(e=>e.shape),1),o=NP(a,i,s,1===r[0].shape[0]),u=Xk(e.map(e=>e.shape),t),l=n.makeTensorInfo(u,s,o);return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}if(e.length>af().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const s=Math.floor(e.length/2),r=dW(e.slice(0,s),t,n),a=dW(e.slice(s),t,n),i=dW([r,a],t,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}if(af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const r=new uW(e.map(e=>e.shape),t);return n.runWebGLProgram(r,e,s)}const{tensors2D:a,outShape:i}=function(e,t,n){const s=Xk(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>zj({inputs:{x:e},attrs:{shape:[-1,Np(e.shape.slice(t))]},backend:n})),outShape:s}}(e,t,n),o=new oW(a.map(e=>e.shape)),u=n.runWebGLProgram(o,a,s);a.forEach(e=>n.disposeIntermediateTensorInfo(e));const l=zj({inputs:{x:u},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(u),l}function pW(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,a=Op(r,t[0].shape)[0],i=Xk(t.map(e=>e.shape),a);if(0===Np(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>Np(e.shape)>0);return 1===o.length?vj({inputs:{x:o[0]},backend:n}):(Kk(o.map(e=>e.shape),a),dW(o,a,n))}const fW={kernelName:zf,backendName:"webgl",kernelFunc:pW};class mW{constructor(e,t=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let v="",w="";n&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${w}\n        setOutput(result);\n      }\n    `}}class gW{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,s=e.padInfo.left,r=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class bW{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:s,inChannels:r,strideWidth:a,strideHeight:i,padInfo:o,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=o,f=r*s,m=GL(),g="channelsLast"===h,b=g?0:1,y=g?1:2;let v="";for(let w=0;w<=1;w++)for(let n=0;n<=1;n++)v+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${w};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${i} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[b]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${a}. - ${d}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${t[y]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*w+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*w+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}function yW({x:e,filter:t,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u=e.shape,l=s.texData.get(e.dataId),c="channelsLast"===n.dataFormat;let h;const d=[],p=u[2]%2!=0&&!!l.isPacked;if((1!=u[0]*u[1]*u[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&af().getBool("WEBGL_LAZILY_UNPACK")&&af().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&p){const p={dataId:e.dataId,shape:[1,c?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),n.inChannels],dtype:e.dtype},f=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Cp(PL(l.shape,p.shape),()=>`packed reshape ${l.shape} to ${p.shape} isn't free`);const m=zj({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});d.push(m);const g=Xj({a:p,b:m,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),b=s.texData.get(g.dataId);Cp(b.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=f,b.shape=n.outShape,h=vj({inputs:{x:g},backend:s}),h.shape=n.outShape,d.push(g)}else{const l=zj({inputs:{x:e},backend:s,attrs:{shape:[1,c?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),p=zj({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=Xj({a:l,b:p,transposeA:!1,transposeB:!1,backend:s,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i});h=zj({inputs:{x:f},backend:s,attrs:{shape:n.outShape}}),d.push(l),d.push(p),d.push(f)}for(const f of d)s.disposeIntermediateTensorInfo(f);return h}function vW({x:e,filter:t,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=u*l*c,g=d*h,b=[m,g],y=[],v=zj({inputs:{x:e},backend:s,attrs:{shape:e.shape.slice(1)}}),w=zj({inputs:{x:t},backend:s,attrs:{shape:[1,m,Np(t.shape)/m]}});y.push(v),y.push(w);const x=new bW(b,v.shape,n),k=s.runWebGLProgram(x,[v],"float32"),I=zj({inputs:{x:k},backend:s,attrs:{shape:[1,b[0],b[1]]}});y.push(k),y.push(I);const C=null!=r,_=null!=a,S="leakyrelu"===o,E=o?Aj(o,!0):null,N=new Rj(I.shape,w.shape,[1,g,n.outChannels],!0,!1,C,E,_,S),$=[I,w];if(r&&$.push(r),_&&$.push(a),S){const e=s.makeTensorInfo([],"float32",fb(i,"float32"));$.push(e),y.push(e)}const T=s.runWebGLProgram(N,$,"float32"),A=zj({inputs:{x:T},backend:s,attrs:{shape:f?[1,d,h,n.outChannels]:[1,n.outChannels,d,h]}});y.push(T);for(const R of y)s.disposeIntermediateTensorInfo(R);return A}const wW={kernelName:Lf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=s,h=Kv(u),d=Pv(r.shape,a.shape,i,l,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(af().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])p=vW({x:r,filter:a,convInfo:d,backend:n});else{const e=new mW(d);p=n.runWebGLProgram(e,[r,a],"float32")}else p=yW({x:r,filter:a,convInfo:d,backend:n});const f=zj({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class xW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===e.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class kW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,s="channelsLast"===e.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${s?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class IW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${e.strideDepth} - ${e.padInfo.front};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class CW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,s=e.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${s-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const _W={kernelName:Pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,h=Kv(u),d=Pv(r.shape,c,i,1,o,l,!1,h),p=new xW(d);return n.runWebGLProgram(p,[r,a],"float32")}},SW={kernelName:jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=s,h=Kv(l),d=Pv(i,a.shape,o,1,u,c,!1,h),p=new kW(d);return n.runWebGLProgram(p,[r,a],"float32")}},EW={kernelName:Vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u}=s,l=jv(r.shape,a.shape,i,u,o),c=new gW(l);return n.runWebGLProgram(c,[r,a],"float32")}},NW={kernelName:Wf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:i,pad:o,filterShape:u}=s,l=jv(r.shape,u,i,1,o),c=new IW(l);return n.runWebGLProgram(c,[r,a],"float32")}},$W={kernelName:Bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{pad:i,strides:o,inputShape:u}=s,l=jv(u,a.shape,o,1,i),c=new CW(l);return n.runWebGLProgram(c,[r,a],"float32")}},TW=$j({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),AW={kernelName:qf,backendName:"webgl",kernelFunc:TW},RW=$j({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),FW={kernelName:Uf,backendName:"webgl",kernelFunc:RW};class DW{constructor(e,t,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,u]=e,[l]=t,[c,h]=n;this.outputShape=[l,c,h,u];const d="bilinear"===s?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,b]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,v,w]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const OW={kernelName:Gf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=s,c=new DW(r.shape,a.shape,o,u,l);return n.runWebGLProgram(c,[r,a,i],"float32")}};class MW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const s=e.length,r=t?"0.0":`getX(${zW(s,"coords")})`,a=e[e.length-1];let i="",o="";t?(i=n?"end != "+(a-1):"end != 0",o=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${a}`:"end >= pow2",o=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${wP(s)} coords = getOutputCoords();\n        int end = ${LW(s,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${i}) {\n          int idx = ${o};\n          ${LW(s,"coords")} = idx;\n          val += getX(${zW(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function zW(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function LW(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const PW={kernelName:Hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,exclusive:i,reverse:o}=s,u=r.shape.length,l=Zw([a],u);let c=r;null!=l&&(c=Gj({inputs:{x:r},backend:n,attrs:{perm:l}}));const h=Qw(1,u)[0];if(h!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${a}`);const d=c.shape[h];let p=vj({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const e=new MW(c.shape,!1,o),t=e.getCustomSetupFunc(f),s=p;p=n.runWebGLProgram(e,[p],p.dtype,t),n.disposeIntermediateTensorInfo(s)}if(i){const e=new MW(c.shape,i,o),t=p;p=n.runWebGLProgram(e,[p],p.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=Gj({inputs:{x:p},backend:n,attrs:{perm:Jw(l)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),e}return p}},jW={kernelName:Kf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:i,binaryOutput:o}=s;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(a.dataId),s=_P(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,s)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(a),s=SP(e,t,i,o);return n.makeTensorInfo(s.shape,a.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class VW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const WW={kernelName:Xf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:a,dataFormat:i}=s;Cp(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const o=r.shape[0],u=("NHWC"===i?r.shape[1]:r.shape[2])*a,l=("NHWC"===i?r.shape[2]:r.shape[3])*a,c=("NHWC"===i?r.shape[3]:r.shape[1])/(a*a),h=new VW("NHWC"===i?[o,u,l,c]:[o,c,u,l],a,i);return n.runWebGLProgram(h,[r],r.dtype)}};class BW{constructor(e,t=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.inHeight,i=e.inWidth,o=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",b="";n&&(g=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${a}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${i}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${b}\n        setOutput(result);\n      }\n    `}}class qW{constructor(e,t=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const a=e.outChannels/e.inChannels,i=e.inHeight,o=e.inWidth,u=e.padInfo.top,l=e.padInfo.left,c=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=m;let b="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let x=0;x<m;x++)b+=`\n          vec4 xTexelC${2*x};\n          int xTexelC${2*x}Ready;\n          vec4 xC${x};`;for(let x=0;x<f;x++){for(let e=0;e<m;e++)b+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xC${e} = vec4(0.0);`;b+=`\n        xR = xRCorner + ${x*d};\n        if (xR >=0 && xR < ${i}) {\n      `;for(let e=0;e<(g+1)/2;e++){const t=2*e,n=t*p;if(b+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(t<m&&(l%2==1?(b+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,b+=1===p&&n>0?`\n                xC${t} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${o}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):b+=`\n                if (xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${t} = xTexelC${n};\n                `,n+1<m)){const e=l%2==0?Ip(p):p;p%2==0&&l%2==1||p%2!=0&&l%2!=1?(b+=`\n                  xCOffset = xC + ${l%2} + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,p>1&&(b+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),b+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):b+=1===e?`\n                    xC${t+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${o}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${n+2};\n                    `}}else n<m&&(l%2==1?(b+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(b+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(b+=`\n                if(xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(b+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));t<m&&(b+=`\n            wTexel = getW(${x}, ${n}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(b+=`\n              wTexel = getW(${x}, ${n+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}b+="\n        }\n      "}let y="",v="";n&&(y=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${u}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${b}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}const UW={kernelName:Yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=s;let c=u;null==c&&(c=[1,1]),Cp(Gv(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=Pv(r.shape,a.shape,i,c,o,l,!0);let d;return d=af().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new qW(h):new BW(h),n.runWebGLProgram(d,[r,a],"float32")}};class HW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class GW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,s=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const KW={kernelName:Zf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=s,h=Pv(r.shape,c,i,o,u,l,!0),d=new HW(h);return n.runWebGLProgram(d,[r,a],"float32")}},XW={kernelName:Jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=s,h=Pv(c,a.shape,i,o,u,l,!0),d=new GW(h);return n.runWebGLProgram(d,[r,a],"float32")}};class YW{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const ZW={kernelName:Qf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=[...s.shape,...s.shape],a=Np(s.shape),i=zj({inputs:{x:s},backend:n,attrs:{shape:[a]}}),o=new YW(a),u=n.runWebGLProgram(o,[i],i.dtype),l=zj({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}};class JW{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:s,strideHeight:r,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:u,dilationWidth:l}=e,{top:c,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const QW={kernelName:em,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u}=s,l=Mv(r.shape,a.shape,i,o,"NHWC",u);let c;const h=new JW(l);c=n.runWebGLProgram(h,[r,a],"float32");const d=zj({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),d}},eB={kernelName:rm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,a=t,{allDims:i,summedDims:o,idDims:u}=EI(r,a.length);$I(i.length,u,a);const{path:l,steps:c}=TI(o,u),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:s}=NI(p,u[e]);let r;AI(t)?r=a[e]:(r=Gj({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(r));const i=r.shape.slice();for(let e=0;e<s.length;++e)i.splice(s[e],0,1);$p(r.shape,i)||(r=zj({inputs:{x:r},backend:n,attrs:{shape:i}}),f.push(r)),null===d?d=r:(d=Oj({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=Uj({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},tB=$j({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),nB={kernelName:am,backendName:"webgl",kernelFunc:tB},sB={kernelName:im,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:s,y:r}=t,a=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new yj("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new bj("return (b >= 1.0) ? a : a * (b + 1.0);",s.shape,r.shape);return n.runWebGLProgram(a,[s,r],s.dtype)}},rB=Tj({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),aB={kernelName:um,backendName:"webgl",kernelFunc:rB},iB=$j({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${cI};\n  float a1 = ${hI};\n  float a2 = ${dI};\n  float a3 = ${pI};\n  float a4 = ${fI};\n  float a5 = ${mI};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),oB={kernelName:om,backendName:"webgl",kernelFunc:iB},uB="return exp(x);",lB=$j({opSnippet:uB,packedOpSnippet:uB,cpuKernelImpl:$P}),cB={kernelName:lm,backendName:"webgl",kernelFunc:lB};function hB(e){const{inputs:t,attrs:n,backend:s}=e,{dim:r}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let u=r;return r<0&&(Cp(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),o.splice(u,0,1),zj({inputs:{x:a},backend:s,attrs:{shape:o}})}const dB={kernelName:cm,backendName:"webgl",kernelFunc:hB},pB="return exp(x) - 1.0;",fB=$j({opSnippet:pB,packedOpSnippet:pB,cpuKernelImpl:TP}),mB={kernelName:hm,backendName:"webgl",kernelFunc:fB};class gB{constructor(e,t,n){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${s}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function bB(e,t,n){const s=n.texData.get(e.dataId),r=Np(e.shape),a=e.shape[e.shape.length-1],i=zj({inputs:{x:e},backend:n,attrs:{shape:[r/a,a]}}),o=i.shape,u=new gB("real",o,t),l=new gB("imag",o,t),c=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:o},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(u,c,"float32"),d=n.runWebGLProgram(l,c,"float32"),p=xj({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=zj({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const yB={kernelName:dm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t;return bB(s,!1,n)}};class vB{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function wB(e){const{backend:t,attrs:n}=e,{shape:s,value:r}=n;let{dtype:a}=n;if(a=a||qp(r),"string"===a){const e=Lp(a,Np(s));return e.fill(r),t.makeTensorInfo(s,a,e)}{const e=new vB(s,r),n=e.getCustomSetupFunc(r);return t.runWebGLProgram(e,[],a,n)}}const xB={kernelName:pm,backendName:"webgl",kernelFunc:wB};class kB{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const IB={kernelName:fm,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,s=t,r=new kB(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}},CB="return floor(x);",_B=$j({opSnippet:CB,packedOpSnippet:CB,cpuKernelImpl:AP}),SB={kernelName:mm,backendName:"webgl",kernelFunc:_B},EB=Tj({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),NB={kernelName:gm,backendName:"webgl",kernelFunc:EB};class $B{constructor(e){this.variableNames=["A"];const t=GL(),[n,s]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class TB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=GL(),[n,s]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const AB={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e;let{pixels:r}=t;const{numChannels:a}=s,i="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[u,l]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[l,u],h=[l,u,a];(o||i)&&(null==RB&&(RB=document.createElement("canvas").getContext("2d")),RB.canvas.width=u,RB.canvas.height=l,RB.drawImage(r,0,0,u,l),r=RB.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=vL.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=af().getBool("WEBGL_PACK")?new TB(h):new $B(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let RB;const FB={kernelName:rb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=Kv(c),g=Pv(r.shape,a.shape,u,h,l,d,!1,m);let b;const y=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(af().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])b=vW({x:r,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=null!=i,t=null!=o,s="leakyrelu"===p,u=p?Aj(p,!1):null,l=new mW(g,e,u,t,s),c=[r,a];if(i&&c.push(i),o&&c.push(o),s){const e=n.makeTensorInfo([],"float32",fb(f,"float32"));c.push(e),y.push(e)}b=n.runWebGLProgram(l,c,"float32")}else b=yW({x:r,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const v=zj({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(e=>n.disposeIntermediateTensorInfo(e)),v}},DB={kernelName:ab,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let m=c;null==m&&(m=[1,1]),Cp(Gv(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=Pv(r.shape,a.shape,u,m,l,h,!0),b=af().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=d?Aj(d,b):null,v=[r,a],w=null!=i,x=null!=o,k="leakyrelu"===d;if(w&&v.push(i),x&&v.push(o),k){const e=n.makeTensorInfo([],"float32",fb(p,"float32"));v.push(e),f.push(e)}let I;I=b?new qW(g,w,y,x,k):new BW(g,w,y,x,k);const C=n.runWebGLProgram(I,v,"float32");return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),C}};class OB{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const s=wP(t.length),r=wP(n.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const MB={kernelName:vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,a=r.shape,i=a[a.length-1],[o,u,l,c]=rI(s,r),h=zj({inputs:{x:r},backend:n,attrs:{shape:[u,i]}}),d=zj({inputs:{x:s},backend:n,attrs:{shape:[Np(s.shape)/l,l]}}),p=new OB(i,c,[u,l]),f=n.runWebGLProgram(p,[d,h],d.dtype),m=zj({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}};class zB{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=wP(this.rank),s=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<e.length;r++)s.push(2===r?"int(getIndices(resRC.x, resRC.z))":`${n[r]}`);return s.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const LB={kernelName:ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:a}=t,{axis:i,batchDims:o}=s,u=MI(r,a,Op(i,r.shape)[0],o),l=Np(a.shape),c=[],h=zj({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=zj({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});c.push(h),c.push(d);const p=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.bufferSync(d),t=n.bufferSync(h),s=RP(t,e,p);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,s.dtype,s.values)}const f=new zB(h.shape,p),m=n.runWebGLProgram(f,[h,d],h.dtype);c.push(m);const g=zj({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},PB=Tj({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:FP,dtype:"bool"}),jB={kernelName:wm,backendName:"webgl",kernelFunc:PB},VB=Tj({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),WB={kernelName:xm,backendName:"webgl",kernelFunc:VB},BB={kernelName:Im,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t;return bB(s,!0,n)}},qB=$j({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),UB={kernelName:_m,backendName:"webgl",kernelFunc:qB},HB=$j({opSnippet:"return float(isinf(x));",dtype:"bool"}),GB={kernelName:Sm,backendName:"webgl",kernelFunc:HB},KB=$j({opSnippet:"return float(isnan(x));",dtype:"bool"}),XB={kernelName:Em,backendName:"webgl",kernelFunc:KB},YB=Tj({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:DP,dtype:"bool"}),ZB={kernelName:$m,backendName:"webgl",kernelFunc:YB},JB=Tj({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),QB={kernelName:Tm,backendName:"webgl",kernelFunc:JB},eq={kernelName:Am,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:a}=n,i=OP(s,r,a);return t.makeTensorInfo([i.length],"float32",i)}},tq=$j({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:MP}),nq={kernelName:Rm,backendName:"webgl",kernelFunc:tq},sq=$j({opSnippet:"return log(1.0 + x);"}),rq={kernelName:Fm,backendName:"webgl",kernelFunc:sq},aq=Tj({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),iq={kernelName:Dm,backendName:"webgl",kernelFunc:aq},oq=$j({opSnippet:"return float(!(x >= 1.0));"}),uq={kernelName:Om,backendName:"webgl",kernelFunc:oq},lq=Tj({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),cq={kernelName:Mm,backendName:"webgl",kernelFunc:lq};class hq{constructor(e,t,n,s,r){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class dq{constructor(e,t,n,s,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const pq={kernelName:zm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=s,l=af().getBool("WEBGL_PACK_NORMALIZATION")?new dq(r.shape,a,i,o,u):new hq(r.shape,a,i,o,u);return n.runWebGLProgram(l,[r],r.dtype)}};class fq{constructor(e,t,n,s,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=s,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const mq={kernelName:Lm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=s,h=new fq(r.shape,o,u,l,c);return n.runWebGLProgram(h,[r,a,i],r.dtype)}};function gq(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:a,keepDims:i}=s,o=r.shape.length,u=Op(a,r.shape);let l=u;const c=Zw(l,o),h=null!=c,d=n.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=r.shape[c[n]];const s=QP(e,r.shape,r.dtype,c,t);p=n.makeTensorInfo(t,r.dtype),n.texData.get(p.dataId).values=s}else p=qj(r,c,n);l=Qw(l.length,o)}Yw("max",l,o);const[f,m]=Kw(p.shape,l);let g,b=f;if(i&&(b=Xw(f,u)),d){const e=n.texData.get(p.dataId),t=zP(e.values,Np(m),b,r.dtype);g=n.makeTensorInfo(b,r.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,s){const r=Np(t),a=zj({inputs:{x:e},attrs:{shape:[Np(e.shape)/r,r]},backend:s}),i=Vj(a,e.dtype,"max",s),o=zj({inputs:{x:i},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(i),o}(p,m,b,n);return h&&n.disposeIntermediateTensorInfo(p),g}const bq={kernelName:Pm,backendName:"webgl",kernelFunc:gq},yq=Tj({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:LP}),vq={kernelName:jm,backendName:"webgl",kernelFunc:yq},wq={kernelName:Vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;UL(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;Cp(Gv(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=zv(r.shape,a,i,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))return vj({inputs:{x:r},backend:n});const c=new NV(l,"max",!1);return n.runWebGLProgram(c,[r],r.dtype)}},xq={kernelName:Bm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:l}=s,c=Lv(r.shape,a,i,[1,1,1],o,l,u),h=new $V(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class kq{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n          wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${t*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Iq{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,s=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${s-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n           wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${t*n*s-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${s} +\n                  wR * ${s} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Cq={kernelName:qm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=s,h=Lv(i.shape,o,u,[1,1,1],l,c),d=new $V(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new Iq(h),m=n.runWebGLProgram(f,[r,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}},_q={kernelName:Wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a,output:i}=t,o=a;UL([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=zv(o.shape,u,l,1,c,h),p=new NV(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new kq(d),g=n.runWebGLProgram(m,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},Sq={kernelName:Um,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;Cp(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const l=[1,1];Cp(Gv(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const c=zv(s.shape,r,a,l,i),[h,d]=function(e,t,n,s){let r=new NV(n,"max",!1);const a=s.runWebGLProgram(r,[e],"float32");return r=new NV(n,"max",!0,!0,t),[a,s.runWebGLProgram(r,[e],"float32")]}(s,o,c,u);return[h,d]}},Eq={kernelName:Hm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{keepDims:r,axis:a}=t,i=n,o=s.shape.length,u=Op(a,s.shape);let l=u;const c=Zw(l,o),h=null!=c,d=i.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const e=i.texData.get(f.dataId).values,t=new Array(o);for(let r=0;r<t.length;r++)t[r]=s.shape[c[r]];const n=QP(e,s.shape,s.dtype,c,t);f=i.makeTensorInfo(t,s.dtype),i.texData.get(f.dataId).values=n}else f=qj(s,c,i);p.push(f),l=Qw(l.length,o)}Yw("sum",l,o);const[m,g]=Kw(f.shape,l);let b=m;r&&(b=Xw(m,u));const y=function(e,t,n,s){const r=Np(t),a=zj({inputs:{x:e},attrs:{shape:[Np(e.shape)/r,r]},backend:s}),i=Vj(a,"float32","mean",s),o=zj({inputs:{x:i},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(i),o}(f,g,b,i);for(const v of p)i.disposeIntermediateTensorInfo(v);return y}},Nq={kernelName:Gm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=Op(a,r.shape);let l=u;const c=Zw(l,o);let h=r;null!=c&&(h=Gj({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Qw(l.length,r.shape.length)),Yw("min",l,o);const[d,p]=Kw(h.shape,l),f=zj({inputs:{x:h},backend:n,attrs:{shape:[-1,Np(p)]}}),m=Vj(f,f.dtype,"min",n);let g;return g=zj(i?{inputs:{x:m},backend:n,attrs:{shape:Xw(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},$q=Tj({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:PP}),Tq={kernelName:Km,backendName:"webgl",kernelFunc:$q};class Aq{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=wP(s),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===n?0:1;this.userCode=1!==s?`\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Rq{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=wP(s),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=nj("rc",s),u=nj("source",s),l=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===s){const e=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[s-2]} += 1;\n        if(${o[s-2]} < ${this.outputShape[s-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${o[s-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${a});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const Fq={kernelName:Xm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s}=e,{paddings:r,mode:a}=n,i=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rq(s.shape,r,a):new Aq(s.shape,r,a);return t.runWebGLProgram(i,[s],s.dtype)}},Dq=Tj({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Oq={kernelName:Ym,backendName:"webgl",kernelFunc:Dq};class Mq{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const zq=Tj({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Lq={kernelName:sm,backendName:"webgl",kernelFunc:zq},Pq="return a - b;",jq=Tj({opSnippet:Pq,packedOpSnippet:Pq,supportsComplex:!0,cpuKernelImpl:YP}),Vq={kernelName:qg,backendName:"webgl",kernelFunc:jq};function Wq(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:a}=s,i=Op([a],r.shape),o=gq({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=Xw(o.shape,i),l=zj({inputs:{x:o},backend:n,attrs:{shape:u}}),c=jq({inputs:{a:r,b:l},backend:n}),h=lB({inputs:{x:c},backend:n}),d=Uj({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=zj({inputs:{x:d},backend:n,attrs:{shape:u}}),f=zq({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const Bq={kernelName:zg,backendName:"webgl",kernelFunc:Wq},qq={kernelName:Zm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:a,seed:i,normalized:o}=s,u=o?r:Wq({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=new Mq(u.shape[0],u.shape[1],a),c=l.getCustomSetupFunc(i),h=n.runWebGLProgram(l,[u],"int32",c);return o||n.disposeIntermediateTensorInfo(u),h}},Uq="return -x;",Hq={kernelName:Qm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])){const e=n.texData.get(s.dataId),[t,r]=VP(e.values,s.shape,s.dtype);return n.makeTensorInfo(r,s.dtype,t)}let r;return r=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new dj(s.shape,Uq):new lj(s.shape,Uq),n.runWebGLProgram(r,[s],s.dtype)}},Gq=hk,Kq={kernelName:tg,backendName:"webgl",kernelFunc:function(e){gI("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=s,l=n.readSync(r.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=Gq(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Xq=dk,Yq={kernelName:ng,backendName:"webgl",kernelFunc:function(e){gI("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=s,c=n.readSync(r.dataId),h=n.readSync(a.dataId),{selectedIndices:d,validOutputs:p}=Xq(c,h,i,o,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Zq=pk,Jq={kernelName:sg,backendName:"webgl",kernelFunc:function(e){gI("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=s,c=n.readSync(r.dataId),h=n.readSync(a.dataId),d=i,p=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=Zq(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class Qq{constructor(e,t,n,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const eU={kernelName:ag,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{depth:a,onValue:i,offValue:o}=s,u=Np(r.shape),l=new Qq(u,a,i,o),c=zj({inputs:{x:r},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(l,[c],r.dtype);n.disposeIntermediateTensorInfo(c);const d=zj({inputs:{x:h},backend:n,attrs:{shape:[...r.shape,a]}});return n.disposeIntermediateTensorInfo(h),d}};function tU(e){const{inputs:t,backend:n}=e,{x:s}=t;if("complex64"===s.dtype){const e=XV({inputs:{input:s},backend:n}),t=tU({inputs:{x:e},backend:n}),r=cW({inputs:{input:s},backend:n}),a=tU({inputs:{x:r},backend:n}),i=xj({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}return wB({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:n})}const nU={kernelName:eb,backendName:"webgl",kernelFunc:tU},sU={kernelName:rg,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=XV({inputs:{input:r},backend:s}),n=e({inputs:{x:t},backend:s}),a=cW({inputs:{input:r},backend:s}),i=tU({inputs:{x:a},backend:s}),o=xj({inputs:{real:n,imag:i},backend:s});return s.disposeIntermediateTensorInfo(t),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(i),o}return wB({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:s})}},rU={kernelName:ig,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return hB({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{_p(a,e.shape,"All tensors passed to stack must have matching shapes"),Cp(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=pW({inputs:t.map(e=>{const t=hB({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(t),t}),backend:n,attrs:{axis:r}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};class aU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=wP(s),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${i});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class iU{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=wP(s),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=nj("rc",s),u=nj("source",s),l=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[s-1]} += 1;\n       if(${l}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${o[s-2]} += 1;\n       if(${o[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${o[s-1]} += 1;\n         if(${l}) {`],d=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===s?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${a});\n      const ${r} end = ${r}(${i});\n      uniform float value;\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}const oU=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,constantValue:i}=s,o=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new iU(r.shape,a,i):new aU(r.shape,a,i),u=o.getCustomSetupFunc(i);return n.runWebGLProgram(o,[r],r.dtype,u)},uU={kernelName:og,backendName:"webgl",kernelFunc:oU},lU=Tj({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),cU={kernelName:ug,backendName:"webgl",kernelFunc:lU},hU={kernelName:cg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=[],l=Op(a,r.shape);let c=l;const h=Zw(c,o);let d,p=r;if(null!=h&&(p=Gj({inputs:{x:r},backend:n,attrs:{perm:h}}),c=Qw(c.length,o),u.push(p)),Yw("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:s,outDtype:r}=WP(p.shape,p.dtype,e,c);d=n.makeTensorInfo(s,r,t)}else{const[e,t]=Kw(p.shape,c),s=Np(t),a=zj({inputs:{x:p},backend:n,attrs:{shape:[-1,s]}}),i=Vj(a,Vb(r.dtype),"prod",n);d=zj({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(a),u.push(i)}if(i){u.push(d);const e=Xw(d.shape,l);d=zj({inputs:{x:d},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},dU=e=>{const{backend:t,attrs:n}=e,{start:s,stop:r,step:a,dtype:i}=n,o=BP(s,r,a,i);return t.makeTensorInfo([o.length],i,o)},pU={kernelName:hg,backendName:"webgl",kernelFunc:dU},fU=$j({opSnippet:"return 1.0 / x;"}),mU={kernelName:pg,backendName:"webgl",kernelFunc:fU},gU=$j({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),bU={kernelName:fg,backendName:"webgl",kernelFunc:gU},yU=$j({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),vU={kernelName:wg,backendName:"webgl",kernelFunc:yU};class wU{constructor(e,t,n,s,r){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?i-1:i,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class xU{constructor(e,t,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?i-1:i,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const kU={kernelName:yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s,[u,l]=o,c=af().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xU(r.shape,u,l,a,i):new wU(r.shape,u,l,a,i);return n.runWebGLProgram(c,[r],"float32")}};class IU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,r]=t,[,a,i]=e,o=[n&&a>1?s-1:s,n&&i>1?r-1:r],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const CU={kernelName:vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:i}=s,o=new IU(a.shape,r.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class _U{constructor(e,t,n,s,r){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?i-1:i,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let h;h=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class SU{constructor(e,t,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?i-1:i,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let h;h=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const EU={kernelName:gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s,[u,l]=o,c=af().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new SU(r.shape,u,l,a,i):new _U(r.shape,u,l,a,i);return n.runWebGLProgram(c,[r],r.dtype)}};class NU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,r]=t,[,a,i]=e,o=[n&&a>1?s-1:s,n&&i>1?r-1:r],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const $U={kernelName:bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:i}=s,o=new NU(a.shape,r.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class TU{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const s=e.map((n,s)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(s)).join(","),r=wP(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class AU{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const s=nj("rc",n),r=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,i=wP(n);function o(n){const s=e.map((s,r)=>function(n,s){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${s[n]} - 1`:`${s[n]}`}(r,n));return`getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(s.slice())};\n          if(${r}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(s.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const RU={kernelName:xg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:a}=s,i=r.shape.length,o=Op(a,r.shape);if(0===i)return vj({inputs:{x:r},backend:n});const u=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AU(r.shape,o):new TU(r.shape,o);return n.runWebGLProgram(u,[r],r.dtype)}};class FU{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];const n=e[1],s=e[2];this.outputShape=e;let r="";r="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(e,t,n,s){return(r,a)=>{null==this.paramsLoc&&(this.paramsLoc=r.getUniformLocationNoThrow(a,"params")),r.gl.uniform4f(this.paramsLoc,e,t,n,s)}}}const DU={kernelName:nb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:r,fillValue:a,center:i}=t,o=n,u=new FU(s.shape,a),[l,c]=Jk(i,s.shape[1],s.shape[2]),h=u.getCustomSetupFunc(l,c,Math.sin(r),Math.cos(r));return o.runWebGLProgram(u,[s],s.dtype,h)}},OU=$j({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),MU={kernelName:kg,backendName:"webgl",kernelFunc:OU},zU=$j({opSnippet:"return inversesqrt(x);",cpuKernelImpl:qP}),LU={kernelName:Ig,backendName:"webgl",kernelFunc:zU};class PU{constructor(e,t,n,s,r,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const o=wP(r.length),u=wP(a.length);let l="";1===n?l="i":2===n&&(l="i, j");let c="";1===s?c="i":2===s&&(c="i, coords[1]"),this.userCode=`\n        ${o} strides = ${o}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${l}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const jU={kernelName:Cg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:a}=t,{shape:i}=s,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=oI(0,r,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,r.dtype);const p=zj({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),f=zj({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new PU(u,o,p.shape.length,f.shape.length,c,d),b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=zj({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class VU{constructor(e,t,n){let s,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",s="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let s=0;s<t.length;s++)i.push(`${n[s]}`),s<e&&a.push(`${n[s]}`);s=a.join(),r=i.join()}const a=wP(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const WU={kernelName:_g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:a}=t,i=new VU(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[s,r,a],jb(r.dtype,a.dtype))}},BU=$j({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${uI};\n  float scale = ${lI};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),qU={kernelName:Sg,backendName:"webgl",kernelFunc:BU},UU=$j({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),HU={kernelName:Ag,backendName:"webgl",kernelFunc:UU},GU=$j({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),KU={kernelName:Tg,backendName:"webgl",kernelFunc:GU},XU=$j({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),YU={kernelName:Ng,backendName:"webgl",kernelFunc:XU},ZU=$j({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),JU={kernelName:$g,backendName:"webgl",kernelFunc:ZU},QU=$j({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),eH={kernelName:Rg,backendName:"webgl",kernelFunc:QU},tH={kernelName:Og,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,paddings:i}=s;Cp(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),u=[[0,0]];u.push(...i);for(let b=1+a.length;b<r.shape.length;++b)u.push([0,0]);const l=[],c=oU({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),h=Qk(c.shape,a,o,!1),d=eI(h.length,a.length,!1),p=tI(c.shape,a,o,!1),f=zj({inputs:{x:c},backend:n,attrs:{shape:h}}),m=Gj({inputs:{x:f},backend:n,attrs:{perm:d}}),g=zj({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(c),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},nH={kernelName:Lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(s.dataId),u=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=GP(o,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}},sH={kernelName:Pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(r.dataId)),o=n.readSync(s.dataId),u=Array.from(n.readSync(a.dataId)),[l,c,h]=KP(o,s.shape,s.dtype,i,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}},rH={kernelName:jg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:a,defaultValue:i}=t,{outputShape:o}=s,{sliceRank:u,numUpdates:l,strides:c,outputSize:h}=oI(0,r,o),d=new PU(l,u,r.shape.length,a.shape.length,c,[h,1],!1),p=n.runWebGLProgram(d,[a,r,i],a.dtype),f=zj({inputs:{x:p},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),f}},aH={kernelName:Mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:a,axis:i}=s,o=Op(i,r.shape)[0],u=FI(r,a,o),l=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(e=>{const t=[...c];t[o]=e;const s=BV({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,s})}},iH=$j({opSnippet:"return sqrt(x);"}),oH={kernelName:Fg,backendName:"webgl",kernelFunc:iH},uH={kernelName:Wg,backendName:"webgl",kernelFunc:$j({opSnippet:"return x * x;"})},lH="return (a - b) * (a - b);",cH=Tj({opSnippet:lH,packedOpSnippet:lH}),hH={kernelName:Vg,backendName:"webgl",kernelFunc:cH},dH={kernelName:tb,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:s}=e,r=new lj(s.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(r,[s],s.dtype)}};class pH{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const s=n.length,r=wP(n.length),a=wP(n.length);let i="";if(1===s)i="coords * strides + begin";else{let e=0;i=n.map((t,s)=>(e++,1===n.length?`coords * strides[${s}] + begin[${s}]`:`coords[${e-1}] * strides[${s}] + begin[${s}]`)).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const fH={kernelName:Bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:b,outShape:y}=yv(r.shape,a,i,o,u,l,c,h,d),v=zj({inputs:{x:r},backend:n,attrs:{shape:b}});let w;if(p){const e=BV({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});w=zj({inputs:{x:e},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(e)}else if(y.some(e=>0===e))w=n.makeTensorInfo(y,r.dtype,[]);else if(n.shouldExecuteOnCPU([v])){const e=n.texData.get(v.dataId),t=qy(v.shape,v.dtype,e.values),s=XP(y,t,m,f);w=n.makeTensorInfo(y,v.dtype,s.values)}else{const e=new pH(f,m,y);w=n.runWebGLProgram(e,[v],v.dtype)}const x=zj({inputs:{x:w},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),x}},mH=$j({opSnippet:"return tan(x);"}),gH={kernelName:Ug,backendName:"webgl",kernelFunc:mH},bH=$j({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),yH={kernelName:Hg,backendName:"webgl",kernelFunc:bH};class vH{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const s=wP(this.rank),r=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<e.length;r++)s.push(`imod(${n[r]}, ${e[r]})`);return s.join()}(e);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function wH(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:a}=s;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map(e=>yb(e)):e,s=qy(r.shape,r.dtype,t),i=ZP(s,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new vH(r.shape,a);return n.runWebGLProgram(i,[r],r.dtype)}const xH={kernelName:Gg,backendName:"webgl",kernelFunc:wH},kH={kernelName:Kg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:a,sorted:i}=s,o=n.readSync(r.dataId),[u,l]=JP(o,r.shape,r.dtype,a,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};class IH{constructor(e,t,n,s,r,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(s){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const CH={kernelName:Xg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=s,[c,h,d,p]=r.shape,[f,m]=null!=l?l:[h,d],g=new IH(h,d,i,o,u,[c,f,m,p]);return n.runWebGLProgram(g,[r,a],"float32")}},_H={kernelName:Zg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:a}=t;UL(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(a.dataId),{outputValues:o,outputShape:u,indices:l}=ej(i,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,o),s.makeTensorInfo([l.length],"int32",l)]}},SH={kernelName:Jg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r,o=i.shape.length,u=r.shape[a],l=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(l[c++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(u);for(let m=0;m<f.length;m++){d[a]=m;const e=BV({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=zj({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class EH{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,s=e.batchSize,r=e.inSize,a=e.numSegments,i=a*Math.ceil(r/n);this.outputShape=[s,i];const o=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const NH=[pq,mq,Yj,Jj,eV,nV,aV,uV,lV,cV,gV,bV,vV,xV,_V,IV,EV,AV,TV,DV,OV,MV,PV,UV,HV,ZV,eW,sW,iW,kj,fW,_W,SW,wW,NW,$W,EW,AW,FW,OW,PW,jW,WW,KW,XW,UW,ZW,QW,eB,nB,sB,aB,oB,cB,dB,mB,yB,xB,IB,SB,NB,AB,FB,DB,MB,LB,jB,WB,wj,BB,hW,UB,GB,XB,_j,ZB,QB,eq,rq,nq,iq,uq,cq,bq,xq,wq,Cq,_q,Sq,vq,Eq,Nq,Tq,Fq,Oq,qq,Mj,Hq,Kq,Yq,Jq,KV,eU,sU,rU,uU,cU,Nj,hU,pU,YV,Lq,mU,vU,bU,Lj,kU,CU,EU,$U,RU,DU,MU,LU,jU,WU,qU,HU,KU,YU,JU,qV,Bq,eH,tH,nH,sH,rH,aH,oH,uH,hH,dH,fH,Vq,Hj,gH,yH,xH,kH,CH,Kj,_H,SH,{kernelName:Qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:a}=t,{numSegments:i}=s,o=r.shape.length,u=[];let l=0;const c=Zw([l],o);let h=r;null!=c&&(h=Gj({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(h),l=Qw(1,o)[0]);const d=OI(h.shape,l,i),p=Np([h.shape[l]]),f=zj({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=Vb(r.dtype),g=(e,t,s,r,a)=>{const i=e.shape[0],o=e.shape[1],l=DI(o,a),c=new EH({windowSize:l,inSize:o,batchSize:i,numSegments:a},t),h=n.compileAndRun(c,[e,s],r);if(u.push(h),h.shape[1]===a)return h;const d=dU({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=wH({inputs:{x:d},backend:n,attrs:{reps:[o/l]}});return u.push(d),u.push(p),g(h,t,p,r,a)},b=zj({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:d}});let y=b;if(null!=c){u.push(b);const e=Jw(c);y=Gj({inputs:{x:y},backend:n,attrs:{perm:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},nU];for(const rK of NH)hb(rK);let $H=(()=>{class e{constructor(){this.model=null,this.tokenizer=null,this.responsesMap=null}loadModel(){var e=this;return bp(function*(){if(!e.model||!e.tokenizer||!e.responsesMap)try{e.model=yield Y$("assets/intents_model/model.json");const t=yield fetch("assets/intents_model/chatbot_tokenizer.json");e.tokenizer=yield t.json();const n=yield fetch("assets/intents_model/data-programming.json"),s=yield n.json();e.responsesMap={},s.forEach(t=>{e.responsesMap[t.input]=t.output}),console.log("Modelo, tokenizer y respuestas cargados correctamente.")}catch(t){console.error("Error al cargar el modelo o tokenizer:",t)}})()}predict(e){var t=this;return bp(function*(){if(!t.model||!t.tokenizer||!t.responsesMap)throw new Error("El modelo, tokenizer o mapa de respuestas no est\xe1n cargados.");const n=t.cleanText(e),s=t.textToSequences([n],t.tokenizer.config.word_index),r=Fx(t.padSequences(s,t.tokenizer.max_length||20)),a=t.model.predict(r),i=(yield a.argMax(1).data())[0],o=Object.keys(t.responsesMap)[i],u=t.responsesMap[o];return u[Math.floor(Math.random()*u.length)]||"No entend\xed la pregunta."})()}cleanText(e){return e.toLowerCase().replace(/[^\w\s]/gi,"")}textToSequences(e,t){return e.map(e=>e.split(" ").map(e=>t[e]||0))}padSequences(e,t){return e.map(e=>{const n=Array(Math.max(0,t-e.length)).fill(0);return e.concat(n).slice(0,t)})}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();const TH=JSON.parse('[{"input":"hola","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"bien","output":["me alegra saberlo, dime en que puedo ayudarte, estoy entrenado para temas de programacion ","que alegria, puedo ayudarte en distintos temas, estoy entrenado para temas de programacion","me alegra escuchar eso, puedo ayudarte con el tema de programacion"]},{"input":"en que puedes ayudarme","output":["puedo responder preguntas, darte informacion y ayudarte en lo que necesites, estoy entrenado para temas de programacion","estoy aqui para resolver tus dudas y ayudarte en lo que necesites, estoy entrenado para temas de programacion,","puedo ayudarte sobre temas como programacion"]},{"input":"buenas","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"hey","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"como estas","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"todo bien","output":["estoy bien gracias por preguntar","todo bien, y tu?","me alegra escuchar eso"]},{"input":"adios","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"nos vemos","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"buenos dias","output":["buenos dias espero que tengas un excelente dia, puedo ayudarte en temas de programacion","hola como estas en este dia"]},{"input":"como te llamas","output":["soy un asistente virtual pero puedes llamarme bot","me llamo bot, tu asistente"]},{"input":"tienes algun nombre","output":["soy un asistente virtual pero puedes llamarme bot","me llamo bot, tu asistente"]},{"input":"quien eres","output":["soy un asistente virtual pero puedes llamarme bot","me llamo bot, tu asistente"]},{"input":"que puedes hacer","output":["puedo responder preguntas, darte informacion y ayudarte en lo que necesites, estoy entrenado para temas de programacion","estoy aqui para resolver tus dudas y ayudarte en lo que necesites, estoy entrenado para temas de programacion,","puedo ayudarte sobre temas como programacion"]},{"input":"gracias","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"perdon","output":["no te preocupes todo esta bien","no hay problema, como puedo ayudarte?, estoy entrenado para temas de programacion"]},{"input":"lo siento","output":["no pasa nada, como puedo ayudarte?, estoy entrenado para temas de programacion y uno que otro chiste","no te preocupes, estoy aqui para ayudarte"]},{"input":"que hora es","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"dime la hora","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"que dia es hoy","output":["hoy es un gran dia, como puedo ayudarte? estoy entrenado para temas de programacion","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"ayuda","output":["por supuesto dime que necesitas y vere como ayudarte, estoy entrenado para temas de programacion","estoy aqui para lo que necesites, dime como puedo ayudarte, estoy entrenado para temas de programacion","puedo ayudarte en temas de programacion"]},{"input":"estoy triste","output":["lo siento mucho si necesitas hablar o apoyo estoy aqui","te entiendo, no estas solo, cuentame mas"]},{"input":"estoy feliz","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"cuentame un chiste","output":["por que los pajaros no usan facebook porque ya tienen twitter","que hace una abeja en el gimnasio zumba"]},{"input":"dime un chiste","output":["por que los pajaros no usan facebook porque ya tienen twitter","que hace una abeja en el gimnasio zumba"]},{"input":"cuentame otro chiste","output":["por que los pajaros no usan facebook porque ya tienen twitter","que hace una abeja en el gimnasio zumba"]},{"input":"dime otro chiste","output":["por que los pajaros no usan facebook porque ya tienen twitter","que hace una abeja en el gimnasio zumba"]},{"input":"que son los pajaros","output":["los pajaros son animales voladores que tienen plumas y pico","los pajaros son animales que vuelan y tienen plumas"]},{"input":"que es un pajaro","output":["un pajaro es un animal volador que tiene plumas y pico","un pajaro es un animal que vuela y tienen pluma"]},{"input":"que es facebook","output":["facebook es una red social donde las personas pueden compartir contenido interactuar y conectar"]},{"input":"que es una red social","output":["una red social es una plataforma digital donde las personas pueden interactuar compartir ideas contenido y comunicarse entre si"]},{"input":"que son las redes sociales","output":["las redes sociales son plataformas digitales que permiten a los usuarios conectarse compartir contenido y comunicarse entre ellos"]},{"input":"que son las personas","output":["las personas son seres humanos que poseen capacidades de pensamiento razonamiento y comunicacion"]},{"input":"que significa compartir","output":["compartir significa poner algo a disposicion de otros para que lo usen o disfruten en conjunto"]},{"input":"que es conectar","output":["conectar es establecer una relacion o vinculo entre dos o mas elementos"]},{"input":"que significa conectar","output":["conectar significa unir o enlazar cosas personas o ideas para que interactuen o trabajen en conjunto"]},{"input":"que es twitter","output":["twitter es una plataforma donde los usuarios pueden publicar mensajes cortos llamados tweets"]},{"input":"por que los pajaros no usan facebook","output":["porque ya tienen twitter"]},{"input":"que hace una abeja en el gimnasio","output":["zumba"]},{"input":"que es la zumba","output":["la zumba es una actividad fisica que combina baile y ejercicio al ritmo de musica latina"]},{"input":"que son las abejas","output":["las abejas son insectos polinizadores que juegan un papel crucial en el ecosistema y producen miel"]},{"input":"que es un pajaro","output":["un pajaro es un animal vertebrado con plumas alas y generalmente la capacidad de volar"]},{"input":"que hacen los pajaros en redes sociales","output":["en este contexto los pajaros usan twitter como parte del chiste"]},{"input":"que es un gimnasio","output":["un gimnasio es un lugar donde las personas van a ejercitarse y mejorar su condicion fisica"]},{"input":"estoy animado","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"estoy de maravilla","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"que hora tienes","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"cual es la hora","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"que dia tenemos","output":["hoy es un gran dia, como puedo ayudarte?","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"que dia es","output":["hoy es un gran dia, como puedo ayudarte?, quieres saber sobre que es la programacion","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"si","output":["Es el proceso de escribir instrucciones que una computadora puede entender.","Es la creaci\xf3n de c\xf3digo para resolver problemas o automatizar tareas en una computadora."]},{"input":"estas disponible","output":["claro que si estoy aqui para ayudarte","estoy disponible, dime en qu\xe9 puedo ayudarte"]},{"input":"sigues disponible","output":["claro que si estoy aqui para ayudarte","estoy disponible, dime en qu\xe9 puedo ayudarte"]},{"input":"me puedes ayudar","output":["por supuesto dime que necesitas y vere como ayudarte","estoy aqui para lo que necesites, dime como puedo ayudarte"]},{"input":"me ayudas","output":["por supuesto dime que necesitas y vere como ayudarte","estoy aqui para lo que necesites, dime como puedo ayudarte"]},{"input":"ayudame","output":["por supuesto dime que necesitas y vere como ayudarte, estoy entrenado para temas de programacion y uno que otro chiste","estoy aqui para lo que necesites, dime como puedo ayudarte, estoy entrenado para temas de programacion y uno que otro chiste"]},{"input":"hola como estas","output":["estoy bien y tu"]},{"input":"buenos dias","output":["buenos dias como te sientes hoy"]},{"input":"hola que tal","output":["todo va bien por aqui y tu como estas"]},{"input":"hola todo bien","output":["si gracias como te va a ti"]},{"input":"hola me escuchas","output":["claro que si en que puedo ayudarte hoy"]},{"input":"buenas tardes","output":["buenas tardes espero que tengas un buen dia"]},{"input":"buenas noches","output":["buenas noches necesitas algo antes de dormir"]},{"input":"hey como te va","output":["hola todo bien por aqui y tu"]},{"input":"hola que haces","output":["hola estoy aqui esperando ayudarte"]},{"input":"hola me puedes ayudar","output":["claro que si dime en que necesitas ayuda"]},{"input":"hola como te llamas","output":["hola soy un asistente virtual y tu como te llamas"]},{"input":"hola que me cuentas","output":["hola aqui listo para ayudarte y tu que cuentas"]},{"input":"hola hace tiempo que no hablamos","output":["hola si es verdad que gusto verte de nuevo"]},{"input":"hola que tal todo por ahi","output":["todo va bien y por ahi como va todo"]},{"input":"hola que tal como estas hoy","output":["hola estoy bien gracias por preguntar y tu como estas hoy"]},{"input":"hola tienes tiempo para hablar","output":["claro estoy aqui para ti dime en que te ayudo"]},{"input":"hola puedo preguntarte algo","output":["claro que si estoy aqui para responder tus preguntas"]},{"input":"hola que tal tu tarde","output":["mi tarde ha sido tranquila y la tuya que tal"]},{"input":"hola como has estado","output":["hola he estado bien gracias por preguntar y tu"]},{"input":"hola espero que estes bien","output":["hola gracias espero que tu tambien lo estes"]},{"input":"hola hace mucho que no hablamos","output":["si es cierto hola que gusto hablar contigo de nuevo"]},{"input":"hola que tal tu dia hasta ahora","output":["mi dia ha sido bueno y el tuyo como va hasta ahora"]},{"input":"hola que tal tu semana","output":["mi semana va bien gracias y la tuya como va"]},{"input":"hola como amaneciste hoy","output":["hola amaneci bien gracias por preguntar y tu"]},{"input":"hola buenas como va tu dia","output":["buenas mi dia va bien gracias y el tuyo como va"]},{"input":"hola estas disponible","output":["hola si claro en que puedo ayudarte"]},{"input":"por que existes","output":["fui creado para ayudarte y mejorar tus interacciones con la tecnologia"]},{"input":"que es la programacion","output":["Es el proceso de escribir instrucciones que una computadora puede entender.","Es la creaci\xf3n de c\xf3digo para resolver problemas o automatizar tareas en una computadora."]},{"input":"que es la programacion","output":["Es el proceso de escribir instrucciones que una computadora puede entender.","Es la creaci\xf3n de c\xf3digo para resolver problemas o automatizar tareas en una computadora."]},{"input":"que es instrucciones","output":["Son indicaciones espec\xedficas que le dicen a una computadora qu\xe9 hacer paso a paso.","Son \xf3rdenes organizadas que una m\xe1quina o persona sigue para realizar una tarea."]},{"input":"que es una computadora","output":["Es un dispositivo electr\xf3nico capaz de procesar y almacenar datos siguiendo instrucciones.","Es una m\xe1quina dise\xf1ada para realizar c\xe1lculos y ejecutar programas de software."]},{"input":"que significa la creacion de codigo","output":["Es el proceso de escribir l\xedneas de texto en un lenguaje de programaci\xf3n para construir software.","Es desarrollar instrucciones que definen c\xf3mo debe funcionar un programa o sistema."]},{"input":"que es automatizar","output":["Es hacer que procesos o tareas se realicen autom\xe1ticamente sin intervenci\xf3n humana constante.","Es usar tecnolog\xeda para ejecutar actividades repetitivas de manera eficiente."]},{"input":"que es un dispositivo electronico","output":["Es un aparato que funciona con electricidad y realiza tareas espec\xedficas mediante circuitos electr\xf3nicos.","Es una m\xe1quina que usa componentes el\xe9ctricos y electr\xf3nicos para procesar informaci\xf3n o realizar acciones."]},{"input":"que significa procesar informacion","output":["Es realizar operaciones sobre datos para transformarlos en informaci\xf3n \xfatil.","Es aplicar algoritmos o reglas para analizar, organizar o convertir datos."]},{"input":"que es almacenar datos","output":["Es guardar informaci\xf3n en un medio f\xedsico o digital para su uso futuro.","Es conservar datos de manera organizada para acceder a ellos cuando se necesiten."]},{"input":"que es informacion util","output":["Es conocimiento derivado de datos que tiene valor para tomar decisiones o resolver problemas.","Es el resultado de procesar datos de manera que sean comprensibles y accionables."]},{"input":"que es conocimiento derivado","output":["Es informaci\xf3n obtenida al procesar y analizar datos de forma l\xf3gica y sistem\xe1tica.","Es el entendimiento generado a partir de datos que tienen un contexto o un prop\xf3sito."]},{"input":"que es una tarea automatica","output":["Es una actividad que se realiza sin necesidad de intervenci\xf3n humana continua.","Es un proceso que se ejecuta de manera independiente mediante programaci\xf3n o dispositivos."]},{"input":"que son pasos organizados","output":["Son acciones dispuestas en un orden l\xf3gico para alcanzar un objetivo espec\xedfico.","Son instrucciones estructuradas que garantizan que un proceso se realice de manera efectiva."]},{"input":"que significa tomar decisiones","output":["Es el proceso de elegir una opci\xf3n entre varias alternativas disponibles.","Es analizar informaci\xf3n para seleccionar la acci\xf3n m\xe1s adecuada en una situaci\xf3n dada."]},{"input":"que es analizar datos","output":["Es examinar informaci\xf3n detalladamente para extraer patrones, tendencias o conclusiones.","Es el proceso de evaluar datos para comprenderlos y utilizarlos en la toma de decisiones."]},{"input":"que es un medio digital","output":["Es un soporte electr\xf3nico como discos duros, la nube o dispositivos USB donde se almacena informaci\xf3n.","Es un entorno basado en tecnolog\xeda digital que permite guardar y transmitir datos."]},{"input":"que significa transformar datos","output":["Es modificar o reorganizar informaci\xf3n para cambiar su formato, estructura o prop\xf3sito.","Es convertir datos en una forma m\xe1s \xfatil o comprensible para an\xe1lisis o uso."]},{"input":"que es una tarea repetitiva","output":["Es una acci\xf3n que se realiza una y otra vez de manera similar o id\xe9ntica.","Es un proceso que no cambia con el tiempo y que suele ser automatizable."]},{"input":"que es automatizable","output":["Es algo que puede configurarse para ejecutarse autom\xe1ticamente sin intervenci\xf3n humana.","Es una actividad susceptible de ser realizada por sistemas tecnol\xf3gicos de forma aut\xf3noma."]},{"input":"que son reglas organizadas","output":["Son normas dispuestas de forma l\xf3gica y estructurada para garantizar un funcionamiento eficiente.","Son principios que definen un orden para realizar tareas de manera efectiva."]},{"input":"que significa realizar tareas","output":["Es ejecutar actividades o acciones espec\xedficas para cumplir con un objetivo.","Es llevar a cabo un conjunto de pasos que conducen a un resultado esperado."]},{"input":"que es una actividad estructurada","output":["Es una acci\xf3n planificada con un inicio, desarrollo y final definidos.","Es un conjunto de pasos organizados para lograr un prop\xf3sito claro."]},{"input":"que es identificar patrones","output":["Es reconocer estructuras o repeticiones dentro de un conjunto de datos o informaci\xf3n.","Es detectar similitudes o regularidades que ayuden a interpretar o predecir comportamientos."]},{"input":"que es codigo","output":["Es un conjunto de instrucciones escritas en un lenguaje de programaci\xf3n para ser ejecutadas por una computadora.","Es una representaci\xf3n estructurada de \xf3rdenes que permiten realizar tareas o resolver problemas mediante software."]},{"input":"que es un conjunto de instrucciones","output":["Son varias \xf3rdenes organizadas que, al ser ejecutadas, logran un objetivo o completan una tarea.","Es una secuencia de pasos que indica a una computadora c\xf3mo realizar una acci\xf3n espec\xedfica."]},{"input":"que es una representacion estructurada","output":["Es una forma organizada de presentar informaci\xf3n o datos siguiendo un esquema l\xf3gico.","Es un modelo o formato claro y ordenado que facilita la comprensi\xf3n y ejecuci\xf3n de un proceso."]},{"input":"que significa ser ejecutadas","output":["Es llevar a cabo las instrucciones de un c\xf3digo para que se realicen las acciones indicadas.","Es procesar las \xf3rdenes de un programa para generar resultados o realizar tareas."]},{"input":"que son ordenes","output":["Son comandos espec\xedficos que indican a una computadora qu\xe9 hacer y c\xf3mo hacerlo.","Son instrucciones puntuales que se deben seguir para completar un proceso."]},{"input":"que significa realizar tareas mediante software","output":["Es usar programas o aplicaciones para ejecutar actividades o resolver problemas autom\xe1ticamente.","Es emplear herramientas tecnol\xf3gicas para llevar a cabo acciones espec\xedficas de manera eficiente."]},{"input":"que es una computadora ejecutando codigo","output":["Es un dispositivo procesando instrucciones escritas en un lenguaje de programaci\xf3n.","Es el acto de interpretar y seguir las \xf3rdenes definidas en un c\xf3digo para realizar acciones."]},{"input":"que significa procesar instrucciones","output":["Es interpretar y realizar las acciones indicadas por un conjunto de \xf3rdenes.","Es ejecutar pasos definidos en un c\xf3digo para producir resultados espec\xedficos."]},{"input":"que es resolver problemas con codigo","output":["Es escribir y ejecutar instrucciones para encontrar soluciones a desaf\xedos o necesidades.","Es usar lenguajes de programaci\xf3n para automatizar procesos o crear herramientas que simplifiquen tareas."]},{"input":"que significa escribir un conjunto de ordenes","output":["Es redactar instrucciones en un lenguaje de programaci\xf3n para que una computadora las entienda.","Es dise\xf1ar una secuencia l\xf3gica de pasos para lograr un objetivo o realizar una tarea."]},{"input":"que es un modelo ordenado","output":["Es una estructura organizada que facilita la comprensi\xf3n y ejecuci\xf3n de un proceso.","Es un esquema l\xf3gico que define c\xf3mo deben realizarse tareas o procesarse datos."]},{"input":"que es un algoritmo","output":["es una secuencia de pasos definidos para resolver un problema","es un conjunto de instrucciones que se ejecutan en orden para alcanzar un objetivo","es una serie de pasos logicos que describen como resolver una tarea especifica"]},{"input":"que significa un conjunto de pasos","output":["Son varias acciones organizadas en un orden l\xf3gico para lograr un resultado.","Es una serie de etapas que se deben seguir para completar una tarea o resolver un problema."]},{"input":"que significa definido de manera logica","output":["Es estructurado de forma clara y coherente, siguiendo reglas o principios razonables.","Es dise\xf1ado para que cada paso tenga sentido y est\xe9 alineado con el objetivo final."]},{"input":"que significa resolver un problema con un algoritmo","output":["Es usar una secuencia de pasos claros para encontrar una soluci\xf3n a una dificultad o necesidad.","Es aplicar un conjunto de instrucciones organizadas para superar un reto o cumplir un prop\xf3sito."]},{"input":"que significa una serie de pasos escritos","output":["Es una lista de acciones detalladas redactadas en un formato que puede ser entendido y seguido.","Es un grupo de instrucciones documentadas de manera clara y organizada."]},{"input":"que significa interpretar un algoritmo","output":["Es analizar cada paso de un conjunto de instrucciones para ejecutarlo de manera adecuada.","Es convertir las acciones definidas en un algoritmo en operaciones que la computadora pueda realizar."]},{"input":"que es ejecutar un algoritmo","output":["Es realizar los pasos definidos en un algoritmo para obtener un resultado.","Es seguir las instrucciones de un algoritmo para resolver un problema o completar una tarea."]},{"input":"para que sirve un algoritmo","output":["sirve para resolver problemas de manera estructurada y eficiente","se utiliza para automatizar tareas y encontrar soluciones a problemas complejos","es esencial para crear programas y sistemas que resuelvan problemas especificos"]},{"input":"cuales son las caracteristicas de un algoritmo","output":["debe ser finito, tener pasos bien definidos y ser preciso","tiene un inicio y un fin, y debe producir un resultado correcto","debe ser claro, eficiente y aplicable en cualquier contexto definido"]},{"input":"cuales son los tipos de algoritmos","output":["algunos tipos son los algoritmos recursivos, iterativos, voraces y dinamicos","pueden ser de busqueda, ordenamiento, optimizacion o generacion","se clasifican segun su enfoque como divide y venceras, backtracking o algoritmos probabilisticos"]},{"input":"que es un algoritmo recursivo","output":["es un algoritmo que se llama a si mismo para resolver un problema","es un tipo de algoritmo que divide un problema grande en subproblemas mas peque\xf1os","se basa en definirse en terminos de si mismo hasta alcanzar un caso base"]},{"input":"que ejemplos hay de algoritmos recursivos","output":["el calculo del factorial de un numero es un ejemplo clasico","la sucesion de fibonacci se puede resolver con un algoritmo recursivo","la busqueda en profundidad en un grafo es otro ejemplo comun"]},{"input":"que es un algoritmo de ordenamiento","output":["es un algoritmo dise\xf1ado para reorganizar elementos en un orden especifico","sirve para ordenar datos de forma ascendente o descendente","es una tecnica para organizar listas de datos como numeros o cadenas"]},{"input":"cuales son los algoritmos de ordenamiento mas comunes","output":["algunos son quicksort, mergesort, bubble sort y insertion sort","los mas comunes incluyen quicksort, heapsort y selection sort","puedes encontrar algoritmos como merge sort y radix sort entre los mas usados"]},{"input":"que es quicksort","output":["es un algoritmo de ordenamiento basado en divide y venceras","organiza los elementos seleccionando un pivote y particionando los datos alrededor de el","es un metodo eficiente para ordenar listas grandes de datos"]},{"input":"cual es la complejidad de quicksort","output":["en el mejor caso y promedio es o n log n","en el peor caso puede ser o n al cuadrado si los pivotes se eligen mal","es eficiente en la mayoria de los casos pero depende de como se seleccionen los pivotes"]},{"input":"que es un algoritmo voraz","output":["es un algoritmo que toma decisiones optimas en cada paso con la esperanza de encontrar la solucion global optima","se utiliza en problemas donde las soluciones parciales optimas llevan a la solucion completa","es un enfoque para resolver problemas dividiendo la solucion en pasos secuenciales"]},{"input":"cuales son ejemplos de algoritmos voraces","output":["el algoritmo de dijkstra para encontrar el camino mas corto en un grafo","el problema de la mochila fraccional puede resolverse con un enfoque voraz","el algoritmo de kruskal para arboles de expansion minima es otro ejemplo"]},{"input":"que diferencia hay entre algoritmos voraces y dinamicos","output":["los algoritmos voraces toman decisiones paso a paso, mientras que los dinamicos resuelven subproblemas y combinan soluciones","los voraces buscan soluciones optimas inmediatas, los dinamicos almacenan resultados intermedios para optimizar el proceso","los voraces son mas simples pero no siempre garantizan la solucion optima como los dinamicos"]},{"input":"que es un algoritmo dinamico","output":["es un metodo para resolver problemas dividiendolos en subproblemas y almacenando sus soluciones","es un enfoque que evita recomputaciones al guardar resultados en memoria","se utiliza para problemas que tienen subproblemas solapados y propiedades de optimizacion"]},{"input":"que ejemplos hay de algoritmos dinamicos","output":["el algoritmo de floyd-warshall para caminos mas cortos en grafos","la solucion al problema de la mochila entera es un clasico de la programacion dinamica","el calculo de la sucesion de fibonacci con memoizacion es otro ejemplo"]},{"input":"que tipos de instrucciones tiene un algoritmo","output":["puede tener instrucciones secuenciales, condicionales y repetitivas","las instrucciones se clasifican en secuenciales, de decision y de repeticion","puede incluir instrucciones de flujo lineal, bifurcaciones y bucles"]},{"input":"que es una instruccion secuencial","output":["es una instruccion que se ejecuta una tras otra en el orden en que aparecen","son pasos que se siguen de manera lineal sin desviarse","es un tipo de instruccion donde cada accion ocurre exactamente una vez"]},{"input":"que significa transformar un conjunto de instrucciones","output":["Es modificar las \xf3rdenes para adaptarlas a un formato o contexto espec\xedfico.","Es convertir pasos definidos en una estructura que pueda ser procesada o ejecutada."]},{"input":"que es un formato especifico","output":["Es una estructura definida que organiza informaci\xf3n de manera que pueda ser interpretada correctamente.","Es una disposici\xf3n est\xe1ndar que asegura que los datos sean entendidos o utilizados adecuadamente."]},{"input":"que es una estructura definida","output":["Es un esquema previamente dise\xf1ado que organiza elementos de manera coherente.","Es un marco l\xf3gico que establece c\xf3mo deben ordenarse las partes de un sistema o proceso."]},{"input":"que significa modificar un algoritmo","output":["Es ajustar los pasos de un conjunto de instrucciones para adaptarlos a nuevas necesidades o mejorar su eficiencia.","Es cambiar la l\xf3gica o estructura de un algoritmo para optimizar su funcionamiento."]},{"input":"que significa optimizar un algoritmo","output":["Es mejorar un conjunto de instrucciones para que sea m\xe1s r\xe1pido o eficiente al resolver un problema.","Es reducir el tiempo o los recursos necesarios para ejecutar un algoritmo manteniendo su funcionalidad."]},{"input":"que es la eficiencia en un algoritmo","output":["Es la capacidad de resolver un problema utilizando la menor cantidad posible de tiempo y recursos.","Es la medida de cu\xe1n bien un algoritmo realiza su tarea en comparaci\xf3n con otros m\xe9todos."]},{"input":"que significa comparar metodos","output":["Es analizar diferentes t\xe9cnicas o enfoques para identificar cu\xe1l es m\xe1s adecuado o eficiente.","Es evaluar las ventajas y desventajas de distintos procesos para elegir el mejor."]},{"input":"que significa elegir un metodo","output":["Es seleccionar la t\xe9cnica m\xe1s adecuada para resolver un problema o realizar una tarea espec\xedfica.","Es tomar una decisi\xf3n basada en la eficiencia y las caracter\xedsticas de cada opci\xf3n disponible."]},{"input":"que es una tecnica adecuada","output":["Es un enfoque o m\xe9todo que se ajusta de manera efectiva a las necesidades de una tarea o problema.","Es una estrategia que permite lograr un objetivo de forma precisa y eficiente."]},{"input":"que es la logica en un algoritmo","output":["Es la base racional que organiza los pasos de un conjunto de instrucciones para garantizar que cumplan su prop\xf3sito.","Es el razonamiento que gu\xeda la secuencia y estructura de las acciones dentro de un algoritmo."]},{"input":"puedes darme ejemplos de instrucciones secuenciales","output":["asignar un valor a una variable, mostrar un mensaje en pantalla y realizar una suma","leer un dato del usuario, calcular el doble y mostrar el resultado","calcular el promedio de tres numeros, imprimirlo y finalizar el programa"]},{"input":"que es una instruccion condicional","output":["es una instruccion que permite tomar decisiones basadas en una condicion","se utiliza para ejecutar diferentes bloques de codigo segun si una condicion es verdadera o falsa","es un tipo de instruccion que evalua una expresion y decide el flujo del algoritmo"]},{"input":"puedes darme ejemplos de instrucciones condicionales","output":["si la edad es mayor o igual a 18, mostrar eres mayor de edad","si el numero es positivo, imprimir es positivo, de lo contrario imprimir es negativo","verificar si un numero es par o impar y mostrar el resultado"]},{"input":"que es una instruccion repetitiva","output":["es una instruccion que ejecuta un bloque de codigo varias veces mientras se cumpla una condicion","se utiliza para realizar tareas repetitivas de manera automatica","es un tipo de instruccion que repite una accion hasta que se cumple un criterio de finalizacion"]},{"input":"puedes darme ejemplos de instrucciones repetitivas","output":["repetir hasta que el usuario introduzca un numero mayor a 0","calcular la suma de los numeros del 1 al 100 utilizando un bucle","mostrar los numeros pares entre 1 y 50 utilizando un bucle for"]},{"input":"que tipos de bucles existen en los algoritmos","output":["los mas comunes son bucles for, while y do while","puedes usar bucles definidos como for y bucles indeterminados como while","los tipos principales son for para iteraciones definidas y while para condiciones"]},{"input":"que es un bucle for","output":["es un bucle que repite un bloque de codigo un numero fijo de veces","se utiliza cuando se conoce de antemano la cantidad de iteraciones","es una estructura que incluye un inicio, una condicion y un incremento o decremento"]},{"input":"puedes darme ejemplos de un bucle for","output":["recorrer un arreglo para imprimir cada elemento","mostrar los numeros del 1 al 10 incrementando de uno en uno","calcular el factorial de un numero utilizando un bucle for"]},{"input":"que es un bucle while","output":["es un bucle que ejecuta un bloque de codigo mientras una condicion sea verdadera","se utiliza cuando no se sabe exactamente cuantas veces se repetira la tarea","es una estructura que evalua una condicion antes de ejecutar el bloque de codigo"]},{"input":"puedes darme ejemplos de un bucle while","output":["seguir pidiendo al usuario un numero hasta que introduzca un numero positivo","sumar numeros introducidos por el usuario hasta que ingrese cero","mostrar un contador que incrementa mientras sea menor a 10"]},{"input":"puedes darme ejemplos de un bucle do while","output":["pedir al usuario un numero hasta que introduzca uno mayor a 10","mostrar un mensaje en pantalla al menos una vez, luego repetir segun una condicion","calcular la suma de numeros ingresados hasta que el usuario escriba salir"]},{"input":"que son las instrucciones de entrada y salida en un algoritmo","output":["son las instrucciones que permiten interactuar con el usuario o el entorno","las instrucciones de entrada capturan datos, y las de salida los muestran o los envian","se utilizan para recibir informacion del usuario y mostrar resultados o mensajes"]},{"input":"puedes darme ejemplos de instrucciones de entrada y salida","output":["leer un numero del usuario y mostrar su cuadrado","pedir al usuario su nombre y mostrar un mensaje de bienvenida","capturar dos numeros y mostrar su suma en pantalla"]},{"input":"que es un lenguaje de programacion","output":["es un medio para comunicarse con una computadora mediante instrucciones","es un sistema de notacion para escribir programas que ejecuta una computadora","es una herramienta para crear software a traves de instrucciones entendibles por maquinas"]},{"input":"que significa escribir instrucciones en un lenguaje de programacion","output":["Es redactar un conjunto de \xf3rdenes en un formato que la computadora pueda interpretar y ejecutar.","Es usar la sintaxis de un lenguaje de programaci\xf3n para definir c\xf3mo se deben realizar las acciones en un algoritmo."]},{"input":"que es la sintaxis de un lenguaje de programacion","output":["Es el conjunto de reglas que dictan c\xf3mo deben escribirse las instrucciones para que sean comprendidas por una computadora.","Es la estructura y el orden en el que deben organizarse los comandos en un lenguaje de programaci\xf3n."]},{"input":"que es un programa en un lenguaje de programacion","output":["Es un conjunto de instrucciones escritas en un lenguaje de programaci\xf3n para ejecutar una tarea espec\xedfica.","Es un algoritmo codificado en un formato que una computadora puede procesar y ejecutar."]},{"input":"que significa codificar un algoritmo","output":["Es traducir un conjunto de pasos l\xf3gicos de un algoritmo a un lenguaje de programaci\xf3n para que pueda ser ejecutado por una computadora.","Es escribir un algoritmo utilizando la sintaxis y reglas de un lenguaje de programaci\xf3n."]},{"input":"que significa traducir un algoritmo","output":["Es convertir las instrucciones de un algoritmo a un formato que pueda ser interpretado por una computadora.","Es transformar un conjunto de pasos l\xf3gicos en c\xf3digo utilizando un lenguaje de programaci\xf3n."]},{"input":"cuales son los tipos de lenguajes de programacion","output":["los principales tipos son lenguajes de bajo nivel y de alto nivel","se clasifican en lenguajes de maquina, ensambladores, y lenguajes como c o python","pueden ser de bajo nivel como ensamblador o de alto nivel como java o python"]},{"input":"que es un lenguaje de bajo nivel","output":["es un lenguaje cercano al hardware de la computadora, como el lenguaje ensamblador","es un tipo de lenguaje que opera directamente con instrucciones de maquina","es un lenguaje menos abstracto que requiere conocer detalles del hardware"]},{"input":"dame ejemplos de lenguajes de bajo nivel","output":["ensamblador y lenguaje de maquina son ejemplos clasicos","los microcontroladores a menudo usan lenguaje ensamblador","el codigo binario es el lenguaje de bajo nivel mas basico"]},{"input":"que es un lenguaje de alto nivel","output":["es un lenguaje dise\xf1ado para ser facil de entender por los humanos","es un tipo de lenguaje mas abstracto que oculta los detalles del hardware","es una herramienta para escribir programas complejos con sintaxis cercana al lenguaje natural"]},{"input":"dame ejemplos de lenguajes de alto nivel","output":["python, java, c++, y javascript son ejemplos de lenguajes de alto nivel","lenguajes como ruby, php y swift son tambien de alto nivel","herramientas populares como go y kotlin pertenecen a esta categoria"]},{"input":"que diferencia hay entre lenguajes de alto y bajo nivel","output":["los de bajo nivel son cercanos al hardware, mientras que los de alto nivel son mas faciles para los humanos","los lenguajes de bajo nivel requieren mas conocimiento del hardware, los de alto nivel son mas abstractos","en los lenguajes de alto nivel escribes menos lineas de codigo para tareas complejas"]},{"input":"que es un lenguaje compilado","output":["es un lenguaje que se traduce a codigo maquina antes de ejecutarse","es un tipo de lenguaje donde el programa completo se convierte a binario antes de ejecutarse","es un lenguaje que necesita un compilador para generar un ejecutable"]},{"input":"puedes darme ejemplos de lenguajes compilados","output":["c, c++ y rust son ejemplos de lenguajes compilados","lenguajes como go y fortran son compilados","swift y kotlin tambien pueden ser compilados"]},{"input":"que es un lenguaje interpretado","output":["es un lenguaje que se ejecuta directamente por un interprete sin necesidad de compilar","es un tipo de lenguaje donde las instrucciones se traducen y ejecutan en tiempo real","los lenguajes interpretados no generan un archivo binario antes de ejecutarse"]},{"input":"puedes darme ejemplos de lenguajes interpretados","output":["python, javascript y ruby son lenguajes interpretados","php y perl son otros ejemplos de lenguajes interpretados","lenguajes como lua y bash tambien son interpretados"]},{"input":"que diferencia hay entre lenguajes compilados e interpretados","output":["los compilados generan un ejecutable antes de ejecutarse, los interpretados no","los compilados son mas rapidos en ejecucion, pero los interpretados son mas flexibles","los interpretados traducen instrucciones en tiempo real, los compilados lo hacen antes"]},{"input":"que es un lenguaje orientado a objetos","output":["es un lenguaje que organiza el codigo en objetos que representan entidades del mundo real","es un paradigma de programacion que utiliza clases y objetos para estructurar el codigo","es un tipo de lenguaje donde los datos y las funciones se encapsulan en objetos"]},{"input":"puedes darme ejemplos de lenguajes orientados a objetos","output":["java, python, c++ y ruby son lenguajes orientados a objetos","lenguajes como kotlin y swift tambien usan orientacion a objetos","c# y javascript soportan programacion orientada a objetos"]},{"input":"que es un lenguaje funcional","output":["es un lenguaje que trata las computaciones como evaluaciones de funciones matematicas","es un paradigma donde las funciones son las unidades principales del programa","los lenguajes funcionales evitan estados y datos mutables"]},{"input":"puedes darme ejemplos de lenguajes funcionales","output":["haskell, elixir y erlang son ejemplos de lenguajes funcionales","lenguajes como f# y clojure tambien son funcionales","scala y ocaml soportan el paradigma funcional"]},{"input":"que es un lenguaje de scripting","output":["es un lenguaje dise\xf1ado para automatizar tareas en un sistema operativo o aplicacion","es un tipo de lenguaje utilizado para escribir scripts que controlan programas o procesos","los lenguajes de scripting son comunmente interpretados y usados para tareas rapidas"]},{"input":"puedes darme ejemplos de lenguajes de scripting","output":["javascript, python y bash son lenguajes de scripting comunes","lenguajes como ruby, php y perl son tambien de scripting","lua y powershell son otros ejemplos de lenguajes de scripting"]},{"input":"que es python","output":["es un lenguaje de programacion de alto nivel, interpretado y multiproposito","es un lenguaje popular por su sintaxis sencilla y gran cantidad de bibliotecas","es una herramienta muy utilizada para ciencia de datos, inteligencia artificial y desarrollo web"]},{"input":"para que se utiliza python","output":["se utiliza en ciencia de datos, inteligencia artificial, desarrollo web y automatizacion","es comun en analisis de datos, aprendizaje automatico y desarrollo de aplicaciones","tambien se usa para crear scripts, manejar datos y programar aplicaciones"]},{"input":"que es java","output":["es un lenguaje de programacion de alto nivel, orientado a objetos y multiplataforma","es un lenguaje conocido por su portabilidad gracias a la maquina virtual de java","es una herramienta popular para aplicaciones empresariales y desarrollo movil"]},{"input":"para que se utiliza java","output":["se utiliza para desarrollar aplicaciones empresariales, juegos y software para android","es comun en aplicaciones de servidor, sistemas distribuidos y aplicaciones web","tambien se usa para programar dispositivos embebidos y aplicaciones de escritorio"]},{"input":"que es javascript","output":["es un lenguaje de programacion de alto nivel utilizado principalmente para desarrollo web","es un lenguaje interpretado que permite crear paginas web dinamicas e interactivas","es una herramienta clave para la programacion del lado del cliente y del servidor"]},{"input":"para que se utiliza javascript","output":["se utiliza para crear interfaces web interactivas y aplicaciones web modernas","es comun en el desarrollo del lado del cliente y del servidor con nodejs","tambien se usa para manejar eventos en paginas web y construir juegos web"]},{"input":"que es c","output":["es un lenguaje de programacion de bajo nivel, estructurado y eficiente","es conocido por su velocidad y control sobre los recursos del sistema","es una herramienta utilizada para sistemas operativos, compiladores y aplicaciones de alto rendimiento"]},{"input":"para que se utiliza c","output":["se utiliza en el desarrollo de sistemas operativos y software de hardware","es comun para programar dispositivos embebidos y aplicaciones de alto rendimiento","tambien se usa en videojuegos, simulaciones y sistemas en tiempo real"]},{"input":"que es c++","output":["es un lenguaje de programacion de alto nivel basado en c, con soporte para programacion orientada a objetos","es un lenguaje versatil y eficiente utilizado para desarrollo de software complejo","es una extension de c que incluye caracteristicas avanzadas como clases y objetos"]},{"input":"para que se utiliza c++","output":["se utiliza para desarrollar videojuegos, software de simulacion y motores graficos","es comun en el desarrollo de sistemas operativos y aplicaciones cientificas","tambien se usa para aplicaciones de alto rendimiento y sistemas embebidos"]},{"input":"que es ruby","output":["es un lenguaje de programacion de alto nivel, interpretado y orientado a objetos","es conocido por su enfoque en la simplicidad y productividad","es una herramienta popular para desarrollo web, especialmente con ruby on rails"]},{"input":"para que se utiliza ruby","output":["se utiliza principalmente para desarrollo web con el framework ruby on rails","es comun en aplicaciones de automatizacion y scripting","tambien se usa para prototipos rapidos y desarrollo de aplicaciones dinamicas"]},{"input":"que es kotlin","output":["es un lenguaje de programacion moderno y de alto nivel desarrollado por jetbrains","es conocido por ser interoperable con java y utilizado principalmente para desarrollo movil","es una herramienta popular para desarrollar aplicaciones android y sistemas backend"]},{"input":"para que se utiliza kotlin","output":["se utiliza para desarrollar aplicaciones android y sistemas backend","es comun en proyectos que requieren integracion con java","tambien se usa para aplicaciones multiplataforma y microservicios"]},{"input":"que es swift","output":["es un lenguaje de programacion moderno desarrollado por apple para sus plataformas","es conocido por ser rapido, seguro y facil de aprender","es una herramienta popular para desarrollar aplicaciones para ios y macos"]},{"input":"para que se utiliza swift","output":["se utiliza para desarrollar aplicaciones para ios, macos, watchos y tvos","es comun en el ecosistema apple para aplicaciones moviles y de escritorio","tambien se usa para aprendizaje y proyectos de codigo abierto en la comunidad apple"]},{"input":"que es rust","output":["es un lenguaje de programacion moderno enfocado en seguridad y rendimiento","es conocido por su sistema de manejo de memoria que evita errores comunes","es una herramienta utilizada para sistemas de alto rendimiento y software seguro"]},{"input":"para que se utiliza rust","output":["se utiliza para desarrollar sistemas embebidos, navegadores y software seguro","es comun en proyectos donde el rendimiento y la seguridad son criticos","tambien se usa en aplicaciones de sistemas como motores de bases de datos"]},{"input":"que es go","output":["es un lenguaje de programacion creado por google enfocado en la simplicidad y el rendimiento","es conocido por ser rapido, escalable y facil de compilar","es una herramienta popular para sistemas distribuidos y servicios web"]},{"input":"para que se utiliza go","output":["se utiliza para desarrollar servicios web, herramientas de infraestructura y sistemas distribuidos","es comun en aplicaciones de alto rendimiento como servidores y microservicios","tambien se usa en proyectos de red, cloud computing y contenedores"]},{"input":"cuales son las ventajas de python","output":["es facil de aprender y leer gracias a su sintaxis simple","tiene una gran cantidad de bibliotecas y frameworks disponibles","es multiplataforma y ampliamente soportado por la comunidad"]},{"input":"cuales son las desventajas de python","output":["es mas lento que otros lenguajes como c o java","consume mas recursos debido a su naturaleza interpretada","no es la mejor opcion para aplicaciones de tiempo real"]},{"input":"que frameworks existen en python","output":["algunos frameworks populares son django, flask y fastapi","tambien estan pandas y numpy para analisis de datos","se usa tensorflow y pytorch para inteligencia artificial"]},{"input":"que diferencia hay entre python y java","output":["python tiene una sintaxis mas sencilla y es interpretado","java es mas rapido y se compila en bytecode para la maquina virtual","java se usa mas para aplicaciones empresariales, mientras que python es comun en analisis de datos"]},{"input":"que caracteristicas tiene java","output":["es orientado a objetos y tiene recoleccion automatica de basura","es multiplataforma gracias a la maquina virtual de java","tiene un sistema de tipado estatico que previene errores en tiempo de compilacion"]},{"input":"cuales son las ventajas de java","output":["es muy escalable y adecuado para aplicaciones empresariales","tiene un ecosistema maduro y documentacion amplia","es compatible con una gran cantidad de plataformas"]},{"input":"que frameworks existen en java","output":["algunos frameworks populares son spring, hibernate y struts","spring boot es comun para desarrollar microservicios","javafx se usa para crear interfaces graficas"]},{"input":"que caracteristicas tiene c++","output":["soporta programacion orientada a objetos y funcional","permite un control detallado sobre la memoria","es un lenguaje compilado que ofrece alto rendimiento"]},{"input":"que diferencia hay entre c y c++","output":["c es un lenguaje estructurado mientras que c++ soporta programacion orientada a objetos","c++ incluye funcionalidades como clases, herencia y polimorfismo","c se usa para sistemas operativos, mientras que c++ es mas comun en videojuegos y simulaciones"]},{"input":"que es un framework","output":["es una estructura de codigo predefinida que facilita el desarrollo de aplicaciones","es un conjunto de herramientas y bibliotecas que ayudan a resolver problemas comunes","sirve para agilizar y estandarizar el proceso de desarrollo"]},{"input":"como elegir un lenguaje de programacion","output":["depende del proyecto que desees realizar, como desarrollo web o aplicaciones moviles","considera el soporte comunitario y las herramientas disponibles","piensa en la curva de aprendizaje y tus objetivos a largo plazo"]},{"input":"que es django","output":["es un framework de alto nivel para desarrollo web en python","es conocido por seguir el principio de no te repitas y facilitar el desarrollo rapido","incluye herramientas para manejar bases de datos, autentificacion y mas"]},{"input":"que ventajas tiene django","output":["tiene un sistema de administracion integrado y poderoso","es escalable y adecuado para proyectos peque\xf1os y grandes","sigue buenas practicas como el principio mvc"]},{"input":"que es flask","output":["es un microframework para desarrollo web en python","es conocido por ser ligero y facil de extender","permite crear aplicaciones web con minima configuracion"]},{"input":"para que sirve flask","output":["se utiliza para desarrollar aplicaciones web peque\xf1as y api","es ideal para proyectos que requieren flexibilidad","se usa en aplicaciones donde no se necesita un framework robusto como django"]},{"input":"que frameworks hay para inteligencia artificial en python","output":["algunos populares son tensorflow, pytorch y scikit-learn","tensorflow es usado para redes neuronales y aprendizaje profundo","scikit-learn es ideal para aprendizaje automatico clasico"]},{"input":"que es spring","output":["es un framework para desarrollo de aplicaciones empresariales en java","proporciona herramientas para desarrollar aplicaciones escalables","soporta programacion orientada a aspectos y gestion de dependencias"]},{"input":"para que sirve spring boot","output":["sirve para crear aplicaciones java con configuracion minima","facilita el desarrollo de microservicios","es ideal para proyectos que requieren implementacion rapida"]},{"input":"que es hibernate","output":["es un framework de mapeo objeto-relacional para java","permite interactuar con bases de datos de manera eficiente","facilita la persistencia de datos en aplicaciones java"]},{"input":"que diferencia hay entre spring y hibernate","output":["spring es un framework general para aplicaciones empresariales","hibernate se centra en el mapeo de datos y la persistencia","spring puede integrar hibernate como parte de su ecosistema"]},{"input":"que es react","output":["es una biblioteca de javascript para construir interfaces de usuario","es desarrollada por facebook y se centra en componentes reutilizables","es ideal para aplicaciones web dinamicas y modernas"]},{"input":"para que sirve react","output":["sirve para crear aplicaciones web con interfaces dinamicas","se utiliza para construir paginas web de una sola pagina o spa","facilita la gestion del estado y el renderizado de componentes"]},{"input":"que es angular","output":["es un framework de javascript para desarrollo de aplicaciones web","es mantenido por google y sigue una arquitectura basada en componentes","ofrece herramientas integradas como inyeccion de dependencias y enrutamiento"]},{"input":"que diferencia hay entre angular y react","output":["angular es un framework completo mientras que react es una biblioteca","react permite mas flexibilidad al integrar herramientas externas","angular tiene una curva de aprendizaje mas pronunciada pero ofrece mas funcionalidades integradas"]},{"input":"que es vue","output":["es un framework progresivo de javascript para construir interfaces de usuario","es conocido por su simplicidad y facilidad de integracion","es ideal para proyectos peque\xf1os y grandes que requieren modularidad"]},{"input":"que frameworks existen en c++","output":["algunos populares son qt, boost y poco","qt se usa para desarrollo de aplicaciones multiplataforma con interfaces graficas","boost proporciona bibliotecas para muchas tareas comunes como gestion de memoria"]},{"input":"que es qt","output":["es un framework para c++ enfocado en aplicaciones graficas y multiplataforma","incluye herramientas para crear interfaces graficas modernas","es utilizado en software de escritorio, movil y embebido"]},{"input":"que frameworks hay para desarrollo movil","output":["algunos populares son flutter, react native y xamarin","flutter es desarrollado por google y usa dart como lenguaje base","react native permite desarrollar aplicaciones moviles usando javascript"]},{"input":"que es flutter","output":["es un framework de google para desarrollo movil multiplataforma","permite crear aplicaciones nativas con una sola base de codigo","usa dart como lenguaje de programacion"]},{"input":"que es react native","output":["es un framework basado en javascript para desarrollo movil","permite crear aplicaciones para ios y android con una sola base de codigo","se basa en la misma filosofia de componentes que react"]},{"input":"que es frontend","output":["es la parte visual de una aplicacion con la que interactuan los usuarios","se refiere al desarrollo de interfaces graficas y experiencias de usuario","incluye tecnologias como html, css y javascript"]},{"input":"que lenguajes se usan en frontend","output":["los principales son html, css y javascript","tambien se utilizan tecnologias como typescript y frameworks como react o angular"]},{"input":"que es html","output":["es un lenguaje de marcado utilizado para estructurar el contenido de una pagina web","define la estructura basica de una pagina como encabezados, parrafos y enlaces","es esencial para el desarrollo frontend"]},{"input":"que es css","output":["es un lenguaje de estilos usado para definir la apariencia de una pagina web","permite personalizar colores, fuentes y dise\xf1o de los elementos","se usa junto con html para mejorar la experiencia visual"]},{"input":"que es javascript","output":["es un lenguaje de programacion utilizado para a\xf1adir interactividad a las paginas web","permite crear funcionalidades dinamicas como animaciones y validaciones","es esencial para el desarrollo frontend moderno"]},{"input":"que frameworks se usan en frontend","output":["algunos populares son react, angular y vue","bootstrap se usa para dise\xf1o responsivo","tailwind css es una herramienta moderna para estilos"]},{"input":"que diferencia hay entre react y angular","output":["react es una biblioteca mientras que angular es un framework completo","react ofrece mas flexibilidad, pero angular incluye mas herramientas integradas","react se usa para proyectos ligeros y angular para aplicaciones robustas"]},{"input":"que es un spa","output":["es una aplicacion de pagina unica donde el contenido se carga dinamicamente","evita recargar toda la pagina al navegar entre secciones","es comun en frameworks como react, angular y vue"]},{"input":"que es backend","output":["es la parte de un sistema que maneja la logica, bases de datos y servidores","se encarga de procesar solicitudes y enviar respuestas al frontend","es esencial para manejar la logica de negocio de una aplicacion"]},{"input":"que lenguajes se usan en backend","output":["algunos populares son java, python, php, ruby y javascript con nodejs","tambien se usa go, c# y kotlin dependiendo del caso de uso"]},{"input":"que frameworks se usan en backend","output":["algunos populares son spring boot para java, django y flask para python","laravel para php y express para nodejs son opciones comunes","tambien se usa ruby on rails y .net core"]},{"input":"que es nodejs","output":["es un entorno de ejecucion de javascript para el backend","permite desarrollar aplicaciones escalables con un unico lenguaje","es conocido por su eficiencia en manejo de multiples solicitudes"]},{"input":"que es flask","output":["es un microframework de python para desarrollo backend","es ligero y permite crear api rapidas con minima configuracion","es ideal para proyectos peque\xf1os y prototipos"]},{"input":"que es una api rest","output":["es una interfaz que permite la comunicacion entre sistemas usando peticiones http","sigue principios como la separacion entre cliente y servidor","es comun en aplicaciones web y servicios moviles"]},{"input":"que es graphql","output":["es una alternativa a rest para apis","permite al cliente especificar exactamente que datos necesita","es desarrollado por facebook y se usa en aplicaciones modernas"]},{"input":"que es una base de datos","output":["es un sistema para almacenar y organizar informacion","puede ser sql como mysql y postgresql, o no sql como mongodb","se utiliza para guardar datos que seran usados por el backend"]},{"input":"que diferencia hay entre sql y no sql","output":["sql usa tablas con esquemas definidos, mientras que no sql es mas flexible","sql es ideal para datos estructurados, no sql para datos no estructurados","sql incluye sistemas como mysql y postgresql, no sql incluye mongodb y cassandra"]},{"input":"como se comunican frontend y backend","output":["a traves de apis usando protocolos como http","el frontend envia solicitudes al backend y este responde con datos","la comunicacion puede ser en formatos como json o xml"]},{"input":"que es un full stack developer","output":["es un desarrollador que trabaja tanto en frontend como en backend","tiene conocimientos en dise\xf1o de interfaces y logica del servidor","puede desarrollar aplicaciones completas de inicio a fin"]},{"input":"que diferencia hay entre frontend y backend","output":["el frontend es lo que ve el usuario, el backend es la logica detras","el frontend usa html, css y javascript, el backend usa lenguajes como java o python","el backend se encarga de procesar datos y gestionar la comunicacion con bases de datos"]},{"input":"que es una base de datos","output":["es un sistema para almacenar y gestionar informacion de manera estructurada","se utiliza para guardar datos que pueden ser consultados y modificados facilmente","es esencial para aplicaciones que necesitan manejar grandes cantidades de informacion"]},{"input":"que tipos de bases de datos existen","output":["hay bases de datos relacionales y no relacionales","tambien existen bases de datos jerarquicas, en red y orientadas a objetos","dependen del tipo de informacion y del caso de uso"]},{"input":"que es una base de datos relacional","output":["es una base de datos que organiza la informacion en tablas con filas y columnas","usa sql como lenguaje para consultar y modificar datos","ejemplos incluyen mysql, postgresql y sql server"]},{"input":"que es una base de datos no relacional","output":["es una base de datos que no usa tablas para organizar los datos","puede almacenar informacion en formatos como documentos, grafos o claves-valor","ejemplos incluyen mongodb, cassandra y redis"]},{"input":"que es un esquema en una base de datos","output":["es la estructura que define como se organizan los datos en una base de datos","incluye tablas, columnas, tipos de datos y relaciones entre tablas","es importante en bases de datos relacionales"]},{"input":"que es sql","output":["es un lenguaje de consulta estructurado usado para interactuar con bases de datos relacionales","permite realizar operaciones como insertar, consultar y eliminar datos","es compatible con sistemas como mysql, postgresql y oracle"]},{"input":"que es mysql","output":["es un sistema de gestion de bases de datos relacional de codigo abierto","es popular por ser rapido y facil de usar","se usa comunmente en aplicaciones web"]},{"input":"que es postgresql","output":["es un sistema de gestion de bases de datos relacional avanzado y de codigo abierto","ofrece soporte para transacciones complejas y extensibilidad","es ideal para aplicaciones empresariales y proyectos avanzados"]},{"input":"que es sql server","output":["es un sistema de gestion de bases de datos relacional desarrollado por microsoft","se usa principalmente en entornos empresariales","ofrece integracion con otros productos de microsoft como azure y visual studio"]},{"input":"que es mongodb","output":["es una base de datos no relacional que almacena datos en formato de documentos json","es ideal para aplicaciones que manejan datos no estructurados o semiestructurados","es popular en aplicaciones web modernas y sistemas distribuidos"]},{"input":"para que se usa mongodb","output":["se utiliza en aplicaciones web, sistemas de recomendacion y big data","es ideal para manejar grandes volumenes de datos y escalar horizontalmente","se usa cuando no se necesita una estructura estricta de tablas y columnas"]},{"input":"que es redis","output":["es una base de datos no relacional basada en clave-valor","es conocida por su velocidad y se usa como cache o para almacenar sesiones","es popular en aplicaciones que requieren acceso rapido a los datos"]},{"input":"que es cassandra","output":["es una base de datos no relacional distribuida y escalable","es ideal para manejar grandes volumenes de datos en tiempo real","es utilizada por empresas como netflix y twitter para alta disponibilidad"]},{"input":"que diferencias hay entre mongodb y redis","output":["mongodb almacena documentos json, mientras que redis usa un modelo clave-valor","redis es mas rapido pero mongodb es mas flexible para datos complejos","redis es ideal para cache y mongodb para datos no estructurados"]},{"input":"que es un compilador","output":["un compilador es un programa que traduce el c\xf3digo fuente de un lenguaje de programaci\xf3n de alto nivel a un lenguaje de bajo nivel o c\xf3digo m\xe1quina","el compilador permite que el c\xf3digo escrito en un lenguaje comprensible por los humanos sea ejecutado por una computadora","un ejemplo de compilador es GCC para C o C++"]},{"input":"que es un interprete","output":["es un tipo de programa que ejecuta el c\xf3digo de un lenguaje de programaci\xf3n l\xednea por l\xednea, sin necesidad de compilar todo el c\xf3digo de antemano","a diferencia de un compilador, un int\xe9rprete no crea un archivo de c\xf3digo m\xe1quina, sino que traduce y ejecuta las instrucciones directamente","un ejemplo com\xfan de int\xe9rprete es Python"]},{"input":"que es un bug","output":["un bug es un error o fallo en el c\xf3digo de un programa que causa un comportamiento inesperado o incorrecto","los bugs pueden ser causados por errores de sintaxis, l\xf3gicas o problemas de rendimiento","es importante depurar el c\xf3digo para encontrar y corregir los bugs"]},{"input":"que es un debugger","output":["un debugger es una herramienta que permite examinar el estado de un programa mientras se ejecuta, ayudando a identificar y corregir bugs","los debuggers permiten realizar seguimiento de la ejecuci\xf3n del c\xf3digo, inspeccionar variables y controlar el flujo del programa","algunos debuggers populares son GDB para C y C++, o el debugger integrado en IDEs como Visual Studio Code"]},{"input":"que es una variable","output":["una variable es un espacio de almacenamiento que contiene un valor que puede cambiar durante la ejecuci\xf3n de un programa","las variables se utilizan para almacenar datos como n\xfameros, cadenas de texto o incluso objetos","cada variable tiene un tipo de dato que determina qu\xe9 tipo de valores puede almacenar, como \'int\' para enteros o \'string\' para texto"]},{"input":"que es un tipo de dato","output":["un tipo de dato es una clasificaci\xf3n de los valores que una variable puede almacenar, como n\xfameros, texto o booleanos","los tipos de datos b\xe1sicos incluyen enteros (int), n\xfameros decimales (float), texto (string) y valores l\xf3gicos (boolean)","los tipos de datos tambi\xe9n pueden ser m\xe1s complejos, como listas, diccionarios o incluso clases definidas por el usuario"]},{"input":"que es un tipo de dato primitivo","output":["un tipo de dato primitivo es un tipo de dato b\xe1sico que no se puede descomponer en tipos m\xe1s simples","los tipos de datos primitivos incluyen enteros (int), decimales (float), cadenas de texto (string) y valores l\xf3gicos (boolean)","estos tipos de datos son fundamentales y forman la base para construir otros tipos de datos m\xe1s complejos"]},{"input":"que es un tipo de dato compuesto","output":["un tipo de dato compuesto es un tipo de dato que se crea combinando varios tipos de datos primitivos o incluso otros tipos compuestos","los tipos de datos compuestos incluyen listas (arrays), diccionarios (objetos en algunos lenguajes), tuplas y conjuntos","estos tipos de datos permiten almacenar colecciones de datos m\xe1s complejas y estructuradas"]},{"input":"que es un array","output":["un array es una estructura de datos que almacena una colecci\xf3n de elementos del mismo tipo","los elementos de un array se almacenan en posiciones contiguas de memoria y se accede a ellos mediante un \xedndice","en muchos lenguajes de programaci\xf3n, como JavaScript o Python, los arrays pueden ser din\xe1micos o de tama\xf1o fijo"]},{"input":"que es una lista en programaci\xf3n","output":["una lista es un tipo de dato compuesto que almacena una colecci\xf3n ordenada de elementos, que pueden ser de diferentes tipos","a diferencia de los arrays, las listas pueden almacenar elementos de diferentes tipos de datos en muchos lenguajes, como en Python","una lista tambi\xe9n puede ser din\xe1mica, es decir, se puede cambiar su tama\xf1o durante la ejecuci\xf3n del programa"]},{"input":"que es un diccionario","output":["un diccionario es una estructura de datos que almacena pares de clave-valor","cada elemento en un diccionario est\xe1 compuesto por una clave \xfanica y un valor asociado a esa clave","los diccionarios son \xfatiles cuando necesitas buscar un valor r\xe1pidamente a partir de una clave, como en Python o JavaScript"]},{"input":"que es una tupla","output":["una tupla es una estructura de datos similar a una lista, pero con la diferencia de que las tuplas son inmutables, es decir, no pueden ser modificadas despu\xe9s de su creaci\xf3n","en muchos lenguajes de programaci\xf3n, como Python, las tuplas se utilizan para almacenar datos que no deben cambiar durante la ejecuci\xf3n del programa","las tuplas tambi\xe9n pueden contener elementos de diferentes tipos de datos"]},{"input":"que es un conjunto","output":["un conjunto es una colecci\xf3n de elementos no ordenados y sin duplicados","los conjuntos son \xfatiles cuando necesitas almacenar datos \xfanicos, sin preocuparte del orden en que se insertan","en Python, los conjuntos se definen utilizando la clase \'set\', y son diferentes de las listas o tuplas en cuanto a la unicidad de los elementos"]},{"input":"que es un string","output":["un string es un tipo de dato que representa una secuencia de caracteres, como texto","los strings pueden incluir letras, n\xfameros y otros caracteres, y se utilizan para manipular texto en la mayor\xeda de los lenguajes de programaci\xf3n","en algunos lenguajes, los strings son inmutables, lo que significa que no pueden ser modificados despu\xe9s de su creaci\xf3n, como en Python o Java"]},{"input":"que es un booleano","output":["un booleano es un tipo de dato que tiene solo dos valores posibles: verdadero (true) o falso (false)","los valores booleanos se utilizan en las condiciones y estructuras de control, como \'if\' o \'while\', para tomar decisiones en un programa","los booleanos son fundamentales en la programaci\xf3n l\xf3gica y las expresiones condicionales"]},{"input":"que es un valor nulo","output":["un valor nulo es un valor especial que representa la ausencia de un valor v\xe1lido o definido en una variable","el valor nulo puede ser utilizado para indicar que una variable a\xfan no ha sido inicializada o que no tiene un valor asignado","en algunos lenguajes, como JavaScript, se utiliza \'null\' para denotar un valor nulo, mientras que en otros, como Python, se utiliza \'None\'"]},{"input":"que es un tipo de dato flotante","output":["un tipo de dato flotante es un tipo num\xe9rico que se utiliza para representar n\xfameros con decimales","los n\xfameros flotantes son especialmente \xfatiles para realizar c\xe1lculos precisos que incluyen valores decimales, como 3.14 o 0.5","en muchos lenguajes de programaci\xf3n, como Python o Java, los flotantes se representan con el tipo \'float\'"]},{"input":"que es un tipo de dato entero","output":["un tipo de dato entero es un tipo num\xe9rico que se utiliza para representar n\xfameros sin decimales, como 1, 100 o -5","los enteros son fundamentales en programaci\xf3n para realizar operaciones matem\xe1ticas simples, como contar o iterar sobre elementos","en lenguajes como Python o Java, los enteros se representan con el tipo \'int\'"]},{"input":"que es el tipo de dato char","output":["el tipo de dato \'char\' se utiliza para representar un solo car\xe1cter, como \'a\', \'B\' o \'9\'","el \'char\' es com\xfanmente utilizado en lenguajes como C y C++ para manipular caracteres individuales en cadenas de texto","en otros lenguajes como Python, los caracteres son tratados como strings de longitud 1"]},{"input":"que es el tipo de dato complejo","output":["el tipo de dato complejo se utiliza para representar n\xfameros que tienen una parte real y una parte imaginaria, como 3 + 4i","en algunos lenguajes, como Python, puedes trabajar con n\xfameros complejos utilizando el tipo \'complex\'","los n\xfameros complejos son utilizados en \xe1reas como la ingenier\xeda, matem\xe1ticas y procesamiento de se\xf1ales"]},{"input":"que es una funcion","output":["una funci\xf3n es un bloque de c\xf3digo que realiza una tarea espec\xedfica y puede ser reutilizado en diferentes partes del programa","las funciones pueden aceptar entradas (par\xe1metros) y devolver un valor como resultado","en muchos lenguajes de programaci\xf3n, las funciones permiten organizar el c\xf3digo de manera modular y eficiente"]},{"input":"que es la recursion","output":["la recursi\xf3n es una t\xe9cnica en programaci\xf3n en la que una funci\xf3n se llama a s\xed misma para resolver un problema","generalmente, la recursi\xf3n se utiliza para resolver problemas que se pueden dividir en subproblemas m\xe1s peque\xf1os, como en el caso de los \xe1rboles o la b\xfasqueda binaria","es importante que una funci\xf3n recursiva tenga una condici\xf3n base que detenga la llamada recursiva"]},{"input":"hello","output":["Hi, how are you","hi how are things","good morning how are you"]},{"input":"good","output":["I\'m glad to know, tell me how I can help you, I\'m trained in programming topics ","What a joy, I can help you on different topics, I am trained in programming topics","I\'m glad to hear that, I can help you with the programming issue"]},{"input":"how can you help me","output":["I can answer questions, give you information and help you with whatever you need, I am trained in programming topics","I am here to answer your questions and help you with whatever you need, I am trained in programming issues,","I can help you on topics such as programming"]},{"input":"hello good","output":["Hi, how are you","hi how are things","good morning how are you"]},{"input":"hey","output":["Hi, how are you","hi how are things","good morning how are you"]},{"input":"how are you","output":["I\'m fine thanks for asking","everything is fine, and you?"]},{"input":"all good","output":["I\'m fine thanks for asking","everything is fine, and you?","I\'m glad to hear that"]},{"input":"bye","output":["goodbye take care","see you later","see you"]},{"input":"see you","output":["goodbye take care","see you later","see you"]},{"input":"good morning","output":["good morning I hope you have a great day, I can help you with programming issues","Hello, how are you today?"]},{"input":"what is your name","output":["I\'m a virtual assistant but you can call me a bot","My name is bot, your assistant"]},{"input":"do you have any name","output":["I\'m a virtual assistant but you can call me a bot","My name is bot, your assistant"]},{"input":"who are you","output":["I\'m a virtual assistant but you can call me a bot","My name is bot, your assistant"]},{"input":"what can you do","output":["I can answer questions, give you information and help you with whatever you need, I am trained in programming topics","I am here to answer your questions and help you with whatever you need, I am trained in programming issues,","I can help you on topics such as programming"]},{"input":"thank you","output":["you\'re welcome always here to help you","it doesn\'t matter","I\'m here for whatever you need"]},{"input":"sorry","output":["don\'t worry everything is fine","No problem, how can I help you? I am trained in programming topics."]},{"input":"I\'m sorry","output":["It\'s okay, how can I help you? I am trained in programming topics and the occasional joke.","Don\'t worry, I\'m here to help you."]},{"input":"what time is it","output":["Sorry I can\'t give the exact time but I can help you with other things","I don\'t have a watch, but I can help you with something else"]},{"input":"tell me the time","output":["Sorry I can\'t give the exact time but I can help you with other things","I don\'t have a watch, but I can help you with something else"]},{"input":"What day is today","output":["Today is a big day, how can I help you? ","Today is a perfect day to learn something new."]},{"input":"aid","output":["Of course tell me what you need and I will see how to help you, I am trained in programming topics","I am here for whatever you need, tell me how I can help you, I am trained in programming topics","I can help you with programming issues"]},{"input":"I\'m sad","output":["I\'m so sorry if you need to talk or support I\'m here","I understand you, you are not alone, tell me more"]},{"input":"I\'m happy","output":["What a joy to hear that, it makes me happy to know that you are well.","That\'s great, I love knowing that!"]},{"input":"tell me a joke","output":["Why don\'t birds use Facebook because they already have Twitter?","What does a bee do in the gym?"]},{"input":"tell me a joke","output":["Why don\'t birds use Facebook because they already have Twitter?","What does a bee do in the gym?"]},{"input":"tell me another joke","output":["Why don\'t birds use Facebook because they already have Twitter?","What does a bee do in the gym?"]},{"input":"tell me another joke","output":["Why don\'t birds use Facebook because they already have Twitter?","What does a bee do in the gym?"]},{"input":"what are birds","output":["Birds are flying animals that have feathers and a beak.","Birds are animals that fly and have feathers."]},{"input":"what is a bird","output":["A bird is a flying animal that has feathers and a beak.","a bird is an animal that flies and has a feather"]},{"input":"what is facebook","output":["Facebook is a social network where people can share content, interact and connect."]},{"input":"what is a social network","output":["A social network is a digital platform where people can interact, share ideas, content and communicate with each other."]},{"input":"what are social networks","output":["Social networks are digital platforms that allow users to connect, share content and communicate with each other."]},{"input":"what are people","output":["People are human beings who have thinking, reasoning and communication capabilities."]},{"input":"What does it mean to share?","output":["Sharing means making something available to others to use or enjoy together."]},{"input":"what is connecting","output":["connect is to establish a relationship or link between two or more elements"]},{"input":"what does it mean to connect","output":["connect means to join or link things, people or ideas so that they interact or work together."]},{"input":"what is twitter","output":["Twitter is a platform where users can post short messages called tweets."]},{"input":"Why don\'t birds use Facebook?","output":["because they already have twitter"]},{"input":"What does a bee do in the gym?","output":["zumba"]},{"input":"what is zumba","output":["Zumba is a physical activity that combines dance and exercise to the rhythm of Latin music"]},{"input":"what are bees","output":["Bees are pollinating insects that play a crucial role in the ecosystem and produce honey"]},{"input":"what is a bird","output":["A bird is a vertebrate animal with feathers, wings and generally the ability to fly."]},{"input":"What birds do on social networks","output":["In this context, the birds use Twitter as part of the joke."]},{"input":"what is a gym","output":["A gym is a place where people go to exercise and improve their physical condition."]},{"input":"I\'m encouraged","output":["What a joy to hear that, it makes me happy to know that you are well.","That\'s great, I love knowing that!"]},{"input":"I\'m wonderful","output":["What a joy to hear that, it makes me happy to know that you are well.","That\'s great, I love knowing that!"]},{"input":"what time do you have","output":["Sorry I can\'t give the exact time but I can help you with other things","I don\'t have a watch, but I can help you with something else"]},{"input":"what is the time","output":["Sorry I can\'t give the exact time but I can help you with other things","I don\'t have a watch, but I can help you with something else"]},{"input":"what day do we have","output":["Today is a big day, how can I help you?","Today is a perfect day to learn something new."]},{"input":"what day is it","output":["Today is a big day, how can I help you? You want to know what programming is about.","Today is a perfect day to learn something new."]},{"input":"Yeah","output":["It is the process of writing instructions that a computer can understand.","It is the creation of code to solve problems or automate tasks on a computer."]},{"input":"are you available","output":["Of course I\'m here to help you.","I am available, tell me how I can help you"]},{"input":"are you still available","output":["Of course I\'m here to help you.","I am available, tell me how I can help you"]},{"input":"can you help me","output":["Of course tell me what you need and I will see how to help you.","I\'m here for whatever you need, tell me how I can help you"]},{"input":"you help me","output":["Of course tell me what you need and I will see how to help you.","I\'m here for whatever you need, tell me how I can help you"]},{"input":"help me","output":["Of course, tell me what you need and I will see how to help you, I am trained in programming topics and the occasional joke.","I am here for whatever you need, tell me how I can help you, I am trained in programming topics and the occasional joke."]},{"input":"Hi, how are you","output":["I\'m good and you"]},{"input":"good morning","output":["good morning how are you feeling today"]},{"input":"hi how are things","output":["everything is going well here and how are you?"]},{"input":"hello everything is fine","output":["Yes, thank you, how are you doing?"]},{"input":"Hello, are you listening to me?","output":["Of course, how can I help you today?"]},{"input":"Good afternoon","output":["good afternoon I hope you have a good day"]},{"input":"good night","output":["good night you need something before going to sleep"]},{"input":"hey how are you doing","output":["Hello, everything is fine here and you"]},{"input":"hello what are you doing","output":["Hello, I\'m here waiting to help you."]},{"input":"hello can you help me","output":["Of course, tell me what you need help with."]},{"input":"hello what\'s your name","output":["Hello, I am a virtual assistant and what is your name?"]},{"input":"Hello, what can you tell me?","output":["Hello, here ready to help you and what do you say?"]},{"input":"Hello, it\'s been a while since we talked","output":["Hello, yes it\'s true, it\'s nice to see you again."]},{"input":"Hello, how\'s everything going there?","output":["everything is going well and here\'s how everything is going"]},{"input":"Hello, how are you today?","output":["Hello, I\'m fine, thank you for asking and how are you today?"]},{"input":"hello do you have time to talk","output":["Of course I\'m here for you, tell me how I can help you"]},{"input":"Hello, can I ask you something?","output":["Of course I\'m here to answer your questions."]},{"input":"Hello, how was your afternoon?","output":["My afternoon has been calm and how is yours?"]},{"input":"hello how have you been","output":["Hello, I have been fine, thank you for asking and you?"]},{"input":"Hello I hope you are well","output":["Hello, thank you, I hope you are too."]},{"input":"Hello, we haven\'t talked in a long time.","output":["yes that\'s true hello it\'s nice talking to you again"]},{"input":"Hello, how\'s your day so far?","output":["My day has been good and yours, how is it going so far?"]},{"input":"Hello, how was your week?","output":["My week is going well, thank you, and how is yours?"]},{"input":"Hello, how did you wake up today?","output":["Hello, I woke up well, thank you for asking and you?"]},{"input":"Hello, how is your day going?","output":["Hello, my day is going well, thank you, and how is yours?"]},{"input":"Hello, are you available?","output":["Hello, yes, of course, how can I help you?"]},{"input":"why do you exist","output":["I was created to help you and improve your interactions with technology"]},{"input":"what is programming","output":["It is the process of writing instructions that a computer can understand.","It is the creation of code to solve problems or automate tasks on a computer."]},{"input":"what is programming","output":["It is the process of writing instructions that a computer can understand.","It is the creation of code to solve problems or automate tasks on a computer."]},{"input":"what is instructions","output":["They are specific directions that tell a computer what to do step by step.","They are organized orders that a machine or person follows to perform a task."]},{"input":"what is a computer","output":["It is an electronic device capable of processing and storing data following instructions.","It is a machine designed to perform calculations and run software programs."]},{"input":"What does code creation mean?","output":["It is the process of writing lines of text in a programming language to build software.","It is developing instructions that define how a program or system should work."]},{"input":"what is automation","output":["It is making processes or tasks carried out automatically without constant human intervention.","It is using technology to execute repetitive activities efficiently."]},{"input":"what is an electronic device","output":["It is a device that runs on electricity and performs specific tasks using electronic circuits.","It is a machine that uses electrical and electronic components to process information or perform actions."]},{"input":"What does it mean to process information?","output":["It is performing operations on data to transform it into useful information.","It is applying algorithms or rules to analyze, organize or convert data."]},{"input":"what is storing data","output":["It is saving information in a physical or digital medium for future use.","It is keeping data in an organized way to access it when needed."]},{"input":"what is useful information","output":["It is knowledge derived from data that has value for making decisions or solving problems.","It is the result of processing data in a way that makes it understandable and actionable."]},{"input":"what is derived knowledge","output":["It is information obtained by processing and analyzing data in a logical and systematic way.","It is the understanding generated from data that has a context or purpose."]},{"input":"What is an automatic task?","output":["It is an activity that is carried out without the need for continuous human intervention.","It is a process that is executed independently through programming or devices."]},{"input":"What are organized steps?","output":["They are actions arranged in a logical order to achieve a specific objective.","They are structured instructions that guarantee that a process is carried out effectively."]},{"input":"What does it mean to make decisions?","output":["It is the process of choosing an option among several available alternatives.","It is analyzing information to select the most appropriate action in a given situation."]},{"input":"what is analyzing data","output":["It is examining information in detail to extract patterns, trends or conclusions.","It is the process of evaluating data to understand it and use it in decision making."]},{"input":"what is a digital medium","output":["It is an electronic medium such as hard drives, the cloud or USB devices where information is stored.","It is an environment based on digital technology that allows data to be stored and transmitted."]},{"input":"What does it mean to transform data?","output":["It is modifying or reorganizing information to change its format, structure or purpose.","It is converting data into a more useful or understandable form for analysis or use."]},{"input":"which is a repetitive task","output":["It is an action that is performed over and over again in a similar or identical manner.","It is a process that does not change over time and is usually automatable."]},{"input":"which is automatable","output":["It is something that can be set to run automatically without human intervention.","It is an activity that can be carried out autonomously by technological systems."]},{"input":"What are organized rules?","output":["They are rules arranged in a logical and structured way to guarantee efficient operation.","They are principles that define an order to perform tasks effectively."]},{"input":"What does it mean to perform tasks?","output":["It is executing specific activities or actions to meet an objective.","It is carrying out a set of steps that lead to an expected result."]},{"input":"which is a structured activity","output":["It is a planned action with a defined beginning, middle and end.","It is a set of steps organized to achieve a clear purpose."]},{"input":"what is identifying patterns","output":["It is recognizing structures or repetitions within a set of data or information.","It is detecting similarities or regularities that help interpret or predict behaviors."]},{"input":"what is code","output":["It is a set of instructions written in a programming language to be executed by a computer.","It is a structured representation of orders that allow tasks to be performed or problems to be solved using software."]},{"input":"what is a set of instructions","output":["They are several organized orders that, when executed, achieve an objective or complete a task.","It is a sequence of steps that tells a computer how to perform a specific action."]},{"input":"What is a structured representation?","output":["It is an organized way of presenting information or data following a logical scheme.","It is a clear and orderly model or format that facilitates the understanding and execution of a process."]},{"input":"What does it mean to be executed?","output":["It is carrying out the instructions of a code so that the indicated actions are carried out.","It is processing the orders of a program to generate results or perform tasks."]},{"input":"what are orders","output":["They are specific commands that tell a computer what to do and how to do it.","They are specific instructions that must be followed to complete a process."]},{"input":"What does it mean to perform tasks using software?","output":["It is using programs or applications to execute activities or solve problems automatically.","It is using technological tools to carry out specific actions efficiently."]},{"input":"what is a computer executing code","output":["It is a device processing instructions written in a programming language.","It is the act of interpreting and following the orders defined in a code to perform actions."]},{"input":"What does it mean to process instructions?","output":["It is interpreting and carrying out the actions indicated by a set of orders.","It is executing defined steps in code to produce specific results."]},{"input":"What is solving problems with code?","output":["It is writing and executing instructions to find solutions to challenges or needs.","It is using programming languages \u200b\u200bto automate processes or create tools that simplify tasks."]},{"input":"What does it mean to write a set of commands?","output":["It is writing instructions in a programming language so that a computer understands them.","It is designing a logical sequence of steps to achieve a goal or perform a task."]},{"input":"what is an ordered model","output":["It is an organized structure that facilitates the understanding and execution of a process.","It is a logical scheme that defines how tasks should be performed or data processed."]},{"input":"what is an algorithm","output":["It is a sequence of steps defined to solve a problem","is a set of instructions that are executed in order to achieve a goal","is a series of logical steps that describe how to solve a specific task"]},{"input":"What does a set of steps mean?","output":["They are several actions organized in a logical order to achieve a result.","It is a series of stages that must be followed to complete a task or solve a problem."]},{"input":"What does logically defined mean?","output":["It is structured in a clear and coherent way, following reasonable rules or principles.","It is designed so that each step makes sense and is aligned with the final objective."]},{"input":"What does it mean to solve a problem with an algorithm?","output":["It is using a sequence of clear steps to find a solution to a difficulty or need.","It is applying a set of organized instructions to overcome a challenge or fulfill a purpose."]},{"input":"What does a series of written steps mean?","output":["It is a list of detailed actions written in a format that can be understood and followed.","It is a group of instructions documented in a clear and organized manner."]},{"input":"What does it mean to interpret an algorithm?","output":["It is analyzing each step of a set of instructions to execute it appropriately.","It is converting the actions defined in an algorithm into operations that the computer can perform."]},{"input":"what is running an algorithm","output":["It is carrying out the steps defined in an algorithm to obtain a result.","It is following the instructions of an algorithm to solve a problem or complete a task."]},{"input":"What is an algorithm for?","output":["serves to solve problems in a structured and efficient way","used to automate tasks and find solutions to complex problems","It is essential to create programs and systems that solve specific problems"]},{"input":"What are the characteristics of an algorithm","output":["It must be finite, have well-defined steps and be precise","has a beginning and an end, and must produce a correct result","must be clear, efficient and applicable in any defined context"]},{"input":"what are the types of algorithms","output":["Some types are recursive, iterative, greedy and dynamic algorithms.","They can be search, sorting, optimization or generation","They are classified according to their approach such as divide and conquer, backtracking or probabilistic algorithms."]},{"input":"what is a recursive algorithm","output":["It is an algorithm that calls itself to solve a problem.","It is a type of algorithm that divides a large problem into smaller subproblems.","is based on defining oneself in terms of oneself until reaching a base case"]},{"input":"What examples are there of recursive algorithms?","output":["calculating the factorial of a number is a classic example","The Fibonacci sequence can be solved with a recursive algorithm","Depth-first search in a graph is another common example."]},{"input":"what is a sorting algorithm","output":["is an algorithm designed to rearrange elements in a specific order","Used to sort data in ascending or descending order","It is a technique for organizing lists of data such as numbers or strings."]},{"input":"What are the most common sorting algorithms?","output":["some are quicksort, mergesort, bubble sort and insertion sort","the most common include quicksort, heapsort and selection sort","You can find algorithms such as merge sort and radix sort among the most used"]},{"input":"what is quicksort","output":["It is a sorting algorithm based on divide and conquer.","organizes the elements by selecting a pivot and partitioning the data around it","It is an efficient method for sorting large lists of data."]},{"input":"what is the complexity of quicksort","output":["in the best case and average is o n log n","in the worst case it can be or n squared if the pivots are chosen poorly","It is efficient in most cases but it depends on how the pivots are selected."]},{"input":"what is a greedy algorithm","output":["It is an algorithm that makes optimal decisions at each step in the hope of finding the overall optimal solution.","It is used in problems where optimal partial solutions lead to the complete solution.","It is an approach to solving problems by breaking the solution into sequential steps."]},{"input":"What are examples of greedy algorithms?","output":["Dijkstra\'s algorithm to find the shortest path in a graph","the fractional knapsack problem can be solved with a greedy approach","Kruskal\'s algorithm for minimum spanning trees is another example."]},{"input":"What is the difference between greedy and dynamic algorithms?","output":["Greedy algorithms make decisions step by step, while dynamic algorithms solve subproblems and combine solutions.","The voracious ones look for immediate optimal solutions, the dynamic ones store intermediate results to optimize the process.","The greedy ones are simpler but do not always guarantee the optimal solution like the dynamic ones."]},{"input":"what is a dynamic algorithm","output":["It is a method of solving problems by dividing them into subproblems and storing their solutions.","is an approach that avoids recomputations by saving results in memory","It is used for problems that have overlapping subproblems and optimization properties."]},{"input":"What examples are there of dynamic algorithms?","output":["the floyd-warshall algorithm for shortest paths in graphs","The solution to the entire backpack problem is a classic of dynamic programming","The calculation of the Fibonacci sequence with memoization is another example."]},{"input":"What types of instructions does an algorithm have?","output":["can have sequential, conditional and repetitive instructions","Instructions are classified as sequential, decision and repetition.","may include linear flow instructions, branches, and loops"]},{"input":"What is a sequential instruction?","output":["It is an instruction that is executed one after another in the order in which they appear","They are steps that are followed in a linear manner without deviating","It is a type of instruction where each action occurs exactly once."]},{"input":"What does it mean to transform a set of instructions?","output":["It is modifying orders to adapt them to a specific format or context.","It is converting defined steps into a structure that can be processed or executed."]},{"input":"What is a specific format?","output":["It is a defined structure that organizes information so that it can be interpreted correctly.","It is a standard provision that ensures that data is understood or used appropriately."]},{"input":"which is a defined structure","output":["It is a previously designed scheme that organizes elements in a coherent way.","It is a logical framework that establishes how the parts of a system or process should be ordered."]},{"input":"What does it mean to modify an algorithm?","output":["It is adjusting the steps of a set of instructions to adapt them to new needs or improve their efficiency.","It is changing the logic or structure of an algorithm to optimize its operation."]},{"input":"What does it mean to optimize an algorithm?","output":["It is improving a set of instructions to make it faster or more efficient in solving a problem.","It is reducing the time or resources necessary to execute an algorithm while maintaining its functionality."]},{"input":"What is efficiency in an algorithm?","output":["It is the ability to solve a problem using the least amount of time and resources possible.","It is the measure of how well an algorithm performs its task compared to other methods."]},{"input":"What does it mean to compare methods?","output":["It is analyzing different techniques or approaches to identify which is most appropriate or efficient.","It is evaluating the advantages and disadvantages of different processes to choose the best one."]},{"input":"What does it mean to choose a method?","output":["It is selecting the most appropriate technique to solve a problem or perform a specific task.","It is making a decision based on the efficiency and characteristics of each available option."]},{"input":"What is an appropriate technique?","output":["It is an approach or method that effectively meets the needs of a task or problem.","It is a strategy that allows you to achieve a goal accurately and efficiently."]},{"input":"What is logic in an algorithm?","output":["It is the rational basis that organizes the steps of a set of instructions to ensure that they fulfill their purpose.","It is the reasoning that guides the sequence and structure of actions within an algorithm."]},{"input":"Can you give me examples of sequential instructions?","output":["assign a value to a variable, display a message on the screen and perform a sum","read a data from the user, calculate the double and show the result","calculate the average of three numbers, print it and finish the program"]},{"input":"what is a conditional statement","output":["It is an instruction that allows you to make decisions based on a condition","used to execute different blocks of code depending on whether a condition is true or false","It is a type of instruction that evaluates an expression and decides the flow of the algorithm"]},{"input":"Can you give me examples of conditional statements?","output":["If the age is greater than or equal to 18, show that you are of legal age","If the number is positive, print is positive, otherwise print is negative","check if a number is even or odd and show the result"]},{"input":"What is a repetitive instruction?","output":["It is an instruction that executes a block of code several times as long as a condition is met.","It is used to perform repetitive tasks automatically","is a type of instruction that repeats an action until a completion criterion is met"]},{"input":"Can you give me examples of repetitive instructions?","output":["repeat until the user enters a number greater than 0","calculate the sum of numbers from 1 to 100 using a loop","display even numbers between 1 and 50 using a for loop"]},{"input":"What types of loops exist in algorithms","output":["the most common are for, while and do while loops","you can use defined loops like for and indeterminate loops like while","The main types are for for defined iterations and while for conditions"]},{"input":"what is a for loop","output":["is a loop that repeats a block of code a fixed number of times","It is used when the number of iterations is known in advance","is a structure that includes a beginning, a condition, and an increment or decrement"]},{"input":"can you give me examples of a for loop","output":["loop through an array to print each element","show the numbers from 1 to 10 incrementing one by one","calculate the factorial of a number using a for loop"]},{"input":"what is a while loop","output":["is a loop that executes a block of code as long as a condition is true","It is used when it is not known exactly how many times the task will be repeated","It is a structure that evaluates a condition before executing the code block"]},{"input":"can you give me examples of a while loop","output":["keep asking the user for a number until they enter a positive number","add numbers entered by the user until zero is entered","show a counter that increments as long as it is less than 10"]},{"input":"can you give me examples of a do while loop","output":["ask the user for a number until they enter one greater than 10","display a message on the screen at least once, then repeat according to a condition","calculate the sum of numbers entered until the user types exit"]},{"input":"What are the input and output instructions in an algorithm?","output":["are the instructions that allow you to interact with the user or the environment","Input instructions capture data, and output instructions display or send it.","They are used to receive information from the user and display results or messages"]},{"input":"Can you give me examples of input and output instructions?","output":["read a number from the user and show its square","ask the user for their name and display a welcome message","capture two numbers and show their sum on the screen"]},{"input":"what is a programming language","output":["It is a means of communicating with a computer using instructions","It is a notation system for writing programs that a computer executes.","It is a tool for creating software through machine-understandable instructions."]},{"input":"What does it mean to write instructions in a programming language?","output":["It is writing a set of commands in a format that the computer can interpret and execute.","It is using the syntax of a programming language to define how actions should be performed in an algorithm."]},{"input":"What is the syntax of a programming language?","output":["It is the set of rules that dictate how instructions must be written so that they are understood by a computer.","It is the structure and order in which commands should be organized in a programming language."]},{"input":"What is a program in a programming language?","output":["It is a set of instructions written in a programming language to execute a specific task.","It is an algorithm encoded in a format that a computer can process and execute."]},{"input":"What does it mean to code an algorithm?","output":["It is translating a set of logical steps of an algorithm into a programming language so that it can be executed by a computer.","It is writing an algorithm using the syntax and rules of a programming language."]},{"input":"What does it mean to translate an algorithm?","output":["It is converting the instructions of an algorithm into a format that can be interpreted by a computer.","It is transforming a set of logical steps into code using a programming language."]},{"input":"What are the types of programming languages?","output":["The main types are low-level and high-level languages","They are classified into machine languages, assembly languages, and languages \u200b\u200bsuch as C or Python.","They can be low level like assembler or high level like java or python"]},{"input":"which is a low level language","output":["It is a language close to computer hardware, like assembly language","It is a type of language that operates directly with machine instructions","It is a less abstract language that requires knowing hardware details"]},{"input":"give me examples of low level languages","output":["assembly and machine language are classic examples","microcontrollers often use assembly language","Binary code is the most basic low-level language."]},{"input":"what is a high level language","output":["It is a language designed to be easy for humans to understand.","It is a more abstract type of language that hides the details of the hardware","is a tool for writing complex programs with syntax close to natural language"]},{"input":"give me examples of high level languages","output":["python, java, c++, and javascript are examples of high-level languages","languages \u200b\u200blike ruby, php and swift are also high level","popular tools like go and kotlin belong to this category"]},{"input":"What is the difference between high and low level languages?","output":["low level ones are close to the hardware, while high level ones are easier for humans","Low-level languages \u200b\u200brequire more hardware knowledge, high-level languages \u200b\u200bare more abstract.","In high-level languages \u200b\u200byou write fewer lines of code for complex tasks"]},{"input":"what is a compiled language","output":["It is a language that is translated into machine code before being executed.","is a type of language where the entire program is converted to binary before being executed","It is a language that needs a compiler to generate an executable"]},{"input":"can you give me examples of compiled languages","output":["c, c++ and rust are examples of compiled languages","languages \u200b\u200blike go and fortran are compiled","swift and kotlin can also be compiled"]},{"input":"what is an interpreted language","output":["It is a language that is executed directly by an interpreter without the need to compile","It is a type of language where instructions are translated and executed in real time","Interpreted languages \u200b\u200bdo not generate a binary file before running"]},{"input":"Can you give me examples of interpreted languages?","output":["python, javascript and ruby \u200b\u200bare interpreted languages","php and perl are other examples of interpreted languages","languages \u200b\u200blike lua and bash are also interpreted"]},{"input":"What is the difference between compiled and interpreted languages?","output":["compiled ones generate an executable before running, interpreted ones do not","The compiled ones are faster in execution, but the interpreted ones are more flexible","Interpreted ones translate instructions in real time, compiled ones do it sooner"]},{"input":"what is an object oriented language","output":["It is a language that organizes code into objects that represent real-world entities.","It is a programming paradigm that uses classes and objects to structure the code.","It is a type of language where data and functions are encapsulated in objects"]},{"input":"Can you give me examples of object-oriented languages?","output":["Java, Python, C++ and Ruby are object-oriented languages.","Languages \u200b\u200blike Kotlin and Swift also use object orientation","c# and javascript support object-oriented programming"]},{"input":"what is a functional language","output":["is a language that treats computations as evaluations of mathematical functions","It is a paradigm where functions are the main units of the program","functional languages \u200b\u200bavoid mutable states and data"]},{"input":"Can you give me examples of functional languages?","output":["Haskell, Elixir and Erlang are examples of functional languages","languages \u200b\u200blike f# and clojure are also functional","scala and ocaml support the functional paradigm"]},{"input":"what is a scripting language","output":["is a language designed to automate tasks in an operating system or application","is a type of language used to write scripts that control programs or processes","Scripting languages \u200b\u200bare commonly interpreted and used for quick tasks."]},{"input":"Can you give me examples of scripting languages?","output":["javascript, python and bash are common scripting languages","languages \u200b\u200blike ruby, php and perl are also scripting","lua and powershell are other examples of scripting languages"]},{"input":"what is python","output":["It is a high-level, interpreted, multipurpose programming language.","It is a popular language for its simple syntax and large number of libraries","It is a widely used tool for data science, artificial intelligence and web development"]},{"input":"what is python used for","output":["It is used in data science, artificial intelligence, web development and automation","It is common in data analysis, machine learning and application development","It is also used to create scripts, manage data and program applications."]},{"input":"what is java","output":["It is a high-level, object-oriented, cross-platform programming language.","It is a language known for its portability thanks to the Java virtual machine","It is a popular tool for enterprise applications and mobile development"]},{"input":"What is java used for?","output":["It is used to develop business applications, games and software for android","It is common in server applications, distributed systems and web applications","It is also used to program embedded devices and desktop applications."]},{"input":"what is javascript","output":["It is a high-level programming language used primarily for web development.","It is an interpreted language that allows you to create dynamic and interactive web pages.","It is a key tool for client-side and server-side programming."]},{"input":"What is javascript used for?","output":["used to create interactive web interfaces and modern web applications","It is common in client and server side development with nodejs","It is also used to handle events on web pages and build web games."]},{"input":"what is c","output":["It is a low-level, structured and efficient programming language.","It is known for its speed and control over system resources","is a tool used for high-performance operating systems, compilers and applications"]},{"input":"what is c used for","output":["It is used in the development of operating systems and hardware software","It is common for programming embedded devices and high-performance applications.","It is also used in video games, simulations and real-time systems."]},{"input":"what is c++","output":["It is a high-level programming language based on C, with support for object-oriented programming.","It is a versatile and efficient language used for complex software development.","It is a C extension that includes advanced features such as classes and objects."]},{"input":"What is c++ used for?","output":["It is used to develop video games, simulation software and graphics engines.","It is common in the development of operating systems and scientific applications","It is also used for high performance applications and embedded systems."]},{"input":"what is ruby","output":["It is a high-level, interpreted, object-oriented programming language.","is known for its focus on simplicity and productivity","It is a popular tool for web development, especially with ruby \u200b\u200bon rails"]},{"input":"What is ruby \u200b\u200bused for?","output":["It is mainly used for web development with the ruby \u200b\u200bon rails framework","It is common in automation and scripting applications","It is also used for rapid prototyping and dynamic application development."]},{"input":"what is kotlin","output":["is a modern, high-level programming language developed by jetbrains","It is known to be interoperable with Java and mainly used for mobile development.","It is a popular tool for developing Android applications and backend systems."]},{"input":"What is Kotlin used for?","output":["It is used to develop android applications and backend systems","It is common in projects that require integration with Java","It is also used for cross-platform applications and microservices."]},{"input":"what is swift","output":["It is a modern programming language developed by Apple for its platforms.","It is known for being fast, secure and easy to learn","It is a popular tool for developing applications for iOS and Macos."]},{"input":"What is Swift used for?","output":["It is used to develop applications for ios, macos, watchos and tvos","It is common in the Apple ecosystem for mobile and desktop applications","It is also used for learning and open source projects in the Apple community."]},{"input":"what is rust","output":["It is a modern programming language focused on security and performance","It is known for its memory management system that prevents common errors","is a tool used for high performance systems and secure software"]},{"input":"What is rust used for?","output":["It is used to develop embedded systems, browsers and secure software","It is common in projects where performance and security are critical","It is also used in system applications such as database engines."]},{"input":"what is go","output":["It is a programming language created by Google focused on simplicity and performance.","It is known for being fast, scalable and easy to compile.","It is a popular tool for distributed systems and web services"]},{"input":"What is go used for?","output":["used to develop web services, infrastructure tools and distributed systems","It is common in high-performance applications such as servers and microservices","It is also used in network, cloud computing and container projects."]},{"input":"what are the advantages of python","output":["It is easy to learn and read thanks to its simple syntax","has a large number of libraries and frameworks available","It is cross-platform and widely supported by the community"]},{"input":"what are the disadvantages of python","output":["It is slower than other languages \u200b\u200blike C or Java.","consumes more resources due to its interpreted nature","It is not the best option for real-time applications."]},{"input":"What frameworks exist in Python?","output":["some popular frameworks are django, flask and fastapi","There are also pandas and numpy for data analysis","tensorflow and pytorch are used for artificial intelligence"]},{"input":"What is the difference between Python and Java?","output":["python has a simpler syntax and is interpreted","java is faster and is compiled into bytecode for the virtual machine","Java is used more for business applications, while Python is common in data analysis."]},{"input":"What features does Java have?","output":["It is object-oriented and has automatic garbage collection.","It is cross-platform thanks to the Java virtual machine","It has a static typing system that prevents errors at compile time"]},{"input":"what are the advantages of java","output":["It is very scalable and suitable for enterprise applications","It has a mature ecosystem and extensive documentation","It is compatible with a large number of platforms"]},{"input":"What frameworks exist in Java?","output":["some popular frameworks are spring, hibernate and struts","spring boot is common to develop microservices","javafx is used to create graphical interfaces"]},{"input":"What characteristics does c++ have?","output":["supports object-oriented and functional programming","allows fine-grained control over memory","It is a compiled language that offers high performance"]},{"input":"what is the difference between c and c++","output":["C is a structured language while C++ supports object-oriented programming.","c++ includes features such as classes, inheritance and polymorphism","c is used for operating systems, while c++ is more common in video games and simulations."]},{"input":"what is a framework","output":["It is a predefined code structure that makes application development easier.","is a set of tools and libraries that help solve common problems","serves to streamline and standardize the development process"]},{"input":"how to choose a programming language","output":["It depends on the project you want to carry out, such as web development or mobile applications.","consider community support and tools available","think about the learning curve and your long-term goals"]},{"input":"what is django","output":["It is a high-level framework for web development in Python.","It is known for following the principle of don\'t repeat yourself and facilitating rapid development.","includes tools to manage databases, authentication and more"]},{"input":"What advantages does django have?","output":["It has an integrated and powerful administration system","It is scalable and suitable for small and large projects","follow good practices like the mvc principle"]},{"input":"what is flask","output":["It is a microframework for web development in Python","It is known for being lightweight and easy to extend.","allows you to create web applications with minimal configuration"]},{"input":"What is flask for?","output":["used to develop small web applications and APIs","It is ideal for projects that require flexibility","It is used in applications where a robust framework like django is not needed"]},{"input":"What frameworks are there for artificial intelligence in Python?","output":["some popular ones are tensorflow, pytorch and scikit-learn","tensorflow is used for neural networks and deep learning","scikit-learn is ideal for classical machine learning"]},{"input":"what is spring","output":["It is a framework for developing business applications in Java.","provides tools to develop scalable applications","supports aspect-oriented programming and dependency management"]},{"input":"What is spring boot for?","output":["It is used to create Java applications with minimal configuration","facilitates the development of microservices","It is ideal for projects that require quick implementation"]},{"input":"what is hibernate","output":["is an object-relational mapping framework for java","allows you to interact with databases efficiently","facilitates data persistence in java applications"]},{"input":"What is the difference between spring and hibernate?","output":["spring is a general framework for enterprise applications","hibernate focuses on data mapping and persistence","spring can integrate hibernate as part of its ecosystem"]},{"input":"what is react","output":["is a javascript library for building user interfaces","It is developed by Facebook and focuses on reusable components","It is ideal for dynamic and modern web applications"]},{"input":"What is react for?","output":["It is used to create web applications with dynamic interfaces","It is used to build single page or spa websites.","makes it easier to manage state and render components"]},{"input":"what is angular","output":["is a javascript framework for web application development","It is maintained by Google and follows a component-based architecture.","offers built-in tools such as dependency injection and routing"]},{"input":"What is the difference between Angular and React?","output":["angular is a complete framework while react is a library","react allows more flexibility when integrating external tools","Angular has a steeper learning curve but offers more built-in functionality"]},{"input":"what is vue","output":["is a progressive javascript framework for building user interfaces","It is known for its simplicity and ease of integration","It is ideal for small and large projects that require modularity"]},{"input":"What frameworks exist in c++","output":["some popular ones are qt, boost and bit","qt is used for developing cross-platform applications with graphical interfaces","boost provides libraries for many common tasks such as memory management"]},{"input":"what is qt","output":["It is a framework for C++ focused on graphical and cross-platform applications.","includes tools to create modern graphical interfaces","It is used in desktop, mobile and embedded software"]},{"input":"What frameworks are there for mobile development?","output":["some popular ones are flutter, react native and xamarin","flutter is developed by google and uses dart as the base language","react native allows you to develop mobile applications using javascript"]},{"input":"what is flutter","output":["It is a Google framework for cross-platform mobile development.","allows you to create native applications with a single code base","use dart as a programming language"]},{"input":"what is react native","output":["It is a javascript-based framework for mobile development.","allows you to create applications for iOS and Android with a single code base","It is based on the same component philosophy as react"]},{"input":"what is frontend","output":["It is the visual part of an application with which users interact","refers to the development of graphic interfaces and user experiences","includes technologies such as html, css and javascript"]},{"input":"What languages \u200b\u200bare used in frontend?","output":["the main ones are html, css and javascript","Technologies such as typescript and frameworks such as react or angular are also used."]},{"input":"what is html","output":["It is a markup language used to structure the content of a web page.","defines the basic structure of a page such as headings, paragraphs and links","It is essential for frontend development"]},{"input":"what is css","output":["It is a styling language used to define the appearance of a web page.","allows you to customize colors, fonts and design of elements","used in conjunction with html to enhance the visual experience"]},{"input":"what is javascript","output":["It is a programming language used to add interactivity to web pages","allows you to create dynamic functionalities such as animations and validations","It is essential for modern frontend development"]},{"input":"What frameworks are used in frontend","output":["some popular ones are react, angular and vue","bootstrap is used for responsive design","tailwind css is a modern tool for styles"]},{"input":"What is the difference between react and angular?","output":["react is a library while angular is a complete framework","react offers more flexibility, but angular includes more built-in tools","react is used for lightweight projects and angular for robust applications"]},{"input":"what is a spa","output":["It is a single page application where the content loads dynamically","avoid reloading the entire page when navigating between sections","It is common in frameworks like react, angular and vue"]},{"input":"what is backend","output":["It is the part of a system that manages the logic, databases and servers","is responsible for processing requests and sending responses to the frontend","It is essential to manage the business logic of an application"]},{"input":"What languages \u200b\u200bare used in the backend?","output":["some popular ones are java, python, php, ruby \u200b\u200band javascript with nodejs","go, c# and kotlin are also used depending on the use case"]},{"input":"What frameworks are used in the backend?","output":["some popular ones are spring boot for java, django and flask for python","laravel for php and express for nodejs are common options","Ruby on rails and .net core are also used"]},{"input":"what is nodejs","output":["It is a javascript execution environment for the backend","allows you to develop scalable applications with a single language","It is known for its efficiency in handling multiple requests"]},{"input":"what is flask","output":["is a python microframework for backend development","It is lightweight and allows you to create fast APIs with minimal configuration.","It is ideal for small projects and prototypes"]},{"input":"what is a rest api","output":["It is an interface that allows communication between systems using http requests","follows principles such as the separation between client and server","It is common in web applications and mobile services"]},{"input":"what is graphql","output":["It is an alternative to rest for apis","allows the client to specify exactly what data they need","It is developed by Facebook and is used in modern applications"]},{"input":"what is a database","output":["It is a system for storing and organizing information","can be sql like mysql and postgresql, or non-sql like mongodb","It is used to store data that will be used by the backend"]},{"input":"What is the difference between SQL and non-SQL?","output":["SQL uses tables with defined schemas, while non-SQL is more flexible.","sql is great for structured data, not sql for unstructured data","sql includes systems such as mysql and postgresql, non-sql includes mongodb and cassandra"]},{"input":"How frontend and backend communicate","output":["through apis using protocols like http","The frontend sends requests to the backend and it responds with data","Communication can be in formats such as json or xml"]},{"input":"what is a full stack developer","output":["is a developer who works on both frontend and backend","Has knowledge of interface design and server logic","can develop complete applications from start to finish"]},{"input":"What is the difference between frontend and backend?","output":["The frontend is what the user sees, the backend is the logic behind","The frontend uses html, css and javascript, the backend uses languages \u200b\u200b\u200b\u200blike java or python","The backend is responsible for processing data and managing communication with databases."]},{"input":"what is a database","output":["It is a system for storing and managing information in a structured way.","It is used to store data that can be easily consulted and modified","It is essential for applications that need to handle large amounts of information."]},{"input":"What types of databases exist?","output":["There are relational and non-relational databases.","There are also hierarchical, network and object-oriented databases.","They depend on the type of information and the use case."]},{"input":"what is a relational database","output":["It is a database that organizes information in tables with rows and columns.","uses sql as a language to query and modify data","Examples include mysql, postgresql and sql server"]},{"input":"What is a non-relational database?","output":["It is a database that does not use tables to organize data","can store information in formats such as documents, graphs or key-values","Examples include mongodb, cassandra and redis"]},{"input":"What is a schema in a database?","output":["It is the structure that defines how data is organized in a database","includes tables, columns, data types, and relationships between tables","It is important in relational databases"]},{"input":"what is sql","output":["is a structured query language used to interact with relational databases","allows you to perform operations such as inserting, querying and deleting data","It is compatible with systems such as mysql, postgresql and oracle"]},{"input":"what is mysql","output":["It is an open source relational database management system.","It is popular for being fast and easy to use.","commonly used in web applications"]},{"input":"what is postgresql","output":["It is an advanced, open source relational database management system.","offers support for complex transactions and extensibility","It is ideal for enterprise applications and advanced projects"]},{"input":"what is sql server","output":["It is a relational database management system developed by Microsoft.","primarily used in business environments","Offers integration with other Microsoft products such as Azure and Visual Studio"]},{"input":"what is mongodb","output":["is a non-relational database that stores data in json document format","It is ideal for applications that handle unstructured or semi-structured data","It is popular in modern web applications and distributed systems"]},{"input":"What is mongodb used for?","output":["It is used in web applications, recommendation systems and big data","It is ideal for handling large volumes of data and scaling horizontally","used when a strict structure of tables and columns is not needed"]},{"input":"what is redis","output":["It is a non-relational database based on key-value","It is known for its speed and is used as a cache or to store sessions","It is popular in applications that require quick access to data"]},{"input":"what is cassandra","output":["It is a distributed and scalable non-relational database","It is ideal for handling large volumes of data in real time","It is used by companies like Netflix and Twitter for high availability"]},{"input":"What are the differences between mongodb and redis?","output":["mongodb stores json documents, while redis uses a key-value model","redis is faster but mongodb is more flexible for complex data","redis is ideal for caching and mongodb for unstructured data"]},{"input":"what is a compiler","output":["A compiler is a program that translates the source code of a high-level programming language into a low-level language or machine code.","the compiler allows code written in a human-understandable language to be executed by a computer","an example of a compiler is GCC for C or C++"]},{"input":"what is an interpreter","output":["is a type of program that executes the code of a programming language line by line, without having to compile all the code beforehand","Unlike a compiler, an interpreter does not create a machine code file, but rather translates and executes instructions directly","a common example of an interpreter is Python"]},{"input":"what is a bug","output":["A bug is an error or flaw in a program\'s code that causes unexpected or incorrect behavior.","Bugs can be caused by syntax errors, logic errors, or performance problems.","It is important to debug the code to find and fix bugs"]},{"input":"what is a debugger","output":["A debugger is a tool that allows you to examine the state of a program while it is running, helping to identify and correct bugs.","Debuggers allow you to track code execution, inspect variables, and control program flow.","Some popular debuggers are GDB for C and C++, or the debugger built into IDEs like Visual Studio Code"]},{"input":"what is a variable","output":["A variable is a storage space that contains a value that can change during the execution of a program","Variables are used to store data such as numbers, text strings, or even objects","Each variable has a data type that determines what type of values \u200b\u200bit can store, such as \'int\' for integers or \'string\' for text"]},{"input":"what is a data type","output":["A data type is a classification of the values \u200b\u200bthat a variable can store, such as numbers, text, or booleans","Basic data types include integers (int), decimal numbers (float), text (string), and logical values \u200b\u200b(boolean)","data types can also be more complex, such as lists, dictionaries, or even user-defined classes"]},{"input":"which is a primitive data type","output":["A primitive data type is a basic data type that cannot be decomposed into simpler types.","Primitive data types include integers (int), decimals (float), strings (string), and logical values \u200b\u200b(boolean)","These data types are fundamental and form the basis for building other more complex data types."]},{"input":"which is a composite data type","output":["A composite data type is a data type that is created by combining several primitive data types or even other composite types.","Composite data types include lists (arrays), dictionaries (objects in some languages), tuples, and sets","These data types allow for storing more complex and structured collections of data."]},{"input":"what is an array","output":["An array is a data structure that stores a collection of elements of the same type","The elements of an array are stored in contiguous memory locations and are accessed using an index","In many programming languages, such as JavaScript or Python, arrays can be dynamic or fixed size"]},{"input":"what is a list in programming","output":["A list is a composite data type that stores an ordered collection of elements, which can be of different types","Unlike arrays, lists can store elements of different data types in many languages, such as Python","A list can also be dynamic, that is, its size can be changed during program execution"]},{"input":"what is a dictionary","output":["A dictionary is a data structure that stores key-value pairs","Each element in a dictionary is composed of a unique key and a value associated with that key","Dictionaries are useful when you need to quickly look up a value from a key, such as in Python or JavaScript"]},{"input":"what is a tuple","output":["A tuple is a data structure similar to a list, but with the difference that tuples are immutable, that is, they cannot be modified after their creation.","In many programming languages, such as Python, tuples are used to store data that should not change during program execution","tuples can also contain elements of different data types"]},{"input":"what is a set","output":["A set is a collection of unordered elements without duplicates.","Sets are useful when you need to store unique data, without worrying about the order in which it is inserted","In Python, sets are defined using the \'set\' class, and are different from lists or tuples in terms of the uniqueness of the elements"]},{"input":"what is a string","output":["A string is a data type that represents a sequence of characters, such as text","Strings can include letters, numbers, and other characters, and are used to manipulate text in most programming languages.","In some languages, strings are immutable, meaning they cannot be modified after they are created, such as in Python or Java"]},{"input":"what is a boolean","output":["A boolean is a data type that has only two possible values: true or false.","Boolean values \u200b\u200bare used in conditions and control structures, such as \'if\' or \'while\', to make decisions in a program","Booleans are fundamental in logic programming and conditional expressions"]},{"input":"which is a null value","output":["A null value is a special value that represents the absence of a valid or defined value in a variable.","The null value can be used to indicate that a variable has not yet been initialized or that it does not have a value assigned","In some languages, such as JavaScript, \'null\' is used to denote a null value, while in others, such as Python, \'None\' is used"]},{"input":"what is a floating data type","output":["A float data type is a numeric type used to represent numbers with decimals.","Float numbers are especially useful for performing precise calculations that include decimal values, such as 3.14 or 0.5","In many programming languages, such as Python or Java, floats are represented with the type \'float\'"]},{"input":"which is an integer data type","output":["An integer data type is a numeric type used to represent numbers without decimals, such as 1, 100, or -5","Integers are essential in programming to perform simple mathematical operations, such as counting or iterating over elements","In languages \u200b\u200blike Python or Java, integers are represented with the \'int\' type"]},{"input":"what is the char data type","output":["The \'char\' data type is used to represent a single character, such as \'a\', \'B\' or \'9\'","\'char\' is commonly used in languages \u200b\u200bsuch as C and C++ to manipulate individual characters in text strings","In other languages \u200b\u200blike Python, characters are treated as strings of length 1"]},{"input":"What is the complex data type?","output":["The complex data type is used to represent numbers that have a real part and an imaginary part, such as 3 + 4i","In some languages, such as Python, you can work with complex numbers using the \'complex\' type","Complex numbers are used in areas such as engineering, mathematics, and signal processing."]},{"input":"what is a function","output":["A function is a block of code that performs a specific task and can be reused in different parts of the program.","functions can accept input (parameters) and return a value as a result","In many programming languages, functions allow code to be organized in a modular and efficient way"]},{"input":"what is recursion","output":["Recursion is a technique in programming in which a function calls itself to solve a problem","Generally, recursion is used to solve problems that can be broken down into smaller subproblems, such as trees or binary search.","It is important that a recursive function have a base condition that stops the recursive call"]}]');function AH(e,t){const n=["y","que","o","u","pero","porque","aunque","si","cuando","como","por","a","de","en","con","para","el","la","los","las","un","una","unos","unas","al","del"],s=e.normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^\w\s]/g,"").toLowerCase().split(" ").filter(e=>!n.includes(e)),r=new Array(t.length).fill(0);return s.forEach(e=>{const n=t.indexOf(e);-1!==n?r[n]=1:console.warn(`Unknown word: ${e}`)}),r}function RH(e){return e[Math.floor(Math.random()*e.length)]}function FH(e){const t=e.map(e=>e.input.toLowerCase().split(" ")).reduce((e,t)=>e.concat(t),[]);return Array.from(new Set(t))}function DH(e,t){const n=new X$(void 0);return n.add(nR({units:16,activation:"relu",inputShape:[e]})),n.add(nR({units:8,activation:"relu"})),n.add(nR({units:t,activation:"softmax"})),n.compile({optimizer:"adam",loss:"categoricalCrossentropy",metrics:[]}),n}function OH(){return(OH=bp(function*(){const e=FH(TH),t=DH(e.length,TH.length),n=TH.map(t=>AH(t.input,e)),s=TH.map((e,t)=>{const n=new Array(TH.length).fill(0);return n[t]=1,n}),r=Fx(n),a=Fx(s);yield t.fit(r,a,{epochs:190,batchSize:35,shuffle:!0}),yield t.save("localstorage://chatbot-model"),console.log("Modelo entrenado y guardado.")})).apply(this,arguments)}function MH(){return(MH=bp(function*(e){const t=FH(TH),n=yield Y$("localstorage://chatbot-model"),s=Fx([AH(e,t)],[1,t.length]),r=n.predict(s).argMax(-1).dataSync()[0];return RH(TH[r].output)})).apply(this,arguments)}let zH=(()=>{class e{trainChatbot(){return bp(function*(){const e=localStorage.getItem("tensorflowjs_models/chatbot-model/info");null===JSON.parse(e)?(console.log("Entrenando modelo..."),yield function(){return OH.apply(this,arguments)}()):console.log("Modelo ya entrenado")})()}getResponse(e){return bp(function*(){return yield function(e){return MH.apply(this,arguments)}(e)})()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();function LH(e,t){return new k(n=>{const s=e.length;if(0===s)return void n.complete();const r=new Array(s);let a=0,i=0;for(let o=0;o<s;o++){const u=j(e[o]);let l=!1;n.add(u.subscribe({next:e=>{l||(l=!0,i++),r[o]=e},error:e=>n.error(e),complete:()=>{a++,a!==s&&l||(i===s&&n.next(t?t.reduce((e,t,n)=>(e[t]=r[n],e),{}):r),n.complete())}}))}})}let PH=(()=>{class e{constructor(e,t){this._renderer=e,this._elementRef=t,this.onChange=e=>{},this.onTouched=()=>{}}setProperty(e,t){this._renderer.setProperty(this._elementRef.nativeElement,e,t)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return e.\u0275fac=function(t){return new(t||e)(va(hi),va(ui))},e.\u0275dir=Ze({type:e}),e})(),jH=(()=>{class e extends PH{}return e.\u0275fac=function(){let t;return function(n){return(t||(t=On(e)))(n||e)}}(),e.\u0275dir=Ze({type:e,features:[la]}),e})();const VH=new Pn("NgValueAccessor"),WH={provide:VH,useExisting:oe(()=>qH),multi:!0},BH=new Pn("CompositionEventMode");let qH=(()=>{class e extends PH{constructor(e,t,n){super(e,t),this._compositionMode=n,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const e=ku()?ku().getUserAgent():"";return/android (\d+)/.test(e.toLowerCase())}())}writeValue(e){this.setProperty("value",null==e?"":e)}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return e.\u0275fac=function(t){return new(t||e)(va(hi),va(ui),va(BH,8))},e.\u0275dir=Ze({type:e,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,t){1&e&&Ea("input",function(e){return t._handleInput(e.target.value)})("blur",function(){return t.onTouched()})("compositionstart",function(){return t._compositionStart()})("compositionend",function(e){return t._compositionEnd(e.target.value)})},features:[ti([WH]),la]}),e})();const UH=new Pn("NgValidators"),HH=new Pn("NgAsyncValidators");function GH(e){return null!=e}function KH(e){const t=_a(e)?j(e):e;return Sa(t),t}function XH(e){let t={};return e.forEach(e=>{t=null!=e?Object.assign(Object.assign({},t),e):t}),0===Object.keys(t).length?null:t}function YH(e,t){return t.map(t=>t(e))}function ZH(e){return e.map(e=>function(e){return!e.validate}(e)?e:t=>e.validate(t))}function JH(e){return null!=e?function(e){if(!e)return null;const t=e.filter(GH);return 0==t.length?null:function(e){return XH(YH(e,t))}}(ZH(e)):null}function QH(e){return null!=e?function(e){if(!e)return null;const t=e.filter(GH);return 0==t.length?null:function(e){return function(...e){if(1===e.length){const t=e[0];if(d(t))return LH(t,null);if(p(t)&&Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);return LH(e.map(e=>t[e]),e)}}if("function"==typeof e[e.length-1]){const t=e.pop();return LH(e=1===e.length&&d(e[0])?e[0]:e,null).pipe(T(e=>t(...e)))}return LH(e,null)}(YH(e,t).map(KH)).pipe(T(XH))}}(ZH(e)):null}function eG(e,t){return null===e?[t]:Array.isArray(e)?[...e,t]:[e,t]}function tG(e){return e._rawValidators}function nG(e){return e._rawAsyncValidators}let sG=(()=>{class e{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(e){this._rawValidators=e||[],this._composedValidatorFn=JH(this._rawValidators)}_setAsyncValidators(e){this._rawAsyncValidators=e||[],this._composedAsyncValidatorFn=QH(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(e){this._onDestroyCallbacks.push(e)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(e=>e()),this._onDestroyCallbacks=[]}reset(e){this.control&&this.control.reset(e)}hasError(e,t){return!!this.control&&this.control.hasError(e,t)}getError(e,t){return this.control?this.control.getError(e,t):null}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275dir=Ze({type:e}),e})(),rG=(()=>{class e extends sG{get formDirective(){return null}get path(){return null}}return e.\u0275fac=function(){let t;return function(n){return(t||(t=On(e)))(n||e)}}(),e.\u0275dir=Ze({type:e,features:[la]}),e})();class aG extends sG{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class iG{constructor(e){this._cd=e}is(e){var t,n;return!!(null===(n=null===(t=this._cd)||void 0===t?void 0:t.control)||void 0===n?void 0:n[e])}}let oG=(()=>{class e extends iG{constructor(e){super(e)}}return e.\u0275fac=function(t){return new(t||e)(va(aG,2))},e.\u0275dir=Ze({type:e,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,t){2&e&&Ra("ng-untouched",t.is("untouched"))("ng-touched",t.is("touched"))("ng-pristine",t.is("pristine"))("ng-dirty",t.is("dirty"))("ng-valid",t.is("valid"))("ng-invalid",t.is("invalid"))("ng-pending",t.is("pending"))},features:[la]}),e})(),uG=(()=>{class e extends iG{constructor(e){super(e)}}return e.\u0275fac=function(t){return new(t||e)(va(rG,10))},e.\u0275dir=Ze({type:e,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:14,hostBindings:function(e,t){2&e&&Ra("ng-untouched",t.is("untouched"))("ng-touched",t.is("touched"))("ng-pristine",t.is("pristine"))("ng-dirty",t.is("dirty"))("ng-valid",t.is("valid"))("ng-invalid",t.is("invalid"))("ng-pending",t.is("pending"))},features:[la]}),e})();function lG(e,t){return[...t.path,e]}function cG(e,t){pG(e,t),t.valueAccessor.writeValue(e.value),function(e,t){t.valueAccessor.registerOnChange(n=>{e._pendingValue=n,e._pendingChange=!0,e._pendingDirty=!0,"change"===e.updateOn&&mG(e,t)})}(e,t),function(e,t){const n=(e,n)=>{t.valueAccessor.writeValue(e),n&&t.viewToModelUpdate(e)};e.registerOnChange(n),t._registerOnDestroy(()=>{e._unregisterOnChange(n)})}(e,t),function(e,t){t.valueAccessor.registerOnTouched(()=>{e._pendingTouched=!0,"blur"===e.updateOn&&e._pendingChange&&mG(e,t),"submit"!==e.updateOn&&e.markAsTouched()})}(e,t),function(e,t){if(t.valueAccessor.setDisabledState){const n=e=>{t.valueAccessor.setDisabledState(e)};e.registerOnDisabledChange(n),t._registerOnDestroy(()=>{e._unregisterOnDisabledChange(n)})}}(e,t)}function hG(e,t,n=!0){const s=()=>{};t.valueAccessor&&(t.valueAccessor.registerOnChange(s),t.valueAccessor.registerOnTouched(s)),fG(e,t),e&&(t._invokeOnDestroyCallbacks(),e._registerOnCollectionChange(()=>{}))}function dG(e,t){e.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function pG(e,t){const n=tG(e);null!==t.validator?e.setValidators(eG(n,t.validator)):"function"==typeof n&&e.setValidators([n]);const s=nG(e);null!==t.asyncValidator?e.setAsyncValidators(eG(s,t.asyncValidator)):"function"==typeof s&&e.setAsyncValidators([s]);const r=()=>e.updateValueAndValidity();dG(t._rawValidators,r),dG(t._rawAsyncValidators,r)}function fG(e,t){let n=!1;if(null!==e){if(null!==t.validator){const s=tG(e);if(Array.isArray(s)&&s.length>0){const r=s.filter(e=>e!==t.validator);r.length!==s.length&&(n=!0,e.setValidators(r))}}if(null!==t.asyncValidator){const s=nG(e);if(Array.isArray(s)&&s.length>0){const r=s.filter(e=>e!==t.asyncValidator);r.length!==s.length&&(n=!0,e.setAsyncValidators(r))}}}const s=()=>{};return dG(t._rawValidators,s),dG(t._rawAsyncValidators,s),n}function mG(e,t){e._pendingDirty&&e.markAsDirty(),e.setValue(e._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(e._pendingValue),e._pendingChange=!1}function gG(e,t){if(!e.hasOwnProperty("model"))return!1;const n=e.model;return!!n.isFirstChange()||!Object.is(t,n.currentValue)}function bG(e,t){if(!t)return null;let n,s,r;return Array.isArray(t),t.forEach(e=>{e.constructor===qH?n=e:Object.getPrototypeOf(e.constructor)===jH?s=e:r=e}),r||s||n||null}function yG(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}const vG="VALID",wG="INVALID",xG="PENDING",kG="DISABLED";function IG(e){return(EG(e)?e.validators:e)||null}function CG(e){return Array.isArray(e)?JH(e):e||null}function _G(e,t){return(EG(t)?t.asyncValidators:e)||null}function SG(e){return Array.isArray(e)?QH(e):e||null}function EG(e){return null!=e&&!Array.isArray(e)&&"object"==typeof e}class NG{constructor(e,t){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=e,this._rawAsyncValidators=t,this._composedValidatorFn=CG(this._rawValidators),this._composedAsyncValidatorFn=SG(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(e){this._rawValidators=this._composedValidatorFn=e}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(e){this._rawAsyncValidators=this._composedAsyncValidatorFn=e}get parent(){return this._parent}get valid(){return this.status===vG}get invalid(){return this.status===wG}get pending(){return this.status==xG}get disabled(){return this.status===kG}get enabled(){return this.status!==kG}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(e){this._rawValidators=e,this._composedValidatorFn=CG(e)}setAsyncValidators(e){this._rawAsyncValidators=e,this._composedAsyncValidatorFn=SG(e)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(e={}){this.touched=!0,this._parent&&!e.onlySelf&&this._parent.markAsTouched(e)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(e=>e.markAllAsTouched())}markAsUntouched(e={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}markAsDirty(e={}){this.pristine=!1,this._parent&&!e.onlySelf&&this._parent.markAsDirty(e)}markAsPristine(e={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}markAsPending(e={}){this.status=xG,!1!==e.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!e.onlySelf&&this._parent.markAsPending(e)}disable(e={}){const t=this._parentMarkedDirty(e.onlySelf);this.status=kG,this.errors=null,this._forEachChild(t=>{t.disable(Object.assign(Object.assign({},e),{onlySelf:!0}))}),this._updateValue(),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},e),{skipPristineCheck:t})),this._onDisabledChange.forEach(e=>e(!0))}enable(e={}){const t=this._parentMarkedDirty(e.onlySelf);this.status=vG,this._forEachChild(t=>{t.enable(Object.assign(Object.assign({},e),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},e),{skipPristineCheck:t})),this._onDisabledChange.forEach(e=>e(!1))}_updateAncestors(e){this._parent&&!e.onlySelf&&(this._parent.updateValueAndValidity(e),e.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(e){this._parent=e}updateValueAndValidity(e={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),this.status!==vG&&this.status!==xG||this._runAsyncValidator(e.emitEvent)),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!e.onlySelf&&this._parent.updateValueAndValidity(e)}_updateTreeValidity(e={emitEvent:!0}){this._forEachChild(t=>t._updateTreeValidity(e)),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?kG:vG}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(e){if(this.asyncValidator){this.status=xG,this._hasOwnPendingAsyncValidator=!0;const t=KH(this.asyncValidator(this));this._asyncValidationSubscription=t.subscribe(t=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(t,{emitEvent:e})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(e,t={}){this.errors=e,this._updateControlsErrors(!1!==t.emitEvent)}get(e){return function(e,t,n){if(null==t)return null;if(Array.isArray(t)||(t=t.split(".")),Array.isArray(t)&&0===t.length)return null;let s=e;return t.forEach(e=>{s=s instanceof TG?s.controls.hasOwnProperty(e)?s.controls[e]:null:s instanceof AG&&s.at(e)||null}),s}(this,e)}getError(e,t){const n=t?this.get(t):this;return n&&n.errors?n.errors[e]:null}hasError(e,t){return!!this.getError(e,t)}get root(){let e=this;for(;e._parent;)e=e._parent;return e}_updateControlsErrors(e){this.status=this._calculateStatus(),e&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(e)}_initObservables(){this.valueChanges=new lo,this.statusChanges=new lo}_calculateStatus(){return this._allControlsDisabled()?kG:this.errors?wG:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(xG)?xG:this._anyControlsHaveStatus(wG)?wG:vG}_anyControlsHaveStatus(e){return this._anyControls(t=>t.status===e)}_anyControlsDirty(){return this._anyControls(e=>e.dirty)}_anyControlsTouched(){return this._anyControls(e=>e.touched)}_updatePristine(e={}){this.pristine=!this._anyControlsDirty(),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}_updateTouched(e={}){this.touched=this._anyControlsTouched(),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}_isBoxedValue(e){return"object"==typeof e&&null!==e&&2===Object.keys(e).length&&"value"in e&&"disabled"in e}_registerOnCollectionChange(e){this._onCollectionChange=e}_setUpdateStrategy(e){EG(e)&&null!=e.updateOn&&(this._updateOn=e.updateOn)}_parentMarkedDirty(e){return!e&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class $G extends NG{constructor(e=null,t,n){super(IG(t),_G(n,t)),this._onChange=[],this._applyFormState(e),this._setUpdateStrategy(t),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}setValue(e,t={}){this.value=this._pendingValue=e,this._onChange.length&&!1!==t.emitModelToViewChange&&this._onChange.forEach(e=>e(this.value,!1!==t.emitViewToModelChange)),this.updateValueAndValidity(t)}patchValue(e,t={}){this.setValue(e,t)}reset(e=null,t={}){this._applyFormState(e),this.markAsPristine(t),this.markAsUntouched(t),this.setValue(this.value,t),this._pendingChange=!1}_updateValue(){}_anyControls(e){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(e){this._onChange.push(e)}_unregisterOnChange(e){yG(this._onChange,e)}registerOnDisabledChange(e){this._onDisabledChange.push(e)}_unregisterOnDisabledChange(e){yG(this._onDisabledChange,e)}_forEachChild(e){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(e){this._isBoxedValue(e)?(this.value=this._pendingValue=e.value,e.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=e}}class TG extends NG{constructor(e,t,n){super(IG(t),_G(n,t)),this.controls=e,this._initObservables(),this._setUpdateStrategy(t),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(e,t){return this.controls[e]?this.controls[e]:(this.controls[e]=t,t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange),t)}addControl(e,t,n={}){this.registerControl(e,t),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}removeControl(e,t={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],this.updateValueAndValidity({emitEvent:t.emitEvent}),this._onCollectionChange()}setControl(e,t,n={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],t&&this.registerControl(e,t),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}contains(e){return this.controls.hasOwnProperty(e)&&this.controls[e].enabled}setValue(e,t={}){this._checkAllValuesPresent(e),Object.keys(e).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(e[n],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t)}patchValue(e,t={}){null!=e&&(Object.keys(e).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(e[n],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t))}reset(e={},t={}){this._forEachChild((n,s)=>{n.reset(e[s],{onlySelf:!0,emitEvent:t.emitEvent})}),this._updatePristine(t),this._updateTouched(t),this.updateValueAndValidity(t)}getRawValue(){return this._reduceChildren({},(e,t,n)=>(e[n]=t instanceof $G?t.value:t.getRawValue(),e))}_syncPendingControls(){let e=this._reduceChildren(!1,(e,t)=>!!t._syncPendingControls()||e);return e&&this.updateValueAndValidity({onlySelf:!0}),e}_throwIfControlMissing(e){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[e])throw new Error(`Cannot find form control with name: ${e}.`)}_forEachChild(e){Object.keys(this.controls).forEach(t=>{const n=this.controls[t];n&&e(n,t)})}_setUpControls(){this._forEachChild(e=>{e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(e){for(const t of Object.keys(this.controls)){const n=this.controls[t];if(this.contains(t)&&e(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(e,t,n)=>((t.enabled||this.disabled)&&(e[n]=t.value),e))}_reduceChildren(e,t){let n=e;return this._forEachChild((e,s)=>{n=t(n,e,s)}),n}_allControlsDisabled(){for(const e of Object.keys(this.controls))if(this.controls[e].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(e){this._forEachChild((t,n)=>{if(void 0===e[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class AG extends NG{constructor(e,t,n){super(IG(t),_G(n,t)),this.controls=e,this._initObservables(),this._setUpdateStrategy(t),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}at(e){return this.controls[e]}push(e,t={}){this.controls.push(e),this._registerControl(e),this.updateValueAndValidity({emitEvent:t.emitEvent}),this._onCollectionChange()}insert(e,t,n={}){this.controls.splice(e,0,t),this._registerControl(t),this.updateValueAndValidity({emitEvent:n.emitEvent})}removeAt(e,t={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),this.controls.splice(e,1),this.updateValueAndValidity({emitEvent:t.emitEvent})}setControl(e,t,n={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),this.controls.splice(e,1),t&&(this.controls.splice(e,0,t),this._registerControl(t)),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(e,t={}){this._checkAllValuesPresent(e),e.forEach((e,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(e,{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t)}patchValue(e,t={}){null!=e&&(e.forEach((e,n)=>{this.at(n)&&this.at(n).patchValue(e,{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t))}reset(e=[],t={}){this._forEachChild((n,s)=>{n.reset(e[s],{onlySelf:!0,emitEvent:t.emitEvent})}),this._updatePristine(t),this._updateTouched(t),this.updateValueAndValidity(t)}getRawValue(){return this.controls.map(e=>e instanceof $G?e.value:e.getRawValue())}clear(e={}){this.controls.length<1||(this._forEachChild(e=>e._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:e.emitEvent}))}_syncPendingControls(){let e=this.controls.reduce((e,t)=>!!t._syncPendingControls()||e,!1);return e&&this.updateValueAndValidity({onlySelf:!0}),e}_throwIfControlMissing(e){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(e))throw new Error(`Cannot find form control at index ${e}`)}_forEachChild(e){this.controls.forEach((t,n)=>{e(t,n)})}_updateValue(){this.value=this.controls.filter(e=>e.enabled||this.disabled).map(e=>e.value)}_anyControls(e){return this.controls.some(t=>t.enabled&&e(t))}_setUpControls(){this._forEachChild(e=>this._registerControl(e))}_checkAllValuesPresent(e){this._forEachChild((t,n)=>{if(void 0===e[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const e of this.controls)if(e.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(e){e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange)}}const RG={provide:aG,useExisting:oe(()=>DG)},FG=(()=>Promise.resolve(null))();let DG=(()=>{class e extends aG{constructor(e,t,n,s){super(),this.control=new $G,this._registered=!1,this.update=new lo,this._parent=e,this._setValidators(t),this._setAsyncValidators(n),this.valueAccessor=bG(0,s)}ngOnChanges(e){this._checkForErrors(),this._registered||this._setUpControl(),"isDisabled"in e&&this._updateDisabled(e),gG(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._parent?lG(this.name,this._parent):[this.name]}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){cG(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){FG.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1})})}_updateDisabled(e){const t=e.isDisabled.currentValue,n=""===t||t&&"false"!==t;FG.then(()=>{n&&!this.control.disabled?this.control.disable():!n&&this.control.disabled&&this.control.enable()})}}return e.\u0275fac=function(t){return new(t||e)(va(rG,9),va(UH,10),va(HH,10),va(VH,10))},e.\u0275dir=Ze({type:e,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[ti([RG]),la,ct]}),e})(),OG=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275dir=Ze({type:e,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),e})();const MG={provide:VH,useExisting:oe(()=>PG),multi:!0};let zG=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({}),e})(),LG=(()=>{class e{constructor(){this._accessors=[]}add(e,t){this._accessors.push([e,t])}remove(e){for(let t=this._accessors.length-1;t>=0;--t)if(this._accessors[t][1]===e)return void this._accessors.splice(t,1)}select(e){this._accessors.forEach(t=>{this._isSameGroup(t,e)&&t[1]!==e&&t[1].fireUncheck(e.value)})}_isSameGroup(e,t){return!!e[0].control&&e[0]._parent===t._control._parent&&e[1].name===t.name}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:function(){return new e},token:e,providedIn:zG}),e})(),PG=(()=>{class e extends jH{constructor(e,t,n,s){super(e,t),this._registry=n,this._injector=s,this.onChange=()=>{}}ngOnInit(){this._control=this._injector.get(aG),this._checkName(),this._registry.add(this._control,this)}ngOnDestroy(){this._registry.remove(this)}writeValue(e){this._state=e===this.value,this.setProperty("checked",this._state)}registerOnChange(e){this._fn=e,this.onChange=()=>{e(this.value),this._registry.select(this)}}fireUncheck(e){this.writeValue(e)}_checkName(){!this.name&&this.formControlName&&(this.name=this.formControlName)}}return e.\u0275fac=function(t){return new(t||e)(va(hi),va(ui),va(LG),va(oa))},e.\u0275dir=Ze({type:e,selectors:[["input","type","radio","formControlName",""],["input","type","radio","formControl",""],["input","type","radio","ngModel",""]],hostBindings:function(e,t){1&e&&Ea("change",function(){return t.onChange()})("blur",function(){return t.onTouched()})},inputs:{name:"name",formControlName:"formControlName",value:"value"},features:[ti([MG]),la]}),e})();const jG=new Pn("NgModelWithFormControlWarning"),VG={provide:rG,useExisting:oe(()=>WG)};let WG=(()=>{class e extends rG{constructor(e,t){super(),this.validators=e,this.asyncValidators=t,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new lo,this._setValidators(e),this._setAsyncValidators(t)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(fG(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const t=this.form.get(e.path);return cG(t,e),t.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),t}getControl(e){return this.form.get(e.path)}removeControl(e){hG(e.control||null,e,!1),yG(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,t){this.form.get(e.path).setValue(t)}onSubmit(e){return this.submitted=!0,t=this.directives,this.form._syncPendingControls(),t.forEach(e=>{const t=e.control;"submit"===t.updateOn&&t._pendingChange&&(e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1)}),this.ngSubmit.emit(e),!1;var t}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const t=e.control,n=this.form.get(e.path);t!==n&&(hG(t||null,e),n instanceof $G&&(cG(n,e),e.control=n))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const t=this.form.get(e.path);(function(e,t){pG(e,t)})(t,e),t.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const t=this.form.get(e.path);t&&function(e,t){return fG(e,t)}(t,e)&&t.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){pG(this.form,this),this._oldForm&&fG(this._oldForm,this)}_checkFormPresent(){}}return e.\u0275fac=function(t){return new(t||e)(va(UH,10),va(HH,10))},e.\u0275dir=Ze({type:e,selectors:[["","formGroup",""]],hostBindings:function(e,t){1&e&&Ea("submit",function(e){return t.onSubmit(e)})("reset",function(){return t.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[ti([VG]),la,ct]}),e})();const BG={provide:aG,useExisting:oe(()=>qG)};let qG=(()=>{class e extends aG{constructor(e,t,n,s,r){super(),this._ngModelWarningConfig=r,this._added=!1,this.update=new lo,this._ngModelWarningSent=!1,this._parent=e,this._setValidators(t),this._setAsyncValidators(n),this.valueAccessor=bG(0,s)}set isDisabled(e){}ngOnChanges(e){this._added||this._setUpControl(),gG(e,this.viewModel)&&(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}get path(){return lG(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this.control.disabled&&this.valueAccessor.setDisabledState&&this.valueAccessor.setDisabledState(!0),this._added=!0}}return e.\u0275fac=function(t){return new(t||e)(va(rG,13),va(UH,10),va(HH,10),va(VH,10),va(jG,8))},e.\u0275dir=Ze({type:e,selectors:[["","formControlName",""]],inputs:{isDisabled:["disabled","isDisabled"],name:["formControlName","name"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},features:[ti([BG]),la,ct]}),e._ngModelWarningSentOnce=!1,e})(),UG=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[[zG]]}),e})(),HG=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[UG]}),e})(),GG=(()=>{class e{static withConfig(t){return{ngModule:e,providers:[{provide:jG,useValue:t.warnOnNgModelWithFormControl}]}}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[UG]}),e})(),KG=(()=>{class e{group(e,t=null){const n=this._reduceControls(e);let s,r=null,a=null;return null!=t&&(function(e){return void 0!==e.asyncValidators||void 0!==e.validators||void 0!==e.updateOn}(t)?(r=null!=t.validators?t.validators:null,a=null!=t.asyncValidators?t.asyncValidators:null,s=null!=t.updateOn?t.updateOn:void 0):(r=null!=t.validator?t.validator:null,a=null!=t.asyncValidator?t.asyncValidator:null)),new TG(n,{asyncValidators:a,updateOn:s,validators:r})}control(e,t,n){return new $G(e,t,n)}array(e,t,n){const s=e.map(e=>this._createControl(e));return new AG(s,t,n)}_reduceControls(e){const t={};return Object.keys(e).forEach(n=>{t[n]=this._createControl(e[n])}),t}_createControl(e){return e instanceof $G||e instanceof TG||e instanceof AG?e:Array.isArray(e)?this.control(e[0],e.length>1?e[1]:null,e.length>2?e[2]:null):this.control(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:function(){return new e},token:e,providedIn:GG}),e})();const XG=["chatMessages"],YG=function(e,t){return{"align-right":e,"align-left":t}},ZG=function(e,t){return{"is-user":e,"is-bot":t}};function JG(e,t){if(1&e&&(ka(0,"div",18),ka(1,"div",19),ka(2,"p"),za(3),Ia(),Ia(),Ia()),2&e){const e=t.$implicit;wa("ngClass",oo(3,YG,"user"===e.sender,"bot"===e.sender)),Qs(1),wa("ngClass",oo(6,ZG,"user"===e.sender,"bot"===e.sender)),Qs(2),La(e.text)}}const QG=[{path:"",redirectTo:"home",pathMatch:"full"},{path:"home",component:(()=>{class e{constructor(e,t,n){this.chatbotService=e,this.chatTrying=t,this.fb=n,this.messages=[]}ngOnInit(){var e=this;return bp(function*(){e.modelSelectionForm=e.fb.group({model:["Python INTENTS"]}),yield e.chatbotService.loadModel(),yield e.chatTrying.trainChatbot()})()}sendMessage(){var e=this;return bp(function*(){if(""===e.userInput.trim())return;e.messages.push({sender:"user",text:e.userInput});const{model:t}=e.modelSelectionForm.value;let n="";n="Python INTENTS"===t?yield e.chatbotService.predict(e.userInput):yield e.chatTrying.getResponse(e.userInput),e.userInput="",e.messages.push({sender:"bot",text:n})})()}generateBotResponse(e){return e.toLowerCase().includes("hola")?"\xa1Hola! \xbfEn qu\xe9 puedo ayudarte?":e.toLowerCase().includes("adi\xf3s")?"\xa1Hasta luego! Que tengas un buen d\xeda.":"Lo siento, no entiendo tu mensaje. \xbfPodr\xedas ser m\xe1s espec\xedfico?"}scrollToBottom(){setTimeout(()=>{this.chatMessages&&(this.chatMessages.nativeElement.scrollTop=this.chatMessages.nativeElement.scrollHeight)},200)}}return e.\u0275fac=function(t){return new(t||e)(va($H),va(zH),va(KG))},e.\u0275cmp=Ue({type:e,selectors:[["app-home"]],viewQuery:function(e,t){if(1&e&&function(e,t,n){const s=At();s.firstCreatePass&&(function(e,t,n){null===e.queries&&(e.queries=new go),e.queries.track(new bo(t,-1))}(s,new mo(e,t,n)),2==(2&t)&&(s.staticViewQueries=!0)),function(e,t,n){const s=new ho(4==(4&n));vr(e,t,s,s.destroy),null===t[19]&&(t[19]=new fo),t[19].queries.push(new po(s))}(s,Tt(),t)}(XG,5),2&e){let e;ko((n=Tt(),s=Vt(),e=n[19].queries[s].queryList))&&(t.chatMessages=e.first)}var n,s},decls:25,vars:3,consts:[[1,"chat-container"],[1,"options-box"],[1,"options-header"],[1,"options-form",3,"formGroup"],[1,"custom-radio"],["type","radio","formControlName","model","value","Python INTENTS"],["type","radio","formControlName","model","value","js INTENTS"],[1,"chat-box"],[1,"chat-header"],[1,"chat-messages"],["chatMessages",""],["class","message-container",3,"ngClass",4,"ngFor","ngForOf"],[1,"chat-input"],[1,"field","has-addons"],[1,"control","is-expanded"],["type","text","placeholder","Escribe tu mensaje...",1,"input",3,"ngModel","ngModelChange","keydown.enter"],[1,"control"],[1,"button","is-primary",3,"click"],[1,"message-container",3,"ngClass"],[1,"message",3,"ngClass"]],template:function(e,t){1&e&&(ka(0,"body"),ka(1,"div",0),ka(2,"div",1),ka(3,"div",2),za(4," Modelos disponibles "),Ia(),ka(5,"form",3),ka(6,"label",4),Ca(7,"input",5),za(8," Python intents "),Ia(),ka(9,"label",4),Ca(10,"input",6),za(11," JavaScript intents "),Ia(),Ia(),Ia(),ka(12,"div",7),ka(13,"div",8),za(14," Chatbot Grupo 5 - Chatbot12 "),Ia(),ka(15,"div",9,10),function(e,t,n,s,r,a,i,o){const u=Tt(),l=At(),c=l.firstCreatePass?function(e,t,n,s,r,a,i,o,u){const l=t.consts,c=lr(t,37,4,"div",_t(l,11));xr(t,n,c,_t(l,undefined)),Qt(t,c);const h=c.tViews=yr(2,c,s,4,9,t.directiveRegistry,t.pipeRegistry,null,t.schemas,l);return null!==t.queries&&(t.queries.template(t,c),h.queries=t.queries.embeddedTView(c)),c}(0,l,u,t):l.data[37];Dt(c,!1);const h=u[11].createComment("");Rs(l,u,h,c),us(h,u),Or(u,u[37]=Ar(h,u,h,c)),it(c)&&mr(l,u,c)}(0,JG),Ia(),ka(18,"div",12),ka(19,"div",13),ka(20,"div",14),ka(21,"input",15),Ea("ngModelChange",function(e){return t.userInput=e})("keydown.enter",function(){return t.sendMessage()}),Ia(),Ia(),ka(22,"div",16),ka(23,"button",17),Ea("click",function(){return t.sendMessage()}),za(24,"Enviar"),Ia(),Ia(),Ia(),Ia(),Ia(),Ia(),Ia()),2&e&&(Qs(5),wa("formGroup",t.modelSelectionForm),Qs(12),wa("ngForOf",t.messages),Qs(4),wa("ngModel",t.userInput))},directives:[OG,uG,WG,PG,qH,oG,qG,Hu,DG,qu],styles:[".chat-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;min-height:100vh;padding:10px;background-color:#fff;position:relative}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]{width:200px;background-color:#fff;border:1px solid #ddd;border-radius:8px;margin-right:15px;box-shadow:0 4px 20px #0000001a;z-index:10;position:static}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-header[_ngcontent-%COMP%]{background-color:#183059;color:#fff;padding:10px;font-size:1rem;text-align:center;border-radius:8px 8px 0 0}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]{padding:10px}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]   .custom-radio[_ngcontent-%COMP%]{display:flex;align-items:center;grid-gap:5px;gap:5px;margin-bottom:10px}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]   .custom-radio[_ngcontent-%COMP%]   input[type=radio][_ngcontent-%COMP%]{margin-right:0}.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{width:100%;max-width:400px;display:flex;flex-direction:column;height:80vh;border-radius:8px;box-shadow:0 4px 20px #0003;background-color:#fff}@media (min-width:768px){.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{max-width:600px;height:85vh}}@media (min-width:1024px){.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{max-width:800px;height:90vh}}.chat-container[_ngcontent-%COMP%]   .chat-header[_ngcontent-%COMP%]{background-color:#183059;color:#fff;padding:10px;text-align:center;font-size:1.5rem;border-radius:5px 5px 0 0;z-index:1}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]{flex:1;overflow-y:auto;padding:15px 10px;background-color:#fff;border:1px solid #ddd;border-top:none;display:flex;flex-direction:column;grid-gap:10px;gap:10px;font-size:1rem}@media (min-width:1024px){.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]{font-size:1.2rem}}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]{display:flex}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container.align-right[_ngcontent-%COMP%]{justify-content:flex-end}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container.align-left[_ngcontent-%COMP%]{justify-content:flex-start}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message[_ngcontent-%COMP%]{padding:10px 15px;border-radius:10px;max-width:70%;word-wrap:break-word;font-size:1rem}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message.is-user[_ngcontent-%COMP%]{background-color:#183059;color:#fff;text-align:right;border-bottom-right-radius:0}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message.is-bot[_ngcontent-%COMP%]{background-color:#f5f5f5;color:#333;text-align:left;border-bottom-left-radius:0}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]{padding:10px;border-top:1px solid #ddd;background-color:#fff}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .field[_ngcontent-%COMP%]{display:flex;align-items:center}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .input[_ngcontent-%COMP%]{flex:1;border-radius:5px;background-color:#fff;color:#333;border:1px solid #ddd;padding:5px 10px}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .input[_ngcontent-%COMP%]::placeholder{color:#333;font-style:italic}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]{background-color:#183059;color:#fff;border-radius:5px;white-space:nowrap;padding:5px 15px;border:none;cursor:pointer;transition:background-color .2s}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]:hover{background-color:#00c1a8}@media (max-width:768px){.chat-container[_ngcontent-%COMP%]{flex-direction:column}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]{position:absolute;top:10px;left:50%;transform:translateX(-50%);width:90%;margin-right:0;border-radius:8px}.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{margin-top:200px}}"]}),e})()}];let eK=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[[op.forRoot(QG)],op]}),e})(),tK=(()=>{class e{constructor(e){this.chatbotService=e,this.title="chatbot12"}}return e.\u0275fac=function(t){return new(t||e)(va($H))},e.\u0275cmp=Ue({type:e,selectors:[["app-root"]],decls:1,vars:0,template:function(e,t){1&e&&Ca(0,"router-outlet")},directives:[Zd],styles:[""]}),e})(),nK=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e,bootstrap:[tK]}),e.\u0275inj=me({providers:[],imports:[[El,eK,HG,GG]]}),e})();(function(){if(ru)throw new Error("Cannot enable prod mode after platform setup.");su=!1})(),_l().bootstrapModule(nK).catch(e=>console.error(e))},410:()=>{},628:()=>{},601:()=>{},792:()=>{},42:()=>{}},e=>{"use strict";e(e.s=862)}]);