(self.webpackChunkchatbot12=self.webpackChunkchatbot12||[]).push([[179],{255:e=>{function t(e){return Promise.resolve().then(()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}t.keys=()=>[],t.resolve=t,t.id=255,e.exports=t},566:(e,t,n)=>{var r=n(683),s=n(669),i=n(64),a=n(763),o=n(553),u=n(464),l=n(147);l.alea=r,l.xor128=s,l.xorwow=i,l.xorshift7=a,l.xor4096=o,l.tychei=u,e.exports=l},683:function(e,t,n){var r;!function(e,s,i){function a(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.alea=u}(0,e=n.nmd(e))},464:function(e,t,n){var r;!function(e,s,i){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.tychei=u}(0,e=n.nmd(e))},669:function(e,t,n){var r;!function(e,s,i){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xor128=u}(0,e=n.nmd(e))},553:function(e,t,n){var r;!function(e,s,i){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,i=t.i;return t.w=r=r+1640531527|0,n=s[i+34&127],e=s[i=i+1&127],n^=n<<13,e^=e<<17,n=s[i]=(n^=n>>>15)^(e^=e>>>12),t.i=i,n+(r^r>>>16)|0},function(e,t){var n,r,s,i,a,o=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,i=-32;i<u;++i)t&&(r^=t.charCodeAt((i+32)%t.length)),0===i&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(s=0==(n=o[127&i]^=r+(a=a+1640531527|0))?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,i=512;i>0;--i)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,o[s]=(r^=r>>>15)^(n^=n>>>12);e.w=a,e.X=o,e.i=s}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xor4096=u}(0,e=n.nmd(e))},763:function(e,t,n){var r;!function(e,s,i){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],r[s]=n^=(e^=e<<13)^e<<9,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n&&(r[7]=-1),e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xorshift7=u}(0,e=n.nmd(e))},64:function(e,t,n){var r;!function(e,s,i){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xorwow=u}(0,e=n.nmd(e))},147:(e,t,n)=>{var r;!function(s,i){var a,o=this,u=256,l=i.pow(u,6),c=i.pow(2,52),h=2*c,d=255;function p(e,t,n){var r=[],d=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(s)]:null==e?function(){try{var e;return a&&(e=a.randomBytes)?e=e(u):(e=new Uint8Array(u),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(r){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(s)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,b(y(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,i=r.i=r.j=0,a=r.S=[];for(n||(e=[n++]);s<u;)a[s]=s++;for(s=0;s<u;s++)a[s]=a[i=d&i+e[s%n]+(t=a[s])],a[i]=t;(r.g=function(e){for(var t,n=0,s=r.i,i=r.j,a=r.S;e--;)t=a[s=d&s+1],n=n*u+a[d&(a[s]=a[i=d&i+t])+(a[i]=t)];return r.i=s,r.j=i,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(i){}return r.length?r:"string"==s?e:e+"\0"}function b(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(i.seedrandom=p,b(i.random(),s),e.exports){e.exports=p;try{a=n(42)}catch(v){}}else void 0===(r=(function(){return p}).call(t,n,t,e))||(e.exports=r)}([],Math)},3:(e,t,n)=>{"use strict";var r={};n.r(r),n.d(r,{assertParamsValid:()=>rv,computeFlatOffset:()=>gv,computeOutShape:()=>iv,getNormalizedAxes:()=>lv,isSliceContinous:()=>mv,maskToAxes:()=>sv,parseSliceParams:()=>bv,sliceInfo:()=>yv,startForAxis:()=>pv,startIndicesWithElidedDims:()=>cv,stopForAxis:()=>fv,stopIndicesWithElidedDims:()=>hv,stridesForAxis:()=>dv,stridesWithElidedDims:()=>av});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>MC,computeOutShape:()=>OC,segOpComputeOptimalWindowSize:()=>DC});var i={};n.r(i),n.d(i,{ERF_A1:()=>hC,ERF_A2:()=>dC,ERF_A3:()=>pC,ERF_A4:()=>fC,ERF_A5:()=>mC,ERF_P:()=>cC,PARALLELIZE_THRESHOLD:()=>Zk,SELU_SCALE:()=>lC,SELU_SCALEALPHA:()=>uC,applyActivation:()=>Qw,assertAndGetBroadcastShape:()=>wx,assertAxesAreInnerMostDims:()=>Zx,assertParamsConsistent:()=>Kk,assignToTypedArray:()=>CC,axesAreInnerMostDims:()=>Gx,calculateShapes:()=>oC,checkEinsumDimSizes:()=>$C,combineLocations:()=>Hx,complexWithEvenIndex:()=>xC,complexWithOddIndex:()=>wC,computeConv2DInfo:()=>zv,computeConv3DInfo:()=>Vv,computeDefaultPad:()=>Bv,computeDilation2DInfo:()=>Mv,computeOptimalWindowSize:()=>Yk,computeOutAndReduceShapes:()=>Kx,computeOutShape:()=>Xk,computePool2DInfo:()=>Lv,computePool3DInfo:()=>Pv,convertConv2DDataFormat:()=>Kv,decodeEinsumEquation:()=>NC,eitherStridesOrDilationsAreOne:()=>Hv,expandShapeToKeepDim:()=>Xx,exponent:()=>_C,exponents:()=>IC,fromStringArrayToUint8:()=>PC,fromUint8ToStringArray:()=>LC,getAxesPermutation:()=>Yx,getBroadcastDims:()=>vx,getComplexWithIndex:()=>kC,getEinsumComputePath:()=>TC,getEinsumPermutation:()=>EC,getFusedBiasGradient:()=>Yw,getFusedDyActivation:()=>Zw,getImageCenter:()=>Qk,getInnerMostAxes:()=>Jx,getPermuted:()=>eC,getReductionAxes:()=>xx,getReshaped:()=>Jk,getReshapedPermuted:()=>tC,getSliceBeginCoords:()=>nC,getSliceSize:()=>rC,getUndoAxesPermutation:()=>Qx,isIdentityPermutation:()=>AC,log:()=>bC,mergeRealAndImagArrays:()=>yC,prepareAndValidate:()=>sC,prepareSplitSize:()=>FC,segment_util:()=>s,shouldFuse:()=>Jw,slice_util:()=>r,splitRealAndImagArrays:()=>vC,tupleValuesAreOne:()=>Gv,upcastType:()=>Vb,validateInput:()=>aC,validateUpdateShape:()=>iC,warn:()=>gC});var a={};function o(e){return"function"==typeof e}n.r(a),n.d(a,{addImpl:()=>hF,bincountImpl:()=>rD,bincountReduceImpl:()=>sD,ceilImpl:()=>oD,concatImpl:()=>pD,expImpl:()=>aO,expm1Impl:()=>hO,floorImpl:()=>EO,gatherV2Impl:()=>LO,greaterImpl:()=>zO,lessImpl:()=>QO,linSpaceImpl:()=>sM,logImpl:()=>aM,maxImpl:()=>wM,maximumImpl:()=>IM,minimumImpl:()=>DM,multiplyImpl:()=>BD,negImpl:()=>qM,notEqualImpl:()=>QM,prodImpl:()=>hL,rangeImpl:()=>pL,rsqrtImpl:()=>_L,simpleAbsImpl:()=>xF,sliceImpl:()=>JF,sparseFillEmptyRowsImpl:()=>jL,sparseReshapeImpl:()=>HL,squaredDifferenceImpl:()=>eP,stridedSliceImpl:()=>iP,subImpl:()=>bO,tileImpl:()=>cP,topKImpl:()=>hP,transposeImpl:()=>NF,uniqueImpl:()=>gP});let u=!1;const l={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else u&&console.log("RxJS: Back to a better error behavior. Thank you. <3");u=e},get useDeprecatedSynchronousErrorHandling(){return u}};function c(e){setTimeout(()=>{throw e},0)}const h={closed:!0,next(e){},error(e){if(l.useDeprecatedSynchronousErrorHandling)throw e;c(e)},complete(){}},d=(()=>Array.isArray||(e=>e&&"number"==typeof e.length))();function p(e){return null!==e&&"object"==typeof e}const f=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();let m=(()=>{class e{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._ctorUnsubscribe=!0,this._unsubscribe=e)}unsubscribe(){let t;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:r,_unsubscribe:s,_subscriptions:i}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof e)n.remove(this);else if(null!==n)for(let e=0;e<n.length;++e)n[e].remove(this);if(o(s)){r&&(this._unsubscribe=void 0);try{s.call(this)}catch(a){t=a instanceof f?g(a.errors):[a]}}if(d(i)){let e=-1,n=i.length;for(;++e<n;){const n=i[e];if(p(n))try{n.unsubscribe()}catch(a){t=t||[],a instanceof f?t=t.concat(g(a.errors)):t.push(a)}}}if(t)throw new f(t)}add(t){let n=t;if(!t)return e.EMPTY;switch(typeof t){case"function":n=new e(t);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof e)){const t=n;n=new e,n._subscriptions=[t]}break;default:throw new Error("unrecognized teardown "+t+" added to Subscription.")}let{_parentOrParents:r}=n;if(null===r)n._parentOrParents=this;else if(r instanceof e){if(r===this)return n;n._parentOrParents=[r,this]}else{if(-1!==r.indexOf(this))return n;r.push(this)}const s=this._subscriptions;return null===s?this._subscriptions=[n]:s.push(n),n}remove(e){const t=this._subscriptions;if(t){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}}}return e.EMPTY=function(e){return e.closed=!0,e}(new e),e})();function g(e){return e.reduce((e,t)=>e.concat(t instanceof f?t.errors:t),[])}const b=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class y extends m{constructor(e,t,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=h;break;case 1:if(!e){this.destination=h;break}if("object"==typeof e){e instanceof y?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new v(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new v(this,e,t,n)}}[b](){return this}static create(e,t,n){const r=new y(e,t,n);return r.syncErrorThrowable=!1,r}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class v extends y{constructor(e,t,n,r){let s;super(),this._parentSubscriber=e;let i=this;o(t)?s=t:t&&(s=t.next,n=t.error,r=t.complete,t!==h&&(i=Object.create(t),o(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=s,this._error=n,this._complete=r}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;l.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:n}=l;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):c(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;c(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);l.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(n){if(this.unsubscribe(),l.useDeprecatedSynchronousErrorHandling)throw n;c(n)}}__tryOrSetError(e,t,n){if(!l.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(r){return l.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=r,e.syncErrorThrown=!0,!0):(c(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const x=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function w(e){return e}let k=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const n=new e;return n.source=this,n.operator=t,n}subscribe(e,t,n){const{operator:r}=this,s=function(e,t,n){if(e){if(e instanceof y)return e;if(e[b])return e[b]()}return e||t||n?new y(e,t,n):new y(h)}(e,t,n);if(s.add(r?r.call(s,this.source):this.source||l.useDeprecatedSynchronousErrorHandling&&!s.syncErrorThrowable?this._subscribe(s):this._trySubscribe(s)),l.useDeprecatedSynchronousErrorHandling&&s.syncErrorThrowable&&(s.syncErrorThrowable=!1,s.syncErrorThrown))throw s.syncErrorValue;return s}_trySubscribe(e){try{return this._subscribe(e)}catch(t){l.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:n,isStopped:r}=e;if(t||r)return!1;e=n&&n instanceof y?n:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=C(t))((t,n)=>{let r;r=this.subscribe(t=>{try{e(t)}catch(s){n(s),r&&r.unsubscribe()}},n,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[x](){return this}pipe(...e){return 0===e.length?this:(0===(t=e).length?w:1===t.length?t[0]:function(e){return t.reduce((e,t)=>t(e),e)})(this);var t}toPromise(e){return new(e=C(e))((e,t)=>{let n;this.subscribe(e=>n=e,e=>t(e),()=>e(n))})}}return e.create=t=>new e(t),e})();function C(e){if(e||(e=l.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const I=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class _ extends m{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const n=t.indexOf(this.subscriber);-1!==n&&t.splice(n,1)}}class S extends y{constructor(e){super(e),this.destination=e}}let N=(()=>{class e extends k{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[b](){return new S(this)}lift(e){const t=new E(this,this);return t.operator=e,t}next(e){if(this.closed)throw new I;if(!this.isStopped){const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].next(e)}}error(e){if(this.closed)throw new I;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].error(e);this.observers.length=0}complete(){if(this.closed)throw new I;this.isStopped=!0;const{observers:e}=this,t=e.length,n=e.slice();for(let r=0;r<t;r++)n[r].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new I;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new I;return this.hasError?(e.error(this.thrownError),m.EMPTY):this.isStopped?(e.complete(),m.EMPTY):(this.observers.push(e),new _(this,e))}asObservable(){const e=new k;return e.source=this,e}}return e.create=(e,t)=>new E(e,t),e})();class E extends N{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):m.EMPTY}}function $(e){return e&&"function"==typeof e.schedule}function T(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new A(e,t))}}class A{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new R(e,this.project,this.thisArg))}}class R extends y{constructor(e,t,n){super(e),this.project=t,this.count=0,this.thisArg=n||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const F=e=>t=>{for(let n=0,r=e.length;n<r&&!t.closed;n++)t.next(e[n]);t.complete()};function D(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const O=D(),M=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function L(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const P=e=>{if(e&&"function"==typeof e[x])return n=e,e=>{const t=n[x]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(M(e))return F(e);if(L(e))return(e=>t=>(e.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,c),t))(e);if(e&&"function"==typeof e[O])return t=e,e=>{const n=t[O]();for(;;){let t;try{t=n.next()}catch(r){return e.error(r),e}if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof n.return&&e.add(()=>{n.return&&n.return()}),e};{const t=p(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,n};function z(e,t){return new k(n=>{const r=new m;let s=0;return r.add(t.schedule(function(){s!==e.length?(n.next(e[s++]),n.closed||r.add(this.schedule())):n.complete()})),r})}function V(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[x]}(e))return function(e,t){return new k(n=>{const r=new m;return r.add(t.schedule(()=>{const s=e[x]();r.add(s.subscribe({next(e){r.add(t.schedule(()=>n.next(e)))},error(e){r.add(t.schedule(()=>n.error(e)))},complete(){r.add(t.schedule(()=>n.complete()))}}))})),r})}(e,t);if(L(e))return function(e,t){return new k(n=>{const r=new m;return r.add(t.schedule(()=>e.then(e=>{r.add(t.schedule(()=>{n.next(e),r.add(t.schedule(()=>n.complete()))}))},e=>{r.add(t.schedule(()=>n.error(e)))}))),r})}(e,t);if(M(e))return z(e,t);if(function(e){return e&&"function"==typeof e[O]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new k(n=>{const r=new m;let s;return r.add(()=>{s&&"function"==typeof s.return&&s.return()}),r.add(t.schedule(()=>{s=e[O](),r.add(t.schedule(function(){if(n.closed)return;let e,t;try{const n=s.next();e=n.value,t=n.done}catch(r){return void n.error(r)}t?n.complete():(n.next(e),this.schedule())}))})),r})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof k?e:new k(P(e))}class B extends y{constructor(e){super(),this.parent=e}_next(e){this.parent.notifyNext(e)}_error(e){this.parent.notifyError(e),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class W extends y{notifyNext(e){this.destination.next(e)}notifyError(e){this.destination.error(e)}notifyComplete(){this.destination.complete()}}function U(e,t){if(t.closed)return;if(e instanceof k)return e.subscribe(t);let n;try{n=P(e)(t)}catch(r){t.error(r)}return n}function q(e,t,n=Number.POSITIVE_INFINITY){return"function"==typeof t?r=>r.pipe(q((n,r)=>V(e(n,r)).pipe(T((e,s)=>t(n,e,r,s))),n)):("number"==typeof t&&(n=t),t=>t.lift(new j(e,n)))}class j{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new G(e,this.project,this.concurrent))}}class G extends W{constructor(e,t,n=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(t)}_innerSub(e){const t=new B(this),n=this.destination;n.add(t);const r=U(e,t);r!==t&&n.add(r)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e){this.destination.next(e)}notifyComplete(){const e=this.buffer;this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function H(e=Number.POSITIVE_INFINITY){return q(w,e)}function K(e,t){return t?z(e,t):new k(F(e))}function X(){return function(e){return e.lift(new Z(e))}}class Z{constructor(e){this.connectable=e}call(e,t){const{connectable:n}=this;n._refCount++;const r=new Y(e,n),s=t.subscribe(r);return r.closed||(r.connection=n.connect()),s}}class Y extends y{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:n}=this,r=e._connection;this.connection=null,!r||n&&r!==n||r.unsubscribe()}}class Q extends k{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new m,e.add(this.source.subscribe(new ee(this.getSubject(),this))),e.closed&&(this._connection=null,e=m.EMPTY)),e}refCount(){return X()(this)}}const J=(()=>{const e=Q.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class ee extends S{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function te(){return new N}function ne(e){for(let t in e)if(e[t]===ne)return t;throw Error("Could not find renamed property on target object.")}function re(e,t){for(const n in t)t.hasOwnProperty(n)&&!e.hasOwnProperty(n)&&(e[n]=t[n])}function se(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(se).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function ie(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const ae=ne({__forward_ref__:ne});function oe(e){return e.__forward_ref__=oe,e.toString=function(){return se(this())},e}function ue(e){return le(e)?e():e}function le(e){return"function"==typeof e&&e.hasOwnProperty(ae)&&e.__forward_ref__===oe}class ce extends Error{constructor(e,t){super(function(e,t){return`${e?`NG0${e}: `:""}${t}`}(e,t)),this.code=e}}function he(e){return"string"==typeof e?e:null==e?"":String(e)}function de(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():he(e)}function pe(e,t){const n=t?` in ${t}`:"";throw new ce("201",`No provider for ${de(e)} found${n}`)}function fe(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function me(e){return{providers:e.providers||[],imports:e.imports||[]}}function ge(e){return be(e,ve)||be(e,we)}function be(e,t){return e.hasOwnProperty(t)?e[t]:null}function ye(e){return e&&(e.hasOwnProperty(xe)||e.hasOwnProperty(ke))?e[xe]:null}const ve=ne({"\u0275prov":ne}),xe=ne({"\u0275inj":ne}),we=ne({ngInjectableDef:ne}),ke=ne({ngInjectorDef:ne});var Ce=function(e){return e[e.Default=0]="Default",e[e.Host=1]="Host",e[e.Self=2]="Self",e[e.SkipSelf=4]="SkipSelf",e[e.Optional=8]="Optional",e}({});let Ie;function _e(e){const t=Ie;return Ie=e,t}function Se(e,t,n){const r=ge(e);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:n&Ce.Optional?null:void 0!==t?t:void pe(se(e),"Injector")}function Ne(e){return{toString:e}.toString()}var Ee=function(e){return e[e.OnPush=0]="OnPush",e[e.Default=1]="Default",e}({}),$e=function(e){return e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",e}({});const Te="undefined"!=typeof globalThis&&globalThis,Ae="undefined"!=typeof window&&window,Re="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Fe="undefined"!=typeof global&&global,De=Te||Fe||Ae||Re,Oe={},Me=[],Le=ne({"\u0275cmp":ne}),Pe=ne({"\u0275dir":ne}),ze=ne({"\u0275pipe":ne}),Ve=ne({"\u0275mod":ne}),Be=ne({"\u0275loc":ne}),We=ne({"\u0275fac":ne}),Ue=ne({__NG_ELEMENT_ID__:ne});let qe=0;function je(e){return Ne(()=>{const t={},n={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===Ee.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||Me,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||$e.Emulated,id:"c",styles:e.styles||Me,_:null,setInput:null,schemas:e.schemas||null,tView:null},r=e.directives,s=e.features,i=e.pipes;return n.id+=qe++,n.inputs=Ze(e.inputs,t),n.outputs=Ze(e.outputs),s&&s.forEach(e=>e(n)),n.directiveDefs=r?()=>("function"==typeof r?r():r).map(Ge):null,n.pipeDefs=i?()=>("function"==typeof i?i():i).map(He):null,n})}function Ge(e){return Qe(e)||function(e){return e[Pe]||null}(e)}function He(e){return function(e){return e[ze]||null}(e)}const Ke={};function Xe(e){return Ne(()=>{const t={type:e.type,bootstrap:e.bootstrap||Me,declarations:e.declarations||Me,imports:e.imports||Me,exports:e.exports||Me,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&(Ke[e.id]=e.type),t})}function Ze(e,t){if(null==e)return Oe;const n={};for(const r in e)if(e.hasOwnProperty(r)){let s=e[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),n[s]=r,t&&(t[s]=i)}return n}const Ye=je;function Qe(e){return e[Le]||null}function Je(e,t){const n=e[Ve]||null;if(!n&&!0===t)throw new Error(`Type ${se(e)} does not have '\u0275mod' property.`);return n}const et=20,tt=10;function nt(e){return Array.isArray(e)&&"object"==typeof e[1]}function rt(e){return Array.isArray(e)&&!0===e[1]}function st(e){return 0!=(8&e.flags)}function it(e){return 2==(2&e.flags)}function at(e){return 1==(1&e.flags)}function ot(e){return null!==e.template}function ut(e,t){return e.hasOwnProperty(We)?e[We]:null}class lt{constructor(e,t,n){this.previousValue=e,this.currentValue=t,this.firstChange=n}isFirstChange(){return this.firstChange}}function ct(){return ht}function ht(e){return e.type.prototype.ngOnChanges&&(e.setInput=pt),dt}function dt(){const e=ft(this),t=null==e?void 0:e.current;if(t){const n=e.previous;if(n===Oe)e.previous=t;else for(let e in t)n[e]=t[e];e.current=null,this.ngOnChanges(t)}}function pt(e,t,n,r){const s=ft(e)||function(e,t){return e.__ngSimpleChanges__=t}(e,{previous:Oe,current:null}),i=s.current||(s.current={}),a=s.previous,o=this.declaredInputs[n],u=a[o];i[o]=new lt(u&&u.currentValue,t,a===Oe),e[r]=t}function ft(e){return e.__ngSimpleChanges__||null}let mt;function gt(e){return!!e.listen}ct.ngInherit=!0;const bt={createRenderer:(e,t)=>void 0!==mt?mt:"undefined"!=typeof document?document:void 0};function yt(e){for(;Array.isArray(e);)e=e[0];return e}function vt(e,t){return yt(t[e])}function xt(e,t){return yt(t[e.index])}function wt(e,t){return e.data[t]}function kt(e,t){const n=t[e];return nt(n)?n:n[0]}function Ct(e){return 4==(4&e[2])}function It(e){return 128==(128&e[2])}function _t(e,t){return null==t?null:e[t]}function St(e){e[18]=0}function Nt(e,t){e[5]+=t;let n=e,r=e[3];for(;null!==r&&(1===t&&1===n[5]||-1===t&&0===n[5]);)r[5]+=t,n=r,r=r[3]}const Et={lFrame:Ht(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function $t(){return Et.bindingsEnabled}function Tt(){return Et.lFrame.lView}function At(){return Et.lFrame.tView}function Rt(){let e=Ft();for(;null!==e&&64===e.type;)e=e.parent;return e}function Ft(){return Et.lFrame.currentTNode}function Dt(e,t){const n=Et.lFrame;n.currentTNode=e,n.isParent=t}function Ot(){return Et.lFrame.isParent}function Mt(){return Et.isInCheckNoChangesMode}function Lt(e){Et.isInCheckNoChangesMode=e}function Pt(){return Et.lFrame.bindingIndex++}function zt(e,t){const n=Et.lFrame;n.bindingIndex=n.bindingRootIndex=e,Vt(t)}function Vt(e){Et.lFrame.currentDirectiveIndex=e}function Bt(){return Et.lFrame.currentQueryIndex}function Wt(e){Et.lFrame.currentQueryIndex=e}function Ut(e){const t=e[1];return 2===t.type?t.declTNode:1===t.type?e[6]:null}function qt(e,t,n){if(n&Ce.SkipSelf){let r=t,s=e;for(;r=r.parent,!(null!==r||n&Ce.Host||(r=Ut(s),null===r)||(s=s[15],10&r.type)););if(null===r)return!1;t=r,e=s}const r=Et.lFrame=Gt();return r.currentTNode=t,r.lView=e,!0}function jt(e){const t=Gt(),n=e[1];Et.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function Gt(){const e=Et.lFrame,t=null===e?null:e.child;return null===t?Ht(e):t}function Ht(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function Kt(){const e=Et.lFrame;return Et.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const Xt=Kt;function Zt(){const e=Kt();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function Yt(){return Et.lFrame.selectedIndex}function Qt(e){Et.lFrame.selectedIndex=e}function Jt(e,t){for(let n=t.directiveStart,r=t.directiveEnd;n<r;n++){const t=e.data[n].type.prototype,{ngAfterContentInit:r,ngAfterContentChecked:s,ngAfterViewInit:i,ngAfterViewChecked:a,ngOnDestroy:o}=t;r&&(e.contentHooks||(e.contentHooks=[])).push(-n,r),s&&((e.contentHooks||(e.contentHooks=[])).push(n,s),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,s)),i&&(e.viewHooks||(e.viewHooks=[])).push(-n,i),a&&((e.viewHooks||(e.viewHooks=[])).push(n,a),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,a)),null!=o&&(e.destroyHooks||(e.destroyHooks=[])).push(n,o)}}function en(e,t,n){rn(e,t,3,n)}function tn(e,t,n,r){(3&e[2])===n&&rn(e,t,n,r)}function nn(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function rn(e,t,n,r){const s=null!=r?r:-1,i=t.length-1;let a=0;for(let o=void 0!==r?65535&e[18]:0;o<i;o++)if("number"==typeof t[o+1]){if(a=t[o],null!=r&&a>=r)break}else t[o]<0&&(e[18]+=65536),(a<s||-1==s)&&(sn(e,n,t,o),e[18]=(4294901760&e[18])+o+2),o++}function sn(e,t,n,r){const s=n[r]<0,i=n[r+1],a=e[s?-n[r]:n[r]];if(s){if(e[2]>>11<e[18]>>16&&(3&e[2])===t){e[2]+=2048;try{i.call(a)}finally{}}}else try{i.call(a)}finally{}}const an=-1;class on{constructor(e,t,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=n}}function un(e,t,n){const r=gt(e);let s=0;for(;s<n.length;){const i=n[s];if("number"==typeof i){if(0!==i)break;s++;const a=n[s++],o=n[s++],u=n[s++];r?e.setAttribute(t,o,u,a):t.setAttributeNS(a,o,u)}else{const a=i,o=n[++s];cn(a)?r&&e.setProperty(t,a,o):r?e.setAttribute(t,a,o):t.setAttribute(a,o),s++}}return s}function ln(e){return 3===e||4===e||6===e}function cn(e){return 64===e.charCodeAt(0)}function hn(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?n=s:0===n||dn(e,n,s,null,-1===n||2===n?t[++r]:null)}}return e}function dn(e,t,n,r,s){let i=0,a=e.length;if(-1===t)a=-1;else for(;i<e.length;){const n=e[i++];if("number"==typeof n){if(n===t){a=-1;break}if(n>t){a=i-1;break}}}for(;i<e.length;){const t=e[i];if("number"==typeof t)break;if(t===n){if(null===r)return void(null!==s&&(e[i+1]=s));if(r===e[i+1])return void(e[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==a&&(e.splice(a,0,t),i=a+1),e.splice(i++,0,n),null!==r&&e.splice(i++,0,r),null!==s&&e.splice(i++,0,s)}function pn(e){return e!==an}function fn(e){return 32767&e}function mn(e,t){let n=e>>16,r=t;for(;n>0;)r=r[15],n--;return r}let gn=!0;function bn(e){const t=gn;return gn=e,t}let yn=0;function vn(e,t){const n=wn(e,t);if(-1!==n)return n;const r=t[1];r.firstCreatePass&&(e.injectorIndex=t.length,xn(r.data,e),xn(t,null),xn(r.blueprint,null));const s=kn(e,t),i=e.injectorIndex;if(pn(s)){const e=fn(s),n=mn(s,t),r=n[1].data;for(let s=0;s<8;s++)t[i+s]=n[e+s]|r[e+s]}return t[i+8]=s,i}function xn(e,t){e.push(0,0,0,0,0,0,0,0,t)}function wn(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function kn(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,r=null,s=t;for(;null!==s;){const e=s[1],t=e.type;if(r=2===t?e.declTNode:1===t?s[6]:null,null===r)return an;if(n++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|n<<16}return an}function Cn(e,t,n){!function(e,t,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(Ue)&&(r=n[Ue]),null==r&&(r=n[Ue]=yn++);const s=255&r;t.data[e+(s>>5)]|=1<<s}(e,t,n)}function In(e,t,n){if(n&Ce.Optional)return e;pe(t,"NodeInjector")}function _n(e,t,n,r){if(n&Ce.Optional&&void 0===r&&(r=null),0==(n&(Ce.Self|Ce.Host))){const s=e[9],i=_e(void 0);try{return s?s.get(t,r,n&Ce.Optional):Se(t,r,n&Ce.Optional)}finally{_e(i)}}return In(r,t,n)}function Sn(e,t,n,r=Ce.Default,s){if(null!==e){const i=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(Ue)?e[Ue]:void 0;return"number"==typeof t?t>=0?255&t:En:t}(n);if("function"==typeof i){if(!qt(t,e,r))return r&Ce.Host?In(s,n,r):_n(t,n,r,s);try{const e=i(r);if(null!=e||r&Ce.Optional)return e;pe(n)}finally{Xt()}}else if("number"==typeof i){let s=null,a=wn(e,t),o=an,u=r&Ce.Host?t[16][6]:null;for((-1===a||r&Ce.SkipSelf)&&(o=-1===a?kn(e,t):t[a+8],o!==an&&Fn(r,!1)?(s=t[1],a=fn(o),t=mn(o,t)):a=-1);-1!==a;){const e=t[1];if(Rn(i,a,e.data)){const e=$n(a,t,n,s,r,u);if(e!==Nn)return e}o=t[a+8],o!==an&&Fn(r,t[1].data[a+8]===u)&&Rn(i,a,t)?(s=e,a=fn(o),t=mn(o,t)):a=-1}}}return _n(t,n,r,s)}const Nn={};function En(){return new Dn(Rt(),Tt())}function $n(e,t,n,r,s,i){const a=t[1],o=a.data[e+8],u=Tn(o,a,n,null==r?it(o)&&gn:r!=a&&0!=(3&o.type),s&Ce.Host&&i===o);return null!==u?An(t,a,u,o):Nn}function Tn(e,t,n,r,s){const i=e.providerIndexes,a=t.data,o=1048575&i,u=e.directiveStart,l=i>>20,c=s?o+l:e.directiveEnd;for(let h=r?o:o+l;h<c;h++){const e=a[h];if(h<u&&n===e||h>=u&&e.type===n)return h}if(s){const e=a[u];if(e&&ot(e)&&e.type===n)return u}return null}function An(e,t,n,r){let s=e[n];const i=t.data;if(s instanceof on){const a=s;a.resolving&&function(e,t){throw new ce("200",`Circular dependency in DI detected for ${e}`)}(de(i[n]));const o=bn(a.canSeeViewProviders);a.resolving=!0;const u=a.injectImpl?_e(a.injectImpl):null;qt(e,r,Ce.Default);try{s=e[n]=a.factory(void 0,i,e,r),t.firstCreatePass&&n>=r.directiveStart&&function(e,t,n){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=t.type.prototype;if(r){const r=ht(t);(n.preOrderHooks||(n.preOrderHooks=[])).push(e,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,r)}s&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-e,s),i&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,i))}(n,i[n],t)}finally{null!==u&&_e(u),bn(o),a.resolving=!1,Xt()}}return s}function Rn(e,t,n){return!!(n[t+(e>>5)]&1<<e)}function Fn(e,t){return!(e&Ce.Self||e&Ce.Host&&t)}class Dn{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return Sn(this._tNode,this._lView,e,void 0,t)}}function On(e){return Ne(()=>{const t=e.prototype.constructor,n=t[We]||Mn(t),r=Object.prototype;let s=Object.getPrototypeOf(e.prototype).constructor;for(;s&&s!==r;){const e=s[We]||Mn(s);if(e&&e!==n)return e;s=Object.getPrototypeOf(s)}return e=>new e})}function Mn(e){return le(e)?()=>{const t=Mn(ue(e));return t&&t()}:ut(e)}const Ln="__parameters__";function Pn(e,t,n){return Ne(()=>{const r=function(e){return function(...t){if(e){const n=e(...t);for(const e in n)this[e]=n[e]}}}(t);function s(...e){if(this instanceof s)return r.apply(this,e),this;const t=new s(...e);return n.annotation=t,n;function n(e,n,r){const s=e.hasOwnProperty(Ln)?e[Ln]:Object.defineProperty(e,Ln,{value:[]})[Ln];for(;s.length<=r;)s.push(null);return(s[r]=s[r]||[]).push(t),e}}return n&&(s.prototype=Object.create(n.prototype)),s.prototype.ngMetadataName=e,s.annotationCls=s,s})}class zn{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=fe({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Vn=new zn("AnalyzeForEntryComponents"),Bn=Function;function Wn(e,t){void 0===t&&(t=e);for(let n=0;n<e.length;n++){let r=e[n];Array.isArray(r)?(t===e&&(t=e.slice(0,n)),Wn(r,t)):t!==e&&t.push(r)}return t}function Un(e,t){e.forEach(e=>Array.isArray(e)?Un(e,t):t(e))}function qn(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function jn(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}function Gn(e,t,n){let r=Kn(e,t);return r>=0?e[1|r]=n:(r=~r,function(e,t,n,r){let s=e.length;if(s==t)e.push(n,r);else if(1===s)e.push(r,e[0]),e[0]=n;else{for(s--,e.push(e[s-1],e[s]);s>t;)e[s]=e[s-2],s--;e[t]=n,e[t+1]=r}}(e,r,t,n)),r}function Hn(e,t){const n=Kn(e,t);if(n>=0)return e[1|n]}function Kn(e,t){return function(e,t,n){let r=0,s=e.length>>1;for(;s!==r;){const n=r+(s-r>>1),i=e[n<<1];if(t===i)return n<<1;i>t?s=n:r=n+1}return~(s<<1)}(e,t)}const Xn={},Zn=/\n/gm,Yn="__source",Qn=ne({provide:String,useValue:ne});let Jn;function er(e){const t=Jn;return Jn=e,t}function tr(e,t=Ce.Default){if(void 0===Jn)throw new Error("inject() must be called from an injection context");return null===Jn?Se(e,void 0,t):Jn.get(e,t&Ce.Optional?null:void 0,t)}function nr(e,t=Ce.Default){return(Ie||tr)(ue(e),t)}function rr(e){const t=[];for(let n=0;n<e.length;n++){const r=ue(e[n]);if(Array.isArray(r)){if(0===r.length)throw new Error("Arguments array must have arguments.");let e,n=Ce.Default;for(let t=0;t<r.length;t++){const s=r[t],i=s.__NG_DI_FLAG__;"number"==typeof i?-1===i?e=s.token:n|=i:e=s}t.push(nr(e,n))}else t.push(nr(r))}return t}function sr(e,t){return e.__NG_DI_FLAG__=t,e.prototype.__NG_DI_FLAG__=t,e}const ir=sr(Pn("Inject",e=>({token:e})),-1),ar=sr(Pn("Optional"),8),or=sr(Pn("SkipSelf"),4);function ur(e,t){e.__ngContext__=t}function lr(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function cr(e){return e.ngDebugContext}function hr(e){return e.ngOriginalError}function dr(e,...t){e.error(...t)}class pr{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),n=this._findContext(e),r=function(e){return e.ngErrorLogger||dr}(e);r(this._console,"ERROR",e),t&&r(this._console,"ORIGINAL ERROR",t),n&&r(this._console,"ERROR CONTEXT",n)}_findContext(e){return e?cr(e)?cr(e):this._findContext(hr(e)):null}_findOriginalError(e){let t=hr(e);for(;t&&hr(t);)t=hr(t);return t}}const fr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(De))();function mr(e){return e instanceof Function?e():e}var gr=function(e){return e[e.Important=1]="Important",e[e.DashCase=2]="DashCase",e}({});function br(e,t){return(void 0)(e,t)}function yr(e){const t=e[3];return rt(t)?t[3]:t}function vr(e){return wr(e[13])}function xr(e){return wr(e[4])}function wr(e){for(;null!==e&&!rt(e);)e=e[4];return e}function kr(e,t,n,r,s){if(null!=r){let i,a=!1;rt(r)?i=r:nt(r)&&(a=!0,r=r[0]);const o=yt(r);0===e&&null!==n?null==s?$r(t,n,o):Er(t,n,o,s||null,!0):1===e&&null!==n?Er(t,n,o,s||null,!0):2===e?function(e,t,n){const r=Ar(e,t);r&&function(e,t,n,r){gt(e)?e.removeChild(t,n,r):t.removeChild(n)}(e,r,t,n)}(t,o,a):3===e&&t.destroyNode(o),null!=i&&function(e,t,n,r,s){const i=n[7];i!==yt(n)&&kr(t,e,r,i,s);for(let a=tt;a<n.length;a++){const s=n[a];Lr(s[1],s,e,t,r,i)}}(t,e,i,n,s)}}function Cr(e,t,n){return gt(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function Ir(e,t){const n=e[9],r=n.indexOf(t),s=t[3];1024&t[2]&&(t[2]&=-1025,Nt(s,-1)),n.splice(r,1)}function _r(e,t){if(e.length<=tt)return;const n=tt+t,r=e[n];if(r){const i=r[17];null!==i&&i!==e&&Ir(i,r),t>0&&(e[n-1][4]=r[4]);const a=jn(e,tt+t);Lr(r[1],s=r,s[11],2,null,null),s[0]=null,s[6]=null;const o=a[19];null!==o&&o.detachView(a[1]),r[3]=null,r[4]=null,r[2]&=-129}var s;return r}function Sr(e,t){if(!(256&t[2])){const n=t[11];gt(n)&&n.destroyNode&&Lr(e,t,n,3,null,null),function(e){let t=e[13];if(!t)return Nr(e[1],e);for(;t;){let n=null;if(nt(t))n=t[13];else{const e=t[10];e&&(n=e)}if(!n){for(;t&&!t[4]&&t!==e;)nt(t)&&Nr(t[1],t),t=t[3];null===t&&(t=e),nt(t)&&Nr(t[1],t),n=t&&t[4]}t=n}}(t)}}function Nr(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let r=0;r<n.length;r+=2){const e=t[n[r]];if(!(e instanceof on)){const t=n[r+1];if(Array.isArray(t))for(let n=0;n<t.length;n+=2){const r=e[t[n]],s=t[n+1];try{s.call(r)}finally{}}else try{t.call(e)}finally{}}}}(e,t),function(e,t){const n=e.cleanup,r=t[7];let s=-1;if(null!==n)for(let i=0;i<n.length-1;i+=2)if("string"==typeof n[i]){const e=n[i+1],a="function"==typeof e?e(t):yt(t[e]),o=r[s=n[i+2]],u=n[i+3];"boolean"==typeof u?a.removeEventListener(n[i],o,u):u>=0?r[s=u]():r[s=-u].unsubscribe(),i+=2}else{const e=r[s=n[i+1]];n[i].call(e)}if(null!==r){for(let e=s+1;e<r.length;e++)(0,r[e])();t[7]=null}}(e,t),1===t[1].type&&gt(t[11])&&t[11].destroy();const n=t[17];if(null!==n&&rt(t[3])){n!==t[3]&&Ir(n,t);const r=t[19];null!==r&&r.detachView(e)}}}function Er(e,t,n,r,s){gt(e)?e.insertBefore(t,n,r,s):t.insertBefore(n,r,s)}function $r(e,t,n){gt(e)?e.appendChild(t,n):t.appendChild(n)}function Tr(e,t,n,r,s){null!==r?Er(e,t,n,r,s):$r(e,t,n)}function Ar(e,t){return gt(e)?e.parentNode(t):t.parentNode}function Rr(e,t,n,r){const s=function(e,t,n){return function(e,t,n){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return n[0];if(2&r.flags){const t=e.data[r.directiveStart].encapsulation;if(t===$e.None||t===$e.Emulated)return null}return xt(r,n)}(e,t.parent,n)}(e,r,t),i=t[11],a=function(e,t,n){return function(e,t,n){return 40&e.type?xt(e,n):null}(e,0,n)}(r.parent||t[6],0,t);if(null!=s)if(Array.isArray(n))for(let o=0;o<n.length;o++)Tr(i,s,n[o],a,!1);else Tr(i,s,n,a,!1)}function Fr(e,t){if(null!==t){const n=t.type;if(3&n)return xt(t,e);if(4&n)return Or(-1,e[t.index]);if(8&n){const n=t.child;if(null!==n)return Fr(e,n);{const n=e[t.index];return rt(n)?Or(-1,n):yt(n)}}if(32&n)return br(t,e)()||yt(e[t.index]);{const n=Dr(e,t);return null!==n?Array.isArray(n)?n[0]:Fr(yr(e[16]),n):Fr(e,t.next)}}return null}function Dr(e,t){return null!==t?e[16][6].projection[t.projection]:null}function Or(e,t){const n=tt+e+1;if(n<t.length){const e=t[n],r=e[1].firstChild;if(null!==r)return Fr(e,r)}return t[7]}function Mr(e,t,n,r,s,i,a){for(;null!=n;){const o=r[n.index],u=n.type;if(a&&0===t&&(o&&ur(yt(o),r),n.flags|=4),64!=(64&n.flags))if(8&u)Mr(e,t,n.child,r,s,i,!1),kr(t,e,s,o,i);else if(32&u){const a=br(n,r);let u;for(;u=a();)kr(t,e,s,u,i);kr(t,e,s,o,i)}else 16&u?Pr(e,t,r,n,s,i):kr(t,e,s,o,i);n=a?n.projectionNext:n.next}}function Lr(e,t,n,r,s,i){Mr(n,r,e.firstChild,t,s,i,!1)}function Pr(e,t,n,r,s,i){const a=n[16],o=a[6].projection[r.projection];if(Array.isArray(o))for(let u=0;u<o.length;u++)kr(t,e,s,o[u],i);else Mr(e,t,o,a[3],s,i,!0)}function zr(e,t,n){gt(e)?e.setAttribute(t,"style",n):t.style.cssText=n}function Vr(e,t,n){gt(e)?""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n):t.className=n}function Br(e,t,n){let r=e.length;for(;;){const s=e.indexOf(t,n);if(-1===s)return s;if(0===s||e.charCodeAt(s-1)<=32){const n=t.length;if(s+n===r||e.charCodeAt(s+n)<=32)return s}n=s+1}}const Wr="ng-template";function Ur(e,t,n){let r=0;for(;r<e.length;){let s=e[r++];if(n&&"class"===s){if(s=e[r],-1!==Br(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<e.length&&"string"==typeof(s=e[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function qr(e){return 4===e.type&&e.value!==Wr}function jr(e,t,n){return t===(4!==e.type||n?e.value:Wr)}function Gr(e,t,n){let r=4;const s=e.attrs||[],i=function(e){for(let t=0;t<e.length;t++)if(ln(e[t]))return t;return e.length}(s);let a=!1;for(let o=0;o<t.length;o++){const u=t[o];if("number"!=typeof u){if(!a)if(4&r){if(r=2|1&r,""!==u&&!jr(e,u,n)||""===u&&1===t.length){if(Hr(r))return!1;a=!0}}else{const l=8&r?u:t[++o];if(8&r&&null!==e.attrs){if(!Ur(e.attrs,l,n)){if(Hr(r))return!1;a=!0}continue}const c=Kr(8&r?"class":u,s,qr(e),n);if(-1===c){if(Hr(r))return!1;a=!0;continue}if(""!==l){let e;e=c>i?"":s[c+1].toLowerCase();const t=8&r?e:null;if(t&&-1!==Br(t,l,0)||2&r&&l!==e){if(Hr(r))return!1;a=!0}}}}else{if(!a&&!Hr(r)&&!Hr(u))return!1;if(a&&Hr(u))continue;a=!1,r=u|1&r}}return Hr(r)||a}function Hr(e){return 0==(1&e)}function Kr(e,t,n,r){if(null===t)return-1;let s=0;if(r||!n){let n=!1;for(;s<t.length;){const r=t[s];if(r===e)return s;if(3===r||6===r)n=!0;else{if(1===r||2===r){let e=t[++s];for(;"string"==typeof e;)e=t[++s];continue}if(4===r)break;if(0===r){s+=4;continue}}s+=n?1:2}return-1}return function(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const r=e[n];if("number"==typeof r)return-1;if(r===t)return n;n++}return-1}(t,e)}function Xr(e,t,n=!1){for(let r=0;r<t.length;r++)if(Gr(e,t[r],n))return!0;return!1}function Zr(e,t){return e?":not("+t.trim()+")":t}function Yr(e){let t=e[0],n=1,r=2,s="",i=!1;for(;n<e.length;){let a=e[n];if("string"==typeof a)if(2&r){const t=e[++n];s+="["+a+(t.length>0?'="'+t+'"':"")+"]"}else 8&r?s+="."+a:4&r&&(s+=" "+a);else""===s||Hr(a)||(t+=Zr(i,s),s=""),r=a,i=i||!Hr(r);n++}return""!==s&&(t+=Zr(i,s)),t}const Qr={};function Jr(e){es(At(),Tt(),Yt()+e,Mt())}function es(e,t,n,r){if(!r)if(3==(3&t[2])){const r=e.preOrderCheckHooks;null!==r&&en(t,r,n)}else{const r=e.preOrderHooks;null!==r&&tn(t,r,0,n)}Qt(n)}function ts(e,t){return e<<17|t<<2}function ns(e){return e>>17&32767}function rs(e){return 2|e}function ss(e){return(131068&e)>>2}function is(e,t){return-131069&e|t<<2}function as(e){return 1|e}function os(e,t){const n=e.contentQueries;if(null!==n)for(let r=0;r<n.length;r+=2){const s=n[r],i=n[r+1];if(-1!==i){const n=e.data[i];Wt(s),n.contentQueries(2,t[i],i)}}}function us(e,t,n,r,s,i,a,o,u,l){const c=t.blueprint.slice();return c[0]=s,c[2]=140|r,St(c),c[3]=c[15]=e,c[8]=n,c[10]=a||e&&e[10],c[11]=o||e&&e[11],c[12]=u||e&&e[12]||null,c[9]=l||e&&e[9]||null,c[6]=i,c[16]=2==t.type?e[16]:c,c}function ls(e,t,n,r,s){let i=e.data[t];if(null===i)i=function(e,t,n,r,s){const i=Ft(),a=Ot(),o=e.data[t]=function(e,t,n,r,s,i){return{type:n,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,a?i:i&&i.parent,n,t,r,s);return null===e.firstChild&&(e.firstChild=o),null!==i&&(a?null==i.child&&null!==o.parent&&(i.child=o):null===i.next&&(i.next=o)),o}(e,t,n,r,s),Et.lFrame.inI18n&&(i.flags|=64);else if(64&i.type){i.type=n,i.value=r,i.attrs=s;const e=function(){const e=Et.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();i.injectorIndex=null===e?-1:e.injectorIndex}return Dt(i,!0),i}function cs(e,t,n,r){if(0===n)return-1;const s=t.length;for(let i=0;i<n;i++)t.push(r),e.blueprint.push(r),e.data.push(null);return s}function hs(e,t,n){jt(t);try{const r=e.viewQuery;null!==r&&zs(1,r,n);const s=e.template;null!==s&&fs(e,t,s,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&os(e,t),e.staticViewQueries&&zs(2,e.viewQuery,n);const i=e.components;null!==i&&function(e,t){for(let n=0;n<t.length;n++)Ds(e,t[n])}(t,i)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),r}finally{t[2]&=-5,Zt()}}function ds(e,t,n,r){const s=t[2];if(256==(256&s))return;jt(t);const i=Mt();try{St(t),Et.lFrame.bindingIndex=e.bindingStartIndex,null!==n&&fs(e,t,n,2,r);const a=3==(3&s);if(!i)if(a){const n=e.preOrderCheckHooks;null!==n&&en(t,n,null)}else{const n=e.preOrderHooks;null!==n&&tn(t,n,0,null),nn(t,0)}if(function(e){for(let t=vr(e);null!==t;t=xr(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const n=e[t],r=n[3];0==(1024&n[2])&&Nt(r,1),n[2]|=1024}}}(t),function(e){for(let t=vr(e);null!==t;t=xr(t))for(let e=tt;e<t.length;e++){const n=t[e],r=n[1];It(n)&&ds(r,n,r.template,n[8])}}(t),null!==e.contentQueries&&os(e,t),!i)if(a){const n=e.contentCheckHooks;null!==n&&en(t,n)}else{const n=e.contentHooks;null!==n&&tn(t,n,1),nn(t,1)}!function(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let e=0;e<n.length;e++){const r=n[e];if(r<0)Qt(~r);else{const s=r,i=n[++e],a=n[++e];zt(i,s),a(2,t[s])}}}finally{Qt(-1)}}(e,t);const o=e.components;null!==o&&function(e,t){for(let n=0;n<t.length;n++)Rs(e,t[n])}(t,o);const u=e.viewQuery;if(null!==u&&zs(2,u,r),!i)if(a){const n=e.viewCheckHooks;null!==n&&en(t,n)}else{const n=e.viewHooks;null!==n&&tn(t,n,2),nn(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),i||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,Nt(t[3],-1))}finally{Zt()}}function ps(e,t,n,r){const s=t[10],i=!Mt(),a=Ct(t);try{i&&!a&&s.begin&&s.begin(),a&&hs(e,t,r),ds(e,t,n,r)}finally{i&&!a&&s.end&&s.end()}}function fs(e,t,n,r,s){const i=Yt(),a=2&r;try{Qt(-1),a&&t.length>et&&es(e,t,et,Mt()),n(r,s)}finally{Qt(i)}}function ms(e,t,n){$t()&&(function(e,t,n,r){const s=n.directiveStart,i=n.directiveEnd;e.firstCreatePass||vn(n,t),ur(r,t);const a=n.initialInputs;for(let o=s;o<i;o++){const r=e.data[o],i=ot(r);i&&Es(t,n,r);const u=An(t,e,o,n);ur(u,t),null!==a&&$s(0,o-s,u,r,0,a),i&&(kt(n.index,t)[8]=u)}}(e,t,n,xt(n,t)),128==(128&n.flags)&&function(e,t,n){const r=n.directiveStart,s=n.directiveEnd,i=n.index,a=Et.lFrame.currentDirectiveIndex;try{Qt(i);for(let n=r;n<s;n++){const r=e.data[n],s=t[n];Vt(n),null===r.hostBindings&&0===r.hostVars&&null===r.hostAttrs||Cs(r,s)}}finally{Qt(-1),Vt(a)}}(e,t,n))}function gs(e,t,n=xt){const r=t.localNames;if(null!==r){let s=t.index+1;for(let i=0;i<r.length;i+=2){const a=r[i+1],o=-1===a?n(t,e):e[a];e[s++]=o}}}function bs(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=ys(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function ys(e,t,n,r,s,i,a,o,u,l){const c=et+r,h=c+s,d=function(e,t){const n=[];for(let r=0;r<t;r++)n.push(r<e?null:Qr);return n}(c,h),p="function"==typeof l?l():l;return d[1]={type:e,blueprint:d,template:n,queries:null,viewQuery:o,declTNode:t,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof a?a():a,firstChild:null,schemas:u,consts:p,incompleteFirstPass:!1}}function vs(e,t,n,r){const s=Bs(t);null===n?s.push(r):(s.push(n),e.firstCreatePass&&Ws(e).push(r,s.length-1))}function xs(e,t,n){for(let r in e)if(e.hasOwnProperty(r)){const s=e[r];(n=null===n?{}:n).hasOwnProperty(r)?n[r].push(t,s):n[r]=[t,s]}return n}function ws(e,t,n,r){let s=!1;if($t()){const i=function(e,t,n){const r=e.directiveRegistry;let s=null;if(r)for(let i=0;i<r.length;i++){const a=r[i];Xr(n,a.selectors,!1)&&(s||(s=[]),Cn(vn(n,t),e,a.type),ot(a)?(Is(e,n),s.unshift(a)):s.push(a))}return s}(e,t,n),a=null===r?null:{"":-1};if(null!==i){s=!0,Ss(n,e.data.length,i.length);for(let e=0;e<i.length;e++){const t=i[e];t.providersResolver&&t.providersResolver(t)}let r=!1,o=!1,u=cs(e,t,i.length,null);for(let s=0;s<i.length;s++){const l=i[s];n.mergedAttrs=hn(n.mergedAttrs,l.hostAttrs),Ns(e,n,t,u,l),_s(u,l,a),null!==l.contentQueries&&(n.flags|=8),null===l.hostBindings&&null===l.hostAttrs&&0===l.hostVars||(n.flags|=128);const c=l.type.prototype;!r&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n.index),r=!0),o||!c.ngOnChanges&&!c.ngDoCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n.index),o=!0),u++}!function(e,t){const n=t.directiveEnd,r=e.data,s=t.attrs,i=[];let a=null,o=null;for(let u=t.directiveStart;u<n;u++){const e=r[u],n=e.inputs,l=null===s||qr(t)?null:Ts(n,s);i.push(l),a=xs(n,u,a),o=xs(e.outputs,u,o)}null!==a&&(a.hasOwnProperty("class")&&(t.flags|=16),a.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=i,t.inputs=a,t.outputs=o}(e,n)}a&&function(e,t,n){if(t){const r=e.localNames=[];for(let e=0;e<t.length;e+=2){const s=n[t[e+1]];if(null==s)throw new ce("301",`Export of name '${t[e+1]}' not found!`);r.push(t[e],s)}}}(n,r,a)}return n.mergedAttrs=hn(n.mergedAttrs,n.attrs),s}function ks(e,t,n,r,s,i){const a=i.hostBindings;if(a){let n=e.hostBindingOpCodes;null===n&&(n=e.hostBindingOpCodes=[]);const i=~t.index;(function(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(n)!=i&&n.push(i),n.push(r,s,a)}}function Cs(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function Is(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function _s(e,t,n){if(n){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)n[t.exportAs[r]]=e;ot(t)&&(n[""]=e)}}function Ss(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function Ns(e,t,n,r,s){e.data[r]=s;const i=s.factory||(s.factory=ut(s.type)),a=new on(i,ot(s),null);e.blueprint[r]=a,n[r]=a,ks(e,t,0,r,cs(e,n,s.hostVars,Qr),s)}function Es(e,t,n){const r=xt(t,e),s=bs(n),i=e[10],a=Os(e,us(e,s,null,n.onPush?64:16,r,t,i,i.createRenderer(r,n),null,null));e[t.index]=a}function $s(e,t,n,r,s,i){const a=i[t];if(null!==a){const e=r.setInput;for(let t=0;t<a.length;){const s=a[t++],i=a[t++],o=a[t++];null!==e?r.setInput(n,o,s,i):n[i]=o}}}function Ts(e,t){let n=null,r=0;for(;r<t.length;){const s=t[r];if(0!==s)if(5!==s){if("number"==typeof s)break;e.hasOwnProperty(s)&&(null===n&&(n=[]),n.push(s,e[s],t[r+1])),r+=2}else r+=2;else r+=4}return n}function As(e,t,n,r){return new Array(e,!0,!1,t,null,0,r,n,null,null)}function Rs(e,t){const n=kt(t,e);if(It(n)){const e=n[1];80&n[2]?ds(e,n,e.template,n[8]):n[5]>0&&Fs(n)}}function Fs(e){for(let n=vr(e);null!==n;n=xr(n))for(let e=tt;e<n.length;e++){const t=n[e];if(1024&t[2]){const e=t[1];ds(e,t,e.template,t[8])}else t[5]>0&&Fs(t)}const t=e[1].components;if(null!==t)for(let n=0;n<t.length;n++){const r=kt(t[n],e);It(r)&&r[5]>0&&Fs(r)}}function Ds(e,t){const n=kt(t,e),r=n[1];!function(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(r,n),hs(r,n,n[8])}function Os(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function Ms(e){for(;e;){e[2]|=64;const t=yr(e);if(0!=(512&e[2])&&!t)return e;e=t}return null}function Ls(e,t,n){const r=t[10];r.begin&&r.begin();try{ds(e,t,e.template,n)}catch(s){throw Us(t,s),s}finally{r.end&&r.end()}}function Ps(e){!function(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],r=lr(n),s=r[1];ps(s,r,s.template,n)}}(e[8])}function zs(e,t,n){Wt(0),t(e,n)}const Vs=(()=>Promise.resolve(null))();function Bs(e){return e[7]||(e[7]=[])}function Ws(e){return e.cleanup||(e.cleanup=[])}function Us(e,t){const n=e[9],r=n?n.get(pr,null):null;r&&r.handleError(t)}function qs(e,t,n,r,s){for(let i=0;i<n.length;){const a=n[i++],o=n[i++],u=t[a],l=e.data[a];null!==l.setInput?l.setInput(u,s,r,o):u[o]=s}}function js(e,t,n){let r=n?e.styles:null,s=n?e.classes:null,i=0;if(null!==t)for(let a=0;a<t.length;a++){const e=t[a];"number"==typeof e?i=e:1==i?s=ie(s,e):2==i&&(r=ie(r,e+": "+t[++a]+";"))}n?e.styles=r:e.stylesWithoutHost=r,n?e.classes=s:e.classesWithoutHost=s}const Gs=new zn("INJECTOR",-1);class Hs{get(e,t=Xn){if(t===Xn){const t=new Error(`NullInjectorError: No provider for ${se(e)}!`);throw t.name="NullInjectorError",t}return t}}const Ks=new zn("Set Injector scope."),Xs={},Zs={};let Ys;function Qs(){return void 0===Ys&&(Ys=new Hs),Ys}function Js(e,t=null,n=null,r){return new ei(e,n,t||Qs(),r)}class ei{constructor(e,t,n,r=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const s=[];t&&Un(t,n=>this.processProvider(n,e,t)),Un([e],e=>this.processInjectorType(e,[],s)),this.records.set(Gs,ri(void 0,this));const i=this.records.get(Ks);this.scope=null!=i?i.value:null,this.source=r||("object"==typeof e?null:se(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=Xn,n=Ce.Default){this.assertNotDestroyed();const r=er(this);try{if(!(n&Ce.SkipSelf)){let t=this.records.get(e);if(void 0===t){const n=("function"==typeof(s=e)||"object"==typeof s&&s instanceof zn)&&ge(e);t=n&&this.injectableDefInScope(n)?ri(ti(e),Xs):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(n&Ce.Self?Qs():this.parent).get(e,t=n&Ce.Optional&&t===Xn?null:t)}catch(i){if("NullInjectorError"===i.name){if((i.ngTempTokenPath=i.ngTempTokenPath||[]).unshift(se(e)),r)throw i;return function(e,t,n,r){const s=e.ngTempTokenPath;throw t[Yn]&&s.unshift(t[Yn]),e.message=function(e,t,n,r=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let s=se(t);if(Array.isArray(t))s=t.map(se).join(" -> ");else if("object"==typeof t){let e=[];for(let n in t)if(t.hasOwnProperty(n)){let r=t[n];e.push(n+":"+("string"==typeof r?JSON.stringify(r):se(r)))}s=`{${e.join(", ")}}`}return`${n}${r?"("+r+")":""}[${s}]: ${e.replace(Zn,"\n  ")}`}("\n"+e.message,s,n,r),e.ngTokenPath=s,e.ngTempTokenPath=null,e}(i,e,"R3InjectorError",this.source)}throw i}finally{er(r)}var s}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,n)=>e.push(se(n))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,n){if(!(e=ue(e)))return!1;let r=ye(e);const s=null==r&&e.ngModule||void 0,i=void 0===s?e:s,a=-1!==n.indexOf(i);if(void 0!==s&&(r=ye(s)),null==r)return!1;if(null!=r.imports&&!a){let e;n.push(i);try{Un(r.imports,r=>{this.processInjectorType(r,t,n)&&(void 0===e&&(e=[]),e.push(r))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:n,providers:r}=e[t];Un(r,e=>this.processProvider(e,n,r||Me))}}this.injectorDefTypes.add(i);const o=ut(i)||(()=>new i);this.records.set(i,ri(o,Xs));const u=r.providers;if(null!=u&&!a){const t=e;Un(u,e=>this.processProvider(e,t,u))}return void 0!==s&&void 0!==e.providers}processProvider(e,t,n){let r=ii(e=ue(e))?e:ue(e&&e.provide);const s=function(e,t,n){return si(e)?ri(void 0,e.useValue):ri(ni(e),Xs)}(e);if(ii(e)||!0!==e.multi)this.records.get(r);else{let t=this.records.get(r);t||(t=ri(void 0,Xs,!0),t.factory=()=>rr(t.multi),this.records.set(r,t)),r=e,t.multi.push(e)}this.records.set(r,s)}hydrate(e,t){var n;return t.value===Xs&&(t.value=Zs,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(n=t.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){if(!e.providedIn)return!1;const t=ue(e.providedIn);return"string"==typeof t?"any"===t||t===this.scope:this.injectorDefTypes.has(t)}}function ti(e){const t=ge(e),n=null!==t?t.factory:ut(e);if(null!==n)return n;if(e instanceof zn)throw new Error(`Token ${se(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const n=function(e,t){const n=[];for(let r=0;r<e;r++)n.push("?");return n}(t);throw new Error(`Can't resolve all parameters for ${se(e)}: (${n.join(", ")}).`)}const n=function(e){const t=e&&(e[ve]||e[we]);if(t){const n=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Error("unreachable")}function ni(e,t,n){let r;if(ii(e)){const t=ue(e);return ut(t)||ti(t)}if(si(e))r=()=>ue(e.useValue);else if((s=e)&&s.useFactory)r=()=>e.useFactory(...rr(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))r=()=>nr(ue(e.useExisting));else{const t=ue(e&&(e.useClass||e.provide));if(!function(e){return!!e.deps}(e))return ut(t)||ti(t);r=()=>new t(...rr(e.deps))}var s;return r}function ri(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function si(e){return null!==e&&"object"==typeof e&&Qn in e}function ii(e){return"function"==typeof e}const ai=function(e,t,n){return function(e,t=null,n=null,r){const s=Js(e,t,n,r);return s._resolveInjectorDefTypes(),s}({name:n},t,e,n)};let oi=(()=>{class e{static create(e,t){return Array.isArray(e)?ai(e,t,""):ai(e.providers,e.parent,e.name||"")}}return e.THROW_IF_NOT_FOUND=Xn,e.NULL=new Hs,e.\u0275prov=fe({token:e,providedIn:"any",factory:()=>nr(Gs)}),e.__NG_ELEMENT_ID__=-1,e})();function ui(e,t){Jt(lr(e)[1],Rt())}function li(e){let t=Object.getPrototypeOf(e.type.prototype).constructor,n=!0;const r=[e];for(;t;){let s;if(ot(e))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Error("Directives cannot inherit Components");s=t.\u0275dir}if(s){if(n){r.push(s);const t=e;t.inputs=ci(e.inputs),t.declaredInputs=ci(e.declaredInputs),t.outputs=ci(e.outputs);const n=s.hostBindings;n&&pi(e,n);const i=s.viewQuery,a=s.contentQueries;if(i&&hi(e,i),a&&di(e,a),re(e.inputs,s.inputs),re(e.declaredInputs,s.declaredInputs),re(e.outputs,s.outputs),ot(s)&&s.data.animation){const t=e.data;t.animation=(t.animation||[]).concat(s.data.animation)}}const t=s.features;if(t)for(let r=0;r<t.length;r++){const s=t[r];s&&s.ngInherit&&s(e),s===li&&(n=!1)}}t=Object.getPrototypeOf(t)}!function(e){let t=0,n=null;for(let r=e.length-1;r>=0;r--){const s=e[r];s.hostVars=t+=s.hostVars,s.hostAttrs=hn(s.hostAttrs,n=hn(n,s.hostAttrs))}}(r)}function ci(e){return e===Oe?{}:e===Me?[]:e}function hi(e,t){const n=e.viewQuery;e.viewQuery=n?(e,r)=>{t(e,r),n(e,r)}:t}function di(e,t){const n=e.contentQueries;e.contentQueries=n?(e,r,s)=>{t(e,r,s),n(e,r,s)}:t}function pi(e,t){const n=e.hostBindings;e.hostBindings=n?(e,r)=>{t(e,r),n(e,r)}:t}let fi=null;function mi(){if(!fi){const e=De.Symbol;if(e&&e.iterator)fi=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const n=e[t];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(fi=n)}}}return fi}function gi(e){return!!bi(e)&&(Array.isArray(e)||!(e instanceof Map)&&mi()in e)}function bi(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function yi(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}function vi(e,t=Ce.Default){const n=Tt();return null===n?nr(e,t):Sn(Rt(),n,ue(e),t)}function xi(e,t,n){const r=Tt();return yi(r,Pt(),t)&&function(e,t,n,r,s,i,a,o){const u=xt(t,n);let l,c=t.inputs;var h;null!=c&&(l=c[r])?(qs(e,n,l,r,s),it(t)&&function(e,t){const n=kt(t,e);16&n[2]||(n[2]|=64)}(n,t.index)):3&t.type&&(r="class"===(h=r)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,s=null!=a?a(s,t.value||"",r):s,gt(i)?i.setProperty(u,r,s):cn(r)||(u.setProperty?u.setProperty(r,s):u[r]=s))}(At(),function(){const e=Et.lFrame;return wt(e.tView,e.selectedIndex)}(),r,e,t,r[11],n),xi}function wi(e,t,n,r,s){const i=s?"class":"style";qs(e,n,t.inputs[i],i,r)}function ki(e,t,n,r){const s=Tt(),i=At(),a=et+e,o=s[11],u=s[a]=Cr(o,t,Et.lFrame.currentNamespace),l=i.firstCreatePass?function(e,t,n,r,s,i,a){const o=t.consts,u=ls(t,e,2,s,_t(o,i));return ws(t,n,u,_t(o,a)),null!==u.attrs&&js(u,u.attrs,!1),null!==u.mergedAttrs&&js(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(a,i,s,0,t,n,r):i.data[a];Dt(l,!0);const c=l.mergedAttrs;null!==c&&un(o,u,c);const h=l.classes;null!==h&&Vr(o,u,h);const d=l.styles;null!==d&&zr(o,u,d),64!=(64&l.flags)&&Rr(i,s,u,l),0===Et.lFrame.elementDepthCount&&ur(u,s),Et.lFrame.elementDepthCount++,at(l)&&(ms(i,s,l),function(e,t,n){if(st(t)){const r=t.directiveEnd;for(let s=t.directiveStart;s<r;s++){const t=e.data[s];t.contentQueries&&t.contentQueries(1,n[s],s)}}}(i,l,s)),null!==r&&gs(s,l)}function Ci(){let e=Rt();Ot()?Et.lFrame.isParent=!1:(e=e.parent,Dt(e,!1));const t=e;Et.lFrame.elementDepthCount--;const n=At();n.firstCreatePass&&(Jt(n,e),st(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&wi(n,t,Tt(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&wi(n,t,Tt(),t.stylesWithoutHost,!1)}function Ii(e,t,n,r){ki(e,t,n,r),Ci()}function _i(e){return!!e&&"function"==typeof e.then}const Si=function(e){return!!e&&"function"==typeof e.subscribe};function Ni(e,t,n,r){const s=Tt(),i=At(),a=Rt();return function(e,t,n,r,s,i,a,o){const u=at(r),l=e.firstCreatePass&&Ws(e),c=Bs(t);let h=!0;if(3&r.type||o){const d=xt(r,t),p=o?o(d):d,f=c.length,m=o?e=>o(yt(e[r.index])):r.index;if(gt(n)){let a=null;if(!o&&u&&(a=function(e,t,n,r){const s=e.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const e=s[i];if(e===n&&s[i+1]===r){const e=t[7],n=s[i+2];return e.length>n?e[n]:null}"string"==typeof e&&(i+=2)}return null}(e,t,s,r.index)),null!==a)(a.__ngLastListenerFn__||a).__ngNextListenerFn__=i,a.__ngLastListenerFn__=i,h=!1;else{i=$i(r,t,0,i,!1);const e=n.listen(p,s,i);c.push(i,e),l&&l.push(s,m,f,f+1)}}else i=$i(r,t,0,i,!0),p.addEventListener(s,i,a),c.push(i),l&&l.push(s,m,f,a)}else i=$i(r,t,0,i,!1);const d=r.outputs;let p;if(h&&null!==d&&(p=d[s])){const e=p.length;if(e)for(let n=0;n<e;n+=2){const e=t[p[n]][p[n+1]].subscribe(i),a=c.length;c.push(i,e),l&&l.push(s,r.index,a,-(a+1))}}}(i,s,s[11],a,e,t,!!n,r),Ni}function Ei(e,t,n,r){try{return!1!==n(r)}catch(s){return Us(e,s),!1}}function $i(e,t,n,r,s){return function n(i){if(i===Function)return r;const a=2&e.flags?kt(e.index,t):t;0==(32&t[2])&&Ms(a);let o=Ei(t,0,r,i),u=n.__ngNextListenerFn__;for(;u;)o=Ei(t,0,u,i)&&o,u=u.__ngNextListenerFn__;return s&&!1===o&&(i.preventDefault(),i.returnValue=!1),o}}function Ti(e,t,n,r,s){const i=e[n+1],a=null===t;let o=r?ns(i):ss(i),u=!1;for(;0!==o&&(!1===u||a);){const n=e[o+1];Ai(e[o],t)&&(u=!0,e[o+1]=r?as(n):rs(n)),o=r?ns(n):ss(n)}u&&(e[n+1]=r?rs(i):as(i))}function Ai(e,t){return null===e||null==t||(Array.isArray(e)?e[1]:e)===t||!(!Array.isArray(e)||"string"!=typeof t)&&Kn(e,t)>=0}function Ri(e,t){return function(e,t,n,r){const s=Tt(),i=At(),a=function(e){const t=Et.lFrame,n=t.bindingIndex;return t.bindingIndex=t.bindingIndex+2,n}();i.firstUpdatePass&&function(e,t,n,r){const s=e.data;if(null===s[n+1]){const i=s[Yt()],a=function(e,t){return t>=e.expandoStartIndex}(e,n);(function(e,t){return 0!=(16&e.flags)})(i)&&null===t&&!a&&(t=!1),t=function(e,t,n,r){const s=function(e){const t=Et.lFrame.currentDirectiveIndex;return-1===t?null:e[t]}(e);let i=t.residualClasses;if(null===s)0===t.classBindings&&(n=Di(n=Fi(null,e,t,n,r),t.attrs,r),i=null);else{const a=t.directiveStylingLast;if(-1===a||e[a]!==s)if(n=Fi(s,e,t,n,r),null===i){let n=function(e,t,n){const r=t.classBindings;if(0!==ss(r))return e[ns(r)]}(e,t);void 0!==n&&Array.isArray(n)&&(n=Fi(null,e,t,n[1],r),n=Di(n,t.attrs,r),function(e,t,n,r){e[ns(t.classBindings)]=r}(e,t,0,n))}else i=function(e,t,n){let r;const s=t.directiveEnd;for(let i=1+t.directiveStylingLast;i<s;i++)r=Di(r,e[i].hostAttrs,true);return Di(r,t.attrs,true)}(e,t)}return void 0!==i&&(t.residualClasses=i),n}(s,i,t,r),function(e,t,n,r,s,i){let a=t.classBindings,o=ns(a),u=ss(a);e[r]=n;let l,c=!1;if(Array.isArray(n)){const e=n;l=e[1],(null===l||Kn(e,l)>0)&&(c=!0)}else l=n;if(s)if(0!==u){const t=ns(e[o+1]);e[r+1]=ts(t,o),0!==t&&(e[t+1]=is(e[t+1],r)),e[o+1]=131071&e[o+1]|r<<17}else e[r+1]=ts(o,0),0!==o&&(e[o+1]=is(e[o+1],r)),o=r;else e[r+1]=ts(u,0),0===o?o=r:e[u+1]=is(e[u+1],r),u=r;c&&(e[r+1]=rs(e[r+1])),Ti(e,l,r,!0),Ti(e,l,r,!1),function(e,t,n,r,s){const i=e.residualClasses;null!=i&&"string"==typeof t&&Kn(i,t)>=0&&(n[r+1]=as(n[r+1]))}(t,l,e,r),a=ts(o,u),t.classBindings=a}(s,i,t,n,a)}}(i,e,a,true),t!==Qr&&yi(s,a,t)&&function(e,t,n,r,s,i,a,o){if(!(3&t.type))return;const u=e.data,l=u[o+1];Mi(1==(1&l)?Oi(u,t,n,s,ss(l),a):void 0)||(Mi(i)||function(e){return 2==(2&e)}(l)&&(i=Oi(u,null,n,s,o,a)),function(e,t,n,r,s){const i=gt(e);s?i?e.addClass(n,r):n.classList.add(r):i?e.removeClass(n,r):n.classList.remove(r)}(r,0,vt(Yt(),n),s,i))}(i,i.data[Yt()],s,s[11],e,s[a+1]=function(e,t){return null==e||"object"==typeof e&&(e=se(function(e){return e instanceof class{constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}?e.changingThisBreaksApplicationSecurity:e}(e))),e}(t),true,a)}(e,t),Ri}function Fi(e,t,n,r,s){let i=null;const a=n.directiveEnd;let o=n.directiveStylingLast;for(-1===o?o=n.directiveStart:o++;o<a&&(i=t[o],r=Di(r,i.hostAttrs,s),i!==e);)o++;return null!==e&&(n.directiveStylingLast=o),r}function Di(e,t,n){const r=n?1:2;let s=-1;if(null!==t)for(let i=0;i<t.length;i++){const a=t[i];"number"==typeof a?s=a:s===r&&(Array.isArray(e)||(e=void 0===e?[]:["",e]),Gn(e,a,!!n||t[++i]))}return void 0===e?null:e}function Oi(e,t,n,r,s,i){const a=null===t;let o;for(;s>0;){const t=e[s],i=Array.isArray(t),u=i?t[1]:t,l=null===u;let c=n[s+1];c===Qr&&(c=l?Me:void 0);let h=l?Hn(c,r):u===r?c:void 0;if(i&&!Mi(h)&&(h=Hn(t,r)),Mi(h)&&(o=h,a))return o;const d=e[s+1];s=a?ns(d):ss(d)}if(null!==t){let e=i?t.residualClasses:t.residualStyles;null!=e&&(o=Hn(e,r))}return o}function Mi(e){return void 0!==e}function Li(e,t=""){const n=Tt(),r=At(),s=e+et,i=r.firstCreatePass?ls(r,s,1,t,null):r.data[s],a=n[s]=function(e,t){return gt(e)?e.createText(t):e.createTextNode(t)}(n[11],t);Rr(r,n,a,i),Dt(i,!1)}function Pi(e){return zi("",e,""),Pi}function zi(e,t,n){const r=Tt(),s=function(e,t,n,r){return yi(e,Pt(),n)?t+he(n)+r:Qr}(r,e,t,n);return s!==Qr&&function(e,t,n){const r=vt(t,e);!function(e,t,n){gt(e)?e.setValue(t,n):t.textContent=n}(e[11],r,n)}(r,Yt(),s),zi}const Vi=void 0;var Bi=["en",[["a","p"],["AM","PM"],Vi],[["AM","PM"],Vi,Vi],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Vi,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Vi,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Vi,"{1} 'at' {0}",Vi],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===n?1:5}];let Wi={};function Ui(e){return e in Wi||(Wi[e]=De.ng&&De.ng.common&&De.ng.common.locales&&De.ng.common.locales[e]),Wi[e]}var qi=function(e){return e[e.LocaleId=0]="LocaleId",e[e.DayPeriodsFormat=1]="DayPeriodsFormat",e[e.DayPeriodsStandalone=2]="DayPeriodsStandalone",e[e.DaysFormat=3]="DaysFormat",e[e.DaysStandalone=4]="DaysStandalone",e[e.MonthsFormat=5]="MonthsFormat",e[e.MonthsStandalone=6]="MonthsStandalone",e[e.Eras=7]="Eras",e[e.FirstDayOfWeek=8]="FirstDayOfWeek",e[e.WeekendRange=9]="WeekendRange",e[e.DateFormat=10]="DateFormat",e[e.TimeFormat=11]="TimeFormat",e[e.DateTimeFormat=12]="DateTimeFormat",e[e.NumberSymbols=13]="NumberSymbols",e[e.NumberFormats=14]="NumberFormats",e[e.CurrencyCode=15]="CurrencyCode",e[e.CurrencySymbol=16]="CurrencySymbol",e[e.CurrencyName=17]="CurrencyName",e[e.Currencies=18]="Currencies",e[e.Directionality=19]="Directionality",e[e.PluralCase=20]="PluralCase",e[e.ExtraData=21]="ExtraData",e}({});const ji="en-US";let Gi=ji;function Hi(e){var t,n;n="Expected localeId to be defined",null==(t=e)&&function(e,t,n,r){throw new Error(`ASSERTION ERROR: ${e} [Expected=> null != ${t} <=Actual]`)}(n,t),"string"==typeof e&&(Gi=e.toLowerCase().replace(/_/g,"-"))}function Ki(e,t,n,r,s){if(e=ue(e),Array.isArray(e))for(let i=0;i<e.length;i++)Ki(e[i],t,n,r,s);else{const i=At(),a=Tt();let o=ii(e)?e:ue(e.provide),u=ni(e);const l=Rt(),c=1048575&l.providerIndexes,h=l.directiveStart,d=l.providerIndexes>>20;if(ii(e)||!e.multi){const r=new on(u,s,vi),p=Yi(o,t,s?c:c+d,h);-1===p?(Cn(vn(l,a),i,o),Xi(i,e,t.length),t.push(o),l.directiveStart++,l.directiveEnd++,s&&(l.providerIndexes+=1048576),n.push(r),a.push(r)):(n[p]=r,a[p]=r)}else{const p=Yi(o,t,c+d,h),f=Yi(o,t,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(s&&!g||!s&&!m){Cn(vn(l,a),i,o);const c=function(e,t,n,r,s){const i=new on(e,n,vi);return i.multi=[],i.index=t,i.componentProviders=0,Zi(i,s,r&&!n),i}(s?Ji:Qi,n.length,s,r,u);!s&&g&&(n[f].providerFactory=c),Xi(i,e,t.length,0),t.push(o),l.directiveStart++,l.directiveEnd++,s&&(l.providerIndexes+=1048576),n.push(c),a.push(c)}else Xi(i,e,p>-1?p:f,Zi(n[s?f:p],u,!s&&r));!s&&r&&g&&n[f].componentProviders++}}}function Xi(e,t,n,r){const s=ii(t);if(s||t.useClass){const i=(t.useClass||t).prototype.ngOnDestroy;if(i){const a=e.destroyHooks||(e.destroyHooks=[]);if(!s&&t.multi){const e=a.indexOf(n);-1===e?a.push(n,[r,i]):a[e+1].push(r,i)}else a.push(n,i)}}}function Zi(e,t,n){return n&&e.componentProviders++,e.multi.push(t)-1}function Yi(e,t,n,r){for(let s=n;s<r;s++)if(t[s]===e)return s;return-1}function Qi(e,t,n,r){return ea(this.multi,[])}function Ji(e,t,n,r){const s=this.multi;let i;if(this.providerFactory){const e=this.providerFactory.componentProviders,t=An(n,n[1],this.providerFactory.index,r);i=t.slice(0,e),ea(s,i);for(let n=e;n<t.length;n++)i.push(t[n])}else i=[],ea(s,i);return i}function ea(e,t){for(let n=0;n<e.length;n++)t.push((0,e[n])());return t}function ta(e,t=[]){return n=>{n.providersResolver=(n,r)=>function(e,t,n){const r=At();if(r.firstCreatePass){const s=ot(e);Ki(n,r.data,r.blueprint,s,!0),Ki(t,r.data,r.blueprint,s,!1)}}(n,r?r(e):e,t)}}class na{}class ra{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${se(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}let sa=(()=>{class e{}return e.NULL=new ra,e})();function ia(...e){}function aa(e,t){return new ua(xt(e,t))}const oa=function(){return aa(Rt(),Tt())};let ua=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=oa,e})();function la(e){return e instanceof ua?e.nativeElement:e}class ca{}let ha=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>da(),e})();const da=function(){const e=Tt(),t=kt(Rt().index,e);return function(e){return e[11]}(nt(t)?t:e)};let pa=(()=>{class e{}return e.\u0275prov=fe({token:e,providedIn:"root",factory:()=>null}),e})();class fa{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const ma=new fa("12.0.5");class ga{constructor(){}supports(e){return gi(e)}create(e){return new ya(e)}}const ba=(e,t)=>t;class ya{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||ba}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,n=this._removalsHead,r=0,s=null;for(;t||n;){const i=!n||t&&t.currentIndex<ka(n,r,s)?t:n,a=ka(i,r,s),o=i.currentIndex;if(i===n)r--,n=n._nextRemoved;else if(t=t._next,null==i.previousIndex)r++;else{s||(s=[]);const e=a-r,t=o-r;if(e!=t){for(let n=0;n<e;n++){const r=n<s.length?s[n]:s[n]=0,i=r+n;t<=i&&i<e&&(s[n]=r+1)}s[i.previousIndex]=t-e}}a!==o&&e(i,a,o)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!gi(e))throw new Error(`Error trying to diff '${se(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,n,r,s=this._itHead,i=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)n=e[t],r=this._trackByFn(t,n),null!==s&&Object.is(s.trackById,r)?(i&&(s=this._verifyReinsertion(s,n,r,t)),Object.is(s.item,n)||this._addIdentityChange(s,n)):(s=this._mismatch(s,n,r,t),i=!0),s=s._next}else t=0,function(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{const n=e[mi()]();let r;for(;!(r=n.next()).done;)t(r.value)}}(e,e=>{r=this._trackByFn(t,e),null!==s&&Object.is(s.trackById,r)?(i&&(s=this._verifyReinsertion(s,e,r,t)),Object.is(s.item,e)||this._addIdentityChange(s,e)):(s=this._mismatch(s,e,r,t),i=!0),s=s._next,t++}),this.length=t;return this._truncate(s),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,n,r){let s;return null===e?s=this._itTail:(s=e._prev,this._remove(e)),null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,s,r)):null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,s,r)):e=this._addAfter(new va(t,n),s,r),e}_verifyReinsertion(e,t,n,r){let s=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==s?e=this._reinsertAfter(s,e._prev,r):e.currentIndex!=r&&(e.currentIndex=r,this._addToMoves(e,r)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const r=e._prevRemoved,s=e._nextRemoved;return null===r?this._removalsHead=s:r._nextRemoved=s,null===s?this._removalsTail=r:s._prevRemoved=r,this._insertAfter(e,t,n),this._addToMoves(e,n),e}_moveAfter(e,t,n){return this._unlink(e),this._insertAfter(e,t,n),this._addToMoves(e,n),e}_addAfter(e,t,n){return this._insertAfter(e,t,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,n){const r=null===t?this._itHead:t._next;return e._next=r,e._prev=t,null===r?this._itTail=e:r._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new wa),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,n=e._next;return null===t?this._itHead=n:t._next=n,null===n?this._itTail=t:n._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new wa),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class va{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class xa{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===t||t<=n.currentIndex)&&Object.is(n.trackById,e))return n;return null}remove(e){const t=e._prevDup,n=e._nextDup;return null===t?this._head=n:t._nextDup=n,null===n?this._tail=t:n._prevDup=t,null===this._head}}class wa{constructor(){this.map=new Map}put(e){const t=e.trackById;let n=this.map.get(t);n||(n=new xa,this.map.set(t,n)),n.add(e)}get(e,t){const n=this.map.get(e);return n?n.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function ka(e,t,n){const r=e.previousIndex;if(null===r)return r;let s=0;return n&&r<n.length&&(s=n[r]),r+t+s}class Ca{constructor(){}supports(e){return e instanceof Map||bi(e)}create(){return new Ia}}class Ia{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||bi(e)))throw new Error(`Error trying to diff '${se(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,n)=>{if(t&&t.key===n)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const r=this._getOrCreateRecordForKey(n,e);t=this._insertBeforeOrAppend(t,r)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const n=e._prev;return t._next=e,t._prev=n,e._prev=t,n&&(n._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const n=this._records.get(e);this._maybeAddToChanges(n,t);const r=n._prev,s=n._next;return r&&(r._next=s),s&&(s._prev=r),n._next=null,n._prev=null,n}const n=new _a(e);return this._records.set(e,n),n.currentValue=t,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){Object.is(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(n=>t(e[n],n))}}class _a{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Sa(){return new Na([new ga])}let Na=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(null!=n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Sa()),deps:[[e,new or,new ar]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);var n}}return e.\u0275prov=fe({token:e,providedIn:"root",factory:Sa}),e})();function Ea(){return new $a([new Ca])}let $a=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Ea()),deps:[[e,new or,new ar]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=fe({token:e,providedIn:"root",factory:Ea}),e})();function Ta(e,t,n,r,s=!1){for(;null!==n;){const i=t[n.index];if(null!==i&&r.push(yt(i)),rt(i))for(let e=tt;e<i.length;e++){const t=i[e],n=t[1].firstChild;null!==n&&Ta(t[1],t,n,r)}const a=n.type;if(8&a)Ta(e,t,n.child,r);else if(32&a){const e=br(n,t);let s;for(;s=e();)r.push(s)}else if(16&a){const e=Dr(t,n);if(Array.isArray(e))r.push(...e);else{const n=yr(t[16]);Ta(n[1],n,e,r,!0)}}n=s?n.projectionNext:n.next}return r}class Aa{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const e=this._lView,t=e[1];return Ta(t,e,t.firstChild,[])}get context(){return this._lView[8]}set context(e){this._lView[8]=e}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const e=this._lView[3];if(rt(e)){const t=e[8],n=t?t.indexOf(this):-1;n>-1&&(_r(e,n),jn(t,n))}this._attachedToViewContainer=!1}Sr(this._lView[1],this._lView)}onDestroy(e){vs(this._lView[1],this._lView,null,e)}markForCheck(){Ms(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Ls(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,n){Lt(!0);try{Ls(e,t,n)}finally{Lt(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var e;this._appRef=null,Lr(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class Ra extends Aa{constructor(e){super(e),this._view=e}detectChanges(){Ps(this._view)}checkNoChanges(){!function(e){Lt(!0);try{Ps(e)}finally{Lt(!1)}}(this._view)}get context(){return null}}const Fa=function(e){return function(e,t,n){if(it(e)&&!n){const n=kt(e.index,t);return new Aa(n,n)}return 47&e.type?new Aa(t[16],t):null}(Rt(),Tt(),16==(16&e))};let Da=(()=>{class e{}return e.__NG_ELEMENT_ID__=Fa,e})();const Oa=[new Ca],Ma=new Na([new ga]),La=new $a(Oa),Pa=function(){return Wa(Rt(),Tt())};let za=(()=>{class e{}return e.__NG_ELEMENT_ID__=Pa,e})();const Va=za,Ba=class extends Va{constructor(e,t,n){super(),this._declarationLView=e,this._declarationTContainer=t,this.elementRef=n}createEmbeddedView(e){const t=this._declarationTContainer.tViews,n=us(this._declarationLView,t,e,16,null,t.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const r=this._declarationLView[19];return null!==r&&(n[19]=r.createEmbeddedView(t)),hs(t,n,e),new Aa(n)}};function Wa(e,t){return 4&e.type?new Ba(t,e,aa(e,t)):null}class Ua{}class qa{}const ja=function(){return Ya(Rt(),Tt())};let Ga=(()=>{class e{}return e.__NG_ELEMENT_ID__=ja,e})();const Ha=Ga,Ka=class extends Ha{constructor(e,t,n){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=n}get element(){return aa(this._hostTNode,this._hostLView)}get injector(){return new Dn(this._hostTNode,this._hostLView)}get parentInjector(){const e=kn(this._hostTNode,this._hostLView);if(pn(e)){const t=mn(e,this._hostLView),n=fn(e);return new Dn(t[1].data[n+8],t)}return new Dn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){const t=Xa(this._lContainer);return null!==t&&t[e]||null}get length(){return this._lContainer.length-tt}createEmbeddedView(e,t,n){const r=e.createEmbeddedView(t||{});return this.insert(r,n),r}createComponent(e,t,n,r,s){const i=n||this.parentInjector;if(!s&&null==e.ngModule&&i){const e=i.get(Ua,null);e&&(s=e)}const a=e.create(i,r,void 0,s);return this.insert(a.hostView,t),a}insert(e,t){const n=e._lView,r=n[1];if(rt(n[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=n[3],r=new Ka(t,t[6],t[3]);r.detach(r.indexOf(e))}}const s=this._adjustIndex(t),i=this._lContainer;!function(e,t,n,r){const s=tt+r,i=n.length;r>0&&(n[s-1][4]=t),r<i-tt?(t[4]=n[s],qn(n,tt+r,t)):(n.push(t),t[4]=null),t[3]=n;const a=t[17];null!==a&&n!==a&&function(e,t){const n=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===n?e[9]=[t]:n.push(t)}(a,t);const o=t[19];null!==o&&o.insertView(e),t[2]|=128}(r,n,i,s);const a=Or(s,i),o=n[11],u=Ar(o,i[7]);return null!==u&&function(e,t,n,r,s,i){r[0]=s,r[6]=t,Lr(e,r,n,1,s,i)}(r,i[6],o,n,u,a),e.attachToViewContainerRef(),qn(Za(i),s,e),e}move(e,t){return this.insert(e,t)}indexOf(e){const t=Xa(this._lContainer);return null!==t?t.indexOf(e):-1}remove(e){const t=this._adjustIndex(e,-1),n=_r(this._lContainer,t);n&&(jn(Za(this._lContainer),t),Sr(n[1],n))}detach(e){const t=this._adjustIndex(e,-1),n=_r(this._lContainer,t);return n&&null!=jn(Za(this._lContainer),t)?new Aa(n):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}};function Xa(e){return e[8]}function Za(e){return e[8]||(e[8]=[])}function Ya(e,t){let n;const r=t[e.index];if(rt(r))n=r;else{let s;if(8&e.type)s=yt(r);else{const n=t[11];s=n.createComment("");const r=xt(e,t);Er(n,Ar(n,r),s,function(e,t){return gt(e)?e.nextSibling(t):t.nextSibling}(n,r),!1)}t[e.index]=n=As(r,t,s,e),Os(t,n)}return new Ka(n,e,t)}const Qa={};class Ja extends sa{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=Qe(e);return new no(t,this.ngModule)}}function eo(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}const to=new zn("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>fr});class no extends na{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(Yr).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return eo(this.componentDef.inputs)}get outputs(){return eo(this.componentDef.outputs)}create(e,t,n,r){const s=(r=r||this.ngModule)?function(e,t){return{get:(n,r,s)=>{const i=e.get(n,Qa,s);return i!==Qa||r===Qa?i:t.get(n,r,s)}}}(e,r.injector):e,i=s.get(ca,bt),a=s.get(pa,null),o=i.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",l=n?function(e,t,n){if(gt(e))return e.selectRootElement(t,n===$e.ShadowDom);let r="string"==typeof t?e.querySelector(t):t;return r.textContent="",r}(o,n,this.componentDef.encapsulation):Cr(i.createRenderer(null,this.componentDef),u,function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(u)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:fr,clean:Vs,playerHandler:null,flags:0},d=ys(0,null,null,1,0,null,null,null,null,null),p=us(null,d,h,c,null,null,i,o,a,s);let f,m;jt(p);try{const e=function(e,t,n,r,s,i){const a=n[1];n[20]=e;const o=ls(a,20,2,"#host",null),u=o.mergedAttrs=t.hostAttrs;null!==u&&(js(o,u,!0),null!==e&&(un(s,e,u),null!==o.classes&&Vr(s,e,o.classes),null!==o.styles&&zr(s,e,o.styles)));const l=r.createRenderer(e,t),c=us(n,bs(t),null,t.onPush?64:16,n[20],o,r,l,null,null);return a.firstCreatePass&&(Cn(vn(o,n),a,t.type),Is(a,o),Ss(o,n.length,1)),Os(n,c),n[20]=c}(l,this.componentDef,p,i,o);if(l)if(n)un(o,l,["ng-version",ma.full]);else{const{attrs:e,classes:t}=function(e){const t=[],n=[];let r=1,s=2;for(;r<e.length;){let i=e[r];if("string"==typeof i)2===s?""!==i&&t.push(i,e[++r]):8===s&&n.push(i);else{if(!Hr(s))break;s=i}r++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);e&&un(o,l,e),t&&t.length>0&&Vr(o,l,t.join(" "))}if(m=wt(d,et),void 0!==t){const e=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const r=t[n];e.push(null!=r?Array.from(r):null)}}f=function(e,t,n,r,s){const i=n[1],a=function(e,t,n){const r=Rt();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Ns(e,r,t,cs(e,t,1,null),n));const s=An(t,e,r.directiveStart,r);ur(s,t);const i=xt(r,t);return i&&ur(i,t),s}(i,n,t);if(r.components.push(a),e[8]=a,s&&s.forEach(e=>e(a,t)),t.contentQueries){const e=Rt();t.contentQueries(1,a,e.directiveStart)}const o=Rt();return!i.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(Qt(o.index),ks(n[1],o,0,o.directiveStart,o.directiveEnd,t),Cs(t,a)),a}(e,this.componentDef,p,h,[ui]),hs(d,p,null)}finally{Zt()}return new ro(this.componentType,f,aa(m,p),p,m)}}class ro extends class{}{constructor(e,t,n,r,s){super(),this.location=n,this._rootLView=r,this._tNode=s,this.instance=t,this.hostView=this.changeDetectorRef=new Ra(r),this.componentType=e}get injector(){return new Dn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}}const so=new Map;class io extends Ua{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Ja(this);const n=Je(e),r=e[Be]||null;r&&Hi(r),this._bootstrapComponents=mr(n.bootstrap),this._r3Injector=Js(e,t,[{provide:Ua,useValue:this},{provide:sa,useValue:this.componentFactoryResolver}],se(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=oi.THROW_IF_NOT_FOUND,n=Ce.Default){return e===oi||e===Ua||e===Gs?this:this._r3Injector.get(e,t,n)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class ao extends qa{constructor(e){super(),this.moduleType=e,null!==Je(e)&&function(e){const t=new Set;!function e(n){const r=Je(n,!0),s=r.id;null!==s&&(function(e,t,n){if(t&&t!==n)throw new Error(`Duplicate module registered for ${e} - ${se(t)} vs ${se(t.name)}`)}(s,so.get(s),n),so.set(s,n));const i=mr(r.imports);for(const a of i)t.has(a)||(t.add(a),e(a))}(e)}(e)}create(e){return new io(this.moduleType,e)}}function oo(e,t,n,r,s){return function(e,t,n,r,s,i,a){const o=t+n;return function(e,t,n,r){const s=yi(e,t,n);return yi(e,t+1,r)||s}(e,o,s,i)?function(e,t,n){return e[t]=n}(e,o+2,a?r.call(a,s,i):r(s,i)):function(e,t){const n=e[t];return n===Qr?void 0:n}(e,o+2)}(Tt(),function(){const e=Et.lFrame;let t=e.bindingRootIndex;return-1===t&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}(),e,t,n,r,s)}function uo(e){return t=>{setTimeout(e,void 0,t)}}const lo=class extends N{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,n){var r,s,i;let a=e,o=t||(()=>null),u=n;if(e&&"object"==typeof e){const t=e;a=null===(r=t.next)||void 0===r?void 0:r.bind(t),o=null===(s=t.error)||void 0===s?void 0:s.bind(t),u=null===(i=t.complete)||void 0===i?void 0:i.bind(t)}this.__isAsync&&(o=uo(o),a&&(a=uo(a)),u&&(u=uo(u)));const l=super.subscribe({next:a,error:o,complete:u});return e instanceof m&&e.add(l),l}};function co(){return this._results[mi()]()}class ho{constructor(e=!1){this._emitDistinctChangesOnly=e,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const t=mi(),n=ho.prototype;n[t]||(n[t]=co)}get changes(){return this._changes||(this._changes=new lo)}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){const n=this;n.dirty=!1;const r=Wn(e);(this._changesDetected=!function(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){let s=e[r],i=t[r];if(n&&(s=n(s),i=n(i)),i!==s)return!1}return!0}(n._results,r,t))&&(n._results=r,n.length=r.length,n.last=r[this.length-1],n.first=r[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class po{constructor(e){this.queryList=e,this.matches=null}clone(){return new po(this.queryList)}setDirty(){this.queryList.setDirty()}}class fo{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const n=null!==e.contentQueries?e.contentQueries[0]:t.length,r=[];for(let e=0;e<n;e++){const n=t.getByIndex(e);r.push(this.queries[n.indexInDeclarationView].clone())}return new fo(r)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==Co(e,t).matches&&this.queries[t].setDirty()}}class mo{constructor(e,t,n=null){this.predicate=e,this.flags=t,this.read=n}}class go{constructor(e=[]){this.queries=e}elementStart(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let n=0;n<this.length;n++){const r=null!==t?t.length:0,s=this.getByIndex(n).embeddedTView(e,r);s&&(s.indexInDeclarationView=n,null!==t?t.push(s):t=[s])}return null!==t?new go(t):null}template(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class bo{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new bo(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const t=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&8&n.type&&n.index!==t;)n=n.parent;return t===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,t){const n=this.metadata.predicate;if(Array.isArray(n))for(let r=0;r<n.length;r++){const s=n[r];this.matchTNodeWithReadOption(e,t,yo(t,s)),this.matchTNodeWithReadOption(e,t,Tn(t,e,s,!1,!1))}else n===za?4&t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Tn(t,e,n,!1,!1))}matchTNodeWithReadOption(e,t,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===ua||r===Ga||r===za&&4&t.type)this.addMatch(t.index,-2);else{const n=Tn(t,e,r,!1,!1);null!==n&&this.addMatch(t.index,n)}else this.addMatch(t.index,n)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function yo(e,t){const n=e.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===t)return n[r+1];return null}function vo(e,t,n,r){return-1===n?function(e,t){return 11&e.type?aa(e,t):4&e.type?Wa(e,t):null}(t,e):-2===n?function(e,t,n){return n===ua?aa(t,e):n===za?Wa(t,e):n===Ga?Ya(t,e):void 0}(e,t,r):An(e,e[1],n,t)}function xo(e,t,n,r){const s=t[19].queries[r];if(null===s.matches){const r=e.data,i=n.matches,a=[];for(let e=0;e<i.length;e+=2){const s=i[e];a.push(s<0?null:vo(t,r[s],i[e+1],n.metadata.read))}s.matches=a}return s.matches}function wo(e,t,n,r){const s=e.queries.getByIndex(n),i=s.matches;if(null!==i){const a=xo(e,t,s,n);for(let e=0;e<i.length;e+=2){const n=i[e];if(n>0)r.push(a[e/2]);else{const s=i[e+1],a=t[-n];for(let e=tt;e<a.length;e++){const t=a[e];t[17]===t[3]&&wo(t[1],t,s,r)}if(null!==a[9]){const e=a[9];for(let t=0;t<e.length;t++){const n=e[t];wo(n[1],n,s,r)}}}}}return r}function ko(e){const t=Tt(),n=At(),r=Bt();Wt(r+1);const s=Co(n,r);if(e.dirty&&Ct(t)===(2==(2&s.metadata.flags))){if(null===s.matches)e.reset([]);else{const i=s.crossesNgTemplate?wo(n,t,r,[]):xo(n,t,s,r);e.reset(i,la),e.notifyOnChanges()}return!0}return!1}function Co(e,t){return e.queries.getByIndex(t)}const Io=new zn("Application Initializer");let _o=(()=>{class e{constructor(e){this.appInits=e,this.resolve=ia,this.reject=ia,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const t=this.appInits[n]();if(_i(t))e.push(t);else if(Si(t)){const n=new Promise((e,n)=>{t.subscribe({complete:e,error:n})});e.push(n)}}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(nr(Io,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const So=new zn("AppId"),No={provide:So,useFactory:function(){return`${Eo()}${Eo()}${Eo()}`},deps:[]};function Eo(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const $o=new zn("Platform Initializer"),To=new zn("Platform ID"),Ao=new zn("appBootstrapListener");let Ro=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const Fo=new zn("LocaleId"),Do=new zn("DefaultCurrencyCode");class Oo{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const Mo=function(e){return new ao(e)},Lo=Mo,Po=function(e){return Promise.resolve(Mo(e))},zo=function(e){const t=Mo(e),n=mr(Je(e).declarations).reduce((e,t)=>{const n=Qe(t);return n&&e.push(new no(n)),e},[]);return new Oo(t,n)},Vo=zo,Bo=function(e){return Promise.resolve(zo(e))};let Wo=(()=>{class e{constructor(){this.compileModuleSync=Lo,this.compileModuleAsync=Po,this.compileModuleAndAllComponentsSync=Vo,this.compileModuleAndAllComponentsAsync=Bo}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const Uo=(()=>Promise.resolve(0))();function qo(e){"undefined"==typeof Zone?Uo.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class jo{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new lo(!1),this.onMicrotaskEmpty=new lo(!1),this.onStable=new lo(!1),this.onError=new lo(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!n&&t,r.shouldCoalesceRunChangeDetection=n,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function(){let e=De.requestAnimationFrame,t=De.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=()=>{!function(e){e.isCheckStableRunning||-1!==e.lastRequestAnimationFrameId||(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(De,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,Ko(e),e.isCheckStableRunning=!0,Ho(e),e.isCheckStableRunning=!1},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),Ko(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,r,s,i,a,o)=>{try{return Xo(e),n.invokeTask(s,i,a,o)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||e.shouldCoalesceRunChangeDetection)&&t(),Zo(e)}},onInvoke:(n,r,s,i,a,o,u)=>{try{return Xo(e),n.invoke(s,i,a,o,u)}finally{e.shouldCoalesceRunChangeDetection&&t(),Zo(e)}},onHasTask:(t,n,r,s)=>{t.hasTask(r,s),n===r&&("microTask"==s.change?(e._hasPendingMicrotasks=s.microTask,Ko(e),Ho(e)):"macroTask"==s.change&&(e.hasPendingMacrotasks=s.macroTask))},onHandleError:(t,n,r,s)=>(t.handleError(r,s),e.runOutsideAngular(()=>e.onError.emit(s)),!1)})}(r)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!jo.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(jo.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,n){return this._inner.run(e,t,n)}runTask(e,t,n,r){const s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+r,e,Go,ia,ia);try{return s.runTask(i,t,n)}finally{s.cancelTask(i)}}runGuarded(e,t,n){return this._inner.runGuarded(e,t,n)}runOutsideAngular(e){return this._outer.run(e)}}const Go={};function Ho(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function Ko(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&-1!==e.lastRequestAnimationFrameId)}function Xo(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function Zo(e){e._nesting--,Ho(e)}class Yo{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new lo,this.onMicrotaskEmpty=new lo,this.onStable=new lo,this.onError=new lo}run(e,t,n){return e.apply(t,n)}runGuarded(e,t,n){return e.apply(t,n)}runOutsideAngular(e){return e()}runTask(e,t,n,r){return e.apply(t,n)}}let Qo=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{jo.assertNotInAngularZone(),qo(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())qo(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,n){let r=-1;t&&t>0&&(r=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==r),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:r,updateCb:n})}whenStable(e,t,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,t,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,n){return[]}}return e.\u0275fac=function(t){return new(t||e)(nr(jo))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Jo=(()=>{class e{constructor(){this._applications=new Map,nu.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return nu.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class eu{addToWindow(e){}findTestabilityInTree(e,t,n){return null}}let tu,nu=new eu,ru=!0,su=!1;const iu=new zn("AllowMultipleToken");class au{constructor(e,t){this.name=e,this.token=t}}function ou(e,t,n=[]){const r=`Platform: ${t}`,s=new zn(r);return(t=[])=>{let i=uu();if(!i||i.injector.get(iu,!1))if(e)e(n.concat(t).concat({provide:s,useValue:!0}));else{const e=n.concat(t).concat({provide:s,useValue:!0},{provide:Ks,useValue:"platform"});!function(e){if(tu&&!tu.destroyed&&!tu.injector.get(iu,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");tu=e.get(lu);const t=e.get($o,null);t&&t.forEach(e=>e())}(oi.create({providers:e,name:r}))}return function(e){const t=uu();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(s)}}function uu(){return tu&&!tu.destroyed?tu:null}let lu=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const n=function(e,t){let n;return n="noop"===e?new Yo:("zone.js"===e?void 0:e)||new jo({enableLongStackTrace:(su=!0,ru),shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),n}(t?t.ngZone:void 0,{ngZoneEventCoalescing:t&&t.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:t&&t.ngZoneRunCoalescing||!1}),r=[{provide:jo,useValue:n}];return n.run(()=>{const t=oi.create({providers:r,parent:this.injector,name:e.moduleType.name}),s=e.create(t),i=s.injector.get(pr,null);if(!i)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const e=n.onError.subscribe({next:e=>{i.handleError(e)}});s.onDestroy(()=>{du(this._modules,s),e.unsubscribe()})}),function(e,t,n){try{const r=n();return _i(r)?r.catch(n=>{throw t.runOutsideAngular(()=>e.handleError(n)),n}):r}catch(r){throw t.runOutsideAngular(()=>e.handleError(r)),r}}(i,n,()=>{const e=s.injector.get(_o);return e.runInitializers(),e.donePromise.then(()=>(Hi(s.injector.get(Fo,ji)||ji),this._moduleDoBootstrap(s),s))})})}bootstrapModule(e,t=[]){const n=cu({},t);return function(e,t,n){const r=new ao(n);return Promise.resolve(r)}(0,0,e).then(e=>this.bootstrapModuleFactory(e,n))}_moduleDoBootstrap(e){const t=e.injector.get(hu);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${se(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(nr(oi))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function cu(e,t){return Array.isArray(t)?t.reduce(cu,e):Object.assign(Object.assign({},e),t)}let hu=(()=>{class e{constructor(e,t,n,r,s){this._zone=e,this._injector=t,this._exceptionHandler=n,this._componentFactoryResolver=r,this._initStatus=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new k(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),a=new k(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{jo.assertNotInAngularZone(),qo(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{jo.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),n.unsubscribe()}});this.isStable=function(...e){let t=Number.POSITIVE_INFINITY,n=null,r=e[e.length-1];return $(r)?(n=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof r&&(t=e.pop()),null===n&&1===e.length&&e[0]instanceof k?e[0]:H(t)(K(e,n))}(i,a.pipe(e=>{return X()((t=te,function(e){let n;n="function"==typeof t?t:function(){return t};const r=Object.create(e,J);return r.source=e,r.subjectFactory=n,r})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=e instanceof na?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(n.componentType);const r=n.isBoundToModule?void 0:this._injector.get(Ua),s=n.create(oi.NULL,[],t||n.selector,r),i=s.location.nativeElement,a=s.injector.get(Qo,null),o=a&&s.injector.get(Jo);return a&&o&&o.registerApplication(i,a),s.onDestroy(()=>{this.detachView(s.hostView),du(this.components,s),o&&o.unregisterApplication(i)}),this._loadComponent(s),s}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;du(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(Ao,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(nr(jo),nr(oi),nr(pr),nr(sa),nr(_o))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function du(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class pu{}class fu{}const mu={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let gu=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||mu}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,r]=e.split("#");return void 0===r&&(r="default"),n(255)(t).then(e=>e[r]).then(e=>bu(e,t,r)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,r]=e.split("#"),s="NgFactory";return void 0===r&&(r="default",s=""),n(255)(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[r+s]).then(e=>bu(e,t,r))}}return e.\u0275fac=function(t){return new(t||e)(nr(Wo),nr(fu,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function bu(e,t,n){if(!e)throw new Error(`Cannot find '${n}' in '${t}'`);return e}const yu=ou(null,"core",[{provide:To,useValue:"unknown"},{provide:lu,deps:[oi]},{provide:Jo,deps:[]},{provide:Ro,deps:[]}]),vu=[{provide:hu,useClass:hu,deps:[jo,oi,pr,sa,_o]},{provide:to,deps:[jo],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:_o,useClass:_o,deps:[[new ar,Io]]},{provide:Wo,useClass:Wo,deps:[]},No,{provide:Na,useFactory:function(){return Ma},deps:[]},{provide:$a,useFactory:function(){return La},deps:[]},{provide:Fo,useFactory:function(e){return Hi(e=e||"undefined"!=typeof $localize&&$localize.locale||ji),e},deps:[[new ir(Fo),new ar,new or]]},{provide:Do,useValue:"USD"}];let xu=(()=>{class e{constructor(e){}}return e.\u0275fac=function(t){return new(t||e)(nr(hu))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:vu}),e})(),wu=null;function ku(){return wu}const Cu=new zn("DocumentToken");let Iu=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:_u,token:e,providedIn:"platform"}),e})();function _u(){return nr(Nu)}const Su=new zn("Location Initialized");let Nu=(()=>{class e extends Iu{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return ku().getBaseHref(this._doc)}onPopState(e){const t=ku().getGlobalEventTarget(this._doc,"window");return t.addEventListener("popstate",e,!1),()=>t.removeEventListener("popstate",e)}onHashChange(e){const t=ku().getGlobalEventTarget(this._doc,"window");return t.addEventListener("hashchange",e,!1),()=>t.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,n){Eu()?this._history.pushState(e,t,n):this.location.hash=n}replaceState(e,t,n){Eu()?this._history.replaceState(e,t,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(nr(Cu))},e.\u0275prov=fe({factory:$u,token:e,providedIn:"platform"}),e})();function Eu(){return!!window.history.pushState}function $u(){return new Nu(nr(Cu))}function Tu(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function Au(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function Ru(e){return e&&"?"!==e[0]?"?"+e:e}let Fu=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:Du,token:e,providedIn:"root"}),e})();function Du(e){const t=nr(Cu).location;return new Mu(nr(Iu),t&&t.origin||"")}const Ou=new zn("appBaseHref");let Mu=(()=>{class e extends Fu{constructor(e,t){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Tu(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+Ru(this._platformLocation.search),n=this._platformLocation.hash;return n&&e?`${t}${n}`:t}pushState(e,t,n,r){const s=this.prepareExternalUrl(n+Ru(r));this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){const s=this.prepareExternalUrl(n+Ru(r));this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(nr(Iu),nr(Ou,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Lu=(()=>{class e extends Fu{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=t&&(this._baseHref=t)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=Tu(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,n,r){let s=this.prepareExternalUrl(n+Ru(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){let s=this.prepareExternalUrl(n+Ru(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(nr(Iu),nr(Ou,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Pu=(()=>{class e{constructor(e,t){this._subject=new lo,this._urlChangeListeners=[],this._platformStrategy=e;const n=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=Au(Vu(n)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+Ru(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,Vu(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",n=null){this._platformStrategy.pushState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}replaceState(e,t="",n=null){this._platformStrategy.replaceState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformStrategy).historyGo)||void 0===n||n.call(t,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)}))}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(n=>n(e,t))}subscribe(e,t,n){return this._subject.subscribe({next:e,error:t,complete:n})}}return e.\u0275fac=function(t){return new(t||e)(nr(Fu),nr(Iu))},e.normalizeQueryParams=Ru,e.joinWithSlash=Tu,e.stripTrailingSlash=Au,e.\u0275prov=fe({factory:zu,token:e,providedIn:"root"}),e})();function zu(){return new Pu(nr(Fu),nr(Iu))}function Vu(e){return e.replace(/\/index.html$/,"")}var Bu=function(e){return e[e.Zero=0]="Zero",e[e.One=1]="One",e[e.Two=2]="Two",e[e.Few=3]="Few",e[e.Many=4]="Many",e[e.Other=5]="Other",e}({});class Wu{}let Uu=(()=>{class e extends Wu{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return function(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let n=Ui(t);if(n)return n;const r=t.split("-")[0];if(n=Ui(r),n)return n;if("en"===r)return Bi;throw new Error(`Missing locale data for the locale "${e}".`)}(e)[qi.PluralCase]}(t||this.locale)(e)){case Bu.Zero:return"zero";case Bu.One:return"one";case Bu.Two:return"two";case Bu.Few:return"few";case Bu.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(nr(Fo))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),qu=(()=>{class e{constructor(e,t,n,r){this._iterableDiffers=e,this._keyValueDiffers=t,this._ngEl=n,this._renderer=r,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(gi(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachChangedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachRemovedItem(e=>{e.previousValue&&this._toggleClass(e.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(e=>{if("string"!=typeof e.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${se(e.item)}`);this._toggleClass(e.item,!0)}),e.forEachRemovedItem(e=>this._toggleClass(e.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!0)):Object.keys(e).forEach(t=>this._toggleClass(t,!!e[t])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!1)):Object.keys(e).forEach(e=>this._toggleClass(e,!1)))}_toggleClass(e,t){(e=e.trim())&&e.split(/\s+/g).forEach(e=>{t?this._renderer.addClass(this._ngEl.nativeElement,e):this._renderer.removeClass(this._ngEl.nativeElement,e)})}}return e.\u0275fac=function(t){return new(t||e)(vi(Na),vi($a),vi(ua),vi(ha))},e.\u0275dir=Ye({type:e,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),e})();class ju{constructor(e,t,n,r){this.$implicit=e,this.ngForOf=t,this.index=n,this.count=r}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Gu=(()=>{class e{constructor(e,t,n){this._viewContainer=e,this._template=t,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(t){throw new Error(`Cannot find a differ supporting object '${n}' of type '${e=n,e.name||typeof e}'. NgFor only supports binding to Iterables such as Arrays.`)}}var e;if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const t=[];e.forEachOperation((e,n,r)=>{if(null==e.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new ju(null,this._ngForOf,-1,-1),null===r?void 0:r),s=new Hu(e,n);t.push(s)}else if(null==r)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const s=this._viewContainer.get(n);this._viewContainer.move(s,r);const i=new Hu(e,s);t.push(i)}});for(let n=0;n<t.length;n++)this._perViewChange(t[n].view,t[n].record);for(let n=0,r=this._viewContainer.length;n<r;n++){const e=this._viewContainer.get(n);e.context.index=n,e.context.count=r,e.context.ngForOf=this._ngForOf}e.forEachIdentityChange(e=>{this._viewContainer.get(e.currentIndex).context.$implicit=e.item})}_perViewChange(e,t){e.context.$implicit=t.item}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(vi(Ga),vi(za),vi(Na))},e.\u0275dir=Ye({type:e,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),e})();class Hu{constructor(e,t){this.record=e,this.view=t}}let Ku=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:[{provide:Wu,useClass:Uu}]}),e})(),Xu=(()=>{class e{}return e.\u0275prov=fe({token:e,providedIn:"root",factory:()=>new Zu(nr(Cu),window)}),e})();class Zu{constructor(e,t){this.document=e,this.window=t,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(!this.supportsScrolling())return;const t=function(e,t){const n=e.getElementById(t)||e.getElementsByName(t)[0];if(n)return n;if("function"==typeof e.createTreeWalker&&e.body&&(e.body.createShadowRoot||e.body.attachShadow)){const n=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let r=n.currentNode;for(;r;){const e=r.shadowRoot;if(e){const n=e.getElementById(t)||e.querySelector(`[name="${t}"]`);if(n)return n}r=n.nextNode()}}return null}(this.document,e);t&&(this.scrollToElement(t),this.attemptFocus(t))}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),n=t.left+this.window.pageXOffset,r=t.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(n-s[0],r-s[1])}attemptFocus(e){return e.focus(),this.document.activeElement===e}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const e=Yu(this.window.history)||Yu(Object.getPrototypeOf(this.window.history));return!(!e||!e.writable&&!e.set)}catch(e){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(e){return!1}}}function Yu(e){return Object.getOwnPropertyDescriptor(e,"scrollRestoration")}class Qu extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var e;e=new Qu,wu||(wu=e)}onAndCancel(e,t,n){return e.addEventListener(t,n,!1),()=>{e.removeEventListener(t,n,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.parentNode&&e.parentNode.removeChild(e)}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getBaseHref(e){const t=(el=el||document.querySelector("base"),el?el.getAttribute("href"):null);return null==t?null:function(e){Ju=Ju||document.createElement("a"),Ju.setAttribute("href",e);const t=Ju.pathname;return"/"===t.charAt(0)?t:`/${t}`}(t)}resetBaseElement(){el=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return function(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const e=n.indexOf("="),[r,s]=-1==e?[n,""]:[n.slice(0,e),n.slice(e+1)];if(r.trim()===t)return decodeURIComponent(s)}return null}(document.cookie,e)}}let Ju,el=null;const tl=new zn("TRANSITION_ID"),nl=[{provide:Io,useFactory:function(e,t,n){return()=>{n.get(_o).donePromise.then(()=>{const n=ku();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>n.remove(e))})}},deps:[tl,Cu,oi],multi:!0}];class rl{static init(){var e;e=new rl,nu=e}addToWindow(e){De.getAngularTestability=(t,n=!0)=>{const r=e.findTestabilityInTree(t,n);if(null==r)throw new Error("Could not find testability for element.");return r},De.getAllAngularTestabilities=()=>e.getAllTestabilities(),De.getAllAngularRootElements=()=>e.getAllRootElements(),De.frameworkStabilizers||(De.frameworkStabilizers=[]),De.frameworkStabilizers.push(e=>{const t=De.getAllAngularTestabilities();let n=t.length,r=!1;const s=function(t){r=r||t,n--,0==n&&e(r)};t.forEach(function(e){e.whenStable(s)})})}findTestabilityInTree(e,t,n){if(null==t)return null;const r=e.getTestability(t);return null!=r?r:n?ku().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}let sl=(()=>{class e{build(){return new XMLHttpRequest}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const il=new zn("EventManagerPlugins");let al=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,n){return this._findPluginFor(t).addEventListener(e,t,n)}addGlobalEventListener(e,t,n){return this._findPluginFor(t).addGlobalEventListener(e,t,n)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const n=this._plugins;for(let r=0;r<n.length;r++){const t=n[r];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error(`No event manager plugin found for event ${e}`)}}return e.\u0275fac=function(t){return new(t||e)(nr(il),nr(jo))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class ol{constructor(e){this._doc=e}addGlobalEventListener(e,t,n){const r=ku().getGlobalEventTarget(this._doc,e);if(!r)throw new Error(`Unsupported event target ${r} for event ${t}`);return this.addEventListener(r,t,n)}}let ul=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),ll=(()=>{class e extends ul{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,t,n){e.forEach(e=>{const r=this._doc.createElement("style");r.textContent=e,n.push(t.appendChild(r))})}addHost(e){const t=[];this._addStylesToHost(this._stylesSet,e,t),this._hostNodes.set(e,t)}removeHost(e){const t=this._hostNodes.get(e);t&&t.forEach(cl),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((t,n)=>{this._addStylesToHost(e,n,t)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(cl))}}return e.\u0275fac=function(t){return new(t||e)(nr(Cu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function cl(e){ku().remove(e)}const hl={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},dl=/%COMP%/g;function pl(e,t,n){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?pl(e,s,n):(s=s.replace(dl,e),n.push(s))}return n}function fl(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let ml=(()=>{class e{constructor(e,t,n){this.eventManager=e,this.sharedStylesHost=t,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new gl(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case $e.Emulated:{let n=this.rendererByCompId.get(t.id);return n||(n=new bl(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,n)),n.applyToHost(e),n}case 1:case $e.ShadowDom:return new yl(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=pl(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(nr(al),nr(ll),nr(So))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class gl{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(hl[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,n){e&&e.insertBefore(t,n)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let n="string"==typeof e?document.querySelector(e):e;if(!n)throw new Error(`The selector "${e}" did not match any elements`);return t||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,n,r){if(r){t=r+":"+t;const s=hl[r];s?e.setAttributeNS(s,t,n):e.setAttribute(t,n)}else e.setAttribute(t,n)}removeAttribute(e,t,n){if(n){const r=hl[n];r?e.removeAttributeNS(r,t):e.removeAttribute(`${n}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,n,r){r&(gr.DashCase|gr.Important)?e.style.setProperty(t,n,r&gr.Important?"important":""):e.style[t]=n}removeStyle(e,t,n){n&gr.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,n){e[t]=n}setValue(e,t){e.nodeValue=t}listen(e,t,n){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,fl(n)):this.eventManager.addEventListener(e,t,fl(n))}}class bl extends gl{constructor(e,t,n,r){super(e),this.component=n;const s=pl(r+"-"+n.id,n.styles,[]);t.addStyles(s),this.contentAttr="_ngcontent-%COMP%".replace(dl,r+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(dl,r+"-"+n.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const n=super.createElement(e,t);return super.setAttribute(n,this.contentAttr,""),n}}class yl extends gl{constructor(e,t,n,r){super(e),this.sharedStylesHost=t,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const s=pl(r.id,r.styles,[]);for(let i=0;i<s.length;i++){const e=document.createElement("style");e.textContent=s[i],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,n){return super.insertBefore(this.nodeOrShadowRoot(e),t,n)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let vl=(()=>{class e extends ol{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,n){return e.addEventListener(t,n,!1),()=>this.removeEventListener(e,t,n)}removeEventListener(e,t,n){return e.removeEventListener(t,n)}}return e.\u0275fac=function(t){return new(t||e)(nr(Cu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const xl=["alt","control","meta","shift"],wl={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},kl={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Cl={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let Il=(()=>{class e extends ol{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,n,r){const s=e.parseEventName(n),i=e.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ku().onAndCancel(t,s.domEventName,i))}static parseEventName(t){const n=t.toLowerCase().split("."),r=n.shift();if(0===n.length||"keydown"!==r&&"keyup"!==r)return null;const s=e._normalizeKey(n.pop());let i="";if(xl.forEach(e=>{const t=n.indexOf(e);t>-1&&(n.splice(t,1),i+=e+".")}),i+=s,0!=n.length||0===s.length)return null;const a={};return a.domEventName=r,a.fullKey=i,a}static getEventFullKey(e){let t="",n=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&kl.hasOwnProperty(t)&&(t=kl[t]))}return wl[t]||t}(e);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),xl.forEach(r=>{r!=n&&(0,Cl[r])(e)&&(t+=r+".")}),t+=n,t}static eventCallback(t,n,r){return s=>{e.getEventFullKey(s)===t&&r.runGuarded(()=>n(s))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(nr(Cu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const _l=ou(yu,"browser",[{provide:To,useValue:"browser"},{provide:$o,useValue:function(){Qu.makeCurrent(),rl.init()},multi:!0},{provide:Cu,useFactory:function(){return function(e){mt=e}(document),document},deps:[]}]),Sl=[[],{provide:Ks,useValue:"root"},{provide:pr,useFactory:function(){return new pr},deps:[]},{provide:il,useClass:vl,multi:!0,deps:[Cu,jo,To]},{provide:il,useClass:Il,multi:!0,deps:[Cu]},[],{provide:ml,useClass:ml,deps:[al,ll,So]},{provide:ca,useExisting:ml},{provide:ul,useExisting:ll},{provide:ll,useClass:ll,deps:[Cu]},{provide:Qo,useClass:Qo,deps:[jo]},{provide:al,useClass:al,deps:[il,jo]},{provide:class{},useClass:sl,deps:[]},[]];let Nl=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:So,useValue:t.appId},{provide:tl,useExisting:So},nl]}}}return e.\u0275fac=function(t){return new(t||e)(nr(e,12))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:Sl,imports:[Ku,xu]}),e})();function El(...e){let t=e[e.length-1];return $(t)?(e.pop(),z(e,t)):K(e)}"undefined"!=typeof window&&window;class $l extends N{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new I;return this._value}next(e){super.next(this._value=e)}}class Tl extends y{notifyNext(e,t,n,r,s){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}class Al extends y{constructor(e,t,n){super(),this.parent=e,this.outerValue=t,this.outerIndex=n,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function Rl(e,t,n,r,s=new Al(e,n,r)){if(!s.closed)return t instanceof k?t.subscribe(s):P(t)(s)}const Fl={};class Dl{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new Ol(e,this.resultSelector))}}class Ol extends Tl{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(Fl),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let n=0;n<t;n++)this.add(Rl(this,e[n],void 0,n))}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,n){const r=this.values,s=this.toRespond?r[n]===Fl?--this.toRespond:this.toRespond:0;r[n]=t,0===s&&(this.resultSelector?this._tryResultSelector(r):this.destination.next(r.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const Ml=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})();function Ll(...e){return H(1)(El(...e))}const Pl=new k(e=>e.complete());function zl(e){return e?function(e){return new k(t=>e.schedule(()=>t.complete()))}(e):Pl}function Vl(e){return new k(t=>{let n;try{n=e()}catch(r){return void t.error(r)}return(n?V(n):zl()).subscribe(t)})}function Bl(e,t){return"function"==typeof t?n=>n.pipe(Bl((n,r)=>V(e(n,r)).pipe(T((e,s)=>t(n,e,r,s))))):t=>t.lift(new Wl(e))}class Wl{constructor(e){this.project=e}call(e,t){return t.subscribe(new Ul(e,this.project))}}class Ul extends W{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this._innerSub(t)}_innerSub(e){const t=this.innerSubscription;t&&t.unsubscribe();const n=new B(this),r=this.destination;r.add(n),this.innerSubscription=U(e,n),this.innerSubscription!==n&&r.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(e){this.destination.next(e)}}const ql=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function jl(e){return t=>0===e?zl():t.lift(new Gl(e))}class Gl{constructor(e){if(this.total=e,this.total<0)throw new ql}call(e,t){return t.subscribe(new Hl(e,this.total))}}class Hl extends y{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,n=++this.count;n<=t&&(this.destination.next(e),n===t&&(this.destination.complete(),this.unsubscribe()))}}function Kl(e,t){let n=!1;return arguments.length>=2&&(n=!0),function(r){return r.lift(new Xl(e,t,n))}}class Xl{constructor(e,t,n=!1){this.accumulator=e,this.seed=t,this.hasSeed=n}call(e,t){return t.subscribe(new Zl(e,this.accumulator,this.seed,this.hasSeed))}}class Zl extends y{constructor(e,t,n,r){super(e),this.accumulator=t,this._seed=n,this.hasSeed=r,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let n;try{n=this.accumulator(this.seed,e,t)}catch(r){this.destination.error(r)}this.seed=n,this.destination.next(n)}}function Yl(e,t){return function(n){return n.lift(new Ql(e,t))}}class Ql{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new Jl(e,this.predicate,this.thisArg))}}class Jl extends y{constructor(e,t,n){super(e),this.predicate=t,this.thisArg=n,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}t&&this.destination.next(e)}}function ec(e){return function(t){const n=new tc(e),r=t.lift(n);return n.caught=r}}class tc{constructor(e){this.selector=e}call(e,t){return t.subscribe(new nc(e,this.selector,this.caught))}}class nc extends W{constructor(e,t,n){super(e),this.selector=t,this.caught=n}error(e){if(!this.isStopped){let n;try{n=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const r=new B(this);this.add(r);const s=U(n,r);s!==r&&this.add(s)}}}function rc(e,t){return q(e,t,1)}function sc(e){return function(t){return 0===e?zl():t.lift(new ic(e))}}class ic{constructor(e){if(this.total=e,this.total<0)throw new ql}call(e,t){return t.subscribe(new ac(e,this.total))}}class ac extends y{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,n=this.total,r=this.count++;t.length<n?t.push(e):t[r%n]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const n=this.count>=this.total?this.total:this.count,r=this.ring;for(let s=0;s<n;s++){const s=t++%n;e.next(r[s])}}e.complete()}}function oc(e=cc){return t=>t.lift(new uc(e))}class uc{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new lc(e,this.errorFactory))}}class lc extends y{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function cc(){return new Ml}function hc(e=null){return t=>t.lift(new dc(e))}class dc{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new pc(e,this.defaultValue))}}class pc extends y{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function fc(e,t){const n=arguments.length>=2;return r=>r.pipe(e?Yl((t,n)=>e(t,n,r)):w,jl(1),n?hc(t):oc(()=>new Ml))}function mc(){}function gc(e,t,n){return function(r){return r.lift(new bc(e,t,n))}}class bc{constructor(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}call(e,t){return t.subscribe(new yc(e,this.nextOrObserver,this.error,this.complete))}}class yc extends y{constructor(e,t,n,r){super(e),this._tapNext=mc,this._tapError=mc,this._tapComplete=mc,this._tapError=n||mc,this._tapComplete=r||mc,o(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||mc,this._tapError=t.error||mc,this._tapComplete=t.complete||mc)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class vc{constructor(e){this.callback=e}call(e,t){return t.subscribe(new xc(e,this.callback))}}class xc extends y{constructor(e,t){super(e),this.add(new m(t))}}class wc{constructor(e,t){this.id=e,this.url=t}}class kc extends wc{constructor(e,t,n="imperative",r=null){super(e,t),this.navigationTrigger=n,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Cc extends wc{constructor(e,t,n){super(e,t),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Ic extends wc{constructor(e,t,n){super(e,t),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class _c extends wc{constructor(e,t,n){super(e,t),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Sc extends wc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Nc extends wc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ec extends wc{constructor(e,t,n,r,s){super(e,t),this.urlAfterRedirects=n,this.state=r,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class $c extends wc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Tc extends wc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ac{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Rc{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Fc{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Dc{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Oc{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Mc{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Lc{constructor(e,t,n){this.routerEvent=e,this.position=t,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const Pc="primary";class zc{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function Vc(e){return new zc(e)}function Bc(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function Wc(e,t,n){const r=n.path.split("/");if(r.length>e.length)return null;if("full"===n.pathMatch&&(t.hasChildren()||r.length<e.length))return null;const s={};for(let i=0;i<r.length;i++){const t=r[i],n=e[i];if(t.startsWith(":"))s[t.substring(1)]=n;else if(t!==n.path)return null}return{consumed:e.slice(0,r.length),posParams:s}}function Uc(e,t){const n=e?Object.keys(e):void 0,r=t?Object.keys(t):void 0;if(!n||!r||n.length!=r.length)return!1;let s;for(let i=0;i<n.length;i++)if(s=n[i],!qc(e[s],t[s]))return!1;return!0}function qc(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const n=[...e].sort(),r=[...t].sort();return n.every((e,t)=>r[t]===e)}return e===t}function jc(e){return Array.prototype.concat.apply([],e)}function Gc(e){return e.length>0?e[e.length-1]:null}function Hc(e,t){for(const n in e)e.hasOwnProperty(n)&&t(e[n],n)}function Kc(e){return Si(e)?e:_i(e)?V(Promise.resolve(e)):El(e)}const Xc={exact:function e(t,n,r){if(!sh(t.segments,n.segments))return!1;if(!eh(t.segments,n.segments,r))return!1;if(t.numberOfChildren!==n.numberOfChildren)return!1;for(const s in n.children){if(!t.children[s])return!1;if(!e(t.children[s],n.children[s],r))return!1}return!0},subset:Qc},Zc={exact:function(e,t){return Uc(e,t)},subset:function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>qc(e[n],t[n]))},ignored:()=>!0};function Yc(e,t,n){return Xc[n.paths](e.root,t.root,n.matrixParams)&&Zc[n.queryParams](e.queryParams,t.queryParams)&&!("exact"===n.fragment&&e.fragment!==t.fragment)}function Qc(e,t,n){return Jc(e,t,t.segments,n)}function Jc(e,t,n,r){if(e.segments.length>n.length){const s=e.segments.slice(0,n.length);return!!sh(s,n)&&!t.hasChildren()&&!!eh(s,n,r)}if(e.segments.length===n.length){if(!sh(e.segments,n))return!1;if(!eh(e.segments,n,r))return!1;for(const n in t.children){if(!e.children[n])return!1;if(!Qc(e.children[n],t.children[n],r))return!1}return!0}{const s=n.slice(0,e.segments.length),i=n.slice(e.segments.length);return!!sh(e.segments,s)&&!!eh(e.segments,s,r)&&!!e.children.primary&&Jc(e.children.primary,t,i,r)}}function eh(e,t,n){return t.every((t,r)=>Zc[n](e[r].parameters,t.parameters))}class th{constructor(e,t,n){this.root=e,this.queryParams=t,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Vc(this.queryParams)),this._queryParamMap}toString(){return oh.serialize(this)}}class nh{constructor(e,t){this.segments=e,this.children=t,this.parent=null,Hc(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return uh(this)}}class rh{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=Vc(this.parameters)),this._parameterMap}toString(){return mh(this)}}function sh(e,t){return e.length===t.length&&e.every((e,n)=>e.path===t[n].path)}class ih{}class ah{parse(e){const t=new xh(e);return new th(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){var t;return`/${lh(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const n=e[t];return Array.isArray(n)?n.map(e=>`${hh(t)}=${hh(e)}`).join("&"):`${hh(t)}=${hh(n)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(e.queryParams)}${"string"==typeof e.fragment?`#${t=e.fragment,encodeURI(t)}`:""}`}}const oh=new ah;function uh(e){return e.segments.map(e=>mh(e)).join("/")}function lh(e,t){if(!e.hasChildren())return uh(e);if(t){const t=e.children.primary?lh(e.children.primary,!1):"",n=[];return Hc(e.children,(e,t)=>{t!==Pc&&n.push(`${t}:${lh(e,!1)}`)}),n.length>0?`${t}(${n.join("//")})`:t}{const t=function(e,t){let n=[];return Hc(e.children,(e,r)=>{r===Pc&&(n=n.concat(t(e,r)))}),Hc(e.children,(e,r)=>{r!==Pc&&(n=n.concat(t(e,r)))}),n}(e,(t,n)=>n===Pc?[lh(e.children.primary,!1)]:[`${n}:${lh(t,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children.primary?`${uh(e)}/${t[0]}`:`${uh(e)}/(${t.join("//")})`}}function ch(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function hh(e){return ch(e).replace(/%3B/gi,";")}function dh(e){return ch(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function ph(e){return decodeURIComponent(e)}function fh(e){return ph(e.replace(/\+/g,"%20"))}function mh(e){return`${dh(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${dh(e)}=${dh(t[e])}`).join("")}`;var t}const gh=/^[^\/()?;=#]+/;function bh(e){const t=e.match(gh);return t?t[0]:""}const yh=/^[^=?&#]+/,vh=/^[^?&#]+/;class xh{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new nh([],{}):new nh([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(n.primary=new nh(e,t)),n}parseSegment(){const e=bh(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new rh(ph(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=bh(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=bh(this.remaining);e&&(n=e,this.capture(n))}e[ph(t)]=ph(n)}parseQueryParam(e){const t=function(e){const t=e.match(yh);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(vh);return t?t[0]:""}(this.remaining);e&&(n=e,this.capture(n))}const r=fh(t),s=fh(n);if(e.hasOwnProperty(r)){let t=e[r];Array.isArray(t)||(t=[t],e[r]=t),t.push(s)}else e[r]=s}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=bh(this.remaining),r=this.remaining[n.length];if("/"!==r&&")"!==r&&";"!==r)throw new Error(`Cannot parse url '${this.url}'`);let s;n.indexOf(":")>-1?(s=n.substr(0,n.indexOf(":")),this.capture(s),this.capture(":")):e&&(s=Pc);const i=this.parseChildren();t[s]=1===Object.keys(i).length?i.primary:new nh([],i),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class wh{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=kh(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=kh(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=Ch(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return Ch(e,this._root).map(e=>e.value)}}function kh(e,t){if(e===t.value)return t;for(const n of t.children){const t=kh(e,n);if(t)return t}return null}function Ch(e,t){if(e===t.value)return[t];for(const n of t.children){const r=Ch(e,n);if(r.length)return r.unshift(t),r}return[]}class Ih{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function _h(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class Sh extends wh{constructor(e,t){super(e),this.snapshot=t,Rh(this,e)}toString(){return this.snapshot.toString()}}function Nh(e,t){const n=function(e,t){const n=new Th([],{},{},"",{},Pc,t,null,e.root,-1,{});return new Ah("",new Ih(n,[]))}(e,t),r=new $l([new rh("",{})]),s=new $l({}),i=new $l({}),a=new $l({}),o=new $l(""),u=new Eh(r,s,a,o,i,Pc,t,n.root);return u.snapshot=n.root,new Sh(new Ih(u,[]),n)}class Eh{constructor(e,t,n,r,s,i,a,o){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=i,this.component=a,this._futureSnapshot=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(T(e=>Vc(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(T(e=>Vc(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function $h(e,t="emptyOnly"){const n=e.pathFromRoot;let r=0;if("always"!==t)for(r=n.length-1;r>=1;){const e=n[r],t=n[r-1];if(e.routeConfig&&""===e.routeConfig.path)r--;else{if(t.component)break;r--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(r))}class Th{constructor(e,t,n,r,s,i,a,o,u,l,c){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=i,this.component=a,this.routeConfig=o,this._urlSegment=u,this._lastPathIndex=l,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Vc(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Vc(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Ah extends wh{constructor(e,t){super(t),this.url=e,Rh(this,t)}toString(){return Fh(this._root)}}function Rh(e,t){t.value._routerState=e,t.children.forEach(t=>Rh(e,t))}function Fh(e){const t=e.children.length>0?` { ${e.children.map(Fh).join(", ")} } `:"";return`${e.value}${t}`}function Dh(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,Uc(t.queryParams,n.queryParams)||e.queryParams.next(n.queryParams),t.fragment!==n.fragment&&e.fragment.next(n.fragment),Uc(t.params,n.params)||e.params.next(n.params),function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!Uc(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.url.next(n.url),Uc(t.data,n.data)||e.data.next(n.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function Oh(e,t){var n,r;return Uc(e.params,t.params)&&sh(n=e.url,r=t.url)&&n.every((e,t)=>Uc(e.parameters,r[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||Oh(e.parent,t.parent))}function Mh(e,t,n){if(n&&e.shouldReuseRoute(t.value,n.value.snapshot)){const r=n.value;r._futureSnapshot=t.value;const s=function(e,t,n){return t.children.map(t=>{for(const r of n.children)if(e.shouldReuseRoute(t.value,r.value.snapshot))return Mh(e,t,r);return Mh(e,t)})}(e,t,n);return new Ih(r,s)}{if(e.shouldAttach(t.value)){const n=e.retrieve(t.value);if(null!==n){const e=n.route;return Lh(t,e),e}}const n=new Eh(new $l((r=t.value).url),new $l(r.params),new $l(r.queryParams),new $l(r.fragment),new $l(r.data),r.outlet,r.component,r),s=t.children.map(t=>Mh(e,t));return new Ih(n,s)}var r}function Lh(e,t){if(e.value.routeConfig!==t.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==t.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");t.value._futureSnapshot=e.value;for(let n=0;n<e.children.length;++n)Lh(e.children[n],t.children[n])}function Ph(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function zh(e){return"object"==typeof e&&null!=e&&e.outlets}function Vh(e,t,n,r,s){let i={};return r&&Hc(r,(e,t)=>{i[t]=Array.isArray(e)?e.map(e=>`${e}`):`${e}`}),new th(n.root===e?t:Bh(n.root,e,t),i,s)}function Bh(e,t,n){const r={};return Hc(e.children,(e,s)=>{r[s]=e===t?n:Bh(e,t,n)}),new nh(e.segments,r)}class Wh{constructor(e,t,n){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=n,e&&n.length>0&&Ph(n[0]))throw new Error("Root segment cannot have matrix parameters");const r=n.find(zh);if(r&&r!==Gc(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Uh{constructor(e,t,n){this.segmentGroup=e,this.processChildren=t,this.index=n}}function qh(e,t,n){if(e||(e=new nh([],{})),0===e.segments.length&&e.hasChildren())return jh(e,t,n);const r=function(e,t,n){let r=0,s=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<e.segments.length;){if(r>=n.length)return i;const t=e.segments[s],a=n[r];if(zh(a))break;const o=`${a}`,u=r<n.length-1?n[r+1]:null;if(s>0&&void 0===o)break;if(o&&u&&"object"==typeof u&&void 0===u.outlets){if(!Xh(o,u,t))return i;r+=2}else{if(!Xh(o,{},t))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(e,t,n),s=n.slice(r.commandIndex);if(r.match&&r.pathIndex<e.segments.length){const t=new nh(e.segments.slice(0,r.pathIndex),{});return t.children.primary=new nh(e.segments.slice(r.pathIndex),e.children),jh(t,0,s)}return r.match&&0===s.length?new nh(e.segments,{}):r.match&&!e.hasChildren()?Gh(e,t,n):r.match?jh(e,0,s):Gh(e,t,n)}function jh(e,t,n){if(0===n.length)return new nh(e.segments,{});{const r=function(e){return zh(e[0])?e[0].outlets:{[Pc]:e}}(n),s={};return Hc(r,(n,r)=>{"string"==typeof n&&(n=[n]),null!==n&&(s[r]=qh(e.children[r],t,n))}),Hc(e.children,(e,t)=>{void 0===r[t]&&(s[t]=e)}),new nh(e.segments,s)}}function Gh(e,t,n){const r=e.segments.slice(0,t);let s=0;for(;s<n.length;){const i=n[s];if(zh(i)){const e=Hh(i.outlets);return new nh(r,e)}if(0===s&&Ph(n[0])){r.push(new rh(e.segments[t].path,Kh(n[0]))),s++;continue}const a=zh(i)?i.outlets.primary:`${i}`,o=s<n.length-1?n[s+1]:null;a&&o&&Ph(o)?(r.push(new rh(a,Kh(o))),s+=2):(r.push(new rh(a,{})),s++)}return new nh(r,{})}function Hh(e){const t={};return Hc(e,(e,n)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[n]=Gh(new nh([],{}),0,e))}),t}function Kh(e){const t={};return Hc(e,(e,n)=>t[n]=`${e}`),t}function Xh(e,t,n){return e==n.path&&Uc(t,n.parameters)}class Zh{constructor(e,t,n,r){this.routeReuseStrategy=e,this.futureState=t,this.currState=n,this.forwardEvent=r}activate(e){const t=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,n,e),Dh(this.futureState.root),this.activateChildRoutes(t,n,e)}deactivateChildRoutes(e,t,n){const r=_h(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,r[t],n),delete r[t]}),Hc(r,(e,t)=>{this.deactivateRouteAndItsChildren(e,n)})}deactivateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(r===s)if(r.component){const s=n.getContext(r.outlet);s&&this.deactivateChildRoutes(e,t,s.children)}else this.deactivateChildRoutes(e,t,n);else s&&this.deactivateRouteAndItsChildren(t,n)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const n=t.getContext(e.value.outlet);if(n&&n.outlet){const t=n.outlet.detach(),r=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:r})}}deactivateRouteAndOutlet(e,t){const n=t.getContext(e.value.outlet),r=n&&e.value.component?n.children:t,s=_h(e);for(const i of Object.keys(s))this.deactivateRouteAndItsChildren(s[i],r);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(e,t,n){const r=_h(t);e.children.forEach(e=>{this.activateRoutes(e,r[e.value.outlet],n),this.forwardEvent(new Mc(e.value.snapshot))}),e.children.length&&this.forwardEvent(new Dc(e.value.snapshot))}activateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(Dh(r),r===s)if(r.component){const s=n.getOrCreateContext(r.outlet);this.activateChildRoutes(e,t,s.children)}else this.activateChildRoutes(e,t,n);else if(r.component){const t=n.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const e=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),Yh(e.route)}else{const n=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(r.snapshot),s=n?n.module.componentFactoryResolver:null;t.attachRef=null,t.route=r,t.resolver=s,t.outlet&&t.outlet.activateWith(r,s),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,n)}}function Yh(e){Dh(e.value),e.children.forEach(Yh)}class Qh{constructor(e,t){this.routes=e,this.module=t}}function Jh(e){return"function"==typeof e}function ed(e){return e instanceof th}const td=Symbol("INITIAL_VALUE");function nd(){return Bl(e=>function(...e){let t,n;return $(e[e.length-1])&&(n=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&d(e[0])&&(e=e[0]),K(e,n).lift(new Dl(t))}(e.map(e=>e.pipe(jl(1),function(...e){const t=e[e.length-1];return $(t)?(e.pop(),n=>Ll(e,n,t)):t=>Ll(e,t)}(td)))).pipe(Kl((e,t)=>{let n=!1;return t.reduce((e,r,s)=>{if(e!==td)return e;if(r===td&&(n=!0),!n){if(!1===r)return r;if(s===t.length-1||ed(r))return r}return e},e)},td),Yl(e=>e!==td),T(e=>ed(e)?e:!0===e),jl(1)))}let rd=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=je({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&Ii(0,"router-outlet")},directives:function(){return[Yd]},encapsulation:2}),e})();function sd(e,t=""){for(let n=0;n<e.length;n++){const r=e[n];id(r,ad(t,r))}}function id(e,t){e.children&&sd(e.children,t)}function ad(e,t){return t?e||t.path?e&&!t.path?`${e}/`:!e&&t.path?t.path:`${e}/${t.path}`:"":e}function od(e){const t=e.children&&e.children.map(od),n=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!n.component&&(t||n.loadChildren)&&n.outlet&&n.outlet!==Pc&&(n.component=rd),n}function ud(e){return e.outlet||Pc}function ld(e,t){const n=e.filter(e=>ud(e)===t);return n.push(...e.filter(e=>ud(e)!==t)),n}const cd={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function hd(e,t,n){var r;if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?Object.assign({},cd):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const s=(t.matcher||Wc)(n,e,t);if(!s)return Object.assign({},cd);const i={};Hc(s.posParams,(e,t)=>{i[t]=e.path});const a=s.consumed.length>0?Object.assign(Object.assign({},i),s.consumed[s.consumed.length-1].parameters):i;return{matched:!0,consumedSegments:s.consumed,lastChild:s.consumed.length,parameters:a,positionalParamSegments:null!==(r=s.posParams)&&void 0!==r?r:{}}}function dd(e,t,n,r,s="corrected"){if(n.length>0&&function(e,t,n){return n.some(n=>pd(e,t,n)&&ud(n)!==Pc)}(e,n,r)){const s=new nh(t,function(e,t,n,r){const s={};s.primary=r,r._sourceSegment=e,r._segmentIndexShift=t.length;for(const i of n)if(""===i.path&&ud(i)!==Pc){const n=new nh([],{});n._sourceSegment=e,n._segmentIndexShift=t.length,s[ud(i)]=n}return s}(e,t,r,new nh(n,e.children)));return s._sourceSegment=e,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:[]}}if(0===n.length&&function(e,t,n){return n.some(n=>pd(e,t,n))}(e,n,r)){const i=new nh(e.segments,function(e,t,n,r,s,i){const a={};for(const o of r)if(pd(e,n,o)&&!s[ud(o)]){const n=new nh([],{});n._sourceSegment=e,n._segmentIndexShift="legacy"===i?e.segments.length:t.length,a[ud(o)]=n}return Object.assign(Object.assign({},s),a)}(e,t,n,r,e.children,s));return i._sourceSegment=e,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:n}}const i=new nh(e.segments,e.children);return i._sourceSegment=e,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:n}}function pd(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path}function fd(e,t,n,r){return!!(ud(e)===r||r!==Pc&&pd(t,n,e))&&("**"===e.path||hd(t,e,n).matched)}function md(e,t,n){return 0===t.length&&!e.children[n]}class gd{constructor(e){this.segmentGroup=e||null}}class bd{constructor(e){this.urlTree=e}}function yd(e){return new k(t=>t.error(new gd(e)))}function vd(e){return new k(t=>t.error(new bd(e)))}function xd(e){return new k(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class wd{constructor(e,t,n,r,s){this.configLoader=t,this.urlSerializer=n,this.urlTree=r,this.config=s,this.allowRedirects=!0,this.ngModule=e.get(Ua)}apply(){const e=dd(this.urlTree.root,[],[],this.config).segmentGroup,t=new nh(e.segments,e.children);return this.expandSegmentGroup(this.ngModule,this.config,t,Pc).pipe(T(e=>this.createUrlTree(kd(e),this.urlTree.queryParams,this.urlTree.fragment))).pipe(ec(e=>{if(e instanceof bd)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof gd)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,Pc).pipe(T(t=>this.createUrlTree(kd(t),e.queryParams,e.fragment))).pipe(ec(e=>{if(e instanceof gd)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,n){const r=e.segments.length>0?new nh([],{[Pc]:e}):e;return new th(r,t,n)}expandSegmentGroup(e,t,n,r){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(e,t,n).pipe(T(e=>new nh([],e))):this.expandSegment(e,n,t,n.segments,r,!0)}expandChildren(e,t,n){const r=[];for(const s of Object.keys(n.children))"primary"===s?r.unshift(s):r.push(s);return V(r).pipe(rc(r=>{const s=n.children[r],i=ld(t,r);return this.expandSegmentGroup(e,i,s,r).pipe(T(e=>({segment:e,outlet:r})))}),Kl((e,t)=>(e[t.outlet]=t.segment,e),{}),function(e,t){const n=arguments.length>=2;return r=>r.pipe(e?Yl((t,n)=>e(t,n,r)):w,sc(1),n?hc(t):oc(()=>new Ml))}())}expandSegment(e,t,n,r,s,i){return V(n).pipe(rc(a=>this.expandSegmentAgainstRoute(e,t,n,a,r,s,i).pipe(ec(e=>{if(e instanceof gd)return El(null);throw e}))),fc(e=>!!e),ec((e,n)=>{if(e instanceof Ml||"EmptyError"===e.name){if(md(t,r,s))return El(new nh([],{}));throw new gd(t)}throw e}))}expandSegmentAgainstRoute(e,t,n,r,s,i,a){return fd(r,t,s,i)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(e,t,r,s,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,i):yd(t):yd(t)}expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,i){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,r,i):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,n,r){const s=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?vd(s):this.lineralizeSegments(n,s).pipe(q(n=>{const s=new nh(n,{});return this.expandSegment(e,s,t,n,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,i){const{matched:a,consumedSegments:o,lastChild:u,positionalParamSegments:l}=hd(t,r,s);if(!a)return yd(t);const c=this.applyRedirectCommands(o,r.redirectTo,l);return r.redirectTo.startsWith("/")?vd(c):this.lineralizeSegments(r,c).pipe(q(r=>this.expandSegment(e,t,n,r.concat(s.slice(u)),i,!1)))}matchSegmentAgainstRoute(e,t,n,r,s){if("**"===n.path)return n.loadChildren?(n._loadedConfig?El(n._loadedConfig):this.configLoader.load(e.injector,n)).pipe(T(e=>(n._loadedConfig=e,new nh(r,{})))):El(new nh(r,{}));const{matched:i,consumedSegments:a,lastChild:o}=hd(t,n,r);if(!i)return yd(t);const u=r.slice(o);return this.getChildConfig(e,n,r).pipe(q(e=>{const r=e.module,i=e.routes,{segmentGroup:o,slicedSegments:l}=dd(t,a,u,i),c=new nh(o.segments,o.children);if(0===l.length&&c.hasChildren())return this.expandChildren(r,i,c).pipe(T(e=>new nh(a,e)));if(0===i.length&&0===l.length)return El(new nh(a,{}));const h=ud(n)===s;return this.expandSegment(r,c,i,l,h?Pc:s,!0).pipe(T(e=>new nh(a.concat(e.segments),e.children)))}))}getChildConfig(e,t,n){return t.children?El(new Qh(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?El(t._loadedConfig):this.runCanLoadGuards(e.injector,t,n).pipe(q(n=>n?this.configLoader.load(e.injector,t).pipe(T(e=>(t._loadedConfig=e,e))):function(e){return new k(t=>t.error(Bc(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):El(new Qh([],e))}runCanLoadGuards(e,t,n){const r=t.canLoad;return r&&0!==r.length?El(r.map(r=>{const s=e.get(r);let i;if(function(e){return e&&Jh(e.canLoad)}(s))i=s.canLoad(t,n);else{if(!Jh(s))throw new Error("Invalid CanLoad guard");i=s(t,n)}return Kc(i)})).pipe(nd(),gc(e=>{if(!ed(e))return;const t=Bc(`Redirecting to "${this.urlSerializer.serialize(e)}"`);throw t.url=e,t}),T(e=>!0===e)):El(!0)}lineralizeSegments(e,t){let n=[],r=t.root;for(;;){if(n=n.concat(r.segments),0===r.numberOfChildren)return El(n);if(r.numberOfChildren>1||!r.children.primary)return xd(e.redirectTo);r=r.children.primary}}applyRedirectCommands(e,t,n){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,n)}applyRedirectCreatreUrlTree(e,t,n,r){const s=this.createSegmentGroup(e,t.root,n,r);return new th(s,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const n={};return Hc(e,(e,r)=>{if("string"==typeof e&&e.startsWith(":")){const s=e.substring(1);n[r]=t[s]}else n[r]=e}),n}createSegmentGroup(e,t,n,r){const s=this.createSegments(e,t.segments,n,r);let i={};return Hc(t.children,(t,s)=>{i[s]=this.createSegmentGroup(e,t,n,r)}),new nh(s,i)}createSegments(e,t,n,r){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,r):this.findOrReturn(t,n))}findPosParam(e,t,n){const r=n[t.path.substring(1)];if(!r)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return r}findOrReturn(e,t){let n=0;for(const r of t){if(r.path===e.path)return t.splice(n),r;n++}return e}}function kd(e){const t={};for(const n of Object.keys(e.children)){const r=kd(e.children[n]);(r.segments.length>0||r.hasChildren())&&(t[n]=r)}return function(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new nh(e.segments.concat(t.segments),t.children)}return e}(new nh(e.segments,t))}class Cd{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class Id{constructor(e,t){this.component=e,this.route=t}}function _d(e,t,n){const r=e._root;return Nd(r,t?t._root:null,n,[r.value])}function Sd(e,t,n){const r=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(r?r.module.injector:n).get(e)}function Nd(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=_h(t);return e.children.forEach(e=>{!function(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=e.value,a=t?t.value:null,o=n?n.getContext(e.value.outlet):null;if(a&&i.routeConfig===a.routeConfig){const u=function(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!sh(e.url,t.url);case"pathParamsOrQueryParamsChange":return!sh(e.url,t.url)||!Uc(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Oh(e,t)||!Uc(e.queryParams,t.queryParams);case"paramsChange":default:return!Oh(e,t)}}(a,i,i.routeConfig.runGuardsAndResolvers);u?s.canActivateChecks.push(new Cd(r)):(i.data=a.data,i._resolvedData=a._resolvedData),Nd(e,t,i.component?o?o.children:null:n,r,s),u&&o&&o.outlet&&o.outlet.isActivated&&s.canDeactivateChecks.push(new Id(o.outlet.component,a))}else a&&Ed(t,o,s),s.canActivateChecks.push(new Cd(r)),Nd(e,null,i.component?o?o.children:null:n,r,s)}(e,i[e.value.outlet],n,r.concat([e.value]),s),delete i[e.value.outlet]}),Hc(i,(e,t)=>Ed(e,n.getContext(t),s)),s}function Ed(e,t,n){const r=_h(e),s=e.value;Hc(r,(e,r)=>{Ed(e,s.component?t?t.children.getContext(r):null:t,n)}),n.canDeactivateChecks.push(new Id(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}class $d{}function Td(e){return new k(t=>t.error(e))}class Ad{constructor(e,t,n,r,s,i){this.rootComponentType=e,this.config=t,this.urlTree=n,this.url=r,this.paramsInheritanceStrategy=s,this.relativeLinkResolution=i}recognize(){const e=dd(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,Pc);if(null===t)return null;const n=new Th([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Pc,this.rootComponentType,null,this.urlTree.root,-1,{}),r=new Ih(n,t),s=new Ah(this.url,r);return this.inheritParamsAndData(s._root),s}inheritParamsAndData(e){const t=e.value,n=$h(t,this.paramsInheritanceStrategy);t.params=Object.freeze(n.params),t.data=Object.freeze(n.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,n){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,n)}processChildren(e,t){const n=[];for(const s of Object.keys(t.children)){const r=t.children[s],i=ld(e,s),a=this.processSegmentGroup(i,r,s);if(null===a)return null;n.push(...a)}const r=Fd(n);return r.sort((e,t)=>e.value.outlet===Pc?-1:t.value.outlet===Pc?1:e.value.outlet.localeCompare(t.value.outlet)),r}processSegment(e,t,n,r){for(const s of e){const e=this.processSegmentAgainstRoute(s,t,n,r);if(null!==e)return e}return md(t,n,r)?[]:null}processSegmentAgainstRoute(e,t,n,r){if(e.redirectTo||!fd(e,t,n,r))return null;let s,i=[],a=[];if("**"===e.path){const r=n.length>0?Gc(n).parameters:{};s=new Th(n,r,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Md(e),ud(e),e.component,e,Dd(t),Od(t)+n.length,Ld(e))}else{const r=hd(t,e,n);if(!r.matched)return null;i=r.consumedSegments,a=n.slice(r.lastChild),s=new Th(i,r.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Md(e),ud(e),e.component,e,Dd(t),Od(t)+i.length,Ld(e))}const o=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:u,slicedSegments:l}=dd(t,i,a,o.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution);if(0===l.length&&u.hasChildren()){const e=this.processChildren(o,u);return null===e?null:[new Ih(s,e)]}if(0===o.length&&0===l.length)return[new Ih(s,[])];const c=ud(e)===r,h=this.processSegment(o,u,l,c?Pc:r);return null===h?null:[new Ih(s,h)]}}function Rd(e){const t=e.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function Fd(e){const t=[],n=new Set;for(const r of e){if(!Rd(r)){t.push(r);continue}const e=t.find(e=>r.value.routeConfig===e.value.routeConfig);void 0!==e?(e.children.push(...r.children),n.add(e)):t.push(r)}for(const r of n){const e=Fd(r.children);t.push(new Ih(r.value,e))}return t.filter(e=>!n.has(e))}function Dd(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function Od(e){let t=e,n=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,n+=t._segmentIndexShift?t._segmentIndexShift:0;return n-1}function Md(e){return e.data||{}}function Ld(e){return e.resolve||{}}function Pd(e){return Bl(t=>{const n=e(t);return n?V(n).pipe(T(()=>t)):El(t)})}class zd extends class{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}{}const Vd=new zn("ROUTES");class Bd{constructor(e,t,n,r){this.loader=e,this.compiler=t,this.onLoadStartListener=n,this.onLoadEndListener=r}load(e,t){if(t._loader$)return t._loader$;this.onLoadStartListener&&this.onLoadStartListener(t);const n=this.loadModuleFactory(t.loadChildren).pipe(T(n=>{this.onLoadEndListener&&this.onLoadEndListener(t);const r=n.create(e);return new Qh(jc(r.injector.get(Vd,void 0,Ce.Self|Ce.Optional)).map(od),r)}),ec(e=>{throw t._loader$=void 0,e}));return t._loader$=new Q(n,()=>new N).pipe(X()),t._loader$}loadModuleFactory(e){return"string"==typeof e?V(this.loader.load(e)):Kc(e()).pipe(q(e=>e instanceof qa?El(e):V(this.compiler.compileModuleAsync(e))))}}class Wd{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new Ud,this.attachRef=null}}class Ud{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const n=this.getOrCreateContext(e);n.outlet=t,this.contexts.set(e,n)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new Wd,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}class qd{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function jd(e){throw e}function Gd(e,t,n){return t.parse("/")}function Hd(e,t){return El(null)}const Kd={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Xd={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Zd=(()=>{class e{constructor(e,t,n,r,s,i,a,o){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=n,this.location=r,this.config=o,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new N,this.errorHandler=jd,this.malformedUriErrorHandler=Gd,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Hd,afterPreactivation:Hd},this.urlHandlingStrategy=new qd,this.routeReuseStrategy=new zd,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=s.get(Ua),this.console=s.get(Ro);const u=s.get(jo);this.isNgZoneEnabled=u instanceof jo&&jo.isInAngularZone(),this.resetConfig(o),this.currentUrlTree=new th(new nh([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new Bd(i,a,e=>this.triggerEvent(new Ac(e)),e=>this.triggerEvent(new Rc(e))),this.routerState=Nh(this.currentUrlTree,this.rootComponentType),this.transitions=new $l({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(Yl(e=>0!==e.id),T(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),Bl(e=>{let n=!1,r=!1;return El(e).pipe(gc(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Bl(e=>{const n=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return El(e).pipe(Bl(e=>{const n=this.transitions.getValue();return t.next(new kc(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),n!==this.transitions.getValue()?Pl:Promise.resolve(e)}),function(e,t,n,r){return Bl(s=>function(e,t,n,r,s){return new wd(e,t,n,r,s).apply()}(e,t,n,s.extractedUrl,r).pipe(T(e=>Object.assign(Object.assign({},s),{urlAfterRedirects:e}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),gc(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,n,r,s){return q(i=>function(e,t,n,r,s="emptyOnly",i="legacy"){try{const a=new Ad(e,t,n,r,s,i).recognize();return null===a?Td(new $d):El(a)}catch(a){return Td(a)}}(e,t,i.urlAfterRedirects,n(i.urlAfterRedirects),r,s).pipe(T(e=>Object.assign(Object.assign({},i),{targetSnapshot:e}))))}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),gc(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,e),this.browserUrlTree=e.urlAfterRedirects);const n=new Sc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:r,source:s,restoredState:i,extras:a}=e,o=new kc(n,this.serializeUrl(r),s,i);t.next(o);const u=Nh(r,this.rootComponentType).snapshot;return El(Object.assign(Object.assign({},e),{targetSnapshot:u,urlAfterRedirects:r,extras:Object.assign(Object.assign({},a),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),Pl}),Pd(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:i,replaceUrl:a}}=e;return this.hooks.beforePreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!i,replaceUrl:!!a})}),gc(e=>{const t=new Nc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),T(e=>Object.assign(Object.assign({},e),{guards:_d(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return q(n=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:a}}=n;return 0===a.length&&0===i.length?El(Object.assign(Object.assign({},n),{guardsResult:!0})):function(e,t,n,r){return V(e).pipe(q(e=>function(e,t,n,r,s){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?El(i.map(i=>{const a=Sd(i,t,s);let o;if(function(e){return e&&Jh(e.canDeactivate)}(a))o=Kc(a.canDeactivate(e,t,n,r));else{if(!Jh(a))throw new Error("Invalid CanDeactivate guard");o=Kc(a(e,t,n,r))}return o.pipe(fc())})).pipe(nd()):El(!0)}(e.component,e.route,n,t,r)),fc(e=>!0!==e,!0))}(a,r,s,e).pipe(q(n=>n&&"boolean"==typeof n?function(e,t,n,r){return V(t).pipe(rc(t=>Ll(function(e,t){return null!==e&&t&&t(new Fc(e)),El(!0)}(t.route.parent,r),function(e,t){return null!==e&&t&&t(new Oc(e)),El(!0)}(t.route,r),function(e,t,n){const r=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>Vl(()=>El(t.guards.map(s=>{const i=Sd(s,t.node,n);let a;if(function(e){return e&&Jh(e.canActivateChild)}(i))a=Kc(i.canActivateChild(r,e));else{if(!Jh(i))throw new Error("Invalid CanActivateChild guard");a=Kc(i(r,e))}return a.pipe(fc())})).pipe(nd())));return El(s).pipe(nd())}(e,t.path,n),function(e,t,n){const r=t.routeConfig?t.routeConfig.canActivate:null;return r&&0!==r.length?El(r.map(r=>Vl(()=>{const s=Sd(r,t,n);let i;if(function(e){return e&&Jh(e.canActivate)}(s))i=Kc(s.canActivate(t,e));else{if(!Jh(s))throw new Error("Invalid CanActivate guard");i=Kc(s(t,e))}return i.pipe(fc())}))).pipe(nd()):El(!0)}(e,t.route,n))),fc(e=>!0!==e,!0))}(r,i,e,t):El(n)),T(e=>Object.assign(Object.assign({},n),{guardsResult:e})))})}(this.ngModule.injector,e=>this.triggerEvent(e)),gc(e=>{if(ed(e.guardsResult)){const t=Bc(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}const t=new Ec(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),Yl(e=>!!e.guardsResult||(this.cancelNavigationTransition(e,""),!1)),Pd(e=>{if(e.guards.canActivateChecks.length)return El(e).pipe(gc(e=>{const t=new $c(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),Bl(e=>{let t=!1;return El(e).pipe((n=this.paramsInheritanceStrategy,r=this.ngModule.injector,q(e=>{const{targetSnapshot:t,guards:{canActivateChecks:s}}=e;if(!s.length)return El(e);let i=0;return V(s).pipe(rc(e=>function(e,t,n,r){return function(e,t,n,r){const s=Object.keys(e);if(0===s.length)return El({});const i={};return V(s).pipe(q(s=>function(e,t,n,r){const s=Sd(e,t,r);return Kc(s.resolve?s.resolve(t,n):s(t,n))}(e[s],t,n,r).pipe(gc(e=>{i[s]=e}))),sc(1),q(()=>Object.keys(i).length===s.length?El(i):Pl))}(e._resolve,e,t,r).pipe(T(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),$h(e,n).resolve),null)))}(e.route,t,n,r)),gc(()=>i++),sc(1),q(t=>i===s.length?El(e):Pl))})),gc({next:()=>t=!0,complete:()=>{t||this.cancelNavigationTransition(e,"At least one route resolver didn't emit any value.")}}));var n,r}),gc(e=>{const t=new Tc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}))}),Pd(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:i,replaceUrl:a}}=e;return this.hooks.afterPreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!i,replaceUrl:!!a})}),T(e=>{const t=function(e,t,n){const r=Mh(e,t._root,n?n._root:void 0);return new Sh(r,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),gc(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,e),this.browserUrlTree=e.urlAfterRedirects)}),(i=this.rootContexts,a=this.routeReuseStrategy,o=e=>this.triggerEvent(e),T(e=>(new Zh(a,e.targetRouterState,e.currentRouterState,o).activate(i),e))),gc({next(){n=!0},complete(){n=!0}}),(s=()=>{n||r||this.cancelNavigationTransition(e,`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`),this.currentNavigation=null},e=>e.lift(new vc(s))),ec(n=>{if(r=!0,(s=n)&&s.ngNavigationCancelingError){const r=ed(n.url);r||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const s=new Ic(e.id,this.serializeUrl(e.extractedUrl),n.message);t.next(s),r?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const r=new _c(e.id,this.serializeUrl(e.extractedUrl),n);t.next(r);try{e.resolve(this.errorHandler(n))}catch(i){e.reject(i)}}var s;return Pl}));var s,i,a,o}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const t=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,t)&&setTimeout(()=>{const{source:e,state:n,urlTree:r}=t,s={replaceUrl:!0};if(n){const e=Object.assign({},n);delete e.navigationId,delete e.\u0275routerPageId,0!==Object.keys(e).length&&(s.state=e)}this.scheduleNavigation(r,e,n,s)},0),this.lastLocationChangeInfo=t}))}extractLocationChangeInfoFromEvent(e){var t;return{source:"popstate"===e.type?"popstate":"hashchange",urlTree:this.parseUrl(e.url),state:(null===(t=e.state)||void 0===t?void 0:t.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,t){if(!e)return!0;const n=t.urlTree.toString()===e.urlTree.toString();return!(t.transitionId===e.transitionId&&n&&("hashchange"===t.source&&"popstate"===e.source||"popstate"===t.source&&"hashchange"===e.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){sd(e),this.config=e.map(od),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,t={}){const{relativeTo:n,queryParams:r,fragment:s,queryParamsHandling:i,preserveFragment:a}=t,o=n||this.routerState.root,u=a?this.currentUrlTree.fragment:s;let l=null;switch(i){case"merge":l=Object.assign(Object.assign({},this.currentUrlTree.queryParams),r);break;case"preserve":l=this.currentUrlTree.queryParams;break;default:l=r||null}return null!==l&&(l=this.removeEmptyProps(l)),function(e,t,n,r,s){if(0===n.length)return Vh(t.root,t.root,t,r,s);const i=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new Wh(!0,0,e);let t=0,n=!1;const r=e.reduce((e,r,s)=>{if("object"==typeof r&&null!=r){if(r.outlets){const t={};return Hc(r.outlets,(e,n)=>{t[n]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(r.segmentPath)return[...e,r.segmentPath]}return"string"!=typeof r?[...e,r]:0===s?(r.split("/").forEach((r,s)=>{0==s&&"."===r||(0==s&&""===r?n=!0:".."===r?t++:""!=r&&e.push(r))}),e):[...e,r]},[]);return new Wh(n,t,r)}(n);if(i.toRoot())return Vh(t.root,new nh([],{}),t,r,s);const a=function(e,t,n){if(e.isAbsolute)return new Uh(t.root,!0,0);if(-1===n.snapshot._lastPathIndex){const e=n.snapshot._urlSegment;return new Uh(e,e===t.root,0)}const r=Ph(e.commands[0])?0:1;return function(e,t,n){let r=e,s=t,i=n;for(;i>s;){if(i-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new Uh(r,!1,s-i)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+r,e.numberOfDoubleDots)}(i,t,e),o=a.processChildren?jh(a.segmentGroup,a.index,i.commands):qh(a.segmentGroup,a.index,i.commands);return Vh(a.segmentGroup,o,t,r,s)}(o,this.currentUrlTree,e,l,null!=u?u:null)}navigateByUrl(e,t={skipLocationChange:!1}){const n=ed(e)?e:this.parseUrl(e),r=this.urlHandlingStrategy.merge(n,this.rawUrlTree);let s=null;return"computed"===this.canceledNavigationResolution&&(0===this.currentPageId||t.skipLocationChange||t.replaceUrl)&&(s=this.location.getState()),this.scheduleNavigation(r,"imperative",s,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const n=e[t];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(n){t=this.malformedUriErrorHandler(n,this.urlSerializer,e)}return t}isActive(e,t){let n;if(n=!0===t?Object.assign({},Kd):!1===t?Object.assign({},Xd):t,ed(e))return Yc(this.currentUrlTree,e,n);const r=this.parseUrl(e);return Yc(this.currentUrlTree,r,n)}removeEmptyProps(e){return Object.keys(e).reduce((t,n)=>{const r=e[n];return null!=r&&(t[n]=r),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new Cc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,n,r,s){if(this.disposed)return Promise.resolve(!1);const i=this.getTransition(),a="imperative"!==t&&"imperative"===(null==i?void 0:i.source),o=(this.lastSuccessfulId===i.id||this.currentNavigation?i.rawUrl:i.urlAfterRedirects).toString()===e.toString();if(a&&o)return Promise.resolve(!0);let u,l,c;s?(u=s.resolve,l=s.reject,c=s.promise):c=new Promise((e,t)=>{u=e,l=t});const h=++this.navigationId;let d;return d="computed"===this.canceledNavigationResolution?n&&n.\u0275routerPageId?n.\u0275routerPageId:this.currentPageId+1:0,this.setTransition({id:h,targetPageId:d,source:t,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:r,resolve:u,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(e=>Promise.reject(e))}setBrowserUrl(e,t){const n=this.urlSerializer.serialize(e),r=Object.assign(Object.assign({},t.extras.state),this.generateNgRouterState(t.id,t.targetPageId));this.location.isCurrentPathEqualTo(n)||t.extras.replaceUrl?this.location.replaceState(n,"",r):this.location.go(n,"",r)}resetStateAndUrl(e,t,n){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,t){"computed"===this.canceledNavigationResolution?"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy||this.location.historyGo(this.currentPageId-e.targetPageId):this.resetUrlToCurrentUrlTree();const n=new Ic(e.id,this.serializeUrl(e.extractedUrl),t);this.triggerEvent(n),e.resolve(!1)}generateNgRouterState(e,t){return"computed"===this.canceledNavigationResolution?{navigationId:e,"\u0275routerPageId":t}:{navigationId:e}}}return e.\u0275fac=function(t){return new(t||e)(nr(Bn),nr(ih),nr(Ud),nr(Pu),nr(oi),nr(pu),nr(Wo),nr(void 0))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Yd=(()=>{class e{constructor(e,t,n,r,s){this.parentContexts=e,this.location=t,this.resolver=n,this.changeDetector=s,this.activated=null,this._activatedRoute=null,this.activateEvents=new lo,this.deactivateEvents=new lo,this.name=r||Pc,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const n=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),r=this.parentContexts.getOrCreateContext(this.name).children,s=new Qd(e,r,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,s),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(vi(Ud),vi(Ga),vi(sa),("name",function(e,t){const n=e.attrs;if(n){const e=n.length;let r=0;for(;r<e;){const s=n[r];if(ln(s))break;if(0===s)r+=2;else if("number"==typeof s)for(r++;r<e&&"string"==typeof n[r];)r++;else{if(s===t)return n[r+1];r+=2}}}return null}(Rt(),"name")),vi(Da))},e.\u0275dir=Ye({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class Qd{constructor(e,t,n){this.route=e,this.childContexts=t,this.parent=n}get(e,t){return e===Eh?this.route:e===Ud?this.childContexts:this.parent.get(e,t)}}class Jd{}class ep{preload(e,t){return El(null)}}let tp=(()=>{class e{constructor(e,t,n,r,s){this.router=e,this.injector=r,this.preloadingStrategy=s,this.loader=new Bd(t,n,t=>e.triggerEvent(new Ac(t)),t=>e.triggerEvent(new Rc(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(Yl(e=>e instanceof Cc),rc(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(Ua);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,t){const n=[];for(const r of t)if(r.loadChildren&&!r.canLoad&&r._loadedConfig){const e=r._loadedConfig;n.push(this.processRoutes(e.module,e.routes))}else r.loadChildren&&!r.canLoad?n.push(this.preloadConfig(e,r)):r.children&&n.push(this.processRoutes(e,r.children));return V(n).pipe(H(),T(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>(t._loadedConfig?El(t._loadedConfig):this.loader.load(e.injector,t)).pipe(q(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(nr(Zd),nr(pu),nr(Wo),nr(oi),nr(Jd))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),np=(()=>{class e{constructor(e,t,n={}){this.router=e,this.viewportScroller=t,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof kc?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Cc&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Lc&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new Lc(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(t){return new(t||e)(nr(Zd),nr(Xu),nr(void 0))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const rp=new zn("ROUTER_CONFIGURATION"),sp=new zn("ROUTER_FORROOT_GUARD"),ip=[Pu,{provide:ih,useClass:ah},{provide:Zd,useFactory:function(e,t,n,r,s,i,a,o={},u,l){const c=new Zd(null,e,t,n,r,s,i,jc(a));return u&&(c.urlHandlingStrategy=u),l&&(c.routeReuseStrategy=l),function(e,t){e.errorHandler&&(t.errorHandler=e.errorHandler),e.malformedUriErrorHandler&&(t.malformedUriErrorHandler=e.malformedUriErrorHandler),e.onSameUrlNavigation&&(t.onSameUrlNavigation=e.onSameUrlNavigation),e.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=e.paramsInheritanceStrategy),e.relativeLinkResolution&&(t.relativeLinkResolution=e.relativeLinkResolution),e.urlUpdateStrategy&&(t.urlUpdateStrategy=e.urlUpdateStrategy)}(o,c),o.enableTracing&&c.events.subscribe(e=>{var t,n;null===(t=console.group)||void 0===t||t.call(console,`Router Event: ${e.constructor.name}`),console.log(e.toString()),console.log(e),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[ih,Ud,Pu,oi,pu,Wo,Vd,rp,[class{},new ar],[class{},new ar]]},Ud,{provide:Eh,useFactory:function(e){return e.routerState.root},deps:[Zd]},{provide:pu,useClass:gu},tp,ep,class{preload(e,t){return t().pipe(ec(()=>El(null)))}},{provide:rp,useValue:{enableTracing:!1}}];function ap(){return new au("Router",Zd)}let op=(()=>{class e{constructor(e,t){}static forRoot(t,n){return{ngModule:e,providers:[ip,hp(t),{provide:sp,useFactory:cp,deps:[[Zd,new ar,new or]]},{provide:rp,useValue:n||{}},{provide:Fu,useFactory:lp,deps:[Iu,[new ir(Ou),new ar],rp]},{provide:np,useFactory:up,deps:[Zd,Xu,rp]},{provide:Jd,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:ep},{provide:au,multi:!0,useFactory:ap},[dp,{provide:Io,multi:!0,useFactory:pp,deps:[dp]},{provide:mp,useFactory:fp,deps:[dp]},{provide:Ao,multi:!0,useExisting:mp}]]}}static forChild(t){return{ngModule:e,providers:[hp(t)]}}}return e.\u0275fac=function(t){return new(t||e)(nr(sp,8),nr(Zd,8))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({}),e})();function up(e,t,n){return n.scrollOffset&&t.setOffset(n.scrollOffset),new np(e,t,n)}function lp(e,t,n={}){return n.useHash?new Lu(e,t):new Mu(e,t)}function cp(e){return"guarded"}function hp(e){return[{provide:Vn,multi:!0,useValue:e},{provide:Vd,multi:!0,useValue:e}]}let dp=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.resultOfPreactivationDone=new N}appInitializer(){return this.injector.get(Su,Promise.resolve(null)).then(()=>{let e=null;const t=new Promise(t=>e=t),n=this.injector.get(Zd),r=this.injector.get(rp);return"disabled"===r.initialNavigation?(n.setUpLocationChangeListener(),e(!0)):"enabled"===r.initialNavigation||"enabledBlocking"===r.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?El(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),n.initialNavigation()):e(!0),t})}bootstrapListener(e){const t=this.injector.get(rp),n=this.injector.get(tp),r=this.injector.get(np),s=this.injector.get(Zd),i=this.injector.get(hu);e===i.components[0]&&("enabledNonBlocking"!==t.initialNavigation&&void 0!==t.initialNavigation||s.initialNavigation(),n.setUpPreloading(),r.init(),s.resetRootComponentType(i.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return e.\u0275fac=function(t){return new(t||e)(nr(oi))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function pp(e){return e.appInitializer.bind(e)}function fp(e){return e.bootstrapListener.bind(e)}const mp=new zn("Router Initializer");function gp(e,t,n,r,s,i,a){try{var o=e[i](a),u=o.value}catch(l){return void n(l)}o.done?t(u):Promise.resolve(u).then(r,s)}function bp(e){return function(){var t=this,n=arguments;return new Promise(function(r,s){var i=e.apply(t,n);function a(e){gp(i,r,s,a,o,"next",e)}function o(e){gp(i,r,s,a,o,"throw",e)}a(void 0)})}}class yp{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class vp{refCount(e){return xp("refCount")}incRef(e){return xp("incRef")}timerAvailable(){return!0}time(e){return xp("time")}read(e){return xp("read")}readSync(e){return xp("readSync")}numDataIds(){return xp("numDataIds")}disposeData(e,t){return xp("disposeData")}write(e,t,n){return xp("write")}move(e,t,n,r,s){return xp("move")}memory(){return xp("memory")}floatPrecision(){return xp("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return xp("dispose")}}function xp(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function wp(e){let t=e.length,n=0,r=0;for(;t>0;)r=Math.random()*t|0,t--,n=e[t],e[t]=e[r],e[r]=n}function kp(e,t,n){return Math.max(e,Math.min(t,n))}function Cp(e){return e%2==0?e:e+1}function Ip(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function _p(e,t,n=""){Ip($p(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Sp(e){Ip(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function Np(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Vp(e)&&!n)for(let r=0;r<e.length;++r)Np(e[r],t,n);else t.push(e);return t}function Ep(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function $p(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Tp(e){return e%1==0}function Ap(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Rp(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Fp(e,t=(e=>0),n){return new Promise((r,s)=>{let i=0;const a=()=>{if(e())return void r();i++;const o=t(i);null!=n&&i>=n?s():setTimeout(a,o)};a()})}function Dp(e,t){let n=1,r=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(-1===e[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Op(e,t){const n=t.length;return Ip((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Ip(e.every(e=>Tp(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function Mp(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||s?null:Op(t,e).sort();let a=0;for(let o=0;o<e.length;++o){if(null!=i){if(i[a]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==i[a]||i[a]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),i[a]<=o&&a++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Lp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function Pp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function zp(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Vp(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function Bp(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Wp(e){return"string"==typeof e||e instanceof String}function Up(e){return"number"==typeof e}function qp(e){return Array.isArray(e)?qp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":Up(e)?"float32":Wp(e)?"string":"boolean"==typeof e?"bool":"float32"}function jp(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Gp(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Hp(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Kp(e,t,n,r=!1){const s=new Array;if(1===t.length){const i=t[0]*(r?2:1);for(let t=0;t<i;t++)s[t]=n[e+t]}else{const i=t[0],a=t.slice(1),o=a.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<i;t++)s[t]=Kp(e+t*o,a,n,r)}return s}function Xp(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Kp(0,e,t,n)}function Zp(e,t){const n=Yp(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Yp(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Qp(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return Xp(e,new Float32Array(n));if("int32"===t)return Xp(e,new Int32Array(n));if("bool"===t)return Xp(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Jp(e){e.forEach(t=>{Ip(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function ef(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function tf(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function nf(e){return e&&e.then&&"function"==typeof e.then}class rf{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=sf,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}getAsync(e){var t=this;return bp(function*(){return e in t.flags||(t.flags[e]=yield t.evaluateFlag(e)),t.flags[e]})()}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(nf(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)})}}function sf(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function af(){return uf}let of,uf=null;function lf(){if(null==of){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}of=e}return of}function cf(e,t){const n=function(){const e=lf();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const hf="Abs",df="Acos",pf="Acosh",ff="Add",mf="AddN",gf="All",bf="Any",yf="ArgMax",vf="ArgMin",xf="Asin",wf="Asinh",kf="Atan",Cf="Atanh",If="Atan2",_f="AvgPool",Sf="AvgPoolGrad",Nf="AvgPool3D",Ef="AvgPool3DGrad",$f="BatchMatMul",Tf="BatchToSpaceND",Af="Bincount",Rf="Cast",Ff="Ceil",Df="ClipByValue",Of="Complex",Mf="ComplexAbs",Lf="Concat",Pf="Conv2D",zf="Conv2DBackpropFilter",Vf="Conv2DBackpropInput",Bf="Conv3D",Wf="Conv3DBackpropFilterV2",Uf="Conv3DBackpropInputV2",qf="Cos",jf="Cosh",Gf="Cumsum",Hf="CropAndResize",Kf="DenseBincount",Xf="DepthToSpace",Zf="DepthwiseConv2dNative",Yf="DepthwiseConv2dNativeBackpropFilter",Qf="DepthwiseConv2dNativeBackpropInput",Jf="Diag",em="Dilation2D",tm="Dilation2DBackpropInput",nm="Dilation2DBackpropFilter",rm="RealDiv",sm="Einsum",im="Elu",am="EluGrad",om="Erf",um="Equal",lm="Exp",cm="ExpandDims",hm="Expm1",dm="FFT",pm="Fill",fm="FlipLeftRight",mm="Floor",gm="FloorDiv",bm="FusedBatchNorm",ym="GatherV2",vm="GatherNd",xm="Greater",wm="GreaterEqual",km="Identity",Cm="IFFT",Im="Imag",_m="IsFinite",Sm="IsInf",Nm="IsNan",Em="LeakyRelu",$m="Less",Tm="LessEqual",Am="LinSpace",Rm="Log",Fm="Log1p",Dm="LogicalAnd",Om="LogicalNot",Mm="LogicalOr",Lm="LRN",Pm="LRNGrad",zm="Max",Vm="Maximum",Bm="MaxPool",Wm="MaxPoolGrad",Um="MaxPool3D",qm="MaxPool3DGrad",jm="MaxPoolWithArgmax",Gm="Mean",Hm="Min",Km="Minimum",Xm="MirrorPad",Zm="Mod",Ym="Multinomial",Qm="Multiply",Jm="Neg",eg="NotEqual",tg="NonMaxSuppressionV3",ng="NonMaxSuppressionV4",rg="NonMaxSuppressionV5",sg="OnesLike",ig="OneHot",ag="Pack",og="PadV2",ug="Pow",lg="Prelu",cg="Prod",hg="Range",dg="Real",pg="Reciprocal",fg="Relu",mg="Reshape",gg="ResizeNearestNeighbor",bg="ResizeNearestNeighborGrad",yg="ResizeBilinear",vg="ResizeBilinearGrad",xg="Relu6",wg="Reverse",kg="Round",Cg="Rsqrt",Ig="ScatterNd",_g="Select",Sg="Selu",Ng="Slice",Eg="Sin",$g="Sinh",Tg="Sign",Ag="Sigmoid",Rg="Softplus",Fg="Sqrt",Dg="Sum",Og="SpaceToBatchND",Mg="SplitV",Lg="Softmax",Pg="SparseFillEmptyRows",zg="SparseReshape",Vg="SparseToDense",Bg="SquaredDifference",Wg="Square",Ug="StridedSlice",qg="Sub",jg="Tan",Gg="Tanh",Hg="Tile",Kg="TopK",Xg="Transform",Zg="Transpose",Yg="Unique",Qg="Unpack",Jg="UnsortedSegmentSum",eb="ZerosLike",tb="Step",nb="RotateWithOffset",rb="_FusedMatMul",sb="FusedConv2D",ib="FusedDepthwiseConv2D",ab=cf("kernelRegistry",()=>new Map),ob=cf("gradRegistry",()=>new Map);function ub(e,t){const n=pb(e,t);return ab.get(n)}function lb(e){return ob.get(e)}function cb(e){const t=ab.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[i,a]=s,[o]=i.split("_");o===e&&n.push(a)}return n}function hb(e){const{kernelName:t,backendName:n}=e,r=pb(t,n);ab.has(r)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),ab.set(r,e)}function db(e){const{kernelName:t}=e;ob.has(t)&&af().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),ob.set(t,e)}function pb(e,t){return`${t}_${e}`}function fb(e,t){return"string"===t?bb(e):mb([e],t)}function mb(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Np(e)),af().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function gb(){return af().platform.now()}function bb(e,t="utf-8"){return t=t||"utf-8",af().platform.encode(e,t)}function yb(e,t="utf-8"){return t=t||"utf-8",af().platform.decode(e,t)}class vb{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new wb)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let i;const a=gb();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();i=Promise.resolve({kernelMs:gb()-a})}if(af().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then(n=>{xb(n,t.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then(e=>e.kernelMs),extraInfo:i.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:i}=e;n.forEach(e=>{Promise.all([e.data(),r,i]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function xb(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class wb{logKernelProfile(e,t,n,r,s,i){const a="number"==typeof r?Rp(`${r}ms`,9):r.error,o=Rp(e,25),u=t.rank,l=t.size,c=Rp(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${a}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function kb(e,t,n,r){const s=Hp(t),i=function(e,t,n,r){const s=Ep(t),i=r[r.length-1],a=new Array(i).fill(0),o=t.length,u="complex64"===n?Sb(e):e;if(o>1)for(let l=0;l<s/i;l++){const e=l*i;for(let t=0;t<i;t++)a[t]=Math.max(a[t],Cb(u[e+t],0,n).length)}return a}(e,t,n,s),a=t.length,o=_b(e,t,n,s,i),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${a}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(e=>"    "+e).join("\n")),u.join("\n")}function Cb(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Wp(e)?`'${e}'`:"bool"===n?Ib(e):parseFloat(e.toFixed(7)).toString(),Rp(r,t)}function Ib(e){return 0===e?"false":"true"}function _b(e,t,n,r,s,i=!0){const a="complex64"===n?2:1,o=t[0],u=t.length;if(0===u)return"complex64"===n?[Cb(Sb(e)[0],0,n)]:"bool"===n?[Ib(e[0])]:[e[0].toString()];if(1===u){if(o>20){let t=Array.from(e.slice(0,3*a)),r=Array.from(e.slice((o-3)*a,o*a));return"complex64"===n&&(t=Sb(t),r=Sb(r)),["["+t.map((e,t)=>Cb(e,s[t],n)).join(", ")+", ..., "+r.map((e,t)=>Cb(e,s[o-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?Sb(e):Array.from(e)).map((e,t)=>Cb(e,s[t],n)).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),h=r[0]*a,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*h;d.push(..._b(e.slice(r,r+h),l,n,c,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*h;d.push(..._b(e.slice(r,r+h),l,n,c,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h;d.push(..._b(e.slice(t,t+h),l,n,c,s,m===o-1))}const p=2===u?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<u;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function Sb(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Nb{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Ep(e),null!=n){const e=n.length;Ip(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Pp(t,this.size),this.strides=Hp(e)}set(e,...t){0===t.length&&(t=[0]),Ip(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t])throw new Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Eb().makeTensor(this.values,this.shape,this.dtype)}}let Eb=null,$b=null,Tb=null;class Ab{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ep(e),this.strides=Hp(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var e=this;return bp(function*(){const t=yield e.data();return $b.buffer(e.shape,e.dtype,t)})()}bufferSync(){return $b.buffer(this.shape,this.dtype,this.dataSync())}array(){var e=this;return bp(function*(){const t=yield e.data();return Xp(e.shape,t,"complex64"===e.dtype)})()}arraySync(){return Xp(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var e=this;return bp(function*(){e.throwIfDisposed();const t=Eb().read(e.dataId);if("string"===e.dtype){const e=yield t;try{return e.map(e=>yb(e))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataSync(){this.throwIfDisposed();const e=Eb().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>yb(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){var e=this;return bp(function*(){e.throwIfDisposed();const t=yield Eb().read(e.dataId);return"string"===e.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(Eb().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return $b.print(this,e)}clone(){return this.throwIfDisposed(),$b.clone(this)}toString(e=!1){return kb(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),$b.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Eb().makeVariable(this,e,t,n)}}function Rb(){return cf("Tensor",()=>Ab)}Object.defineProperty(Ab,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Rb();class Fb extends Ab{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!$p(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Eb().disposeTensor(this),this.dataId=e.dataId,Eb().incRef(this,null)}dispose(){Eb().disposeVariable(this),this.isDisposedInternal=!0}}var Db,Ob,Mb,Lb,Pb;Object.defineProperty(Fb,Symbol.hasInstance,{value:e=>e instanceof Ab&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Db||(Db={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Ob||(Ob={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Mb||(Mb={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Lb||(Lb={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Pb||(Pb={}));const zb={float32:Lb,int32:Ob,bool:Mb,complex64:Pb};function Vb(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return zb[e][t]}function Bb(e){return Vb(e,"int32")}function Wb(e,t){if(e.dtype===t.dtype)return[e,t];const n=Vb(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ub(e,t){return t.some(t=>t.id===e.id)}function qb(e){const t=[];return jb(e,t,new Set),t}function jb(e,t,n){if(null==e)return;if(e instanceof Ab)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const i in s){const e=s[i];n.has(e)||(n.add(e),jb(e,t,n))}}function Gb(e){return null!=e.kernelName}class Hb{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Kb{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Hb}ready(){var e=this;return bp(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const t=e.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(yield e.initializeBackend(r).success)return void(yield e.setBackend(r))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}setBackend(e){var t=this;return bp(function*(){if(null==t.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(t.backendName=e,null==t.registry[e]){t.backendInstance=null;const{success:n,asyncInit:r}=t.initializeBackend(e);if(!(r?yield n:n))return!1}return t.backendInstance=t.registry[e],t.setupRegisteredKernels(),t.profiler=new vb(t.backendInstance),!0})()}setupRegisteredKernels(){cb(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){cb(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof vp||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),i=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Kb.nextTensorId++}nextVariableId(){return Kb.nextVariableId++}clone(e){const t=Zb.runKernel(km,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>Zb.runKernel(Rf,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==ub(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const i=r-t-s-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;let a,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=Gb(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Gb(e)){const{kernelName:t,inputs:s,attrs:i}=e,u=ub(t,this.backendName);Ip(null!=u,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),a=()=>{const e=this.backend.numDataIds();o=u.kernelFunc({inputs:s,attrs:i,backend:this.backend});const a=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,a);const l=a.map(e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:r}=e;return this.makeTensorFromDataId(t,n,r)});if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};a=()=>{const e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,s));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,h=Gb(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(u,l,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=a()}),r&&this.addTapeNode(u,l,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const r=lb(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let i;r.saveAllInputs?(Ip(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(e=>t[e])):i=e.map(e=>t[e]);const a=n.filter((e,t)=>s[t]);return i.concat(a)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");r=r||this.backend;let s=e;"string"===(n=n||"float32")&&Wp(e[0])&&(s=e.map(e=>bb(e)));const i=r.write(s,t,n),a=new Ab(t,n,i,this.nextTensorId());if(this.trackTensor(a,r),"string"===n){const e=this.state.tensorInfo.get(i),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return a}makeTensorFromDataId(e,t,n,r){const s=new Ab(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new Fb(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Bp(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Fb||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Bp(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var t=this;return bp(function*(){t.state.profiling=!0;const n=t.state.numBytes,r=t.state.numTensors;t.state.activeProfile.kernels=[],t.state.activeProfile.result=yield e(),t.state.profiling=!1,t.state.activeProfile.peakBytes=Math.max(...t.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),t.state.activeProfile.newBytes=t.state.numBytes-n,t.state.activeProfile.newTensors=t.state.numTensors-r;for(const e of t.state.activeProfile.kernels)e.kernelTimeMs=yield e.kernelTimeMs,e.extraInfo=yield e.extraInfo;return t.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=lb(e);null!=o&&(r=o.gradFunc),null!=r&&(a.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=Yp(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],s,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=qb(e),n=new Set(t.map(e=>e.id));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(Ip(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Ip(s instanceof Ab,()=>"The result y returned by f() must be a tensor.");const i=function(e,t,n){const r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],i=n.inputs;for(const e in i){const a=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[a.id]){n.outputs.forEach(e=>r[e.id]=!0),o=!0,s[n.id]=!0;break}if(o)break}}const i={};i[n.id]=!0;const a={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(i[t.outputs[e].id]){for(const e in n)i[n[e].id]=!0,a[t.id]=!0;break}}const o=[];for(let u=0;u<e.length;u++){const t=e[u];if(s[t.id]&&a[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!r&&0===i.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=Zp(Ep(e),"float32");return Zb.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const i=t[s],a=[];if(i.outputs.forEach(t=>{const n=e[t.id];a.push(null!=n?n:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const t in i.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n(()=>o[t]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const a=i.inputs[t];if(!$p(s.shape,a.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${a.shape}'`);if(null==e[a.id])e[a.id]=s;else{const t=e[a.id];e[a.id]=r(t,s),t.dispose()}}}}(e,i,e=>this.tidy(e),Yb);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(e){return Ip(jp(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;Ip(t.every(e=>e instanceof Ab),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Ip(n.value instanceof Ab,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Ip(jp(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),i=Array.isArray(s)?s:[s];Ip(i.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Ip(i.every(e=>e instanceof Ab),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const a={};return i.forEach((e,t)=>{a[t]=()=>e}),a},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var t=this;return bp(function*(){const n=gb(),r=yield t.backend.time(e);return r.wallMs=gb()-n,r})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Hb;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Xb(){const e=lf();if(null==e._tfengine){const t=new rf(e);e._tfengine=new Kb(t)}return uf=e._tfengine.ENV,Eb=()=>e._tfengine,e._tfengine}Kb.nextTensorId=0,Kb.nextVariableId=0;const Zb=Xb();function Yb(e,t){return Zb.runKernel(ff,{a:e,b:t})}function Qb(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Jb(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ey=af();function ty(e,t){let n=e;if(Vp(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Vp(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&af().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ny(e,r,[]),r}function ny(e,t,n){if(n=n||[],!Array.isArray(e)&&!Vp(e))return void Ip(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Ip(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Ip(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)ny(e[s],r,n.concat(s))}function ry(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function sy(e,t,n,r="numeric"){if(e instanceof Ab)return ry(r,e.dtype,t,n),e;let s=qp(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),ry(r,s,t,n),null==e||!Vp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);const i=ty(e,s);Vp(e)||Array.isArray(e)||(e=[e]);const a="string"!==s?mb(e,s):Np(e,[],!0);return Zb.makeTensor(a,i,s)}function iy(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,s)=>sy(e,`${t}[${s}]`,n,r))}function ay(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...e)=>{Zb.startScope(n);try{const t=r(...e);return nf(t)&&console.error("Cannot return a Promise inside of tidy."),Zb.endScope(t),t}catch(t){throw Zb.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}ey.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ey.registerFlag("IS_BROWSER",()=>Jb()),ey.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),ey.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ey.registerFlag("PROD",()=>!1),ey.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ey.getBool("DEBUG")),ey.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ey.registerFlag("IS_TEST",()=>!1),ey.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ey.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const oy=ay({complex_:function(e,t){const n=sy(e,"real","complex"),r=sy(t,"imag","complex");return _p(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),Zb.runKernel(Of,{real:n,imag:r})}});function uy(e,t,n,r){if(null==r&&(r=qp(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Vp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Jp(t);const e=Ep(t),r=Ep(n);Ip(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Ep(t.slice(s));Ip(n[s]===t[s]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return Vp(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?mb(e,r):Np(e,[],!0),Zb.makeTensor(e,t,r)}function ly(e,t,n){return uy(e,t,ty(e,n),n)}const cy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function hy(e,t){return dy.apply(this,arguments)}function dy(){return(dy=bp(function*(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let i=0;i<s.length;++i){const a=s[i],o=Array.isArray(e)?e[i].tensor:e[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const u={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(function(){var e=bp(function*(e){const t=yield o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+4*t.length,r=new Uint8Array(n);let s=0;for(let i=0;i<t.length;i++){const e=t[i],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=4,r.set(e,s),s+=e.length}e(r)});return function(t){return e.apply(this,arguments)}}());r.push(e)}else r.push(o.data());null!=t&&(u.group=t),n.push(u)}return{data:py(yield Promise.all(r)),specs:n}})).apply(this,arguments)}function py(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength}),r.buffer}const fy="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function my(e){return fy?Buffer.byteLength(e):new Blob([e]).size}function gy(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let r=0;return e.forEach(e=>{n.set(new Uint8Array(e),r),r+=e.byteLength}),n.buffer}function by(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:my(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:my(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function yy(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let a=0;a<r.length;a++){const s=r[a];i[a]=e[n[s>>10]+(1023&s)]+t[s>>10]}return new Float32Array(s)}}class vy{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==vy.instance&&(vy.instance=new vy),vy.instance}static registerSaveRouter(e){vy.getInstance().saveRouters.push(e)}static registerLoadRouter(e){vy.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return vy.getHandlers(e,"save")}static getLoadHandlers(e,t){return vy.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?vy.getInstance().loadRouters:vy.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&r.push(s)}),r}}const xy=(e,t)=>vy.getLoadHandlers(e,t),wy="tensorflowjs",ky="models_store",Cy="model_info_store";function Iy(){if(!af().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function _y(e){const t=e.result;t.createObjectStore(ky,{keyPath:"modelPath"}),t.createObjectStore(Cy,{keyPath:"modelPath"})}class Sy{constructor(e){if(this.indexedDB=Iy(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var t=this;return bp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return t.databaseAction(t.modelPath,e)})()}load(){var e=this;return bp(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,t){return new Promise((e,n)=>{const r=this.indexedDB.open(wy,1);r.onupgradeneeded=()=>_y(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(ky,"readonly"),r=t.objectStore(ky).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{const r=by(t),i=s.transaction(Cy,"readwrite");let a=i.objectStore(Cy);const o=a.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;o.onsuccess=()=>{u=s.transaction(ky,"readwrite");const o=u.objectStore(ky).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});o.onsuccess=()=>e({modelArtifactsInfo:r}),o.onerror=e=>{a=i.objectStore(Cy);const t=a.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(o.error)),t.onerror=e=>(s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)})}}Sy.URL_SCHEME="indexeddb://";const Ny=e=>{return af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Sy.URL_SCHEME)?(t=e.slice(Sy.URL_SCHEME.length),new Sy(t)):null;var t};vy.registerSaveRouter(Ny),vy.registerLoadRouter(Ny);class Ey{constructor(){this.indexedDB=Iy()}listModels(){var e=this;return bp(function*(){return new Promise((t,n)=>{const r=e.indexedDB.open(wy,1);r.onupgradeneeded=()=>_y(r),r.onsuccess=()=>{const e=r.result,s=e.transaction(Cy,"readonly"),i=s.objectStore(Cy).getAll();i.onsuccess=()=>{const e={};for(const t of i.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},i.onerror=t=>(e.close(),n(i.error)),s.oncomplete=()=>e.close()},r.onerror=e=>n(r.error)})})()}removeModel(e){var t=this;return bp(function*(){var n;return e=(n=e).startsWith(Sy.URL_SCHEME)?n.slice(Sy.URL_SCHEME.length):n,new Promise((n,r)=>{const s=t.indexedDB.open(wy,1);s.onupgradeneeded=()=>_y(s),s.onsuccess=()=>{const t=s.result,i=t.transaction(Cy,"readwrite"),a=i.objectStore(Cy),o=a.get(e);let u;o.onsuccess=()=>{if(null==o.result)return t.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const s=a.delete(e),i=()=>{u=t.transaction(ky,"readwrite");const s=u.objectStore(ky).delete(e);s.onsuccess=()=>n(o.result.modelArtifactsInfo),s.onerror=e=>r(o.error)};s.onsuccess=i,s.onerror=e=>(i(),t.close(),r(o.error))}},o.onerror=e=>(t.close(),r(o.error)),i.oncomplete=()=>{null==u?t.close():u.oncomplete=()=>t.close()}},s.onerror=e=>r(s.error)})})()}}const $y="/",Ty="tensorflowjs_models",Ay="info",Ry="model_topology",Fy="weight_specs",Dy="weight_data",Oy="model_metadata";function My(e){return{info:[Ty,e,Ay].join($y),topology:[Ty,e,Ry].join($y),weightSpecs:[Ty,e,Fy].join($y),weightData:[Ty,e,Dy].join($y),modelMetadata:[Ty,e,Oy].join($y)}}function Ly(e){const t=e.split($y);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($y)}class Py{constructor(e){if(!af().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=My(this.modelPath)}save(e){var t=this;return bp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),i=by(e);try{t.LS.setItem(t.keys.info,JSON.stringify(i)),t.LS.setItem(t.keys.topology,r),t.LS.setItem(t.keys.weightSpecs,s),t.LS.setItem(t.keys.weightData,function(e){if(fy)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(e.weightData));const n={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),t.LS.setItem(t.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:i}}catch(n){throw t.LS.removeItem(t.keys.info),t.LS.removeItem(t.keys.topology),t.LS.removeItem(t.keys.weightSpecs),t.LS.removeItem(t.keys.weightData),t.LS.removeItem(t.keys.modelMetadata),new Error(`Failed to save model '${t.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var e=this;return bp(function*(){const t=JSON.parse(e.LS.getItem(e.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(e.LS.getItem(e.keys.topology));if(null==r)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);n.weightSpecs=s;const i=e.LS.getItem(e.keys.modelMetadata);if(null!=i){const e=JSON.parse(i);n.format=e.format,n.generatedBy=e.generatedBy,n.convertedBy=e.convertedBy,null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer)}const a=e.LS.getItem(e.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return n.weightData=function(e){if(fy){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(a),n})()}}Py.URL_SCHEME="localstorage://";const zy=e=>{return af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Py.URL_SCHEME)?(t=e.slice(Py.URL_SCHEME.length),new Py(t)):null;var t};vy.registerSaveRouter(zy),vy.registerLoadRouter(zy);class Vy{constructor(){Ip(af().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Ip("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var e=this;return bp(function*(){const t={},n=Ty+$y,r=$y+Ay;for(let s=0;s<e.LS.length;++s){const i=e.LS.key(s);i.startsWith(n)&&i.endsWith(r)&&(t[Ly(i)]=JSON.parse(e.LS.getItem(i)))}return t})()}removeModel(e){var t=this;return bp(function*(){var n;const r=My(e=(n=e).startsWith(Py.URL_SCHEME)?n.slice(Py.URL_SCHEME.length):n);if(null==t.LS.getItem(r.info))throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(t.LS.getItem(r.info));return t.LS.removeItem(r.info),t.LS.removeItem(r.topology),t.LS.removeItem(r.weightSpecs),t.LS.removeItem(r.weightData),s})()}}class By{constructor(){this.managers={}}static getInstance(){return null==By.instance&&(By.instance=new By),By.instance}static registerManager(e,t){Ip(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Ip(e.length>0,()=>"scheme must not be an empty string.");const n=By.getInstance();Ip(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class Wy{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(af().get("IS_BROWSER")){af().setPlatform("browser",new Wy);try{By.registerManager(Py.URL_SCHEME,new Vy)}catch(aK){}try{By.registerManager(Sy.URL_SCHEME,new Ey)}catch(aK){}}let Uy;function qy(e,t="float32",n){return t=t||"float32",Jp(e),new Nb(e,t,n)}af().get("IS_NODE")&&af().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=af().global.fetch?af().global.fetch(e,t):(null==Uy&&(Uy=n(410)),Uy(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const jy=ay({cast_:function(e,t){const n=sy(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return Zb.runKernel(Rf,{x:n},{dtype:t})}}),Gy=ay({clone_:function(e){const t=sy(e,"x","clone","string_or_numeric");return Zb.runKernel(km,{x:t})}});function Hy(e){return new Promise(e=>setTimeout(e)).then(e)}Xb(),$b={buffer:qy,cast:jy,clone:Gy,print:function(e,t=!1){console.log(e.toString(t))}};class Ky{constructor(e){if(!af().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ky.URL_SCHEME)&&(e=e.slice(Ky.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var t=this;return bp(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+t.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),i=null==t.jsonAnchor?document.createElement("a"):t.jsonAnchor;if(i.download=t.modelTopologyFileName,i.href=s,yield Hy(()=>i.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==t.weightDataAnchor?document.createElement("a"):t.weightDataAnchor;e.download=t.weightDataFileName,e.href=n,yield Hy(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:by(e)}}})()}}function Xy(e,t,n,r){!function(e){Ip(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Ip(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),Ip(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),Ip(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map(i=>(i.then(i=>{const a=n+ ++s/e.length*(r-n);return t(a),i}),i)))}function Zy(e,t){return Yy.apply(this,arguments)}function Yy(){return(Yy=bp(function*(e,t){null==t&&(t={});const n=null==t.fetchFunc?af().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?yield Promise.all(r):yield Xy(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?yield Promise.all(s):yield Xy(s,t.onProgress,.5,1)})).apply(this,arguments)}Ky.URL_SCHEME="downloads://",vy.registerSaveRouter(e=>af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ky.URL_SCHEME)?function(e="model"){return new Ky(e)}(e.slice(Ky.URL_SCHEME.length)):null);class Qy{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Ip("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=af().platform.fetch,Ip(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Ip(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}save(e){var t=this;return bp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:t.DEFAULT_METHOD},t.requestInit);n.body=new FormData;const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=yield t.fetch(t.path,n);if(s.ok)return{modelArtifactsInfo:by(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)})()}load(){var e=this;return bp(function*(){const t=yield e.fetch(e.path,e.requestInit);if(!t.ok)throw new Error(`Request to ${e.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield t.json()}catch(f){let t=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const r=n.modelTopology,s=n.weightsManifest,i=n.generatedBy,a=n.convertedBy,o=n.format,u=n.signature,l=n.userDefinedMetadata;if(null==r&&null==s)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let c,h;if(null!=s){const t=yield e.loadWeights(s);[c,h]=t}const d={modelTopology:r,weightSpecs:c,weightData:h,generatedBy:i,convertedBy:a,format:o};null!=u&&(d.signature=u),null!=l&&(d.userDefinedMetadata=l);const p=n.modelInitializer;return p&&(d.modelInitializer=p),d})()}loadWeights(e){var t=this;return bp(function*(){const n=Array.isArray(t.path)?t.path[1]:t.path,[r,s]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(n),i=t.weightPathPrefix||r,a=[];for(const t of e)a.push(...t.weights);const o=[],u=[];for(const l of e)for(const e of l.paths)null!=t.weightUrlConverter?u.push(t.weightUrlConverter(e)):o.push(i+e+s);return t.weightUrlConverter&&o.push(...yield Promise.all(u)),[a,gy(yield Zy(o,{requestInit:t.requestInit,fetchFunc:t.fetch,onProgress:t.onProgress}))]})()}}function Jy(e){return null!=e.match(Qy.URL_SCHEME_REGEX)}Qy.URL_SCHEME_REGEX=/^https?:\/\//;const ev=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>Jy(e)):Jy(e),n)return tv(e,t)}return null};function tv(e,t){return new Qy(e,t)}function nv(e,t){return tv(e,t)}function rv(e,t,n){const r=e.shape.length;Ip(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Ip(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Ip(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function sv(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function iv(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function av(e,t,n,r){const s=[...e];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<n;i++)0===i?s[t]=1:(s.splice(t,0,1),s.pop());return s}function ov(e,t,n){return n<=e?n:n-(t-1)}function uv(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function lv(e,t,n,r,s,i,a,o,u){const l=e.length;let c=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=cv(a,u,l,r,e),h=hv(o,u,l,s,e),d=av(i,u,l,e)}else for(let p=0;p<l;p++)c[p]=pv(a,r,i,e,p,u),h[p]=fv(o,s,i,e,p,u),d[p]=dv(i,p,u);return{begin:c,end:h,strides:d}}function cv(e,t,n,r,s){const i=[...s],a=uv(n,t);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const s=ov(t,n,o);let a=r[s];e&1<<s&&(a=0),i[o]=a}return i}function hv(e,t,n,r,s){const i=[...s],a=uv(n,t);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const s=ov(t,n,o);let a=r[s];e&1<<s&&(a=Number.MAX_SAFE_INTEGER),i[o]=a}for(let o=0;o<i.length;o++){const e=s[o];i[o]<0&&(i[o]+=e),i[o]=kp(0,i[o],s[o])}return i}function dv(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function pv(e,t,n,r,s,i){let a=t[s];(e&1<<s||i&1<<s||null==a)&&(a=(n[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const o=r[s];return a<0&&(a+=o),a=kp(0,a,o-1),a}function fv(e,t,n,r,s,i){let a=t[s];const o=n[s]||1;(e&1<<s||i&1<<s||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[s];return a<0&&(a+=u),a=o>0?kp(0,a,u):kp(-1,a,u-1),a}function mv(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function gv(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function bv(e,t,n){let r;const s=e.shape.length;let i;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(e=>{Ip(-1!==e,()=>"slice() does not support negative begin indexing.")}),i=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,i=i.map((t,n)=>t>=0?t:(Ip(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,i]}function yv(e,t,n,r,s,i,a,o,u){let l=t.slice(),c=n.slice(),h=r;null==r&&(h=new Array(l.length));const d=sv(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==a&&0!==o)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==a&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=e.length-l.length,f=sv(o),m=e.slice();f.forEach(e=>{l[e]=0,c[e]=1,m.splice(e,0,1)});const{begin:g,end:b,strides:y}=lv(m,d,p,l,c,h,s,i,a);l=g,c=b,h=y;const v=sv(u);v.forEach(e=>{c[e]=l[e]+1,h[e]=1});const x=iv(l,c,h),w=x.filter((e,t)=>-1===v.indexOf(t));return{nonStrided:h.every(e=>1===e),$begin:l,$end:c,$strides:h,size:x,newShape:m,outShape:w}}vy.registerSaveRouter(ev),vy.registerLoadRouter(ev);class vv{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class xv{constructor(){this.classNameMap={}}static getMap(){return null==xv.instance&&(xv.instance=new xv),xv.instance}static register(e){xv.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function wv(e){Ip(null!=e.className,()=>"Class being registered does not have the static className property defined."),Ip("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Ip(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),xv.register(e)}function kv(){return Zb}function Cv(){return Zb.memory()}function Iv(e,t){return Zb.tidy(e,t)}function _v(e){qb(e).forEach(e=>e.dispose())}function Sv(e){return Zb.keep(e)}function Nv(e,t,n=1){return Zb.registerBackend(e,t,n)}function Ev(e){return Zb.customGrad(e)}function $v(e,t){if((Vp(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Vp(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return uy(e,[],[],t)}Tb=function(e){af().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class Tv extends vv{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:s[e.name]}));this.applyGradients(e)}else this.applyGradients(s);return _v(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Ip(jp(e),()=>"The f passed in variableGrads(f) must be a function"),Ip(null==t||Array.isArray(t)&&t.every(e=>e instanceof Fb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in Zb.registeredVariables)t.push(Zb.registeredVariables[e])}const r=n?t.filter(e=>!e.trainable):null,s=t.length;Ip((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=Zb.gradients(e,t,null,!0);Ip(a.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Ip(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const o={};return t.forEach((e,t)=>{null!=a[t]&&(o[e.name]=a[t])}),null!=r&&r.forEach(e=>o[e.name]=null),{value:i,grads:o}}(e,t)}dispose(){null!=this.iterations_&&_v(this.iterations_)}saveIterations(){var e=this;return bp(function*(){return null==e.iterations_&&(e.iterations_=0),{name:"iter",tensor:$v(e.iterations_,"int32")}})()}getWeights(){return bp(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(e){var t=this;return bp(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${t.getClassName()}`)})()}extractIterations(e){var t=this;return bp(function*(){return t.iterations_=(yield e[0].tensor.data())[0],e.slice(1)})()}}Object.defineProperty(Tv,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});const Av=ay({abs_:function(e){const t=sy(e,"x","abs");return Zb.runKernel("complex64"===t.dtype?Mf:hf,{x:t})}}),Rv=ay({add_:function(e,t){let n=sy(e,"a","add"),r=sy(t,"b","add");return[n,r]=Wb(n,r),Zb.runKernel(ff,{a:n,b:r})}}),Fv=ay({all_:function(e,t=null,n=!1){const r=sy(e,"x","all","bool");return Zb.runKernel(gf,{x:r},{axis:t,keepDims:n})}}),Dv=ay({any_:function(e,t=null,n=!1){const r=sy(e,"x","any","bool");return Zb.runKernel(bf,{x:r},{axis:t,keepDims:n})}}),Ov=ay({argMax_:function(e,t=0){const n=sy(e,"x","argMax");return Zb.runKernel(yf,{x:n},{axis:t})}});function Mv(e,t,n,r,s="NHWC",i){return zv(e,[...t,e[3]],n,i,r,null,null,Kv(s))}function Lv(e,t,n,r,s,i,a="channelsLast"){const[o,u]=Wv(t);let l;if("channelsLast"===a)l=[o,u,e[3],e[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);l=[o,u,e[1],e[1]]}return zv(e,l,n,r,s,i,!1,a)}function Pv(e,t,n,r,s,i,a="NDHWC"){const[o,u,l]=Uv(t);let c,h;if("NDHWC"===a)h="channelsLast",c=[o,u,l,e[4],e[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",c=[o,u,l,e[1],e[1]]}return Vv(e,c,n,r,s,!1,h,i)}function zv(e,t,n,r,s,i,a=!1,o="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,h,l,c]=e}const[d,p,,f]=t,[m,g]=Wv(n),[b,y]=Wv(r),v=qv(d,b),x=qv(p,y),{padInfo:w,outHeight:k,outWidth:C}=function(e,t,n,r,s,i,a,o,u){let l,c,h;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=Bv(e,t,n));const i=e[1];return[jv((e[0]-t+2*r)/n+1,s),jv((i-t+2*r)/n+1,s)]}([t,n],i,r,e,o);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+i-t),o=Math.max(0,(h-1)*s+a-n),u=Math.floor(e/2),d=e-u,p=Math.floor(o/2);l={top:u,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-i+1)/r),h=Math.ceil((n-a+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=jv((t-i+d+p)/r+1,o),h=jv((n-a+f+m)/s+1,o)}}return{padInfo:l,outHeight:c,outWidth:h}}(s,l,c,m,g,v,x,i,o),I=a?f*h:f;let _;return"channelsFirst"===o?_=[u,I,k,C]:"channelsLast"===o&&(_=[u,k,C,I]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:c,inChannels:h,outHeight:k,outWidth:C,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:b,dilationWidth:y,inShape:e,outShape:_,filterShape:t}}function Vv(e,t,n,r,s,i=!1,a="channelsLast",o){let[u,l,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[u,l,c,h,d]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[u,d,l,c,h]=e}const[p,f,m,,g]=t,[b,y,v]=Uv(n),[x,w,k]=Uv(r),C=qv(p,x),I=qv(f,w),_=qv(m,k),{padInfo:S,outDepth:N,outHeight:E,outWidth:$}=function(e,t,n,r,s,i,a,o,u,l,c){let h,d,p,f;if("number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const i=function(e,t,n,r,s,i){null==s&&(s=Bv(e,t,r));const a=e[1],o=e[2];return[jv((e[0]-t+2*s)/r+1,i),jv((a-t+2*s)/r+1,i),jv((o-t+2*s)/r+1,i),1]}([t,n,r,1],o,0,s,e,c);d=i[0],p=i[1],f=i[2]}else if("same"===e){d=Math.ceil(t/s),p=Math.ceil(n/i),f=Math.ceil(r/a);const e=(d-1)*s+o-t,c=(p-1)*i+u-n,m=(f-1)*a+l-r,g=Math.floor(e/2),b=e-g,y=Math.floor(c/2),v=c-y,x=Math.floor(m/2);h={top:y,bottom:v,left:x,right:m-x,front:g,back:b,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-o+1)/s),p=Math.ceil((n-u+1)/i),f=Math.ceil((r-l+1)/a)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,l,c,h,b,y,v,C,I,_,o),T=i?g*d:g;let A;return"channelsFirst"===a?A=[u,T,N,E,$]:"channelsLast"===a&&(A=[u,N,E,$,T]),{batchSize:u,dataFormat:a,inDepth:l,inHeight:c,inWidth:h,inChannels:d,outDepth:N,outHeight:E,outWidth:$,outChannels:T,padInfo:S,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:I,effectiveFilterWidth:_,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function Bv(e,t,n,r=1){const s=qv(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Wv(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Uv(e){return"number"==typeof e?[e,e,e]:e}function qv(e,t){return t<=1?e:e+(e-1)*(t-1)}function jv(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Gv(e){const[t,n,r]=Wv(e);return 1===t&&1===n&&1===r}function Hv(e,t){return Gv(e)||Gv(t)}function Kv(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const Xv=ay({reshape_:function(e,t){const n=sy(e,"x","reshape","string_or_numeric");return Zb.runKernel(mg,{x:n},{shape:t})}}),Zv=ay({avgPool_:function(e,t,n,r,s){const i=sy(e,"x","avgPool","float32");Ip(Hv(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let a=i,o=!1;3===i.rank&&(o=!0,a=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ip(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),null!=s&&Ip(Tp(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u=Zb.runKernel(_f,{x:a},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return u=jy(u,i.dtype),o?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Yv=ay({avgPool3d_:function(e,t,n,r,s,i="NDHWC"){const a=sy(e,"x","avgPool3d","float32");let o=a,u=!1;4===a.rank&&(u=!0,o=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Ip(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Ip("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=s&&Ip(Tp(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let l=Zb.runKernel(Nf,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:i});return l=jy(l,o.dtype),u?Xv(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),Qv=ay({batchNorm_:function(e,t,n,r,s,i){null==i&&(i=.001);const a=sy(e,"x","batchNorm"),o=sy(t,"mean","batchNorm"),u=sy(n,"variance","batchNorm");let l,c;null!=s&&(l=sy(s,"scale","batchNorm")),null!=r&&(c=sy(r,"offset","batchNorm")),Ip(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ip(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ip(null==l||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(e){let t;return t=0===e.rank||1===e.rank?Xv(e,[1,1,1,e.size]):2===e.rank?Xv(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(a),d=Zb.runKernel(bm,{x:h,scale:l,offset:c,mean:o,variance:u},{varianceEpsilon:i});return Xv(d,a.shape)}}),Jv=ay({batchNorm2d_:function(e,t,n,r,s,i){const a=sy(e,"x","batchNorm"),o=sy(t,"mean","batchNorm"),u=sy(n,"variance","batchNorm");let l,c;return null!=s&&(l=sy(s,"scale","batchNorm")),null!=r&&(c=sy(r,"offset","batchNorm")),Ip(2===a.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),Ip(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Ip(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=l&&Ip(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&Ip(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Qv(a,o,u,c,l,i)}}),ex=ay({batchNorm3d_:function(e,t,n,r,s,i){const a=sy(e,"x","batchNorm"),o=sy(t,"mean","batchNorm"),u=sy(n,"variance","batchNorm");let l,c;return null!=s&&(l=sy(s,"scale","batchNorm")),null!=r&&(c=sy(r,"offset","batchNorm")),Ip(3===a.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),Ip(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Ip(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=l&&Ip(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&Ip(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Qv(a,o,u,c,l,i)}}),tx=ay({batchNorm4d_:function(e,t,n,r,s,i){const a=sy(e,"x","batchNorm"),o=sy(t,"mean","batchNorm"),u=sy(n,"variance","batchNorm");let l,c;return null!=s&&(l=sy(s,"scale","batchNorm")),null!=r&&(c=sy(r,"offset","batchNorm")),Ip(4===a.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),Ip(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Ip(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=l&&Ip(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&Ip(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Qv(a,o,u,c,l,i)}}),nx=ay({clipByValue_:function(e,t,n){const r=sy(e,"x","clipByValue");return Ip(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),Zb.runKernel(Df,{x:r},{clipValueMin:t,clipValueMax:n})}}),rx=ay({concat_:function(e,t=0){Ip(e.length>=1,()=>"Pass at least one tensor to concat");const n=iy(e,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length?Gy(n[0]):Zb.runKernel(Lf,n,{axis:t})}}),sx=ay({concat1d_:function(e){return rx(e,0)}}),ix=ay({concat2d_:function(e,t){return rx(e,t)}}),ax=ay({concat3d_:function(e,t){return rx(e,t)}}),ox=ay({concat4d_:function(e,t){return rx(e,t)}}),ux=ay({conv2d_:function(e,t,n,r,s="NHWC",i=[1,1],a){const o=sy(e,"x","conv2d"),u=sy(t,"filter","conv2d");let l=o,c=!1;3===o.rank&&(c=!0,l=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ip(4===l.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),Ip(4===u.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),null!=a&&Ip(Tp(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const h="NHWC"===s?l.shape[3]:l.shape[1];Ip(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),Ip(Hv(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d=Zb.runKernel(Pf,{x:l,filter:u},{strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a});return c?Xv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),lx=ay({conv1d_:function(e,t,n,r,s="NWC",i=1,a){const o=sy(e,"x","conv1d"),u=sy(t,"filter","conv1d");let l=o,c=!1;2===o.rank&&(c=!0,l=Xv(o,[1,o.shape[0],o.shape[1]])),Ip(3===l.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),Ip(3===u.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),null!=a&&Ip(Tp(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),Ip(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),Ip(Hv(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),Ip("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=Xv(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=Xv(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=ux(d,h,[1,n],r,"NHWC",[1,i],a);return Xv(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),cx=ay({conv2DBackpropInput_:function(e,t,n,r,s,i="NHWC",a){Ip(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,l=!1;3===t.rank&&(l=!0,u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Ip(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Ip(4===u.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),Ip(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===i?o[3]:o[1],h="NHWC"===i?u.shape[3]:u.shape[1];Ip(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Ip(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=a&&Ip(Tp(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);const d=Zb.runKernel(Vf,{dy:u,filter:n},{strides:r,pad:s,dataFormat:i,dimRoundingMode:a,inputShape:o});return l?Xv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),hx=ay({conv2dTranspose_:function(e,t,n,r,s,i){const a=sy(e,"x","conv2dTranspose"),o=sy(t,"filter","conv2dTranspose");return cx(n,a,o,r,s,"NHWC",i)}}),dx=ay({conv3d_:function(e,t,n,r,s="NDHWC",i=[1,1,1]){const a=sy(e,"x","conv3d"),o=sy(t,"filter","conv3d");let u=a,l=!1;4===a.rank&&(l=!0,u=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Ip(5===u.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),Ip(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Ip(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Ip(Hv(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Ip("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c=Zb.runKernel(Bf,{x:u,filter:o},{strides:n,pad:r,dataFormat:s,dilations:i});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),px=ay({conv3DBackpropInput_:function(e,t,n,r,s){Ip(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,a=t,o=!1;4===t.rank&&(o=!0,a=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);const u=i[4],l=a.shape[4];Ip(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),Ip(5===a.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),Ip(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Ip(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),Ip(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c=Zb.runKernel(Uf,{dy:a,filter:n},{pad:s,strides:r,inputShape:i});return o?Xv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),fx=ay({conv3dTranspose_:function(e,t,n,r,s){const i=sy(e,"x","conv3dTranspose"),a=sy(t,"filter","conv3dTranspose");return px(n,i,a,r,s)}}),mx=ay({depthwiseConv2d_:function(e,t,n,r,s="NHWC",i=[1,1],a){const o=sy(e,"x","depthwiseConv2d"),u=sy(t,"filter","depthwiseConv2d");let l=o,c=!1;3===o.rank&&(c=!0,l=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ip(4===l.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),Ip(4===u.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),Ip(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),null!=a&&Ip(Tp(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const h=Zb.runKernel(Zf,{x:l,filter:u},{strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a});return c?Xv(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),gx=ay({floorDiv_:function(e,t){let n=sy(e,"a","floorDiv"),r=sy(t,"b","floorDiv");return[n,r]=Wb(n,r),Zb.runKernel(gm,{a:n,b:r})}}),bx=ay({div_:function(e,t){let n=sy(e,"a","div"),r=sy(t,"b","div");return[n,r]=Wb(n,r),"int32"===n.dtype&&"int32"===r.dtype?gx(n,r):Zb.runKernel(rm,{a:n,b:r},{})}}),yx=ay({elu_:function(e){const t=sy(e,"x","elu");return Zb.runKernel(im,{x:t})}});function vx(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const i=n-1-s,a=e[i]||1;(t[t.length-1-s]||1)>1&&1===a&&r.unshift(i)}return r}function xx(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],i=t.length-r-1,a=t[i];(null==s||1===s&&a>1)&&n.unshift(i)}return n}function wx(e,t){const n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let r=e[e.length-s-1];null==r&&(r=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===r)n.unshift(i);else if(1===i)n.unshift(r);else{if(r!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(r)}}return n}const kx=ay({equal_:function(e,t){let n=sy(e,"a","equal"),r=sy(t,"b","equal");return[n,r]=Wb(n,r),wx(n.shape,r.shape),Zb.runKernel(um,{a:n,b:r})}}),Cx=ay({expandDims_:function(e,t=0){const n=sy(e,"x","expandDims","string_or_numeric");return Ip(t<=n.rank,()=>"Axis must be <= rank of the tensor"),Zb.runKernel(cm,{input:n},{dim:t})}}),Ix=ay({tile_:function(e,t){const n=sy(e,"x","tile","string_or_numeric");return Ip(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),Zb.runKernel(Hg,{x:n},{reps:t})}}),_x=ay({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=qy([e,t],r),i=e<=t?e:t;for(let o=0;o<i;++o)s.set(1,o,o);const a=Xv(s.toTensor(),[e,t]);if(null==n)return a;if(1===n.length)return Ix(Cx(a,0),[n[0],1,1]);if(2===n.length)return Ix(Cx(Cx(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return Ix(Cx(Cx(Cx(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function Sx(e,t,n){return Zb.runKernel(pm,{},{shape:e,value:t,dtype:n})}const Nx=ay({floor_:function(e){const t=sy(e,"x","floor");return Zb.runKernel(mm,{x:t})}}),Ex=ay({gather_:function(e,t,n=0,r=0){const s=sy(e,"x","gather"),i=sy(t,"indices","gather","int32");return Zb.runKernel(ym,{x:s,indices:i},{axis:n,batchDims:r})}}),$x=ay({greater_:function(e,t){let n=sy(e,"a","greater"),r=sy(t,"b","greater");return[n,r]=Wb(n,r),wx(n.shape,r.shape),Zb.runKernel(xm,{a:n,b:r})}}),Tx=ay({greaterEqual_:function(e,t){let n=sy(e,"a","greaterEqual"),r=sy(t,"b","greaterEqual");return[n,r]=Wb(n,r),wx(n.shape,r.shape),Zb.runKernel(wm,{a:n,b:r})}}),Ax=ay({leakyRelu_:function(e,t=.2){const n=sy(e,"x","leakyRelu");return Zb.runKernel(Em,{x:n},{alpha:t})}}),Rx=ay({log_:function(e){const t=sy(e,"x","log");return Zb.runKernel(Rm,{x:t})}}),Fx=ay({exp_:function(e){const t=sy(e,"x","exp");return Zb.runKernel(lm,{x:t})}}),Dx=ay({max_:function(e,t=null,n=!1){const r=sy(e,"x","max");return Zb.runKernel(zm,{x:r},{reductionIndices:t,keepDims:n})}}),Ox=ay({mul_:function(e,t){let n=sy(e,"a","mul"),r=sy(t,"b","mul");return[n,r]=Wb(n,r),Zb.runKernel(Qm,{a:n,b:r})}}),Mx=ay({sub_:function(e,t){let n=sy(e,"a","sub"),r=sy(t,"b","sub");return[n,r]=Wb(n,r),Zb.runKernel(qg,{a:n,b:r})}}),Lx=ay({sum_:function(e,t=null,n=!1){let r=sy(e,"x","sum");return"bool"===r.dtype&&(r=jy(r,"int32")),Zb.runKernel(Dg,{x:r},{axis:t,keepDims:n})}}),Px=ay({logSoftmax_:function(e,t=-1){const n=sy(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Ev((e,n)=>{const r=Dx(e,t,!0),s=Mx(e,r),i=Mx(jy(s,"float32"),Rx(Lx(Fx(s),t,!0)));return n([i]),{value:i,gradFunc:(e,n)=>{const[r]=n,s=Fx(r);return Mx(e,Ox(Lx(e,t,!0),s))}}})(n)}}),zx=ay({logicalAnd_:function(e,t){const n=sy(e,"a","logicalAnd","bool"),r=sy(t,"b","logicalAnd","bool");return wx(n.shape,r.shape),Zb.runKernel(Dm,{a:n,b:r})}}),Vx=ay({maxPool_:function(e,t,n,r,s){const i=sy(e,"x","maxPool");let a=i,o=!1;3===i.rank&&(o=!0,a=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ip(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),Ip(Hv(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=s&&Ip(Tp(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const u=Zb.runKernel(Bm,{x:a},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return o?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Bx=ay({maxPool3d_:function(e,t=[1,1,1],n,r,s,i="NDHWC"){const a=sy(e,"x","maxPool3d");let o=a,u=!1;4===a.rank&&(u=!0,o=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Ip(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Ip("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),null!=s&&Ip(Tp(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l=Zb.runKernel(Um,{x:o},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:i});return u?Xv(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),Wx=ay({maximum_:function(e,t){let n=sy(e,"a","maximum"),r=sy(t,"b","maximum");return[n,r]=Wb(n,r),"bool"===n.dtype&&(n=jy(n,"int32"),r=jy(r,"int32")),wx(n.shape,r.shape),Zb.runKernel(Vm,{a:n,b:r})}}),Ux=ay({mean_:function(e,t=null,n=!1){const r=sy(e,"x","mean");return Zb.runKernel(Gm,{x:r},{axis:t,keepDims:n})}}),qx=ay({min_:function(e,t=null,n=!1){const r=sy(e,"x","min");return Zb.runKernel(Hm,{x:r},{axis:t,keepDims:n})}}),jx=ay({minimum_:function(e,t){let n=sy(e,"a","minimum"),r=sy(t,"b","minimum");return[n,r]=Wb(n,r),"bool"===n.dtype&&(n=jy(n,"int32"),r=jy(r,"int32")),wx(n.shape,r.shape),Zb.runKernel(Km,{a:n,b:r})}});function Gx(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Hx(e,t,n){const r=e.length+t.length,s=[];let i=0,a=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[i++]):s.push(t[a++]);return s}function Kx(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function Xx(e,t){return Hx(e,t.map(e=>1),t)}function Zx(e,t,n){Ip(Gx(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Yx(e,t){if(Gx(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function Qx(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Jx(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const ew=ay({square_:function(e){const t=sy(e,"x","square");return Zb.runKernel("Square",{x:t},{})}}),tw=ay({moments_:function(e,t=null,n=!1){const r=Op(t,(e=sy(e,"x","moments")).shape),s=Ux(e,r,n);let i=s.shape;n||(i=Xx(s.shape,r));const a=ew(Mx(jy(e,"float32"),Xv(s,i)));return{mean:s,variance:Ux(a,r,n)}}}),nw=ay({neg_:function(e){const t=sy(e,"x","neg");return Zb.runKernel(Jm,{x:t})}}),rw=ay({notEqual_:function(e,t){let n=sy(e,"a","notEqual"),r=sy(t,"b","notEqual");return[n,r]=Wb(n,r),wx(n.shape,r.shape),Zb.runKernel(eg,{a:n,b:r})}}),sw=ay({oneHot_:function(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s=sy(e,"indices","oneHot","int32");return Zb.runKernel(ig,{indices:s},{depth:t,onValue:n,offValue:r})}});function iw(e,t="float32"){if("complex64"===t){const t=iw(e,"float32"),n=iw(e,"float32");return oy(t,n)}const n=Yp(Ep(e),t);return Zb.makeTensor(n,e,t)}function aw(e,t="float32"){if("complex64"===t){const t=aw(e,"float32"),n=iw(e,"float32");return oy(t,n)}const n=Zp(Ep(e),t);return Zb.makeTensor(n,e,t)}const ow=ay({onesLike_:function(e){const t=sy(e,"x","onesLike");return Zb.runKernel(sg,{x:t})}}),uw=ay({pad_:function(e,t,n=0){const r=sy(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return Zb.runKernel(og,{x:r},{paddings:t,constantValue:n})}}),lw=ay({prelu_:function(e,t){const n=sy(e,"x","prelu"),r=sy(t,"alpha","prelu");return Zb.runKernel(lg,{x:n,alpha:r})}});var cw=n(566);class hw{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=s||Math.random();this.random=cw.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,i;do{r=2*this.random()-1,s=2*this.random()-1,i=r*r+s*s}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*s*a,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class dw{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=cw.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const pw=ay({randomNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const i=new hw(t,n,r,!1,s),a=qy(e,r);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),fw=ay({randomUniform_:function(e,t=0,n=1,r="float32",s){const i=qy(e,r),a=new dw(t,n,null,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),mw=ay({relu_:function(e){const t=sy(e,"x","relu");return Zb.runKernel(fg,{x:t})}}),gw=ay({reverse_:function(e,t){const n=sy(e,"x","reverse");return Zb.runKernel(wg,{x:n},{dims:t})}}),bw=ay({selu_:function(e){const t=sy(e,"x","selu");return Zb.runKernel(Sg,{x:t})}}),yw=ay({separableConv2d_:function(e,t,n,r,s,i=[1,1],a="NHWC"){const o=sy(e,"x","separableConv2d"),u=sy(t,"depthwiseFilter","separableConv2d"),l=sy(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Ip(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Ip(4===u.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),Ip(4===l.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),Ip(1===l.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),Ip(1===l.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=u.shape[2],p=u.shape[3];Ip(l.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${l.shape[2]}.`);const f=mx(c,u,r,s,a,i),m=ux(f,l,1,"valid",a);return h?Xv(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),vw=ay({sigmoid_:function(e){const t=sy(e,"x","sigmoid");return Zb.runKernel(Ag,{x:t})}}),xw=ay({slice_:function(e,t,n){const r=sy(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return Zb.runKernel(Ng,{x:r},{begin:t,size:n})}}),ww=ay({slice1d_:function(e,t,n){const r=sy(e,"x","slice1d");return Ip(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),xw(r,[t],[n])}}),kw=ay({slice2d_:function(e,t,n){const r=sy(e,"x","slice2d");return Ip(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),xw(r,t,n)}}),Cw=ay({slice3d_:function(e,t,n){const r=sy(e,"x","slice3d");return Ip(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),xw(r,t,n)}}),Iw=ay({slice4d_:function(e,t,n){const r=sy(e,"x","slice4d");return Ip(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),xw(r,t,n)}}),_w=ay({softmax_:function(e,t=-1){const n=sy(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return Zb.runKernel(Lg,{logits:n},{dim:t})}}),Sw=ay({softplus_:function(e){const t=sy(e,"x","softplus");return Zb.runKernel(Rg,{x:t})}}),Nw=ay({split_:function(e,t,n=0){const r=sy(e,"x","split");return Zb.runKernel(Mg,{x:r},{numOrSizeSplits:t,axis:n})}}),Ew=ay({sqrt_:function(e){const t=sy(e,"x","sqrt");return Zb.runKernel(Fg,{x:t})}}),$w=ay({squeeze_:function(e,t){const n=sy(e,"x","squeeze");return Xv(n,Mp(n.shape,t).newShape)}}),Tw=ay({stack_:function(e,t=0){const n=iy(e,"tensors","stack","string_or_numeric");return Ip(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Ip(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),Zb.runKernel(ag,n,{axis:t})}}),Aw=ay({tanh_:function(e){const t=sy(e,"x","tanh");return Zb.runKernel(Gg,{x:t})}});function Rw(e,t){Sp(e);const n=ty(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return uy(e,null,n,t)}function Fw(e,t,n){if(Sp(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=ty(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return uy(e,t,r,n)}const Dw=ay({truncatedNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new hw(t,n,r,!0,s),a=qy(e,r);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}}),Ow=ay({unstack_:function(e,t=0){const n=sy(e,"x","unstack","string_or_numeric");return Ip(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),Zb.runKernel(Qg,{value:n},{axis:t})}}),Mw=ay({broadcastTo_:function(e,t){let n=sy(e,"broadcastTo","x");const r=n.shape;if(t.some(e=>!(e>0)||e%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Xv(n,e)}const s=n.shape,i=Array.from(t);for(let a=t.length-1;a>=0;a--)if(s[a]===t[a])i[a]=1;else if(1!==n.shape[a])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===i.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length?Gy(n):Zb.runKernel(Hg,{x:n},{reps:i})}}),Lw=ay({where_:function(e,t,n){const r=sy(t,"a","where"),s=sy(n,"b","where"),i=sy(e,"condition","where","bool"),a=wx(wx(i.shape,r.shape),s.shape),o=Mw(i,a),u=Mw(r,a),l=Mw(s,a);return Zb.runKernel(_g,{condition:o,t:u,e:l})}}),Pw=ay({zerosLike_:function(e){const t=sy(e,"x","zerosLike");return Zb.runKernel(eb,{x:t})}}),zw=ay({transpose_:function(e,t){const n=sy(e,"x","transpose");return null==t&&(t=n.shape.map((e,t)=>t).reverse()),Ip(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{Ip(e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`)}),n.rank<=1?n.clone():Zb.runKernel(Zg,{x:n},{perm:t})}}),Vw=ay({dropout_:function(e,t,n,r){const s=sy(e,"x","dropout");if(Ip("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Ip(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof Ab?s.clone():s;const i=function(e,t){if(null==t)return e.shape.slice();if($p(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)n.push(null==t[r]&&null!=e.shape[r]?e.shape[r]:t[r]);return n}return t}(s,n),a=1-t,o=bx(Nx(Rv(fw(i,0,1,"float32",r),a)),a);return Ox(s,o)}}),Bw=ay({imag_:function(e){const t=sy(e,"input","imag");return Zb.runKernel(Im,{input:t})}}),Ww=ay({real_:function(e){const t=sy(e,"input","real");return Zb.runKernel(dg,{input:t})}}),Uw=ay({fft_:function(e){return Ip("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),Zb.runKernel(dm,{input:e})}}),qw=ay({rfft_:function(e,t){Ip("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map(e=>0),i=e.shape.map(e=>e);i[e.shape.length-1]=t,s=xw(e,r,i),n=t}else if(null!=t&&t>n){const r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,s=rx([e,iw(r)],e.shape.length-1),n=t}else s=e;const i=Pw(s),a=Xv(oy(s,i),[r,n]),o=Uw(a),u=Math.floor(n/2)+1,l=Ww(o),c=Bw(o),h=Nw(l,[u,n-u],l.shape.length-1),d=Nw(c,[u,n-u],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=u,Xv(oy(h[0],d[0]),p)}}),jw=ay({ifft_:function(e){return Ip("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),Zb.runKernel(Cm,{input:e})}}),Gw=ay({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Xv(e,[n,t]);r=jw(s)}else{const s=[n,2*(t-1)],i=Xv(Ww(e),[n,t]),a=Xv(Bw(e),[n,t]),o=gw(xw(i,[0,1],[n,t-2]),1),u=Ox(gw(xw(a,[0,1],[n,t-2]),1),$v(-1)),l=rx([i,o],1),c=rx([a,u],1),h=Xv(oy(l,c),[s[0],s[1]]);r=jw(h)}if(r=Ww(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Xv(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}}),Hw=ay({conv2DBackpropFilter_:function(e,t,n,r,s,i="NHWC",a){let o=e;3===e.rank&&(o=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Ip(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Ip(4===u.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),Ip(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l="NHWC"===i?o.shape[3]:o.shape[1],c="NHWC"===i?u.shape[3]:u.shape[1];return Ip(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),Ip(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=a&&Ip(Tp(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),Zb.runKernel(zf,{x:o,dy:u},{strides:r,pad:s,dataFormat:i,dimRoundingMode:a,filterShape:n})}}),Kw=ay({relu6_:function(e){const t=sy(e,"x","relu6");return Zb.runKernel(xg,{x:t})}}),Xw=ay({step_:function(e,t=0){const n=sy(e,"x","step");return Zb.runKernel(tb,{x:n},{alpha:t})}});function Zw(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Ox(e,Xw(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Yw(e,t){let n=t;const r=xx(e.shape,t.shape);return r.length>0&&(n=Lx(n,r)),Xv(n,e.shape)}function Qw(e,t,n,r){if("linear"===t)return e;if("relu"===t)return mw(e);if("elu"===t)return yx(e);if("relu6"===t)return Kw(e);if("prelu"===t)return lw(e,n);if("leakyrelu"===t)return Ax(e,r);if("sigmoid"===t)return vw(e);throw new Error(`Unknown fused activation ${t}.`)}const Jw=(e,t)=>!(e>0)||"linear"===t,ek=ay({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Jw(Zb.state.gradientDepth,u=u||"linear")){let h=ux(e,t,n,r,s,i,a);return null!=o&&(h=Rv(h,o)),Qw(h,u,l,c)}const h=sy(e,"x","conv2d"),d=sy(t,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=Xv(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Ip(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Ip(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=a&&Ip(Tp(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`),Ip(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),Ip(Hv(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Ip("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=zv(p.shape,d.shape,n,i,r,a);let g,b;null!=o&&(g=sy(o,"bias","fused conv2d"),[g]=Wb(g,h),wx(m.outShape,g.shape)),null!=l&&(b=sy(l,"prelu weights","fused conv2d"));const y=(e,t)=>{const[s,a,o,l]=t,c=Zw(e,o,u);Ip(Gv(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const h=[cx(a.shape,c,s,n,r),Hw(a,c,s.shape,n,r)];if(null!=l){const e=Yw(l,c);h.push(e)}return h},v={x:p,filter:d,bias:g,preluActivationWeights:b},x={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:c};return null==o?Ev((e,t,n)=>{let r=Zb.runKernel(sb,v,x);return n([t,e,r]),f&&(r=Xv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(p,d):Ev((e,t,n,r)=>{let s=Zb.runKernel(sb,v,x);return r([t,e,s,n]),f&&(s=Xv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(p,d,g)}}),tk=ay({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,i=[1,1],a){let o=e;3===e.rank&&(o=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;return 3===u.rank&&(u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Zb.runKernel(Yf,{x:o,dy:u},{strides:r,pad:s,dimRoundingMode:a,dilations:i,filterShape:n})}}),nk=ay({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,i=[1,1],a){let o=t,u=!1;3===t.rank&&(u=!0,o=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l=Zb.runKernel(Qf,{dy:o,filter:n},{strides:r,pad:s,dimRoundingMode:a,dilations:i,inputShape:e});return u?Xv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});ay({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Jw(Zb.state.gradientDepth,u)){let h=mx(e,t,n,r,s,i,a);return null!=o&&(h=Rv(h,o)),Qw(h,u,l,c)}const h=sy(e,"x","depthwiseConv2d"),d=sy(t,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=Xv(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Ip(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Ip(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),Ip(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==i&&(i=[1,1]),Ip(Hv(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),null!=a&&Ip(Tp(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`);const m=zv(p.shape,d.shape,n,i,r,a,!0);let g,b;null!=o&&(g=sy(o,"bias","fused conv2d"),[g]=Wb(g,h),wx(m.outShape,g.shape)),null!=l&&(b=sy(l,"prelu weights","fused depthwiseConv2d"));const y=(e,t)=>{Ip(Gv(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[s,o,l,c]=t,h=Zw(e,l,u),d=nk(o.shape,h,s,n,r,i,a),p=tk(o,h,s.shape,n,r,i,a);return null!=c?[d,p,Yw(g,h)]:[d,p]},v={x:p,filter:d,bias:g,preluActivationWeights:b},x={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:c};return null==o?Ev((e,t,n)=>{let r=Zb.runKernel(ib,v,x);return n([t,e,r]),f&&(r=Xv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(p,d):Ev((e,t,n,r)=>{let s=Zb.runKernel(ib,v,x);return r([t,e,s,n]),f&&(s=Xv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(p,d,g)}});const rk=ay({matMul_:function(e,t,n=!1,r=!1){let s=sy(e,"a","matMul"),i=sy(t,"b","matMul");return[s,i]=Wb(s,i),Zb.runKernel($f,{a:s,b:i},{transposeA:n,transposeB:r})}}),sk=ay({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o}){if(!1===Jw(Zb.state.gradientDepth,i)){let u=rk(e,t,n,r);return null!=s&&(u=Rv(u,s)),Qw(u,i,a,o)}let u=sy(e,"a","fused matMul"),l=sy(t,"b","fused matMul");[u,l]=Wb(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=Ep(f),b=Ep(m);Ip(u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),Ip($p(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`),Ip(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const y=u.shape.slice(0,-2).concat([d,p]),v=Xv(u,n?[g,c,d]:[g,d,c]),x=Xv(l,r?[b,p,h]:[b,h,p]);let w,k;null!=s&&(w=sy(s,"bias","fused matMul"),[w]=Wb(w,u),wx(y,w.shape)),null!=a&&(k=sy(a,"prelu weights","fused matMul"));const C=(e,t)=>{const[a,o,u,l]=t,c=Zw(Xv(e,u.shape),u,i);let h,d;return n||r?!n&&r?(h=rk(c,o,!1,!1),d=rk(c,a,!0,!1)):n&&!r?(h=rk(o,c,!1,!0),d=rk(a,c,!1,!1)):(h=rk(o,c,!0,!0),d=rk(c,a,!0,!0)):(h=rk(c,o,!1,!0),d=rk(a,c,!0,!1)),null!=s?[h,d,Yw(l,c)]:[h,d]},I={a:v,b:x,bias:w,preluActivationWeights:k},_={transposeA:n,transposeB:r,activation:i,leakyreluAlpha:o};return null==s?Ev((e,t,n)=>{const r=Zb.runKernel(rb,I,_);return n([e,t,r]),{value:Xv(r,y),gradFunc:C}})(v,x):Ev((e,t,n,r)=>{const s=Zb.runKernel(rb,I,_);return r([e,t,s,n]),{value:Xv(s,y),gradFunc:C}})(v,x,w)}});function ik(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let i=0;i<e;++i){const a=2*Math.PI*i/(e+r-1);s[i]=t-n*Math.cos(a)}return Rw(s,"float32")}ay({hammingWindow_:function(e){return ik(e,.54,.46)}});const ak=ay({hannWindow_:function(e){return ik(e,.5,.5)}}),ok=ay({frame_:function(e,t,n,r=!1,s=0){let i=0;const a=[];for(;i+t<=e.size;)a.push(xw(e,i,t)),i+=n;if(r)for(;i<e.size;){const r=i+t-e.size,o=rx([xw(e,i,t-r),Sx([r],s)]);a.push(o),i+=n}return 0===a.length?Fw([],[0,t]):Xv(rx(a),[a.length,t])}});function uk(e,t,n,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const a=e.shape[0];return n=Math.min(n,a),Ip(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Ip(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Ip(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Ip(1===t.rank,()=>"scores must be a 1D tensor"),Ip(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),Ip(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}function lk(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,i=0,a=!1;for(;r<s;){i=r+(s-r>>>1);const o=n(t,e[i]);o>0?r=i+1:(s=i,a=!o)}return a?r:-r-1}(e,t,n||ck)}(e,t,n);e.splice(r<0?-(r+1):r,0,t)}function ck(e,t){return e>t?1:e<t?-1:0}function hk(e,t,n,r,s){return fk(e,t,n,r,s,0)}function dk(e,t,n,r,s,i){return fk(e,t,n,r,s,0,!1,i,!0)}function pk(e,t,n,r,s,i){return fk(e,t,n,r,s,i,!0)}function fk(e,t,n,r,s,i,a=!1,o=!1,u=!1){const l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(bk);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:i,suppressBeginIndex:a}=t;if(n<s)break;let o=!1;for(let u=h.length-1;u>=a;--u){const n=mk(e,i,h[u]);if(n>=r){o=!0;break}if(t.score=t.score*gk(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(i),d.push(t.score)):t.score>s&&lk(l,t,bk))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),u&&(m.validOutputs=p),m}function mk(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),i=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-i)*(u-a),f=(h-l)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,l),g=Math.max(a,c),b=Math.min(o,h),y=Math.min(u,d),v=Math.max(b-m,0)*Math.max(y-g,0);return v/(p+f-v)}function gk(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function bk(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}ay({stft_:function(e,t,n,r,s=ak){null==r&&(r=Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2)))));const i=ok(e,t,n),a=Ox(i,s(t));return qw(a,r)}}),ay({cropAndResize_:function(e,t,n,r,s="bilinear",i=0){const a=sy(e,"image","cropAndResize"),o=sy(t,"boxes","cropAndResize","float32"),u=sy(n,"boxInd","cropAndResize","int32"),l=o.shape[0];return Ip(4===a.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),Ip(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`),Ip(1===u.rank&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`),Ip(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Ip(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Ip("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),Zb.runKernel(Hf,{image:a,boxes:o,boxInd:u},{method:s,extrapolationValue:i,cropSize:r})}}),ay({flipLeftRight_:function(e){const t=sy(e,"image","flipLeftRight","float32");return Ip(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),Zb.runKernel(fm,{image:t},{})}}),ay({rotateWithOffset_:function(e,t,n=0,r=.5){const s=sy(e,"image","rotateWithOffset","float32");return Ip(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),Zb.runKernel(nb,{image:s},{radians:t,fillValue:n,center:r})}}),ay({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=sy(e,"boxes","nonMaxSuppression"),a=sy(t,"scores","nonMaxSuppression"),o=uk(i,a,n,r,s);return Zb.runKernel(tg,{boxes:i,scores:a},{maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold})}}),ay({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const a=sy(e,"boxes","nonMaxSuppression"),o=sy(t,"scores","nonMaxSuppression"),u=uk(a,o,n,r,s,i),l=Zb.runKernel(rg,{boxes:a,scores:o},{maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold,softNmsSigma:i=u.softNmsSigma});return{selectedIndices:l[0],selectedScores:l[1]}}}),ay({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const a=sy(e,"boxes","nonMaxSuppression"),o=sy(t,"scores","nonMaxSuppression"),u=uk(a,o,n,r,s,null),l=Zb.runKernel(ng,{boxes:a,scores:o},{maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:l[0],validOutputs:l[1]}}});const yk=ay({resizeBilinear_:function(e,t,n=!1,r=!1){const s=sy(e,"images","resizeBilinear");Ip(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Ip(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Ip(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,a=!1;3===s.rank&&(a=!0,i=Xv(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o=Zb.runKernel(yg,{images:i},{alignCorners:n,halfPixelCenters:r,size:t});return a?Xv(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),vk=ay({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=sy(e,"images","resizeNearestNeighbor");Ip(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Ip(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Ip("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Ip(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,a=!1;3===s.rank&&(a=!0,i=Xv(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o=Zb.runKernel(gg,{images:i},{alignCorners:n,halfPixelCenters:r,size:t});return a?Xv(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),xk=ay({bincount_:function(e,t,n){const r=sy(e,"x","bincount"),s=sy(t,"weights","bincount");return Ip("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Ip(n>=0,()=>`size must be non-negative, but got ${n}.`),Ip(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),Zb.runKernel(Af,{x:r,weights:s},{size:n})}}),wk=ay({lessEqual_:function(e,t){let n=sy(e,"a","lessEqual"),r=sy(t,"b","lessEqual");return[n,r]=Wb(n,r),wx(n.shape,r.shape),Zb.runKernel(Tm,{a:n,b:r})}}),kk=ay({round_:function(e){const t=sy(e,"x","round");return Zb.runKernel(kg,{x:t})}});function Ck(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");return Zb.runKernel(hg,{},{start:e,stop:t,step:n,dtype:r})}ay({threshold_:function(e,t="binary",n=!1,r=.5){const s=sy(e,"image","threshold"),i=s.shape[0]*s.shape[1];let a,o,u,l,c=Ox(Rw([r]),255);if(Ip(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Ip(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Ip("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Ip("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[a,o,u]=Nw(s,[1,1,1],-1);const e=Ox(a,.2989),t=Ox(o,.587),n=Ox(u,.114);l=Rv(Rv(e,t),n)}else l=e;"otsu"===t&&(c=function(e,t){let n,r,s,i,a,o,u=Rw([-1]),l=Rw([0]),c=Rw([0]);for(let h=0;h<e.size-1;h++){n=xw(e,0,h+1),r=xw(e,h+1),a=bx(Lx(n),t),o=bx(Lx(r),t);const d=Lx(Ox(n,Ck(0,n.size)));s=bx(d,Lx(n));const p=Sx(r.shape,n.size),f=Rv(Ck(0,r.size),p),m=Ox(r,f);i=bx(Lx(m),Lx(r));const g=Mx(s,i),b=Mx(s,i),y=Ox(a,o);c=Ox(Ox(y,g),b);const v=$x(c,l);l=Lw(v,c,l),u=Lw(v,Rw([h]),u)}return u}(xk(jy(kk(l),"int32"),ly([]),256),i));const h=n?wk(l,c):$x(l,c);return jy(Ox(h,255),"int32")}}),ay({transform_:function(e,t,n="nearest",r="constant",s=0,i){const a=sy(e,"image","transform","float32"),o=sy(t,"transforms","transform","float32");return Ip(4===a.rank,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),Ip(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Ip(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),Zb.runKernel(Xg,{image:a,transforms:o},{interpolation:n,fillMode:r,fillValue:s,outputShape:i})}});const Ik=ay({bandPart_:function(e,t,n){Ip(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Ip(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=sy(e,"a","bandPart");Ip(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,a]=r.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);t<0&&(t=i),n<0&&(n=a);const o=Xv(Ck(0,i,1,"int32"),[-1,1]),u=Ck(0,a,1,"int32"),l=Mx(o,u),c=zx(wk(l,$v(+t,"int32")),Tx(l,$v(-n,"int32"))),h=iw([i,a],r.dtype);return Xv(Tw(Ow(Xv(r,[-1,i,a])).map(e=>Lw(c,e,h))),s)}}),_k=ay({pow_:function(e,t){let n=sy(e,"base","pow"),r=sy(t,"exp","pow");return[n,r]=Wb(n,r),Zb.runKernel(ug,{a:n,b:r})}});function Sk(e,t,n=null){if(0===e.rank)return Av(e);if(1!==e.rank&&null===n)return Sk(Xv(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Lx(Av(e),n);if(t===1/0)return Dx(Av(e),n);if(t===-1/0)return qx(Av(e),n);if("euclidean"===t||2===t)return Ew(Lx(_k(Av(e),$v(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Dx(Lx(Av(e),n[0]),n[1]-1);if(t===1/0)return Dx(Lx(Av(e),n[1]),n[0]);if(t===-1/0)return qx(Lx(Av(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Ew(Lx(ew(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Nk=ay({norm_:function(e,t="euclidean",n=null,r=!1){const s=Sk(e=sy(e,"x","norm"),t,n);let i=s.shape;if(r){const t=Op(n,e.shape);i=Xx(s.shape,t)}return Xv(s,i)}}),Ek=ay({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Ip(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Ip(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=Nw(e,e.shape[0],0).map(e=>$w(e,[0]));Ip(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(Zb.tidy(()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=Ox(Lx(Ox(n[t],e)),n[t]);e=Mx(e,r)}return bx(e,Nk(e,"euclidean"))}));return t?Tw(n,0):n}});function $k(e,t=!1){return Zb.tidy(()=>{Ip(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=_x(n),i=Gy(e);const a=Fw([[1]],[1,1]);let o=Gy(a);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=i,u=o,l=s;[o,i,s]=Zb.tidy(()=>{const t=xw(i,[e,e],[n-e,1]),u=Nk(t),l=xw(i,[e,e],[1,1]),c=Lw($x(l,0),Fw([[-1]]),Fw([[1]])),h=Mx(l,Ox(c,u)),d=bx(t,h);o=1===d.shape[0]?Gy(a):rx([a,xw(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=nw(bx(rk(c,h),u)),f=xw(i,[e,0],[n-e,r]),m=Ox(p,o),g=zw(o);if(0===e)i=Mx(f,rk(m,rk(g,f)));else{const t=Mx(f,rk(m,rk(g,f)));i=rx([xw(i,[0,0],[e,r]),t],0)}const b=zw(m),y=xw(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Mx(y,rk(rk(y,o),b));else{const t=Mx(y,rk(rk(y,o),b));s=rx([xw(s,[0,0],[n,e]),t],1)}return[o,i,s]}),_v([t,u,l])}return!t&&n>r&&(s=xw(s,[0,0],[n,r]),i=xw(i,[0,0],[r,r])),[s,i]})}const Tk=ay({qr_:function(e,t=!1){if(Ip(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return $k(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=Ow(Xv(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],i=[];return r.forEach(e=>{const[n,r]=$k(e,t);s.push(n),i.push(r)}),[Xv(Tw(s,0),e.shape),Xv(Tw(i,0),e.shape)]}}});var Ak;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Ak||(Ak={}));const Rk=ay({computeWeightedLoss_:function(e,t,n=Ak.SUM_BY_NONZERO_WEIGHTS){const r=sy(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=sy(t,"weights","computeWeightedLoss"));const i=null==s?r:Ox(r,s);if(n===Ak.NONE)return i;if(n===Ak.SUM)return Lx(i);if(n===Ak.MEAN){if(null==s)return Ux(i);{const e=r.size/s.size,t=bx(Lx(i),Lx(s));return e>1?bx(t,$v(e)):t}}if(n===Ak.SUM_BY_NONZERO_WEIGHTS){if(null==s)return bx(Lx(i),$v(r.size));{const e=Ox(s,aw(r.shape)),t=jy(Lx(rw(e,$v(0))),"float32");return bx(Lx(i),t)}}throw Error(`Unknown reduction: ${n}`)}});ay({absoluteDifference_:function(e,t,n,r=Ak.SUM_BY_NONZERO_WEIGHTS){const s=sy(e,"labels","absoluteDifference"),i=sy(t,"predictions","absoluteDifference");let a=null;null!=n&&(a=sy(n,"weights","absoluteDifference")),_p(s.shape,i.shape,"Error in absoluteDifference: ");const o=Av(Mx(s,i));return Rk(o,a,r)}}),ay({cosineDistance_:function(e,t,n,r,s=Ak.SUM_BY_NONZERO_WEIGHTS){const i=sy(e,"labels","cosineDistance"),a=sy(t,"predictions","cosineDistance");let o=null;null!=r&&(o=sy(r,"weights","cosineDistance")),_p(i.shape,a.shape,"Error in cosineDistance: ");const u=$v(1),l=Mx(u,Lx(Ox(i,a),n,!0));return Rk(l,o,s)}}),ay({hingeLoss_:function(e,t,n,r=Ak.SUM_BY_NONZERO_WEIGHTS){let s=sy(e,"labels","hingeLoss");const i=sy(t,"predictions","hingeLoss");let a=null;null!=n&&(a=sy(n,"weights","hingeLoss")),_p(s.shape,i.shape,"Error in hingeLoss: ");const o=$v(1);s=Mx(Ox($v(2),s),o);const u=mw(Mx(o,Ox(s,i)));return Rk(u,a,r)}}),ay({huberLoss_:function(e,t,n,r=1,s=Ak.SUM_BY_NONZERO_WEIGHTS){const i=sy(e,"labels","huberLoss"),a=sy(t,"predictions","huberLoss");let o=null;null!=n&&(o=sy(n,"weights","huberLoss")),_p(i.shape,a.shape,"Error in huberLoss: ");const u=$v(r),l=Av(Mx(a,i)),c=jx(l,u),h=Mx(l,c),d=Rv(Ox($v(.5),ew(c)),Ox(u,h));return Rk(d,o,s)}}),ay({logLoss_:function(e,t,n,r=1e-7,s=Ak.SUM_BY_NONZERO_WEIGHTS){const i=sy(e,"labels","logLoss"),a=sy(t,"predictions","logLoss");let o=null;null!=n&&(o=sy(n,"weights","logLoss")),_p(i.shape,a.shape,"Error in logLoss: ");const u=$v(1),l=$v(r),c=nw(Ox(i,Rx(Rv(a,l)))),h=Ox(Mx(u,i),Rx(Rv(Mx(u,a),l))),d=Mx(c,h);return Rk(d,o,s)}});const Fk=ay({squaredDifference_:function(e,t){let n=sy(e,"a","squaredDifference"),r=sy(t,"b","squaredDifference");return[n,r]=Wb(n,r),wx(n.shape,r.shape),Zb.runKernel(Bg,{a:n,b:r},{})}});ay({meanSquaredError_:function(e,t,n,r=Ak.SUM_BY_NONZERO_WEIGHTS){const s=sy(e,"labels","meanSquaredError"),i=sy(t,"predictions","meanSquaredError");let a=null;null!=n&&(a=sy(n,"weights","meanSquaredError")),_p(s.shape,i.shape,"Error in meanSquaredError: ");const o=Fk(s,i);return Rk(o,a,r)}});const Dk=ay({log1p_:function(e){const t=sy(e,"x","log1p");return Zb.runKernel(Fm,{x:t})}});ay({sigmoidCrossEntropy_:function(e,t,n,r=0,s=Ak.SUM_BY_NONZERO_WEIGHTS){let i=sy(e,"multiClassLabels","sigmoidCrossEntropy");const a=sy(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=sy(n,"weights","sigmoidCrossEntropy")),_p(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=$v(r),t=$v(1),n=$v(.5);i=Rv(Ox(i,Mx(t,e)),Ox(n,e))}const u=function(e,t){const n=sy(e,"labels","sigmoidCrossEntropyWithLogits"),r=sy(t,"logits","sigmoidCrossEntropyWithLogits");_p(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=mw(r),i=Ox(r,n),a=Dk(Fx(nw(Av(r))));return Rv(Mx(s,i),a)}(i,a);return Rk(u,o,s)}});const Ok=ay({logSumExp_:function(e,t=null,n=!1){const r=sy(e,"x","logSumExp"),s=Op(t,r.shape),i=Dx(r,s,!0),a=Mx(r,i),o=Fx(a),u=Lx(o,s),l=Rx(u),c=Rv(Xv(i,l.shape),l);if(n){const e=Xx(c.shape,s);return Xv(c,e)}return c}});ay({softmaxCrossEntropy_:function(e,t,n,r=0,s=Ak.SUM_BY_NONZERO_WEIGHTS){let i=sy(e,"onehotLabels","softmaxCrossEntropy");const a=sy(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=sy(n,"weights","softmaxCrossEntropy")),_p(i.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const e=$v(r),t=$v(1),n=$v(i.shape[1]);i=Rv(Ox(i,Mx(t,e)),bx(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Ev((e,t,r)=>{const s=Ok(t,[n],!0),i=Mx(jy(t,"float32"),s);r([e,i]);const a=nw(Ox(i,e));return{value:Lx(a,[n]),gradFunc:(e,t)=>{const[r,s]=t,i=Xx(e.shape,[n]);return[Ox(Xv(e,i),Mx(jy(r,"float32"),Fx(s))),Ox(Xv(e,i),Mx(Fx(s),jy(r,"float32")))]}}})(e,t)}(i,a);return Rk(u,o,s)}}),ay({sparseFillEmptyRows_:function(e,t,n,r){const s=sy(e,"indices","sparseFillEmptyRows"),i=sy(t,"values","sparseFillEmptyRows"),a=sy(n,"denseShape","sparseFillEmptyRows"),o=sy(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==a.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u=Zb.runKernel(Pg,{indices:s,values:i,denseShape:a,defaultValue:o});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),ay({sparseReshape_:function(e,t,n){const r=sy(e,"inputIndices","sparseReshape"),s=sy(t,"inputShape","sparseReshape"),i=sy(n,"newShape","sparseReshape");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=Zb.runKernel(zg,{inputIndices:r,inputShape:s,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}});const Mk={bandPart:Ik,gramSchmidt:Ek,qr:Tk};class Lk extends Tv{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Zb.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Zb.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Iv(()=>Pw(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Iv(()=>Pw(r).variable(!1))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;Iv(()=>{const e=Rv(Ox(i,this.rho),Ox(ew(s),1-this.rho)),t=Ox(bx(Ew(Rv(a,this.epsilon)),Ew(Rv(i,this.epsilon))),s),n=Rv(Ox(a,this.rho),Ox(ew(t),1-this.rho));i.assign(e),a.assign(n);const o=Rv(Ox(t,-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(_v(this.accumulatedGrads.map(e=>e.variable)),_v(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return bp(function*(){const t=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){const n=(e=yield t.extractIterations(e)).length/2;t.accumulatedGrads=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedUpdates=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}Lk.className="Adadelta",wv(Lk);class Pk extends Tv{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Zb.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Iv(()=>Sx(r.shape,this.initialAccumulatorValue).variable(e))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedGrads[n].variable;Iv(()=>{const e=Rv(i,ew(s));i.assign(e);const t=Rv(Ox(bx(s,Ew(Rv(e,Zb.backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&_v(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return bp(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e),t.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Pk.className="Adagrad",wv(Pk);class zk extends Tv{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Iv(()=>{this.accBeta1=$v(t).variable(),this.accBeta2=$v(n).variable()}),null==r&&(this.epsilon=Zb.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Iv(()=>{const n=Mx(1,this.accBeta1),r=Mx(1,this.accBeta2);t.forEach((t,s)=>{const i=Zb.registeredVariables[t];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Iv(()=>Pw(i).variable(!1))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:Iv(()=>Pw(i).variable(!1))});const a=Array.isArray(e)?e[s].tensor:e[t];if(null==a)return;const o=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,l=Rv(Ox(o,this.beta1),Ox(a,1-this.beta1)),c=Rv(Ox(u,this.beta2),Ox(ew(a),1-this.beta2)),h=bx(l,n),d=bx(c,r);o.assign(l),u.assign(c);const p=Rv(Ox(bx(h,Rv(Ew(d),this.epsilon)),-this.learningRate),i);i.assign(p)}),this.accBeta1.assign(Ox(this.accBeta1,this.beta1)),this.accBeta2.assign(Ox(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&_v(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&_v(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return bp(function*(){const t=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e),Iv(()=>{t.accBeta1.assign(_k(t.beta1,t.iterations_+1)),t.accBeta2.assign(_k(t.beta2,t.iterations_+1))});const n=e.length/2;t.accumulatedFirstMoment=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedSecondMoment=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}zk.className="Adam",wv(zk);class Vk extends Tv{constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Iv(()=>{this.iteration=$v(0).variable(),this.accBeta1=$v(t).variable()}),null==r&&(this.epsilon=Zb.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Iv(()=>{const n=Mx(1,this.accBeta1),r=bx(-this.learningRate,Rv(Ox(this.iteration,this.decay),1));t.forEach((t,s)=>{const i=Zb.registeredVariables[t];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Pw(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:Pw(i).variable(!1)});const a=Array.isArray(e)?e[s].tensor:e[t];if(null==a)return;const o=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,l=Rv(Ox(o,this.beta1),Ox(a,1-this.beta1)),c=Ox(u,this.beta2),h=Av(a),d=Wx(c,h);o.assign(l),u.assign(d);const p=Rv(Ox(bx(r,n),bx(l,Rv(d,this.epsilon))),i);i.assign(p)}),this.iteration.assign(Rv(this.iteration,1)),this.accBeta1.assign(Ox(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&_v(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&_v(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return bp(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return bp(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Vk.className="Adamax",wv(Vk);class Bk extends Tv{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=Zb.registeredVariables[t];Iv(()=>{const e=Rv(Ox(this.c,r),s);s.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Sv($v(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return bp(function*(){return[yield e.saveIterations()]})()}setWeights(e){var t=this;return bp(function*(){if(0!==(e=yield t.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Bk.className="SGD",wv(Bk);class Wk extends Bk{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=$v(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Zb.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Iv(()=>Pw(r).variable(e))}}const s=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[t];null!=i&&Iv(()=>{let e;const t=Rv(Ox(this.m,s),i);e=Rv(Ox(this.c,this.useNesterov?Rv(i,Ox(t,this.m)):t),r),s.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&_v(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return bp(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e),t.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Wk.className="Momentum",wv(Wk);class Uk extends Tv{constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=Zb.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Zb.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Iv(()=>Pw(r).variable(s))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Iv(()=>Pw(r).variable(s))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Iv(()=>Pw(r).variable(s))});const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Iv(()=>{const e=Rv(Ox(a,this.decay),Ox(ew(i),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=Rv(Ox(t,this.decay),Ox(i,1-this.decay)),u=bx(Ox(i,this.learningRate),Ew(Mx(e,Rv(ew(s),this.epsilon)))),l=Rv(Ox(o,this.momentum),u);a.assign(e),t.assign(s),o.assign(l);const c=Mx(r,l);r.assign(c)}else{const e=Rv(Ox(a,this.decay),Ox(ew(i),1-this.decay)),t=Rv(Ox(o,this.momentum),bx(Ox(i,this.learningRate),Ew(Rv(e,this.epsilon))));a.assign(e),o.assign(t);const n=Mx(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&_v(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&_v(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&_v(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return bp(function*(){const t=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&t.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bp(function*(){e=yield t.extractIterations(e);const n=t.centered?e.length/3:e.length/2,r=!1;t.accumulatedMeanSquares=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(r)})),t.accumulatedMoments=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(r)})),t.centered&&(t.accumulatedMeanGrads=e.slice(2*n,3*n).map(e=>({originalName:e.name,variable:e.tensor.variable(r)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Uk.className="RMSProp",wv(Uk);class qk{static sgd(e){return new Bk(e)}static momentum(e,t,n=!1){return new Wk(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Uk(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new zk(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Lk(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Vk(e,t,n,r,s)}static adagrad(e,t=.1){return new Pk(e,t)}}const jk={sgd:qk.sgd,momentum:qk.momentum,adadelta:qk.adadelta,adagrad:qk.adagrad,rmsprop:qk.rmsprop,adamax:qk.adamax,adam:qk.adam},Gk="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Hk(){return new Promise(e=>Gk(()=>e()))}function Kk(e,t){const n=e[0].length;e.forEach((e,t)=>{Ip(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),Ip(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,s)=>{for(let i=0;i<n;i++)Ip(i===t||e[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Xk(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}const Zk=30;function Yk(e){return e<=Zk?e:Gp(e,Math.floor(Math.sqrt(e)))}function Qk(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Jk(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function eC(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function tC(e,t,n,r=!0){const s=[];s.push(r?e[0]/n:e[0]*n);for(let i=1;i<e.length;++i)s.push(i<=t.length?r?t[i-1]*e[i]:e[i]/t[i-1]:e[i]);return s}function nC(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function rC(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}function sC(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Ep(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,i=s[s.length-1];let a=1;for(let h=0;h<s.length-1;++h)a*=s[h];const o=e.shape,u=s.slice();u.pop();let l=1;for(let h=i;h<n;++h)l*=o[h],u.push(o[h]);const c=[...Hp(e.shape).map(e=>e/l),1].slice(0,i);return[u,a,l,c]}function iC(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(i+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(i+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(i+" update.rank != "+(s+e.length-r));for(let a=0;a<s;++a)if(n.shape[a]!==t.shape[a])throw new Error(i+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<n.rank-s;++a)if(n.shape[a+s]!==e[a+r])throw new Error(i+` updates.shape[${a+s}] (${n.shape[a+s]}) != shape[${a+s}] (${e[a+s]})`)}function aC(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}iC(n,t,e)}function oC(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=n.length;let a=1;for(let u=s;u<i;++u)a*=n[u];const o=s<1?1:s;return{sliceRank:s,numUpdates:Ep(t.shape)/o,sliceSize:a,strides:[...Hp(n.slice(0,s)),1],outputSize:Ep(n)}}const uC=1.7580993408473768,lC=1.0507009873554805,cC=.3275911,hC=.254829592,dC=-.284496736,pC=1.421413741,fC=-1.453152027,mC=1.061405429;function gC(...e){af().getBool("IS_TEST")||console.warn(...e)}function bC(...e){af().getBool("IS_TEST")||console.log(...e)}function yC(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function vC(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function xC(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function wC(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function kC(e,t){return{real:e[2*t],imag:e[2*t+1]}}function CC(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function IC(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const i=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:n,imag:r}}function _C(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const SC=/->/g;function NC(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(SC,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=e.split("->");Ip(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const i=r.split(","),a=i.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const e=s[h];if(!i.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===o.indexOf(e)&&","!==e&&o.push(e)}const u=new Array(i.length);for(let h=0;h<a;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let e=0;e<i[h].length;++e)u[h].push(o.indexOf(i[h][e]))}const l=o.length,c=[];for(let h=s.length;h<l;++h)c.push(h);return{allDims:o,summedDims:c,idDims:u}}function EC(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:r}}function $C(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:Ip(r[t[s][n]]===e[n],()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`)}}function TC(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let a=0;a<s;++a)r.push([]);const i=[];for(let a=0;a<n.length;++a){const e=RC(t,n[a]);for(const t of e)-1===i.indexOf(t)&&(r[a].push(t),i.push(t))}return{path:n,steps:r}}function AC(e){return e.every((e,t)=>e===t)}function RC(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function FC(e,t,n=0){let r=[];if("number"==typeof t)Ip(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{Ip(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const r=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[n]-r}Ip(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function DC(e,t){let n,r=!1;for(e<=Zk?(n=e,r=!0):n=Gp(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Gp(e,n+1);return n}function OC(e,t,n){const r=[],s=e.length;for(let i=0;i<s;i++)r.push(i!==t?e[i]:n);return r}function MC(e,t,n,r){const s=t.shape.length,i=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const a=e.shape[n],o=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<i;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:a,outputShape:o}}function LC(e){try{return e.map(e=>yb(e))}catch(aK){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${aK}`)}}function PC(e){return e.map(e=>bb(e))}function zC(e,t){const n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);const r=qy(e,"int32"),s=qy([n.length,e.length],"int32");for(let i=0;i<n.length;i++){const t=r.indexToLoc(n[i]);s.values.set(t,i*e.length)}return s.toTensor()}const VC={kernelName:hf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Xw(jy(n,"float32"),-1))}}},BC={kernelName:df,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ew(jy(n,"float32")),r=Ew(Mx($v(1),t));return nw(bx(e,r))}}}},WC={kernelName:pf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Ew(Mx(ew(jy(n,"float32")),1));return bx(e,t)}}}},UC={kernelName:ff,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=wx(n.shape,r.shape);return{a:()=>{let t=e;const r=xx(n.shape,s);return r.length>0&&(t=Lx(t,r)),Xv(t,n.shape)},b:()=>{let t=e;const n=xx(r.shape,s);return n.length>0&&(t=Lx(t,n)),Xv(t,r.shape)}}}},qC={kernelName:mf,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,r)=>{n[r]=()=>e.clone()}),n}},jC={kernelName:yf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Pw(n)}}},GC={kernelName:vf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Pw(n)}}},HC={kernelName:xf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Ew(Mx($v(1),ew(jy(n,"float32")))))}}},KC={kernelName:wf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Ew(Rv($v(1),ew(jy(n,"float32"))));return bx(e,t)}}}},XC={kernelName:If,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=wx(n.shape,r.shape);return{a:()=>{const t=Rv(ew(n),ew(r));let i=Ox(e,bx(r,t));const a=xx(n.shape,s);return a.length>0&&(i=Lx(i,a)),Xv(i,n.shape)},b:()=>{const t=Rv(ew(n),ew(r));let i=nw(Ox(e,bx(n,t)));const a=xx(r.shape,s);return a.length>0&&(i=Lx(i,a)),Xv(i,r.shape)}}}},ZC={kernelName:kf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Rv(ew(jy(n,"float32")),1))}}},YC={kernelName:Cf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Mx($v(1),ew(jy(n,"float32"))))}}},QC=ay({avgPool3dGrad_:function(e,t,n,r,s,i){const a=sy(e,"dy","avgPool3dGrad"),o=sy(t,"input","avgPool3dGrad");let u=a,l=o,c=!1;4===o.rank&&(c=!0,u=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),l=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Ip(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),Ip(5===l.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),null!=i&&Ip(Tp(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const h=Zb.runKernel(Ef,{dy:u,input:l},{filterSize:n,strides:r,pad:s,dimRoundingMode:i});return c?Xv(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),JC={kernelName:Nf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:o}=n;return{x:()=>QC(e,r,s,i,a,o)}}},eI=ay({avgPoolGrad_:function(e,t,n,r,s){const i=sy(e,"dy","avgPoolGrad"),a=sy(t,"input","avgPoolGrad");Ip(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,u=i,l=!1;3===a.rank&&(l=!0,o=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ip(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),Ip(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c=Zb.runKernel(Sf,{dy:u,input:o},{filterSize:n,strides:r,pad:s});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),tI={kernelName:_f,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:i,pad:a}=n;return{x:()=>eI(e,r,s,i,a)}}},nI={kernelName:$f,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:i,transposeB:a}=n;return i||a?!i&&a?{a:()=>rk(e,s,!1,!1),b:()=>rk(e,r,!0,!1)}:i&&!a?{a:()=>rk(s,e,!1,!0),b:()=>rk(r,e,!1,!1)}:{a:()=>rk(s,e,!0,!0),b:()=>rk(e,r,!0,!0)}:{a:()=>rk(e,s,!1,!0),b:()=>rk(r,e,!0,!1)}}},rI=ay({spaceToBatchND_:function(e,t,n){const r=sy(e,"x","spaceToBatchND");return Ip(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Ip(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Ip(r.shape.reduce((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),Zb.runKernel(Og,{x:r},{blockShape:t,paddings:n})}}),sI={kernelName:Tf,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>rI(e,r,s)}}},iI={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n.inputShape,s=n.shape,i=Array.from(s);for(let o=r.length-1;o>=0;o--)if(r[o]===s[o])i[o]=1;else if(1!==r[o])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const a=[];for(let o=0;o<i.length;o++)i[o]>1&&a.push(o);return{x:()=>Lx(e,a,!0)}}},aI={kernelName:Rf,gradFunc:e=>({x:()=>e.clone()})},oI={kernelName:Ff,gradFunc:e=>({x:()=>Pw(e)})},uI={kernelName:Df,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:i}=n;return{x:()=>Lw(zx(Tx(r,s),wk(r,i)),e,Pw(e))}}},lI={kernelName:Mf,inputsToSave:["x"],gradFunc:VC.gradFunc},cI={kernelName:Lf,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(e=>e.shape),{axis:s}=n,i=Op(s,t[0].shape)[0],a=r.map(e=>e[i]);return Nw(e,a,i).map(e=>()=>e)}},hI={kernelName:Pf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:i,strides:a,pad:o,dataFormat:u}=n;return Ip(Gv(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>cx(r.shape,e,s,a,o,u),filter:()=>Hw(r,e,s.shape,a,o,u)}}},dI={kernelName:Vf,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:i,pad:a,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>ux(e,s,i,a,o,1,u),filter:()=>Hw(e,r,s.shape,i,a,o,u)}}},pI=ay({conv3DBackpropFilter_:function(e,t,n,r,s){let i=e;4===e.rank&&(i=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let a=t;return 4===a.rank&&(a=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Ip(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),Ip(5===a.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),Ip(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Ip(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),Ip(a.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`),Zb.runKernel(Wf,{x:i,dy:a},{strides:r,pad:s,filterShape:n})}}),fI={kernelName:Bf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:i}=n;Ip(Gv(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[a,o]=t;return{x:()=>px(a.shape,e,o,s,i),filter:()=>pI(a,e,o.shape,s,i)}}},mI=ay({sin_:function(e){const t=sy(e,"x","sin");return Zb.runKernel(Eg,{x:t})}}),gI={kernelName:qf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(nw(mI(jy(n,"float32"))),e)}}},bI=ay({sinh_:function(e){const t=sy(e,"x","sinh");return Zb.runKernel($g,{x:t})}}),yI={kernelName:jf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(bI(jy(n,"float32")),e)}}},vI=ay({cumsum_:function(e,t=0,n=!1,r=!1){const s=sy(e,"x","cumsum");return Zb.runKernel(Gf,{x:s},{axis:t,exclusive:n,reverse:r})}}),xI={kernelName:Gf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:i,reverse:a}=n;return{x:()=>{const t=Yx([s],r.rank);let n=vI(e,s,i,!a);return null!=t&&(n=zw(n,t)),n}}}},wI={kernelName:Zf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:a}=n,o=null==r?[1,1]:r;Ip(Gv(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,l]=t;return Ip(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),Ip(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),Ip(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),Ip(Hv(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),null!=a&&Ip(Tp(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),{x:()=>nk(u.shape,e,l,s,i,r,a),filter:()=>tk(u,e,l.shape,s,i,r,a)}}},kI={kernelName:em,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,i={x:r,filter:s,dy:e},a={x:r,filter:s,dy:e};return{x:()=>Zb.runKernel(tm,i,n),filter:()=>Zb.runKernel(nm,a,n)}}},CI={kernelName:im,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Zb.runKernel(am,r)}}},II={kernelName:om,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Ox(Fx(nw(ew(n))),2/Math.sqrt(Math.PI));return{x:()=>Ox(e,r)}}},_I={kernelName:lm,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,n)}}},SI={kernelName:cm,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Xv(e,n.shape)}}},NI={kernelName:hm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Fx(n))}}},EI={kernelName:mm,gradFunc:e=>({x:()=>Pw(e)})},$I={kernelName:gm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=wx(n.shape,r.shape);return{a:()=>{const t=bx(e,jy(r,"float32")),i=xx(n.shape,s);return i.length>0?Xv(Lx(t,i),n.shape):t},b:()=>{let t=Ox(e,jy(n,"float32"));const i=xx(r.shape,s);i.length>0&&(t=Xv(Lx(t,i),r.shape));const a=ew(r);return nw(bx(t,jy(a,"float32")))}}}},TI=ay({rsqrt_:function(e){const t=sy(e,"x","rsqrt");return Zb.runKernel(Cg,{x:t})}}),AI={kernelName:bm,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,i,a,o]=t,u=null==o?$v(1):o,l=xx(i.shape,s.shape),c=[];if(1===i.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=Mx(s,i),d=Ox(e,u),p=TI(Rv(a,$v(r))),f=Ox(Ox(Ox(p,p),p),$v(-.5));return{x:()=>Xv(Ox(Ox(e,1===i.rank?Ix(Xv(p,[1,1,1,i.shape[0]]),c):p),u),s.shape),mean:()=>{let e=Ox(Ox(p,$v(-1)),d);return 1===i.rank&&(e=Lx(e,l)),Xv(e,i.shape)},variance:()=>{let e=Ox(Ox(f,h),d);return 1===i.rank&&(e=Lx(e,l)),Xv(e,i.shape)},scale:()=>{const t=Ox(h,p);let n=Ox(e,t);return 1===i.rank&&(n=Lx(n,l)),Xv(n,i.shape)},offset:()=>{let t=e;return 1===i.rank&&(t=Lx(t,l)),Xv(t,i.shape)}}}},RI=ay({unsortedSegmentSum_:function(e,t,n){const r=sy(e,"x","unsortedSegmentSum"),s=sy(t,"segmentIds","unsortedSegmentSum","int32");return Ip(Tp(n),()=>"numSegments must be of dtype int"),Zb.runKernel(Jg,{x:r,segmentIds:s},{numSegments:n})}}),FI={kernelName:ym,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:i}=n,a=Op(i,r.shape)[0];return{x:()=>{const t=r.shape,n=s.size,o=t.slice(0,a),u=o.length,l=t.slice(i,t.length).slice(1),c=l.length,h=DI(0,u),d=DI(u+1,u+1+c),p=OI([o,[n],l]),f=Xv(e,p),m=Xv(s,[n]),g=OI([[u],h,d]),b=zw(f,g);let y=RI(b,m,r.shape[a]);const v=Qx(g);return y=zw(y,v),y},indices:()=>s}}};function DI(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function OI(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const MI={kernelName:wm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Pw(n),b:()=>Pw(r)}}},LI={kernelName:km,gradFunc:e=>({x:()=>jy(e,"float32")})},PI={kernelName:_m,gradFunc:e=>({x:()=>Pw(e)})},zI={kernelName:Sm,gradFunc:e=>({x:()=>Pw(e)})},VI={kernelName:Nm,gradFunc:e=>({x:()=>Pw(e)})},BI={kernelName:Em,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,i=$x(r,0);return{x:()=>Lw(i,e,Ox(e,s))}}},WI={kernelName:Fm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Rv(n,1))}}},UI={kernelName:Rm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,jy(n,"float32"))}}},qI={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=Fx(r);return Mx(e,Ox(Lx(e,s,!0),t))}}}},jI=ay({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,i=1,a=.5){return Zb.runKernel(Pm,{x:e,y:t,dy:n},{depthRadius:r,bias:s,alpha:i,beta:a})}}),GI={kernelName:Lm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:i,bias:a,alpha:o,beta:u}=n;return{x:()=>jI(r,s,e,i,a,o,u)}}};function HI(e,t,n,r){return t.rank<n.rank&&(t=Xv(t,Xx(t.shape,r))),e.rank<n.rank&&(e=Xv(e,Xx(e.shape,r))),{x:()=>Ox(e,jy(kx(n,t),e.dtype))}}const KI={kernelName:zm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,i=t[0],a=HI(e,t[1],i,Op(s,i.shape));return{x:()=>a.x()}}},XI=ay({less_:function(e,t){let n=sy(e,"a","less"),r=sy(t,"b","less");return[n,r]=Wb(n,r),wx(n.shape,r.shape),Zb.runKernel($m,{a:n,b:r})}}),ZI={kernelName:Vm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Ox(e,jy(Tx(n,r),"float32")),b:()=>Ox(e,jy(XI(n,r),"float32"))}}},YI=ay({maxPool3dGrad_:function(e,t,n,r,s,i,a){const o=sy(e,"dy","maxPool3dGrad"),u=sy(t,"input","maxPool3dGrad"),l=sy(n,"output","maxPool3dGrad");let c=o,h=u,d=l,p=!1;4===u.rank&&(p=!0,c=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Xv(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=Xv(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Ip(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Ip(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),Ip(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),null!=a&&Ip(Tp(i),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`);const f=Zb.runKernel(qm,{dy:c,input:h,output:d},{filterSize:r,strides:s,pad:i,dimRoundingMode:a});return p?Xv(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),QI={kernelName:Um,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=n;return{x:()=>YI(e,r,s,i,a,o,u)}}},JI=ay({maxPoolGrad_:function(e,t,n,r,s,i,a){const o=sy(e,"dy","maxPoolGrad"),u=sy(t,"input","maxPoolGrad"),l=sy(n,"output","maxPoolGrad");return Ip(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),Ip(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Ip(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),null!=a&&Ip(Tp(i),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${i}.`),Zb.runKernel(Wm,{dy:o,input:u,output:l},{filterSize:r,strides:s,pad:i,dimRoundingMode:a})}}),e_={kernelName:Bm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:i,strides:a,pad:o}=n;return{x:()=>JI(e,r,s,i,a,o)}}},t_={kernelName:Gm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,i=Op(s,r.shape),a=Ep(Kx(r.shape,i)[1]);return{x:()=>{const t=r.shape.slice();i.forEach(e=>{t[e]=1});const n=Xv(e,t);return bx(Ox(n,aw(r.shape,"float32")),a)}}}},n_={kernelName:Hm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[i,a]=t,o=HI(e,a,i,Op(s,i.shape));return{x:()=>o.x()}}},r_={kernelName:Km,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Ox(e,jy(wk(n,r),"float32")),b:()=>Ox(e,jy($x(n,r),"float32"))}}},s_={kernelName:Xm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,i=s.map(e=>e[0]);return{x:()=>xw(e,i,r.shape)}}},i_={kernelName:Zm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=wx(n.shape,r.shape);return{a:()=>{const t=xx(n.shape,s);return t.length>0?Xv(Lx(e,t),n.shape):e},b:()=>{const t=Ox(e,nw(Nx(bx(n,r)))),i=xx(r.shape,s);return i.length>0?Xv(Lx(t,i),r.shape):t}}}},a_={kernelName:Qm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=wx(n.shape,r.shape);return{a:()=>{const t=Ox(e,jy(r,"float32")),i=xx(n.shape,s);return i.length>0?Xv(Lx(t,i),n.shape):t},b:()=>{const t=Ox(e,jy(n,"float32")),i=xx(r.shape,s);return i.length>0?Xv(Lx(t,i),r.shape):t}}}},o_={kernelName:Jm,gradFunc:e=>({x:()=>nw(e)})},u_={kernelName:ig,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>iw(n.shape,"float32")}}},l_={kernelName:sg,gradFunc:e=>({x:()=>Pw(e)})},c_={kernelName:ag,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return Ow(e,r).map(e=>()=>e)}},h_={kernelName:og,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,i=s.map(e=>e[0]);return{x:()=>xw(e,i,r.shape)}}},d_={kernelName:ug,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,i=n,a=r,o=wx(i.shape,a.shape);return{a:()=>{const t=jy(a,"float32");let n=Ox(e,Ox(t,_k(i,Mx(t,$v(1)))));const r=xx(i.shape,o);return r.length>0&&(n=Lx(n,r)),Xv(n,i.shape)},b:()=>{const t=$x(i,0),n=Lw(t,Rx(i),Pw(i));let r=Ox(e,Ox(s,n));const u=xx(a.shape,o);return u.length>0&&(r=Lx(r,u)),Xv(r,a.shape)}}}},p_={kernelName:lg,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=$x(n,0);return{x:()=>Lw(s,e,Ox(e,r)),alpha:()=>{let t=Lw(s,Pw(e),Ox(e,n));const i=xx(r.shape,e.shape);return i.length>0&&(t=Lx(t,i)),Xv(t,r.shape)}}}},f_={kernelName:rm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=wx(n.shape,r.shape);return{a:()=>{const t=bx(e,jy(r,"float32")),i=xx(n.shape,s);return i.length>0?Xv(Lx(t,i),n.shape):t},b:()=>{let t=Ox(e,jy(n,"float32"));const i=xx(r.shape,s);i.length>0&&(t=Xv(Lx(t,i),r.shape));const a=ew(r);return nw(bx(t,jy(a,"float32")))}}}},m_={kernelName:pg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,nw(ew(n)))}}},g_={kernelName:xg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Ox(wk(n,6),Xw(n));return{x:()=>Ox(e,jy(r,"float32"))}}},b_={kernelName:fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,jy(Xw(n),"float32"))}}},y_={kernelName:mg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xv(e,n.shape)}}},v_={kernelName:yg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Zb.runKernel(vg,s,n)}}},x_={kernelName:gg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Zb.runKernel(bg,s,n)}}},w_={kernelName:wg,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Op(r,e.shape);return{x:()=>gw(e,s)}}},k_={kernelName:kg,gradFunc:e=>({x:()=>Pw(e)})},C_={kernelName:Cg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nw(bx(e,Ox(_k(n,1.5),2)))}}},I_=ay({logicalNot_:function(e){const t=sy(e,"x","logicalNot","bool");return Zb.runKernel(Om,{x:t})}}),__={kernelName:_g,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>jy(Pw(n),"float32"),t:()=>Ox(e,jy(n,e.dtype)),e:()=>Ox(e,jy(I_(n),e.dtype))}}},S_={kernelName:Sg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=$x(n,$v(0)),r=$v(uC),s=$v(lC),i=Ox(e,s),a=Ox(Ox(e,r),Fx(jy(n,"float32")));return Lw(t,i,a)}}}},N_={kernelName:Ag,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Ox(n,Mx($v(1),n)))}}},E_={kernelName:Tg,gradFunc:e=>({x:()=>Pw(e)})},$_=ay({cos_:function(e){const t=sy(e,"x","cos");return Zb.runKernel(qf,{x:t})}}),T_={kernelName:Eg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox($_(jy(n,"float32")),e)}}},A_=ay({cosh_:function(e){const t=sy(e,"x","cosh");return Zb.runKernel(jf,{x:t})}}),R_={kernelName:$g,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(A_(jy(n,"float32")),e)}}},F_={kernelName:Ng,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:i}=n,a=r.shape,[o,u]=bv(r,s,i),l=[];for(let c=0;c<e.rank;c++)l.push([o[c],a[c]-o[c]-u[c]]);return{x:()=>uw(e,l)}}},D_={kernelName:Lg,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,i=Ox(e,r);return{logits:()=>Mx(i,Ox(Lx(i,[s],!0),r))}}},O_={kernelName:Rg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,vw(n))}}},M_=ay({batchToSpaceND_:function(e,t,n){const r=sy(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);return Ip(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Ip(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Ip(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),Zb.runKernel(Tf,{x:r},{blockShape:t,crops:n})}}),L_={kernelName:Og,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>M_(e,r,s)}}},P_={kernelName:Mg,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>rx(e,r)}}},z_=[VC,BC,WC,UC,qC,jC,GC,HC,KC,XC,ZC,YC,JC,tI,nI,sI,iI,aI,oI,uI,lI,cI,dI,hI,fI,gI,yI,xI,wI,kI,f_,CI,II,_I,SI,NI,$I,EI,AI,FI,MI,LI,PI,zI,VI,BI,WI,UI,qI,GI,KI,KI,ZI,QI,e_,t_,n_,r_,s_,i_,a_,o_,u_,l_,c_,h_,h_,d_,p_,m_,g_,b_,y_,v_,x_,w_,k_,C_,__,S_,N_,E_,T_,R_,F_,D_,O_,L_,L_,P_,P_,{kernelName:Fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Ox(Ew(jy(n,"float32")),2))}}},{kernelName:Bg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=$v(2);return{a:()=>Ox(e,Ox(s,Mx(n,r))),b:()=>Ox(e,Ox(s,Mx(r,n)))}}},{kernelName:Wg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Ox(jy(n,"float32"),2))}}},{kernelName:tb,gradFunc:e=>({x:()=>Pw(e)})},{kernelName:qg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=wx(n.shape,r.shape);return{a:()=>{let t=e;const r=xx(n.shape,s);return r.length>0&&(t=Lx(t,r)),Xv(t,n.shape)},b:()=>{let t=e;const n=xx(r.shape,s);return n.length>0&&(t=Lx(t,n)),Xv(nw(t),r.shape)}}}},{kernelName:Dg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:i}=n;Op(i,r.shape).forEach(e=>{s[e]=1});const a=Xv(e,s),o=Ox(a,aw(r.shape,"float32"));return{x:()=>o}}},{kernelName:jg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,ew($_(n)))}}},{kernelName:Gg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(Mx($v(1),ew(n)),e)}}},{kernelName:Hg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=Pw(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=Rv(t,xw(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)t=Rv(t,xw(e,[n*r.shape[0],i*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let a=0;a<s[2];++a)t=Rv(t,xw(e,[n*r.shape[0],i*r.shape[1],a*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let a=0;a<s[2];++a)for(let o=0;o<s[3];++o)t=Rv(t,xw(e,[n*r.shape[0],i*r.shape[1],a*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:Zg,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,i=Qx(s);return{x:()=>zw(e,i)}}},{kernelName:Qg,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>Tw(e,s)}}},{kernelName:Jg,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Wx(t,Pw(t)),r=Ex(e,n);let s=Tx(t,$v(0,"int32"));const i=r.rank-s.rank;for(let o=0;o<i;++o)s=Cx(s,o+1);s=zx(s,aw(r.shape,"bool"));const a=Pw(r);return Lw(s,r,a)}(e,n)}}},{kernelName:eb,gradFunc:e=>({x:()=>Pw(e)})}];for(const oK of z_)db(oK);Rb().prototype.abs=function(){return this.throwIfDisposed(),Av(this)};const V_=ay({acos_:function(e){const t=sy(e,"x","acos");return Zb.runKernel(df,{x:t})}});Rb().prototype.acos=function(){return this.throwIfDisposed(),V_(this)};const B_=ay({acosh_:function(e){const t=sy(e,"x","acosh");return Zb.runKernel(pf,{x:t})}});Rb().prototype.acosh=function(){return this.throwIfDisposed(),B_(this)},Rb().prototype.add=function(e){return this.throwIfDisposed(),Rv(this,e)},Rb().prototype.all=function(e,t){return this.throwIfDisposed(),Fv(this,e,t)},Rb().prototype.any=function(e,t){return this.throwIfDisposed(),Dv(this,e,t)},Rb().prototype.argMax=function(e){return this.throwIfDisposed(),Ov(this,e)};const W_=ay({argMin_:function(e,t=0){const n=sy(e,"x","argMin");return Zb.runKernel(vf,{x:n},{axis:t})}});Rb().prototype.argMin=function(e){return this.throwIfDisposed(),W_(this,e)},Rb().prototype.asScalar=function(){return this.throwIfDisposed(),Ip(1===this.size,()=>"The array must have only 1 element."),Xv(this,[])},Rb().prototype.asType=function(e){return this.throwIfDisposed(),jy(this,e)},Rb().prototype.as1D=function(){return this.throwIfDisposed(),Xv(this,[this.size])},Rb().prototype.as2D=function(e,t){return this.throwIfDisposed(),Xv(this,[e,t])},Rb().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Xv(this,[e,t,n])},Rb().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Xv(this,[e,t,n,r])},Rb().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Xv(this,[e,t,n,r,s])};const U_=ay({asin_:function(e){const t=sy(e,"x","asin");return Zb.runKernel(xf,{x:t})}});Rb().prototype.asin=function(){return this.throwIfDisposed(),U_(this)};const q_=ay({asinh_:function(e){const t=sy(e,"x","asinh");return Zb.runKernel(wf,{x:t})}});Rb().prototype.asinh=function(){return this.throwIfDisposed(),q_(this)};const j_=ay({atan_:function(e){const t=sy(e,"x","atan");return Zb.runKernel(kf,{x:t})}});Rb().prototype.atan=function(){return this.throwIfDisposed(),j_(this)};const G_=ay({atan2_:function(e,t){let n=sy(e,"a","atan2"),r=sy(t,"b","atan2");return[n,r]=Wb(n,r),Zb.runKernel(If,{a:n,b:r})}});Rb().prototype.atan2=function(e){return this.throwIfDisposed(),G_(this,e)};const H_=ay({atanh_:function(e){const t=sy(e,"x","atanh");return Zb.runKernel(Cf,{x:t})}});Rb().prototype.atanh=function(){return this.throwIfDisposed(),H_(this)},Rb().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Zv(this,e,t,n,r)},Rb().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),M_(this,e,t)},Rb().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Qv(this,e,t,n,r,s)},Rb().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Mw(this,e)},Rb().prototype.cast=function(e){return this.throwIfDisposed(),jy(this,e)};const K_=ay({ceil_:function(e){const t=sy(e,"x","ceil");return Zb.runKernel(Ff,{x:t})}});Rb().prototype.ceil=function(){return this.throwIfDisposed(),K_(this)},Rb().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),nx(this,e,t)},Rb().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ab&&(e=[e]),rx([this,...e],t)},Rb().prototype.conv1d=function(e,t,n,r,s,i){return this.throwIfDisposed(),lx(this,e,t,n,r,s,i)},Rb().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),hx(this,e,t,n,r,s)},Rb().prototype.conv2d=function(e,t,n,r,s,i){return this.throwIfDisposed(),ux(this,e,t,n,r,s,i)},Rb().prototype.cos=function(){return this.throwIfDisposed(),$_(this)},Rb().prototype.cosh=function(){return this.throwIfDisposed(),A_(this)},Rb().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),vI(this,e,t,n)};const X_=ay({depthToSpace_:function(e,t,n="NHWC"){const r=sy(e,"x","depthToSpace"),s="NHWC"===n?r.shape[1]:r.shape[2],i="NHWC"===n?r.shape[2]:r.shape[3],a="NHWC"===n?r.shape[3]:r.shape[1];return Ip(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),Ip(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`),Ip(a%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${r.shape}`),Zb.runKernel(Xf,{x:r},{blockSize:t,dataFormat:n})}});Rb().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),X_(this,e,t)},Rb().prototype.depthwiseConv2d=function(e,t,n,r,s,i){return this.throwIfDisposed(),mx(this,e,t,n,r,s,i)};const Z_=ay({dilation2d_:function(e,t,n,r,s=[1,1],i="NHWC"){const a=sy(e,"x","dilation2d"),o=sy(t,"filter","dilation2d");Ip(3===a.rank||4===a.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),Ip(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Ip("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=a,l=!1;3===a.rank&&(u=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=!0);const c=Zb.runKernel(em,{x:u,filter:o},{strides:n,pad:r,dilations:s});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});Rb().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),Z_(this,e,t,n,r,s)};const Y_=ay({divNoNan_:function(e,t){let n=sy(e,"a","div"),r=sy(t,"b","div");[n,r]=Wb(n,r);const s=bx(n,r),i=Pw(s),a=kx(r,i);return Lw(a,i,s)}});Rb().prototype.divNoNan=function(e){return this.throwIfDisposed(),Y_(this,e)},Rb().prototype.div=function(e){return this.throwIfDisposed(),bx(this,e)};const Q_=ay({dot_:function(e,t){const n=sy(e,"t1","dot"),r=sy(t,"t2","dot");Ip(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=1===n.rank?n.size:n.shape[1],i=1===r.rank?r.size:r.shape[0];if(Ip(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===n.rank&&1===r.rank){const e=Xv(n,[1,-1]),t=Xv(r,[-1,1]),s=rk(e,t);return Xv(s,[])}if(1===n.rank&&2===r.rank){const e=Xv(n,[1,-1]),t=Xv(r,[r.shape[0],r.shape[1]]),s=rk(e,t);return Xv(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Xv(r,[-1,1]),t=rk(n,e);return Xv(t,[t.size])}{const e=Xv(r,[r.shape[0],r.shape[1]]);return rk(n,e)}}});Rb().prototype.dot=function(e){return this.throwIfDisposed(),Q_(this,e)},Rb().prototype.elu=function(){return this.throwIfDisposed(),yx(this)},Rb().prototype.equal=function(e){return this.throwIfDisposed(),kx(this,e)};const J_=ay({erf_:function(e){let t=sy(e,"x","erf");return Ip("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=jy(t,"float32")),Zb.runKernel(om,{x:t})}});Rb().prototype.erf=function(){return this.throwIfDisposed(),J_(this)},Rb().prototype.exp=function(){return this.throwIfDisposed(),Fx(this)},Rb().prototype.expandDims=function(e){return this.throwIfDisposed(),Cx(this,e)};const eS=ay({expm1_:function(e){const t=sy(e,"x","expm1");return Zb.runKernel(hm,{x:t})}});Rb().prototype.expm1=function(){return this.throwIfDisposed(),eS(this)},Rb().prototype.fft=function(){return this.throwIfDisposed(),Uw(this)},Rb().prototype.flatten=function(){return this.throwIfDisposed(),Xv(this,[this.size])},Rb().prototype.floor=function(){return this.throwIfDisposed(),Nx(this)},Rb().prototype.floorDiv=function(e){return this.throwIfDisposed(),gx(this,e)},Rb().prototype.gather=function(e,t){return this.throwIfDisposed(),Ex(this,e,t)},Rb().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Tx(this,e)},Rb().prototype.greater=function(e){return this.throwIfDisposed(),$x(this,e)},Rb().prototype.ifft=function(){return this.throwIfDisposed(),jw(this)},Rb().prototype.irfft=function(){return this.throwIfDisposed(),Gw(this)};const tS=ay({isFinite_:function(e){const t=sy(e,"x","isFinite");return Zb.runKernel(_m,{x:t})}});Rb().prototype.isFinite=function(){return this.throwIfDisposed(),tS(this)};const nS=ay({isInf_:function(e){const t=sy(e,"x","isInf");return Zb.runKernel(Sm,{x:t})}});Rb().prototype.isInf=function(){return this.throwIfDisposed(),nS(this)};const rS=ay({isNaN_:function(e){const t=sy(e,"x","isNaN");return Zb.runKernel(Nm,{x:t})}});Rb().prototype.isNaN=function(){return this.throwIfDisposed(),rS(this)},Rb().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Ax(this,e)},Rb().prototype.lessEqual=function(e){return this.throwIfDisposed(),wk(this,e)},Rb().prototype.less=function(e){return this.throwIfDisposed(),XI(this,e)};const sS=ay({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const i=sy(e,"x","localResponseNormalization");Ip(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),Ip(Tp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=i,o=!1;3===i.rank&&(o=!0,a=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u=Zb.runKernel(Lm,{x:a},{depthRadius:t,bias:n,alpha:r,beta:s});return o?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Rb().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),sS(this,e,t,n,r)};const iS=ay({logSigmoid_:function(e){const t=sy(e,"x","logSigmoid");return Ev(e=>({value:nw(Sw(nw(e))),gradFunc:t=>Ox(t,vw(nw(e)))}))(t)}});Rb().prototype.logSigmoid=function(){return this.throwIfDisposed(),iS(this)},Rb().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Px(this,e)},Rb().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Ok(this,e,t)},Rb().prototype.log=function(){return this.throwIfDisposed(),Rx(this)},Rb().prototype.log1p=function(){return this.throwIfDisposed(),Dk(this)},Rb().prototype.logicalAnd=function(e){return this.throwIfDisposed(),zx(this,e)},Rb().prototype.logicalNot=function(){return this.throwIfDisposed(),I_(this)};const aS=ay({logicalOr_:function(e,t){const n=sy(e,"a","logicalOr","bool"),r=sy(t,"b","logicalOr","bool");return wx(n.shape,r.shape),Zb.runKernel(Mm,{a:n,b:r})}});Rb().prototype.logicalOr=function(e){return this.throwIfDisposed(),aS(this,e)};const oS=ay({logicalXor_:function(e,t){const n=sy(e,"a","logicalXor","bool"),r=sy(t,"b","logicalXor","bool");return wx(n.shape,r.shape),zx(aS(e,t),I_(zx(e,t)))}});Rb().prototype.logicalXor=function(e){return this.throwIfDisposed(),oS(this,e)},Rb().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),rk(this,e,t,n)},Rb().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Vx(this,e,t,n,r)},Rb().prototype.max=function(e,t){return this.throwIfDisposed(),Dx(this,e,t)},Rb().prototype.maximum=function(e){return this.throwIfDisposed(),Wx(this,e)},Rb().prototype.mean=function(e,t){return this.throwIfDisposed(),Ux(this,e,t)},Rb().prototype.min=function(e,t){return this.throwIfDisposed(),qx(this,e,t)},Rb().prototype.minimum=function(e){return this.throwIfDisposed(),jx(this,e)};const uS=ay({mirrorPad_:function(e,t,n){Ip("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=sy(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Ip(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===n?1:0;for(let i=0;i<r.rank;i++)Ip(2===t[i].length,()=>"Invalid number of paddings. Must be length of 2 each."),Ip(t[i][0]>=0&&t[i][0]<=r.shape[i]-s&&t[i][1]>=0&&t[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);return Zb.runKernel(Xm,{x:r},{paddings:t,mode:n})}});Rb().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),uS(this,e,t)};const lS=ay({mod_:function(e,t){let n=sy(e,"a","mod"),r=sy(t,"b","mod");return[n,r]=Wb(n,r),Zb.runKernel(Zm,{a:n,b:r})}});Rb().prototype.mod=function(e){return this.throwIfDisposed(),lS(this,e)},Rb().prototype.mul=function(e){return this.throwIfDisposed(),Ox(this,e)},Rb().prototype.neg=function(){return this.throwIfDisposed(),nw(this)},Rb().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Nk(this,e,t,n)},Rb().prototype.notEqual=function(e){return this.throwIfDisposed(),rw(this,e)},Rb().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),sw(this,e,t,n)},Rb().prototype.onesLike=function(){return this.throwIfDisposed(),ow(this)},Rb().prototype.pad=function(e,t){return this.throwIfDisposed(),uw(this,e,t)};const cS=ay({pool_:function(e,t,n,r,s,i){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const a=sy(e,"x","maxPool");let o=a,u=!1;3===a.rank&&(u=!0,o=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ip(Hv(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const l=Lv(o.shape,t,i,s,r),c=[l.dilationHeight,l.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),r=n.map(e=>Math.floor(e/2)),s=n.map((e,t)=>e-r[t]);return n.map((e,t)=>[r[t],s[t]])}([l.filterHeight,l.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(e,t,n){const r=n.map(e=>e[0]),s=n.map(e=>e[1]),i=e.concat(r,s),a=t.map((e,t)=>(e-i[t]%e)%e),o=s.map((e,t)=>e+a[t]);return[t.map((e,t)=>[r[t],o[t]]),t.map((e,t)=>[0,a[t]])]}([l.inHeight,l.inWidth],c,h),m=d?r:"valid",g=d?o:rI(o,c,p),b=("avg"===n?()=>Zv(g,t,i,m):()=>Vx(g,t,i,m))(),y=d?b:M_(b,c,f);return u?Xv(y,[y.shape[1],y.shape[2],y.shape[3]]):y}});Rb().prototype.pool=function(e,t,n,r,s){return this.throwIfDisposed(),cS(this,e,t,n,r,s)},Rb().prototype.pow=function(e){return this.throwIfDisposed(),_k(this,e)},Rb().prototype.prelu=function(e){return this.throwIfDisposed(),lw(this,e)};const hS=ay({prod_:function(e,t=null,n=!1){let r=sy(e,"x","prod");return"bool"===r.dtype&&(r=jy(r,"int32")),Zb.runKernel(cg,{x:r},{axis:t,keepDims:n})}});Rb().prototype.prod=function(e,t){return this.throwIfDisposed(),hS(this,e,t)};const dS=ay({reciprocal_:function(e){const t=sy(e,"x","reciprocal");return Zb.runKernel(pg,{x:t})}});Rb().prototype.reciprocal=function(){return this.throwIfDisposed(),dS(this)},Rb().prototype.relu=function(){return this.throwIfDisposed(),mw(this)},Rb().prototype.relu6=function(){return this.throwIfDisposed(),Kw(this)},Rb().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Xv(this,e.shape)},Rb().prototype.reshape=function(e){return this.throwIfDisposed(),Xv(this,e)},Rb().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),yk(this,e,t,n)},Rb().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),vk(this,e,t,n)},Rb().prototype.reverse=function(e){return this.throwIfDisposed(),gw(this,e)},Rb().prototype.rfft=function(){return this.throwIfDisposed(),qw(this)},Rb().prototype.round=function(){return this.throwIfDisposed(),kk(this)},Rb().prototype.rsqrt=function(){return this.throwIfDisposed(),TI(this)},Rb().prototype.selu=function(){return this.throwIfDisposed(),bw(this)},Rb().prototype.separableConv2d=function(e,t,n,r,s,i){return this.throwIfDisposed(),yw(this,e,t,n,r,s,i)},Rb().prototype.sigmoid=function(){return this.throwIfDisposed(),vw(this)};const pS=ay({sign_:function(e){const t=sy(e,"x","sign");return Zb.runKernel(Tg,{x:t})}});Rb().prototype.sign=function(){return this.throwIfDisposed(),pS(this)},Rb().prototype.sin=function(){return this.throwIfDisposed(),mI(this)},Rb().prototype.sinh=function(){return this.throwIfDisposed(),bI(this)},Rb().prototype.slice=function(e,t){return this.throwIfDisposed(),xw(this,e,t)},Rb().prototype.softmax=function(e){return this.throwIfDisposed(),_w(this,e)},Rb().prototype.softplus=function(){return this.throwIfDisposed(),Sw(this)},Rb().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),rI(this,e,t)},Rb().prototype.split=function(e,t){return this.throwIfDisposed(),Nw(this,e,t)},Rb().prototype.sqrt=function(){return this.throwIfDisposed(),Ew(this)},Rb().prototype.square=function(){return this.throwIfDisposed(),ew(this)},Rb().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Fk(this,e)},Rb().prototype.squeeze=function(e){return this.throwIfDisposed(),$w(this,e)},Rb().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Ab?[this,e]:[this,...e];return Tw(n,t)},Rb().prototype.step=function(e){return this.throwIfDisposed(),Xw(this,e)};const fS=ay({stridedSlice_:function(e,t,n,r,s=0,i=0,a=0,o=0,u=0){const l=sy(e,"x","stridedSlice");return Zb.runKernel(Ug,{x:l},{begin:t,end:n,strides:r,beginMask:s,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u})}});Rb().prototype.stridedSlice=function(e,t,n,r,s,i,a,o){return this.throwIfDisposed(),fS(this,e,t,n,r,s,i,a,o)},Rb().prototype.sub=function(e){return this.throwIfDisposed(),Mx(this,e)},Rb().prototype.sum=function(e,t){return this.throwIfDisposed(),Lx(this,e,t)};const mS=ay({tan_:function(e){const t=sy(e,"x","tan");return Zb.runKernel(jg,{x:t})}});Rb().prototype.tan=function(){return this.throwIfDisposed(),mS(this)},Rb().prototype.tanh=function(){return this.throwIfDisposed(),Aw(this)},Rb().prototype.tile=function(e){return this.throwIfDisposed(),Ix(this,e)},Rb().prototype.toBool=function(){return this.throwIfDisposed(),jy(this,"bool")},Rb().prototype.toFloat=function(){return this.throwIfDisposed(),jy(this,"float32")},Rb().prototype.toInt=function(){return this.throwIfDisposed(),jy(this,"int32")};const gS=ay({topk_:function(e,t=1,n=!0){const r=sy(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const i={x:r},a={k:t,sorted:n},[o,u]=Zb.runKernel(Kg,i,a);return{values:o,indices:u}}});Rb().prototype.topk=function(e,t){return this.throwIfDisposed(),gS(this,e,t)},Rb().prototype.transpose=function(e){return this.throwIfDisposed(),zw(this,e)};const bS=ay({unique_:function(e,t=0){const n=sy(e,"x","unique","string_or_numeric");Ip(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[i,a]=Zb.runKernel(Yg,r,s);return{values:i,indices:a}}});let yS;function vS(){return null==yS&&(yS=Zb.backend.epsilon()),yS}Rb().prototype.unique=function(e){return this.throwIfDisposed(),bS(this,e)},Rb().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),RI(this,e,t)},Rb().prototype.unstack=function(e){return this.throwIfDisposed(),Ow(this,e)},Rb().prototype.where=function(e,t){return this.throwIfDisposed(),Lw(e,this,t)},Rb().prototype.zerosLike=function(){return this.throwIfDisposed(),Pw(this)};class xS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xS.prototype)}}class wS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wS.prototype)}}class kS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kS.prototype)}}class CS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,CS.prototype)}}class IS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,IS.prototype)}}function _S(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function SS(e,t){if(!e)throw new IS(t)}function NS(e,t){let n=0;for(const r of e)r===t&&n++;return n}function ES(e){return 1===e.length?e[0]:e}function $S(e){return Array.isArray(e)?e:[e]}function TS(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function AS(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}Error;let RS={};function FS(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function DS(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>DS(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?DS(t):e[n]=t.value)}}}function OS(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let i;if(s in n)i=n[s];else if(s in RS)i=RS[s];else if(i=t[s],null==i)throw new kS(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=e;if(null==i.className||null==i.config)throw new kS(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const a=i.className;let o,u;if(a in n?[o,u]=n[a]:a in RS?[o,u]=RS.className:a in t&&([o,u]=t[a]),null==o)throw new kS(`Unknown ${r}: ${a}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const e={};for(const n of Object.keys(RS))e[n]=RS[n];for(const s of Object.keys(n))e[s]=n[s];i.config.customObjects=e;const t=Object.assign({},RS);for(const s of Object.keys(n))RS[s]=n[s];DS(i.config);const r=u(o,i.config,n,s);return RS=Object.assign({},t),r}{const e=Object.assign({},RS);for(const r of Object.keys(n))RS[r]=n[r];const t=new o(i.config);return RS=Object.assign({},e),t}}}function MS(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function LS(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function PS(e){if(null==e)throw new kS(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function zS(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new kS(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function VS(e,t,n=0,r=1/0){return SS(n>=0),SS(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(e=>typeof e===t)}function BS(e,t){Array.isArray(e)?(Ip(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>BS(e,`element ${n+1} of ${t}`))):Ip(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${WS(e)}.`)}function WS(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>WS(e)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function US(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function qS(e,t){return Iv(()=>Ew(Lx(Ox(e,e),t,!0)))}class jS extends vv{getConfig(){return{}}}class GS extends jS{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Iv(()=>{const t=qS(e,this.axis),n=nx(t,0,this.maxValue);return Ox(e,bx(n,Rv(vS(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}GS.className="MaxNorm",wv(GS);class HS extends jS{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Iv(()=>bx(e,Rv(vS(),qS(e,this.axis))))}getConfig(){return{axis:this.axis}}}HS.className="UnitNorm",wv(HS);class KS extends jS{apply(e){return mw(e)}}KS.className="NonNeg",wv(KS);class XS extends jS{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Iv(()=>{const t=qS(e,this.axis),n=Rv(Ox(this.rate,nx(t,this.minValue,this.maxValue)),Ox(1-this.rate,t));return Ox(e,bx(n,Rv(vS(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}XS.className="MinMaxNorm",wv(XS);const ZS={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function YS(e){return FS(e)}function QS(e,t={}){return OS(e,xv.getMap().classNameMap,t,"constraint")}function JS(e){return null==e?null:"string"==typeof e?QS({className:e in ZS?ZS[e]:e,config:{}}):e instanceof jS?e:QS(e)}const eN=["channelsFirst","channelsLast"],tN=["nearest","bilinear"],nN=["valid","same","causal"],rN=["max","avg"],sN=["sum","mul","concat","ave"],iN=new Map;function aN(e){zS(eN,"DataFormat",e)}function oN(e){zS(nN,"PaddingMode",e)}function uN(e){zS(rN,"PoolMode",e)}const lN=[];function cN(e,t){lN.push(e);try{const e=t();return lN.pop(),e}catch(n){throw lN.pop(),n}}function hN(e){if(!fN(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===lN.length?"":lN.join("/")+"/")+e}function dN(e){if(!fN(e))throw new Error("Not a valid tensor name: '"+e+"'");iN.has(e)||iN.set(e,0);const t=iN.get(e);if(iN.set(e,iN.get(e)+1),t>0){const n=`${e}_${t}`;return iN.set(n,1),n}return e}const pN=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fN(e){return!!e.match(pN)}function mN(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function gN(e){return Rw(e=Array.isArray(e)?new Float32Array(e):e)}function bN(e){return qx(gN(e)).dataSync()[0]}function yN(e){return Dx(gN(e)).dataSync()[0]}function vN(e,t){if(t<e)throw new kS(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}function xN(e,t){return e.asType(t)}function wN(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function kN(e,t,n){return Iv(()=>{switch(e.rank){case 1:return ww(e,t,n);case 2:return kw(e,[t,0],[n,e.shape[1]]);case 3:return Cw(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Iw(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return xw(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return xw(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new kS(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function CN(e,t,n){return Iv(()=>{switch(e.rank){case 1:return ww(e,t,n);case 2:return kw(e,[0,t],[e.shape[0],n]);case 3:return Cw(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Iw(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new kS(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function IN(e,t,n,r){return Iv(()=>{switch(e.rank){case 1:return ww(e,t,n);case 2:switch(r){case 1:return kN(e,t,n);case 2:return CN(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return kN(e,t,n);case 2:return Cw(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return CN(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return kN(e,t,n);case 2:return Iw(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Iw(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return CN(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${r}`)}default:throw new kS(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function _N(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),rx(e,t)}function SN(e,t){switch(e.rank){case 1:return sx([e,t]);case 2:return ix([e,t],0);case 3:return ax([e,t],0);case 4:return ox([e,t],0);default:throw new kS(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function NN(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new kS(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ix(e,t)}function EN(e,t=0,n=1,r,s){return pw(e,t,n,r,s)}function $N(e,t,n,r){if(e.rank<2||t.rank<2)throw new CS(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new CS(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return sk({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?RN(e.rank,r,"channelsLast"):null,activation:n});{const s=e.shape.slice(),i=s.pop();e=e.reshape([-1,i]);const a=t.shape.slice(),o=a.pop(),u=a.pop(),l=[...a,o],c=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=t.transpose(c).reshape([u,-1]);const h=[...s,...l];return sk({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?RN(e.rank,r,"channelsLast"):null,activation:n}).reshape(h)}}function TN(e,t,n){return Iv(()=>(t=Array.isArray(t)?Rw(t,"int32"):t.toInt(),Ex(e,t,n)))}function AN(e){return Ox(e,e)}function RN(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new kS(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return t.reshape(1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return t.reshape(1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===e){if("channelsFirst"===n)return t.reshape(1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===n)return t.reshape(1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===e){if("channelsFirst"===n)return t.reshape(1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===n)return t.reshape(1===r.length?[1,1,r[0]]:[1].concat(r))}else if(e<3)return t;throw new kS(`Unsupported input rank by biasAdd: ${t.rank}`)}function FN(e,t,n){return Iv(()=>(null==n&&(n="channelsLast"),aN(n),e.add(RN(e.rank,t,n))))}function DN(e,t,n,r){return Iv(()=>Vw(e,t,n,r))}function ON(e,t,n=!1){return n?e():t()}const MN=["fanIn","fanOut","fanAvg"],LN=["normal","uniform","truncatedNormal"];class PN extends vv{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class zN extends PN{apply(e,t){return iw(e,t)}}zN.className="Zeros",wv(zN);class VN extends PN{apply(e,t){return aw(e,t)}}VN.className="Ones",wv(VN);class BN extends PN{constructor(e){if(super(),"object"!=typeof e)throw new kS(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new kS(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Iv(()=>Ox($v(this.value),aw(e,t)))}getConfig(){return{value:this.value}}}BN.className="Constant",wv(BN);class WN extends PN{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return fw(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}WN.className="RandomUniform",wv(WN);class UN extends PN{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new CS(`randomNormal does not support dType ${t}.`);return EN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}UN.className="RandomNormal",wv(UN);class qN extends PN{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new CS(`truncatedNormal does not support dType ${t}.`);return Dw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qN.className="TruncatedNormal",wv(qN);class jN extends PN{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Iv(()=>{if(2!==e.length||e[0]!==e[1])throw new kS("Identity matrix initializer can only be used for 2D square matrices.");return Ox(this.gain,_x(e[0]))})}getConfig(){return{gain:this.gain}}}jN.className="Identity",wv(jN);class GN extends PN{constructor(e){if(super(),e.scale<0)throw new kS(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,zS(MN,"FanMode",this.mode),this.distribution=null==e.distribution?"normal":e.distribution,zS(LN,"Distribution",this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(aN(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=mN(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=mN(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=mN(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,r):"fanOut"===this.mode?Math.max(1,s):Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new CS(`${this.getClassName()} does not support dType ${t}.`);return Dw(e,0,n,t,this.seed)}{const n=Math.sqrt(3*i);return fw(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}GN.className="VarianceScaling",wv(GN);class HN extends GN{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GN.className}}HN.className="GlorotUniform",wv(HN);class KN extends GN{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GN.className}}KN.className="GlorotNormal",wv(KN);class XN extends GN{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GN.className}}XN.className="HeNormal",wv(XN);class ZN extends GN{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GN.className}}ZN.className="HeUniform",wv(ZN);class YN extends GN{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GN.className}}YN.className="LeCunNormal",wv(YN);class QN extends GN{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GN.className}}QN.className="LeCunNormal",wv(QN);class JN extends PN{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new CS("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return Iv(()=>{if(e.length<2)throw new CS("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=EN(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=Mk.gramSchmidt(t);return e[0]>e[1]&&(n=n.transpose()),Ox(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}JN.className="Orthogonal",wv(JN);const eE={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function tE(e,t={}){return OS(e,xv.getMap().classNameMap,t,"initializer")}function nE(e){return FS(e)}function rE(e){if("string"==typeof e){const t=e in eE?eE[e]:e;if("GlorotNormal"===t)return new KN;if("GlorotUniform"===t)return new HN;if("HeNormal"===t)return new XN;if("HeUniform"===t)return new ZN;if("LeCunNormal"===t)return new YN;if("LeCunUniform"===t)return new QN;{const e={};return e.className=t,e.config={},tE(e)}}return e instanceof PN?e:tE(e)}let sE=0;function iE(){return sE++}const aE={};function oE(e=""){return e in aE||(aE[e]=0),aE[e]+=1,e+aE[e].toString()}function uE(e){return Array.isArray(e)&&Array.isArray(e[0])}function lE(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function cE(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new kS(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function hE(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new kS(`Expected exactly 1 Shape; got ${e.length}`)}return e}function dE(e){let t=0;for(const n of e)t+=0===n.shape.length?1:n.shape.reduce((e,t)=>e*t);return t}class pE{constructor(e,t="float32",n="Variable",r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=iE(),this.originalName=hN(n=null==n?"Variable":n),this.name=dN(this.originalName),this.trainable_=r,this.constraint=s,this.val=function(e,t=!0,n,r){return Zb.makeVariable(e,t,n,r)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function fE(e){return e.map(e=>e.read())}function mE(e){e.forEach(e=>{e[0].write(e[1])})}class gE{constructor(e){this.dtype=e.dtype,this.shape=e.shape,this.ndim=null!=e.shape?e.shape.length:e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class bE{constructor(e,t,n,r,s,i,a){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=a,this.id=iE(),null!=i&&(this.originalName=hN(i),this.name=dN(this.originalName)),this.rank=t.length}}let yE=0;class vE{constructor(e,t){this.callArgs=t,this.id=yE++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)e.push(null!=t?t.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let xE=0;class wE extends vv{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xE++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=TS(e)+"_"+oE(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=e.weights?e.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new wS(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new kS(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ES(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ES(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new xS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new xS(`Layer ${this.name} is not connected, no input to return.`);return ES(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new xS(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new xS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ES(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=$S(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=$S(this.inputSpec);if(e.length!==t.length)throw new kS(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const r=e[n],s=t[n];if(null==s)continue;const i=r.rank;if(null!=s.ndim&&i!==s.ndim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(null!=s.maxNDim&&i>s.maxNDim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(null!=s.minNDim&&i<s.minNDim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new kS(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const e=r.shape;for(const t in s.axes){const r=Number(t),i=s.axes[t],a=r>=0?e[r]:e[e.length+r];if(null!=i&&-1===[i,null].indexOf(a))throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${i} but got shape ${e}.`)}}if(null!=s.shape)for(let e=0;e<s.shape.length;++e){const t=s.shape[e],i=r.shape[e];if(null!=t&&null!=i&&t!==i)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=$S(e);let r=!0;for(const i of n)if(!(i instanceof bE)){r=!1;break}let s=!0;for(const i of n)if(i instanceof bE){s=!1;break}if(r===s)throw new kS("Arguments to apply() must be all SymbolicTensors or all Tensors");return cN(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of $S(e))t.push(n.shape);this.build(ES(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);const s=$S(r),i=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),i.push(e);if(r=ES(i),null!=this.activityRegularizer)throw new CS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=$S(e);const t=[];for(const n of e)t.push(n.shape);return ES(t)}(e),r=this.computeOutputShape(n);let s;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new bE(i,n,this,$S(e),t,this.name,r)):new bE(i,r,this,$S(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new CS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new xS(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new xS(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new wS(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return dE(this.weights)}build(e){this.built=!0}getWeights(e=!1){return fE(e?this.trainableWeights:this.weights)}setWeights(e){Iv(()=>{const t=this.weights;if(t.length!==e.length)throw new kS(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=fE(t);for(let s=0;s<r.length;++s){const i=r[s],a=t[s],o=e[s];if(!$p(i.shape,o.shape))throw new kS(`Layer weight shape ${i.shape} not compatible with provided weight shape ${o.shape}`);n.push([a,o])}mE(n)})}addWeight(e,t,n,r,s,i,a){if(-1!==this._addedWeightNames.indexOf(e))throw new kS(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=rE("zeros"));const o=r.apply(t,n),u=new pE(o,n,e,i,a);return o.dispose(),null!=s&&this.addLoss(()=>s.apply(u.read())),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=$S(e),null!=this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}addInboundNode(e,t,n,r,s,i,a=null){const o=$S(e);t=$S(t),n=$S(n),r=$S(r),s=lE(s),i=lE(i);const u=[],l=[],c=[];for(const h of o)u.push(h.sourceLayer),l.push(h.nodeIndex),c.push(h.tensorIndex);new vE({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:i},a);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function kE(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=kE(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class CE extends wE{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:oE("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new kS("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new kS("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new kS("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new bE(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new vE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new kS(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function IE(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new kS("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new CE({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function _E(e){return SE.apply(this,arguments)}function SE(){return(SE=bp(function*(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const i=e[s];if("number"!=typeof i){const e=i;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=yield Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];_v(r)}})).apply(this,arguments)}function NE(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var EE;CE.className="InputLayer",wv(CE),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(EE||(EE={}));class $E{constructor(){this.validationData=null}setParams(e){this.params=e}onEpochBegin(e,t){return bp(function*(){})()}onEpochEnd(e,t){return bp(function*(){})()}onBatchBegin(e,t){return bp(function*(){})()}onBatchEnd(e,t){return bp(function*(){})()}onTrainBegin(e){return bp(function*(){})()}onTrainEnd(e){return bp(function*(){})()}setModel(e){}}class TE{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}onEpochBegin(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onEpochBegin(e,t)})()}onEpochEnd(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onEpochEnd(e,t)})()}onBatchBegin(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onBatchBegin(e,t)})()}onBatchEnd(e,t){var n=this;return bp(function*(){null==t&&(t={});for(const r of n.callbacks)yield r.onBatchEnd(e,t)})()}onTrainBegin(e){var t=this;return bp(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainBegin(e)})()}onTrainEnd(e){var t=this;return bp(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainEnd(e)})()}}class AE extends $E{constructor(){super()}onEpochBegin(e){var t=this;return bp(function*(){t.seen=0,t.totals={}})()}onBatchEnd(e,t){var n=this;return bp(function*(){null==t&&(t={});const e=null==t.size?0:t.size;n.seen+=e;for(const r in t){const s=t[r];if("number"==typeof s)n.totals.hasOwnProperty(r)||(n.totals[r]=0),n.totals[r]=n.totals[r]+s*e;else{let t;r in n.totals?t=n.totals[r]:n.totals[r]=0;const i=Iv(()=>Rv(n.totals[r],Ox(s,e)));n.totals[r]=i,null!=t&&t.dispose()}}})()}onEpochEnd(e,t){var n=this;return bp(function*(){if(null!=t)for(const e of n.params.metrics)null!=n.totals[e]&&("number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:Iv(()=>{const r=Ox(bx(1,n.seen),n.totals[e]);t[e]=r,n.totals[e].dispose(),Sv(t[e])}))})()}}class RE extends $E{onTrainBegin(e){var t=this;return bp(function*(){t.epoch=[],t.history={}})()}onEpochEnd(e,t){var n=this;return bp(function*(){null==t&&(t={}),n.epoch.push(e);for(const e in t)null==n.history[e]&&(n.history[e]=[]),n.history[e].push(t[e])})()}syncData(){var e=this;return bp(function*(){const t=[],n=[],r=[];for(const i in e.history){const s=e.history[i];for(let e=0;e<s.length;++e)"number"!=typeof s[e]&&(t.push(s[e].data()),n.push(i),r.push(e))}const s=yield Promise.all(t);for(let i=0;i<s.length;++i)e.history[n[i]][r[i]].dispose(),e.history[n[i]][r[i]]=s[i][0]})()}}class FE extends $E{constructor(e,t){if(super(),this.currentEpoch=0,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Up(this.yieldEvery)&&(this.maybeWait=function(e,t){let n,r=gb();return(...s)=>{const i=gb();return i-r<t||(r=i,n=e(...s)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}maybeWait(e,t,n){var r=this;return bp(function*(){const s=[];null!=r.yield&&(yield _E(n),s.push(r.yield(e,t,n))),s.push(Hk()),yield Promise.all(s)})()}onEpochBegin(e,t){var n=this;return bp(function*(){n.currentEpoch=e,null!=n.epochBegin&&(yield _E(t),yield n.epochBegin(e,t))})()}onEpochEnd(e,t){var n=this;return bp(function*(){const r=[];null!=n.epochEnd&&(yield _E(t),r.push(n.epochEnd(e,t))),"epoch"===n.yieldEvery&&r.push(Hk()),yield Promise.all(r)})()}onBatchBegin(e,t){var n=this;return bp(function*(){null!=n.batchBegin&&(yield _E(t),yield n.batchBegin(e,t))})()}onBatchEnd(e,t){var n=this;return bp(function*(){const r=[];null!=n.batchEnd&&(yield _E(t),r.push(n.batchEnd(e,t))),"batch"===n.yieldEvery?r.push(Hk()):Up(n.yieldEvery)&&r.push(n.maybeWait(n.currentEpoch,e,t)),yield Promise.all(r)})()}onTrainBegin(e){var t=this;return bp(function*(){null!=t.trainBegin&&(yield _E(e),yield t.trainBegin(e))})()}onTrainEnd(e){var t=this;return bp(function*(){null!=t.trainEnd&&(yield _E(e),yield t.trainEnd(e))})()}}function DE(e,t){return null==e&&(e={}),e instanceof $E?[e]:Array.isArray(e)&&e[0]instanceof $E?e:$S(e).map(e=>new FE(e,t))}class OE{constructor(){}static registerCallbackConstructor(e,t){Ip(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),OE.checkForDuplicate(t),null==OE.constructors[e]&&(OE.constructors[e]=[]),OE.constructors[e].push(t)}static checkForDuplicate(e){for(const t in OE.constructors)OE.constructors[+t].forEach(t=>{if(t===e)throw new kS("Duplicate callback constructor.")})}static clear(){OE.constructors={}}static createCallbacks(e){const t=[];for(const n in OE.constructors){const r=+n;e>=r&&t.push(...OE.constructors[r])}return t.map(e=>new e)}}function ME(e,t,n,r,s,i,a,o,u){const l=new RE,c=[new AE,...OE.createCallbacks(t)];null!=e&&c.push(...e),c.push(l);const h=new TE(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:i,batchSize:a,verbose:t,doValidation:o,metrics:u}),{callbackList:h,history:l}}function LE(e,t={},n=!1){return OS(e,xv.getMap().classNameMap,t,"layer",n)}function PE(e,t){return Iv(()=>{"float32"!==e.dtype&&(e=e.asType("float32"));const n=Lx(AN(e),t,!0),r=Sx(n.shape,vS()),s=Ew(Wx(n,r));return bx(e,s)})}function zE(e,t){return Iv(()=>Ux(AN(Mx(t,e)),-1))}function VE(e,t){return Iv(()=>Ux(Av(Mx(t,e)),-1))}function BE(e,t){return Iv(()=>{const n=Mx(e,t),r=nx(Av(e),vS(),Number.MAX_VALUE),s=Av(bx(n,r));return Ox(100,Ux(s,-1))})}function WE(e,t,n=!1){return Iv(()=>{if(n)t=_w(t);else{const e=Lx(t,t.shape.length-1,!0);t=bx(t,e)}return t=nx(t,vS(),1-vS()),nw(Lx(Ox(e.toFloat(),Rx(t)),t.shape.length-1))})}function UE(e,t,n=!1){return Iv(()=>{const r=Nx(function(e){const t=[mN(e.shape)];return e.reshape(t)}(e)).toInt(),s=(t=nx(t,vS(),1-vS())).shape;return WE(sw(r,s[s.length-1]).reshape(s),t,n)})}function qE(e,t){return Iv(()=>{let n;return n=nx(t,vS(),1-vS()),n=Rx(bx(n,Mx(1,n))),Ux(function(e,t){if(!$p(e.shape,t.shape))throw new kS(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Iv(()=>{const n=t.relu(),r=t.abs().neg();return n.sub(t.mul(e)).add(r.exp().log1p())})}(e,n),-1)})}function jE(e,t){return Iv(()=>{const n=PE(e,-1),r=PE(t,-1),s=Ox(n,r);return nw(Lx(s,-1))})}OE.constructors={};const GE={meanSquaredError:zE,meanAbsoluteError:VE,meanAbsolutePercentageError:BE,meanSquaredLogarithmicError:function(e,t){return Iv(()=>{const n=nx(t,vS(),Number.MAX_VALUE),r=Rx(Rv(1,n)),s=nx(e,vS(),Number.MAX_VALUE),i=Rx(Rv(1,s));return Ux(AN(Mx(r,i)),-1)})},squaredHinge:function(e,t){return Iv(()=>{const n=Wx(0,Mx(1,Ox(e,t)));return Ux(AN(n),-1)})},hinge:function(e,t){return Iv(()=>{const n=Wx(0,Mx(1,Ox(e,t)));return Ux(n,-1)})},categoricalHinge:function(e,t){return Iv(()=>{const n=Lx(Ox(e,t),-1),r=Dx(Ox(Mx(1,e),t),-1);return Wx(0,Rv(1,Mx(r,n)))})},logcosh:function(e,t){return Iv(()=>{const n=Math.log(2),r=Mx(t,e),s=Mx(Rv(r,Sw(Ox(-2,r))),n);return Ux(s,-1)})},categoricalCrossentropy:WE,sparseCategoricalCrossentropy:UE,binaryCrossentropy:qE,kullbackLeiblerDivergence:function(e,t){return Iv(()=>{const n=nx(e,vS(),1),r=nx(t,vS(),1);return Lx(Ox(e,Rx(bx(n,r))),-1)})},poisson:function(e,t){return Iv(()=>{const n=Rx(Rv(vS(),t));return Ux(Mx(t,Ox(e,n)),-1)})},cosineProximity:jE};function HE(e){if("string"==typeof e){if(e in GE)return GE[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new kS(t)}return e}function KE(e,t){return Iv(()=>{const n=Ox(.5,ow(t)),r=xN($x(t,n),e.dtype);return Ux(kx(e,r),-1)})}function XE(e,t){return Iv(()=>xN(kx(Ov(e,-1),Ov(t,-1)),"float32"))}function ZE(e,t){return qE(e,t)}function YE(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),kx(e,t).asType("float32")}const QE=WE,JE=UE,e$={binaryAccuracy:KE,categoricalAccuracy:XE,precision:function(e,t){return Iv(()=>{const n=function(e,t){return Iv(()=>zx(e.equal(1),t.equal(1)).sum().cast("float32"))}(e,t),r=function(e,t){return Iv(()=>zx(e.equal(0),t.equal(1)).sum().cast("float32"))}(e,t),s=n.add(r);return Lw($x(s,0),n.div(s),0).cast("float32")})},categoricalCrossentropy:QE,sparseCategoricalCrossentropy:JE,mse:zE,MSE:zE,mae:VE,MAE:VE,mape:BE,MAPE:BE,cosine:jE};function t$(e){if("string"==typeof e&&e in e$)return e$[e];if("string"!=typeof e&&null!=e)return e;throw new kS(`Unknown metric ${e}`)}function n$(e){if(SS(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(GE))if(GE[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(e$))if(e$[n]===e){t=n;break}return void 0!==t?t:e.name}}function r$(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!s$(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function s$(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!s$(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!s$(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function i$(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function a$(e,t,n){let r;try{r=JSON.stringify(e.outputShape)}catch(aK){r="multiple"}i$([`${e.name} (${e.getClassName()})`,r,e.countParams().toString()],t,n)}function o$(e,t,n,r){let s;try{s=JSON.stringify(e.outputShape)}catch(aK){s="multiple"}const i=[];for(const l of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(let e=0;e<l.inboundLayers.length;++e)i.push(`${l.inboundLayers[e].name}[${l.nodeIndices[e]}][${l.tensorIndices[e]}]`);const a=e.name,o=e.getClassName(),u=0===i.length?"":i[0];i$([`${a} (${o})`,s,e.countParams().toString(),u],t,r);for(let l=1;l<i.length;++l)i$(["","","",i[l]],t,r)}function u$(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function l$(e,t){if(null===e)return null;if("string"==typeof e)return AS(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];u$(t,s,r)?n.push(r):n.push(l$(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=AS(n);t[e]=l$(r,e)}}return t}}function c$(e,t){if(null==e)return null;if("string"==typeof e)return TS(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];u$(t,s,r)?n.push(r):n.push(c$(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];t[TS(n)]="name"!==n&&"className"!==n||"string"!=typeof r?c$(r,n):r}return t}}class h${constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof h$)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new kS(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return jy(t,e.dtype)}catch(aK){throw new kS(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof bE){if(null==this.id2Value[e.id])throw new kS(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new kS(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof bE){if(null==this.id2Value[e.id])throw new kS(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new kS(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&_v(this.id2Mask)}}const d$={},p$={};function f$(e,t,n,r){const s=null!=n&&n.training,i=Array.isArray(e),a=i?e:[e],o=a.map(e=>e.name),u=[],l=t.names();for(const f of o)-1!==l.indexOf(f)?u.push(t.getValue(f)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().join(",");let h,d;if(null==d$[c]){const e=function(e,t){Ip(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===e.length){const s=g$(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of e){const{sorted:e,recipientMap:a}=g$(i,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in a)null==r[t]&&(r[t]=new Set),a[t].forEach(e=>r[t].add(e))}}return{sorted:n,recipientCounts:m$(r)}}(a,t);h=e.sorted,d=e.recipientCounts,d$[c]=h,p$[c]=d}h=d$[c],d={},s||Object.assign(d,p$[c]);const p=new h$(t);for(let f=0;f<h.length;++f){if(null!=r){const e=Cv().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],i=e.sourceLayer;if(i instanceof CE)continue;const a=[],l=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);a.push(e),l.push(r),null!=r&&(m=!0),s||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=l[0]);const g=$S(i.apply(a,n));let b=null;i.supportsMasking&&(b=i.computeMask(a,l));const y=b$(e),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(b)?b[0]:b);const e=o.indexOf(v[t].name);-1!==e&&(u[e]=g[t])}s||_v(c)}return p.disposeMasks(),i?u:u[0]}function m$(e){const t={};for(const n in e)t[n]=e[n].size;return t}function g$(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const i=[],a=[];for(i.push(e);i.length>0;){const e=i[i.length-1];if(n.has(e.name)){i.pop();continue}const t=a[a.length-1]===i.length-1;if(0===e.inputs.length||t)i.pop(),r.push(e),n.add(e.name),t&&a.pop();else{a.push(i.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||i.push(t)}}return{sorted:r,recipientMap:s}}function b$(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}class y$ extends wE{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=oE(e)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(e.inputs)?e.inputs.slice():[e.inputs],this.outputs=Array.isArray(e.outputs)?e.outputs.slice():[e.outputs],LS(this.inputs).length!==this.inputs.length)throw new kS(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);LS(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.nodeIndex,t=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(t)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;SS(0===t,"input layer has >1 nodes"),SS(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof CE))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},r={},s={},i={},a=[],o=(e,t,n,r,s,u)=>{null!=r&&null!=s&&null!=u||(r=e.sourceLayer,s=e.nodeIndex,u=e.tensorIndex);const l=r.inboundNodes[s];if(-1!==n.indexOf(l))throw new wS(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(y$.nodeKey(r,s)),r.id in i||(i[r.id]=Object.keys(i).length),-1===n.indexOf(l)&&n.push(l);const c=l.inboundLayers.length;for(let i=0;i<c;i++)o(l.inputTensors[i],t,n,l.inboundLayers[i],l.nodeIndices[i],l.tensorIndices[i]);for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);a.push(l)},u=[],l=[];for(const b of this.outputs)o(b,u,l);const c=a.slice().reverse();for(const b of c){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];e=Math.max(e,null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id]),r[b.outboundLayer.id]=e,s[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let r=0;r<b.inboundLayers.length;r++){const s=b.inboundLayers[r].inboundNodes[b.nodeIndices[r]];t[s.id]=Math.max(e+1,null==t[s.id]?0:t[s.id]),n[s.id]=s}}const h={};for(const b in t){const e=t[b];e in h||(h[e]=[]),h[e].push(n[b])}const d={};for(const b in r){const e=r[b];e in d||(d[e]=[]),d[e].push(s[b])}let p=Object.keys(d).map(e=>parseInt(e,10)).sort(MS);this.layers=[];for(const b of p){const e=d[b];e.sort((e,t)=>{const n=i[e.id],r=i[t.id];return n<r?-1:n>r?1:0});for(const t of e)t instanceof y$&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map(e=>parseInt(e,10)).sort(MS);const f=this.inputs.slice(),m=[];for(const b of p)for(const e of h[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new wS(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map(e=>e.name);for(const b of g){const e=g.filter(e=>e===b).length;if(1!==e)throw new wS(`The name "${b}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new vE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new kS("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;for(const i of this.layers)for(const e of i.weights){if(null!=n[e.originalName])throw new kS(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}const s=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new kS(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new kS(`${e.length} of ${r} weights are not set: ${e}`)}mE(s)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers 3.6.0",t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=c$(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Iv(()=>{e=$S(e);const n=new h$;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return f$(this.outputs,n,t)})}computeMask(e,t){return Iv(()=>{let n;return e=$S(e),n=null==t?_S(null,e.length):$S(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=lE(e);if(t.length!==this.inputLayers.length)throw new kS(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let a=0;a<t.length;a++)n[this.inputLayers[a].name+"_0_0"]=t[a];const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(MS);if(r.length>1)for(const a of r){const e=this.nodesByDepth[a];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;const r=[];for(let a=0;a<t.inboundLayers.length;a++)r.push(n[`${t.inboundLayers[a].name}_${t.nodeIndices[a]}_${t.tensorIndices[a]}`]);const s=lE(e.computeOutputShape(ES(r))),i=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++)n[`${e.name}_${i}_${t}`]=s[t]}}const s=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const e=i[a];SS(e in n),s.push(n[e])}return ES(s)}runInternalGraph(e,t){null==t&&(t=_S(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o)n[this.inputs[o].id]=[e[o],t[o]];const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(MS);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,i=new Array;for(const t of r)t.id in n&&i.push(n[t.id]);if(i.length===r.length){let r,a,o,u,l={};if(null!=t.callArgs&&(l=t.callArgs),1===i.length){const[t,n]=i[0];null==l.mask&&(l.mask=n),o=$S(e.call(t,l)),u=$S(e.computeMask(t,n)),r=[t],a=[n]}else r=i.map(e=>e[0]),a=i.map(e=>e[1]),null==l.mask&&(l.mask=a),o=$S(e.call(r,l)),u=$S(e.computeMask(r,a));if(e.activityRegularizer)throw new CS("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e)n[s[e].id]=[o[e],u[e]]}}}const s=[],i=[],a=[];for(const o of this.outputs){SS(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];a.push(e.shape),s.push(e),i.push(t)}return[s,i,a]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof y$?1:0;for(let e=0;e<r.inboundNodes.length;e++){const s=y$.nodeKey(r,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new kS(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new kS("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===e)return n;throw new kS(`No such layer: ${e}`)}calculateLosses(){return Iv(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=y$.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const e=i.getClassName(),r=i.getConfig(),s=[];for(let n=0;n<i.inboundNodes.length;n++){const e=i.inboundNodes[n],r=y$.nodeKey(i,n);let a={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),a=e.callArgs}catch(aK){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],i=e.tensorIndices[r];let o=t[y$.nodeKey(s,e.nodeIndices[r])];null==o&&(o=0),n.push([s.name,o,i,a])}s.push(n)}}}const a={};a.name=i.name,a.className=e,a.config=r,a.inboundNodes=s,n.push(a)}e.layers=n;const r=[];for(let i=0;i<this.inputLayers.length;i++){const e=this.inputLayers[i],n=y$.nodeKey(e,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let s=t[n];null==s&&(s=0),r.push([e.name,s,this.inputLayersTensorIndices[i]])}e.inputLayers=r;const s=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],n=y$.nodeKey(e,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let r=t[n];null==r&&(r=0),s.push([e.name,r,this.outputLayersTensorIndices[i]])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},i={};function a(e,t){e.name in i?i[e.name].push(t):i[e.name]=[t]}function o(e,t){const n=[];let r;for(const i of t){const o=i[0],u=i[1],l=i[2];if(r=null==i[3]?{}:i[3],!(o in s))return void a(e,t);const c=s[o];if(c.inboundNodes.length<=u)return void a(e,t);n.push(c.inboundNodes[u].outputTensors[l])}n.length>0&&e.apply(ES(n),r)}function u(e){const n=e.name,i=LE(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(r),s[n]=i,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new kS(`Corrupted configuration, expected array for nodeData: ${e}`);a(i,e)})}const l=t.name,c=t.layers;for(const m of c)u(m);for(;!PS(i);)for(const e of c){const t=s[e.name];if(t.name in i){const e=i[t.name];delete i[t.name];for(const n of e)o(t,n)}}const h=[],d=[],p=t.inputLayers;for(const m of p){const e=m[0],t=m[1],n=m[2];SS(e in s),h.push(s[e].inboundNodes[t].outputTensors[n])}const f=t.outputLayers;for(const m of f){const e=m[0],t=m[1],n=m[2];SS(e in s),d.push(s[e].inboundNodes[t].outputTensors[n])}return new e({inputs:h,outputs:d,name:l})}get stateful(){if(this._stateful)throw new kS("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Iv(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function v$(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided classWeight is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{n.push(t in e?e[t]:null)}),n}throw new Error(`The model has multiple (${r}) outputs, so classWeight must be either an array with ${r} elements or an object with ${t} keys. Provided classWeight not understood: ${JSON.stringify(e)}`)}(e,t)}function x$(e,t,n,r){return w$.apply(this,arguments)}function w$(){return(w$=bp(function*(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Iv(()=>{if(1===e.shape.length)return e.clone();if(2===e.shape.length){if(e.shape[1]>1)return e.argMax(1);if(1===e.shape[1])return e.reshape([e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(yield t.data());_v(t);const s=[];return r.forEach(e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])}),Rw(s,"float32")}return null})).apply(this,arguments)}function k$(e,t){return Ox(e,t)}function C$(e,t){let n,r;n=t.xs,r=t.ys,Ip(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const s=I$("input",e.inputNames,n),i=I$("output",e.outputNames,r),a=s[0].shape[0];Ip(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),Ip(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let o=0;o<s.length;o++)Ip(s[o].shape[0]===a,()=>`Batch size mismatch: input ${e.inputNames[o]} has ${s[o].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);for(let o=0;o<i.length;o++)Ip(i[o].shape[0]===a,()=>`Batch size mismatch: output ${e.outputNames[o]} has ${i[o].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function I$(e,t,n){if(n instanceof Ab)return[n];if(Array.isArray(n))return Ip(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(null==n[s])throw new kS(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function _$(e){if(3===e.length)throw new CS("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function S$(){return(S$=bp(function*(e,t,n){const r=null!=n.batchesPerEpoch;if(Ip(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Ip(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Ip(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),Ip(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),Ip(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let i,a;if(s)if(E$(n.validationData))Ip(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const e=_$(n.validationData);i=e.xs,a=e.ys}const o=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let l;l=s?u.slice().concat(u.map(e=>"val_"+e)):u.slice();const c=DE(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=ME(c,h,n.epochs,null,null,N$(t,n),null,s,l);d.setModel(e),e.history=p,yield d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=yield t.iterator();for(;f<n.epochs;){const l={};yield d.onEpochBegin(f);let c=0,h=0;for(r||(m=yield t.iterator());!r||c<n.batchesPerEpoch;){const t=yield m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=C$(e,t.value),i={};i.batch=h,i.size=r[0].shape[0],yield d.onBatchBegin(h,i);const a=[];if(null!=n.classWeight){const t=v$(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)a.push(yield x$(s[e],null,t[e]))}const l=r.concat(s).concat(a),p=o(l);_v(l);for(let e=0;e<u.length;++e){const t=p[e];i[u[e]]=t,Sv(t)}yield d.onBatchEnd(h,i),NE(i),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=E$(n.validationData)?$S(yield e.evaluateDataset(n.validationData,{batches:n.validationBatches})):$S(e.evaluate(i,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(yield d.onEpochEnd(f,l),f++,e.stopTraining_)break}return yield d.onTrainEnd(),yield e.history.syncData(),e.history}finally{e.isTraining=!1}})).apply(this,arguments)}function N$(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function E$(e){return"function"==typeof e.iterator}function $$(e){return"function"==typeof e.next}function T$(){return(T$=bp(function*(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let i=[];if(n.verbose>0)throw new CS("Verbose mode is not implemented yet.");Ip(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const a=$$(t)?t:yield t.iterator();let o=0,u=0;for(;!r||u<n.batches;){const t=yield a.next();if(i=Iv(()=>{if(t.value){const{xs:n,ys:r}=C$(e,t.value),a=n.concat(r),l=Iv(()=>s(a));if(_v(a),0===u)for(let e=0;e<l.length;++e)i.push($v(0));const c=a[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=i[e];i[e]=Iv(()=>Rv(i[e],Ox(c,t))),u>0&&_v(n)}_v(l),o+=c,++u}return i}),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<i.length;++l){const e=i[l];i[l]=bx(i[l],o),_v(e)}return ES(i)})).apply(this,arguments)}function A$(e){Ip(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function R$(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>kN(e,t,n-t)):kN(e,t,n-t)}function F$(e,t){return Iv(()=>null==e?null:Array.isArray(e)?e.map(e=>F$(e,t)):TN(e,"int32"===t.dtype?t:t.toInt()))}function D$(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function O$(e,t,n,r,s,i,a,o,u,l,c,h,d,p,f){return M$.apply(this,arguments)}function M$(){return(M$=bp(function*(e,t,n,r,s,i,a,o,u,l,c,h,d,p,f){null==s&&(s=32),null==i&&(i=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;if(null!=u&&null!=l&&(m=!0),null!=f&&(m=!0,null==p))throw new kS("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=e.checkNumSamples(n,s,p,"steps_per_epoch");let b;null!=g&&(b=vN(0,g)),null==a&&(a=1);const{callbackList:y,history:v}=ME(o,a,i,d,g,p,s,m,h);y.setModel(e),e.history=v,yield y.onTrainBegin(),e.stopTraining_=!1;for(let x=d;x<i;++x){yield y.onEpochBegin(x);const i={};if(null!=p)throw new CS("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new CS("batch shuffling is not implemneted yet");c&&wp(b);const a=Rw(b),o=D$(g,s);for(let c=0;c<o.length;++c){const h={};if(yield y.onBatchBegin(c,h),Iv(()=>{const d=o[c][0],p=o[c][1],f=kN(a,d,p-d);h.batch=c,h.size=p-d;const g=F$(n,f),b=t(g);for(let e=0;e<r.length;++e){const t=b[e];h[r[e]]=t,Sv(t)}if(c===o.length-1&&m){const t=e.testLoop(u,l,s);for(let e=0;e<r.length;++e){const n=r[e],s=t[e];Sv(s),i["val_"+n]=s}}}),yield y.onBatchEnd(c,h),NE(h),e.stopTraining_)break}a.dispose()}if(yield y.onEpochEnd(x,i),e.stopTraining_)break}return yield y.onTrainEnd(),yield e.history.syncData(),e.history})).apply(this,arguments)}function L$(){return(L$=bp(function*(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,i,a,o,u,l,c;e.isTraining=!0;try{const h=null==r.batchSize?32:r.batchSize;A$(h);const d=!1,p=yield e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,d,h);s=p[0],i=p[1],c=p[2];let f,m=!1;if(null!=r.validationData&&r.validationData.length>0){if(m=!0,2!==r.validationData.length)throw 3===r.validationData.length?new CS("validationData including sample weights is not supported yet."):new kS(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);a=r.validationData[0],o=r.validationData[1];const t=!0,n=yield e.standardizeUserData(a,o,null,null,t,h);u=n[0],l=n[1],f=u.concat(l)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){m=!0;const e=Math.floor(s[0].shape[0]*(1-r.validationSplit)),t=s[0].shape[0];u=R$(s,e,t),s=R$(s,0,e),l=R$(i,e,t),i=R$(i,0,e),f=u.concat(l)}else null!=r.validationSteps&&(m=!0);const g=s.concat(i).concat(c);e.checkTrainableWeightsConsistency();const b=e.makeTrainFunction(),y=e.getDedupedMetricsNames();let v,x;m?(e.makeTestFunction(),v=e.testFunction,x=y.slice().concat(y.map(e=>"val_"+e))):(v=null,f=[],x=y.slice());const w=DE(r.callbacks,r.yieldEvery);return yield O$(e,b,g,y,h,r.epochs,r.verbose,w,v,f,r.shuffle,x,r.initialEpoch,null,null)}finally{e.isTraining=!1,z$(s,t),z$(i,n),z$(u,a),z$(l,o),null!=c&&_v(c)}})).apply(this,arguments)}function P$(e){const t=[];e instanceof Ab&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(wN(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function z$(e,t){if(null==e)return;const n=[];if(t instanceof Ab)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const s in t)n.push(t[s].id);const r=[];if(e instanceof Ab)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&r.push(e)});else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&r.push(t)}r.forEach(e=>{e.isDisposed||e.dispose()})}function V$(e){return Array.isArray(e)}function B$(e){return!function(e){return e instanceof Ab}(e)&&!V$(e)}function W$(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(V$(e)&&e.length>0)t=!0;else if(B$(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new kS(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);let i;if(B$(e)){e=e,i=[];for(const n of t){if(null==e[n])throw new kS(`No data provided for "${n}". Need data for each key in: ${t}`);i.push(e[n])}}else if(V$(e)){if((e=e).length!==t.length)throw new kS(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);i=e}else{if(e=e,t.length>1)throw new kS(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);i=[e]}if(i=P$(i),null!=n)for(let a=0;a<t.length;++a){if(null==n[a])continue;const e=i[a];if(e.shape.length!==n[a].length)throw new kS(`Error when checking ${s}: expected ${t[a]} to have ${n[a].length} dimension(s). but got array with shape ${e.shape}`);for(let i=0;i<n[a].length;++i){if(0===i&&!r)continue;const o=e.shape[i],u=n[a][i];if(null!=u&&u>=0&&o!==u)throw new kS(`Error when checking ${s}: expected ${t[a]} to have shape [${n[a]}], but got array with shape [${e.shape}].`)}}return i}function U$(e,t,n,r=!0,s=""){let i;if(Array.isArray(e)){if(e.length!==t.length)throw new kS(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);i=e}else{if(t.length>1)throw new kS(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);i=[e]}if(null!=n)for(let a=0;a<t.length;++a){if(null==n[a])continue;const e=i[a];if(e.shape.length!==n[a].length)throw new kS(`Error when checking ${s}: expected ${t[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let i=0;i<n[a].length;++i){if(0===i&&!r)continue;const o=e.shape[i],u=n[a][i];if(null!=u&&u!==o)throw new kS(`Error when checking ${s}: expected ${t[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class q$ extends y${constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new kS("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),i=["Layer (type)","Output shape","Param #"];let a;if(s?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!s){i.push("Receives inputs"),a=[];for(const t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),i$(i,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?a$(o[c],n,r):o$(o[c],n,a,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=function(e){let t;return t=dE(null!=e.collectedTrainableWeights?e.collectedTrainableWeights:e.trainableWeights),t}(e),l=dE(e.nonTrainableWeights);r(`Total params: ${u+l}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${l}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>jk.adagrad(.01),Adadelta:()=>jk.adadelta(1,.95,vS()),Adam:()=>jk.adam(.001,.9,.999,vS()),Adamax:()=>jk.adamax(.002,.9,.999,vS(),0),RMSProp:()=>jk.rmsprop(.001,.9,0,vS()),SGD:()=>jk.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new kS(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Tv))throw new kS("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new kS(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(e=>HE(e))}else{const n=HE(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new kS(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(HE(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const e=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],cN("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};cN("metric",()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,i;for(const a of t){if("string"==typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===qE?-1!==["accuracy","acc"].indexOf(a)?r=KE:-1!==["crossentropy","ce"].indexOf(a)&&(r=ZE):this.lossFunctions[e]===UE?-1!==["accuracy","acc"].indexOf(a)?r=YE:-1!==["crossentropy","ce"].indexOf(a)&&(r=JE):-1!==["accuracy","acc"].indexOf(a)?r=XE:-1!==["crossentropy","ce"].indexOf(a)&&(r=QE),-1!==["accuracy","acc"].indexOf(a)?s="acc":-1!==["crossentropy","ce"].indexOf(a)&&(s="ce"),i=r,n=""+s}else{const e=t$(a);i=e,n=""+n$(a)}let t;cN(n,()=>{t=i}),s(e,n,t)}})(r[e])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;A$(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const i=s[0].concat(s[1]);return this.makeTestFunction(),ES(this.testLoop(this.testFunction,i,r,n.verbose,n.steps))}finally{z$(s[0],e),z$(s[1],t)}}evaluateDataset(e,t){var n=this;return bp(function*(){return n.makeTestFunction(),function(e,t,n){return T$.apply(this,arguments)}(n,e,t)})()}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new kS(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new kS(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new kS("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=this.retrieveSymbolicTensors(n?t:[t]),s=new h$;if(e instanceof Ab&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new kS(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const a of this.inputs){const t=e[a.name];if(null==t)throw new kS(`No value is provided for the model's input ${a.name}`);s.add(a,t)}const i=f$(r,s);return n?i:i[0]}retrieveSymbolicTensors(e){const t=_S(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],i=s.map(e=>e.name);for(let r=0;r<e.length;++r){const a=i.indexOf(e[r]);if(-1!==a&&(t[r]=s[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,r)=>{null==t&&n.push(e[r])}),new kS(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return Iv(()=>{const r=this.checkNumSamples(e);if(n)throw new CS("Verbose predictLoop() is not implemented yet.");const s=D$(r,t),i=this.outputs.map(e=>[]);for(let t=0;t<s.length;++t)Iv(()=>{const n=R$(e,s[t][0],s[t][1]),r=[];if(Array.isArray(n))for(let e=0;e<n.length;++e)r.push({key:this.inputs[e],value:n[e]});else r.push({key:this.inputs[0],value:n});const i=new h$(r);return f$(this.outputs,i)}).forEach((e,t)=>i[t].push(e));return ES(i.map(e=>rx(e,0)))})}predict(e,t={}){const n=P$(e);U$(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==t.batchSize?32:t.batchSize;return A$(r),this.predictLoop(n,r)}finally{z$(n,e)}}predictOnBatch(e){U$(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new wS("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let i=0;i<this.feedOutputShapes.length;++i){const e=this.feedOutputShapes[i];s.push(this.feedLossFns[i]===UE?e.slice(0,e.length-1).concat([1]):e)}if(function(e,t,n){const r=LS(e.map(e=>e.shape[0]));r.sort();const s=LS(t.map(e=>e.shape[0]));if(s.sort(),r.length>1)throw new kS(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(e=>e.shape))}`);if(s.length>1)throw new kS(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(e=>e.shape))}`);if(r.length>0&&s.length>0&&!$p(r,s))throw new kS(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=W$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=W$(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[zE,qE,WE];for(let s=0;s<e.length;++s){const i=e[s],a=t[s],o=n[s];if(null!=a){if(a===WE&&1===i.shape[i.shape.length-1])throw new kS(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(a)){const e=i.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new kS(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new kS(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}standardizeUserData(e,t,n,r,s=!0,i){var a=this;return bp(function*(){const[o,u]=a.standardizeUserDataXY(e,t,s,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=v$(r,a.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(yield x$(u[t],null,e[t]))}return[o,u,l]})()}testLoop(e,t,n,r=0,s){return Iv(()=>{const i=this.checkNumSamples(t,n,s,"steps"),a=[];if(r>0)throw new CS("Verbose mode is not implemented yet.");if(null!=s)throw new CS("steps mode in testLoop() is not implemented yet");{const r=D$(i,n),s=Rw(vN(0,i));for(let n=0;n<r.length;++n){const i=r[n][0],o=r[n][1],u=kN(s,i,o-i),l=F$(t,u),c=e(l);if(0===n)for(let e=0;e<c.length;++e)a.push($v(0));for(let e=0;e<c.length;++e)a[e]=Rv(a[e],Ox(o-i,c[e]))}for(let e=0;e<a.length;++e)a[e]=bx(a[e],i)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;NS(e,r)>1&&(s+=`_${NS(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],a=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const a=new h$(e),o=f$(this.outputs,a,{training:!0});let u;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=s[n]&&(e=k$(e,s[n]));const i=Ux(e);t.push(i),u=0===n?e:Rv(u,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][1];e=Ux((0,this.metricsTensors[n][0])(r[t],o[t]))}Sv(e),i.push(e)}return u=Ux(u),this.calculateLosses().forEach(e=>{u=Rv(u,e)}),u},!0,a)].concat(i)}}makeTestFunction(){this.testFunction=e=>Iv(()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:r[e]});const a=new h$(i),o=f$(this.outputs,a);for(let e=0;e<this.lossFunctions.length;++e){const r=Ux((0,this.lossFunctions[e])(s[e],o[e]));n=0===e?r:Rv(n,r),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][1],r=Ux((0,this.metricsTensors[e][0])(s[n],o[n]));t.push(r)}return t})}fit(e,t,n={}){var r=this;return bp(function*(){return function(e,t,n){return L$.apply(this,arguments)}(r,e,t,n)})()}fitDataset(e,t){var n=this;return bp(function*(){return function(e,t,n){return S$.apply(this,arguments)}(n,e,t)})()}trainOnBatch(e,t){var n=this;return bp(function*(){const r=yield n.standardizeUserData(e,t),s=r[0],i=r[1],a=n.makeTrainFunction()(s.concat(i)),o=[];for(const e of a){const t=yield e.data();o.push(t[0])}return _v(a),ES(o)})()}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<r.length;++i)n&&!r[i].trainable||t.push({name:r[i].originalName,tensor:s[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Cv().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Cv().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=TS(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>TS(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=TS(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[TS(n$(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>TS(n$(e)));{const e={};for(const t in this.metrics)e[t]=TS(n$(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=LE(l$(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=AS(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>AS(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=AS(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map(e=>AS(e));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=AS(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}save(e,t){var n=this;return bp(function*(){if("string"==typeof e){const t=vy.getSaveHandlers(e);if(0===t.length)throw new kS(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new kS(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new kS("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=yield hy(n.getNamedWeights(t)),s={modelTopology:n.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.6.0",convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=n.optimizer){s.trainingConfig=n.getTrainingConfig();const e="optimizer",{data:t,specs:i}=yield hy(yield n.optimizer.getWeights(),e);r.specs.push(...i),r.data=gy([r.data,t])}return null!=n.userDefinedMetadata&&(r$(n.userDefinedMetadata,n.name,!0),s.userDefinedMetadata=n.userDefinedMetadata),s.weightData=r.data,s.weightSpecs=r.specs,e.save(s)})()}setUserDefinedMetadata(e){r$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}q$.className="Model",wv(q$);class j$ extends q${}function G$(){return(G$=bp(function*(e,t){if(null==t&&(t={}),"string"==typeof e){const n=xy(e,t);if(0===n.length)n.push(nv(e,t));else if(n.length>1)throw new kS(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return H$(e,void 0,t)})).apply(this,arguments)}function H$(e,t,n){return K$.apply(this,arguments)}function K$(){return(K$=bp(function*(e,t,n){if(null==n&&(n={}),null==e.load)throw new kS("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=yield e.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const i=null==n.strict||n.strict,a=null!=r.weightData&&null!=r.weightSpecs&&i,o=LE(l$(s),t,a),u=r.trainingConfig;if(null!=u&&o.loadTrainingConfig(u),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new kS("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=X$(r.weightData,r.weightSpecs);o.loadWeights(e,i),null!=o.optimizer&&t.length>0&&(yield o.optimizer.setWeights(t)),_v(e),_v(t.map(e=>e.tensor))}return o})).apply(this,arguments)}function X$(e,t){const n=function(e,t){const n={};let r,s=0;for(const i of t){const t=i.name,a=i.dtype,o=i.shape,u=Ep(o);let l;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const o=cy[n.dtype],c=e.slice(s,s+u*o),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++)l[e]=h[e]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=yy()),l=r(h)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${t}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(h.length);for(let e=0;e<h.length;e++)l[e]=Math.round(h[e]*n.scale+n.min)}s+=u*o}else if("string"===a){const t=Ep(i.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(s,s+4))[0];s+=4;const n=new Uint8Array(e.slice(s,s+t));l.push(n),s+=t}}else{const r=cy[a],i=e.slice(s,s+u*r);if("float32"===a)l=new Float32Array(i);else if("int32"===a)l=new Int32Array(i);else if("bool"===a)l=new Uint8Array(i);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${t}': ${a}`);{l=new Float32Array(i);const e=new Float32Array(l.length/2),r=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],r[t]=l[2*t+1];const s=ly(e,o,"float32"),a=ly(r,o,"float32");n[t]=oy(s,a),s.dispose(),a.dispose()}}s+=u*r}"complex64"!==a&&(n[t]=ly(l,o,a))}return n}(e,t),r={},s=[];return t.forEach(e=>{"optimizer"===e.group?s.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]}),{modelWeights:r,optimizerWeights:s}}j$.className="Functional",wv(j$);class Z$ extends q${constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:oE("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new kS(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Z$||e instanceof q$;let n;if(t){if(n=e,1!==n.outputs.length)throw new kS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new kS("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new kS("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=IE({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new kS(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new kS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=kE(this.outputs[0])}this.inboundNodes=[],new vE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:_S(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(hE(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new q$({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new wS("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}evaluateDataset(e,t){var n=this;return bp(function*(){if(!n.built)throw new wS("The model needs to be compiled before being used.");return n.model.evaluateDataset(e,t)})()}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,t,n={}){var r=this;return bp(function*(){if(!r.built)throw new wS("The model needs to be compiled before being used.");return r.model.fit(e,t,n)})()}fitDataset(e,t){var n=this;return bp(function*(){if(!n.built)throw new wS("The model needs to be compiled before being used.");return n.model.fitDataset(e,t)})()}trainOnBatch(e,t){var n=this;return bp(function*(){return n.model.trainOnBatch(e,t)})()}static fromConfig(e,t,n={},r=!1){let s,i={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new kS("Legacy serialization format not supported yet.");s=t}else Ip(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,i=t;const a=new e(i);if(!(a instanceof Z$))throw new CS(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const o of s){const e=LE(o,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),a.add(e)}return a}set stopTraining(e){if(null==this.model)throw new kS("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new kS("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function Y$(e){return new q$(e)}function Q$(e,t){return null==t&&(t={}),function(e,t){return G$.apply(this,arguments)}(e,t)}function J$(e){return IE(e)}Z$.className="Sequential",wv(Z$);class eT extends vv{getConfig(){return{}}}class tT extends eT{apply(e,t=1){return function(e,t=1){if(1!==t)throw new CS(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return yx(e)}(e,t)}}tT.className="elu",wv(tT);class nT extends eT{apply(e){return bw(e)}}nT.className="selu",wv(nT);class rT extends eT{apply(e){return mw(e)}}rT.className="relu",wv(rT);class sT extends eT{apply(e){return Iv(()=>jx(6,mw(e)))}}sT.className="relu6",wv(sT);class iT extends eT{apply(e){return e}}iT.className="linear",wv(iT);class aT extends eT{apply(e){return vw(e)}}aT.className="sigmoid",wv(aT);class oT extends eT{apply(e){return function(e){return Iv(()=>{const t=Rv(.5,Ox(.2,e));return nx(t,0,1)})}(e)}}oT.className="hardSigmoid",wv(oT);class uT extends eT{apply(e){return Sw(e)}}uT.className="softplus",wv(uT);class lT extends eT{apply(e){return function(e){return Iv(()=>bx(e,Av(e).add(1)))}(e)}}lT.className="softsign",wv(lT);class cT extends eT{apply(e){return Aw(e)}}cT.className="tanh",wv(cT);class hT extends eT{apply(e,t=-1){return _w(e,t)}}hT.className="softmax",wv(hT);class dT extends eT{apply(e,t=-1){return Px(e,t)}}dT.className="logSoftmax",wv(dT);class pT extends eT{apply(e,t=1){return Iv(()=>vw(e.mul(t)).mul(e))}}pT.className="swish",wv(pT);class fT extends eT{apply(e){return Iv(()=>Ox(e,Aw(Sw(e))))}}function mT(e){return e.getClassName()}function gT(e,t={}){return OS(e,xv.getMap().classNameMap,t,"activation")}function bT(e){if(null==e)return gT({className:"linear",config:{}});if("string"==typeof e){const t={};return t.className=e,t.config={},gT(t)}return e instanceof eT?e:gT(e)}fT.className="mish",wv(fT);class yT extends vv{}class vT extends yT{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Iv(()=>{let t=iw([1]);return this.hasL1&&(t=Rv(t,Lx(Ox(this.l1,Av(e))))),this.hasL2&&(t=Rv(t,Lx(Ox(this.l2,AN(e))))),t.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}vT.className="L1L2",wv(vT);const xT={l1l2:"L1L2"};function wT(e){return FS(e)}function kT(e,t={}){return OS(e,xv.getMap().classNameMap,t,"regularizer")}function CT(e){return null==e?null:"string"==typeof e?kT({className:e in xT?xT[e]:e,config:{}}):e instanceof yT?e:kT(e)}class IT extends wE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=cE(e);let n=mw(e);return null!=this.maxValue&&(n=nx(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}IT.className="ReLU",wv(IT);class _T extends wE{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=cE(e);return Ax(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}_T.className="LeakyReLU",wv(_T);class ST extends wE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=rE(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=CT(e.alphaRegularizer),this.alphaConstraint=JS(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new kS(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=hE(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new gE({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=cE(e),lw(e,this.alpha.read())}getConfig(){const e={alphaInitializer:nE(this.alphaInitializer),alphaRegularizer:wT(this.alphaRegularizer),alphaConstraint:YS(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}ST.className="PReLU",wv(ST);class NT extends wE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new CS(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=cE(e);return yx(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}NT.className="ELU",wv(NT);class ET extends wE{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=cE(e);return n.mul(xN(n.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}ET.className="ThresholdedReLU",wv(ET);class $T extends wE{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new hT).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=cE(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function TT(e,t,n){if("number"==typeof e)return _S(e,t);if(e.length!==t)throw new kS(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const i=e[s];if((r=i)!==parseInt(r.toString(),10))throw new kS(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${i}`)}return e;var r}function AT(e,t,n,r,s=1){if(null==e)return e;let i;return i="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((i+r-1)/r)}function RT(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+yN([n-t,0]);else{if("same"!==r)throw new kS(`Unsupport padding mode: ${r}.`);e*=t}return e}function FT(e,t){return Iv(()=>(aN(t),"channelsFirst"===t?zw(e,[0,2,3,1]):e))}function DT(e,t){return Iv(()=>(aN(t),"channelsFirst"===t?zw(e,[0,2,3,4,1]):e))}function OT(e,t,n,r=[1,1],s="valid",i,a,o=null){return Iv(()=>{if(null==i&&(i="channelsLast"),aN(i),3!==e.rank&&4!==e.rank)throw new kS(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new kS(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=FT(e,i);if("causal"===s)throw new CS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=ek({x:u,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(u=zw(u,[0,3,1,2])),u})}$T.className="Softmax",wv($T);class MT extends wE{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",MT.verifyArgs(t),this.rank=e,BS(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new CS(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=TT(t.kernelSize,e,"kernelSize"),this.strides=TT(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,oN(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,aN(this.dataFormat),this.activation=bT(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=rE(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=JS(t.biasConstraint),this.biasRegularizer=CT(t.biasRegularizer),this.activityRegularizer=CT(t.activityRegularizer),this.dilationRate=TT(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new kS(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new kS(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new kS(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(SS("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!VS(e.kernelSize,"number",1,3))throw new kS(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:mT(this.activation),useBias:this.useBias,biasInitializer:nE(this.biasInitializer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),biasConstraint:YS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class LT extends MT{constructor(e,t){super(e,t),this.kernel=null,LT.verifyArgs(t),this.filters=t.filters,BS(this.filters,"filters"),this.kernelInitializer=rE(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=JS(t.kernelConstraint),this.kernelRegularizer=CT(t.kernelRegularizer)}build(e){e=hE(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Iv(()=>{let t;e=cE(e);const n=null==this.bias?null:this.bias.read(),r=US(this.activation.getClassName());if(null!=r&&2===this.rank)t=OT(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,s="valid",i,a=1){return Iv(()=>{if(null==i&&(i="channelsLast"),aN(i),3!==e.shape.length)throw new kS(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new kS(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new kS(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(e=zw(e,[0,2,1])),"causal"===s)throw new CS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=lx(e,t,r,"same"===s?"same":"valid","NWC",a);return null!=n&&(o=FN(o,n)),o})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=OT(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new CS("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],s="valid",i,a){return Iv(()=>{if(null==i&&(i="channelsLast"),aN(i),4!==e.rank&&5!==e.rank)throw new kS(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new kS(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=DT(e,i);if("causal"===s)throw new CS("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=dx(o,t,r,"same"===s?"same":"valid","NDHWC",a),null!=n&&(o=FN(o,n)),"channelsFirst"===i&&(o=zw(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=hE(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=AT(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:nE(this.kernelInitializer),kernelRegularizer:wT(this.kernelRegularizer),kernelConstraint:YS(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new kS(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class PT extends LT{constructor(e){super(2,e),PT.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!VS(e.kernelSize,"number",1,2))throw new kS(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}PT.className="Conv2D",wv(PT);class zT extends LT{constructor(e){super(3,e),zT.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new kS(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}zT.className="Conv3D",wv(zT);class VT extends PT{constructor(e){if(super(e),this.inputSpec=[new gE({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new kS(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=hE(e)).length)throw new kS("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gE({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Iv(()=>{let t=cE(e);if(4!==t.shape.length)throw new kS(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const i=n[s],a=this.kernelSize[1],o=this.strides[1],u=[n[0],RT(n[r],this.strides[0],this.kernelSize[0],this.padding),RT(i,o,a,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=zw(t,[0,2,3,1]));let l=hx(t,this.kernel.read(),u,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(l=zw(l,[0,3,1,2])),null!=this.bias&&(l=FN(l,this.bias.read(),this.dataFormat)),null!=this.activation&&(l=this.activation.apply(l)),l})}computeOutputShape(e){const t=(e=hE(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const i=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=RT(t[r],o,i,this.padding),t[s]=RT(t[s],u,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}VT.className="Conv2DTranspose",wv(VT);class BT extends zT{constructor(e){if(super(e),this.inputSpec=[new gE({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new kS(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=hE(e)).length)throw new kS("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gE({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Iv(()=>{let t=cE(e);if(5!==t.shape.length)throw new kS(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let r,s,i;"channelsFirst"===this.dataFormat?(i=2,r=3,s=4):(i=1,r=2,s=3);const a=n[r],o=n[s],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[1],h=this.strides[2],d=[n[0],RT(n[i],this.strides[0],this.kernelSize[0],this.padding),RT(a,c,u,this.padding),RT(o,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=zw(t,[0,2,3,4,1]));let p=fx(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=zw(p,[0,4,1,2,3])),null!==this.bias&&(p=FN(p,this.bias.read(),this.dataFormat)),null!==this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){const t=(e=hE(e)).slice();let n,r,s,i;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,i=4):(n=4,r=1,s=2,i=3);const a=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=RT(t[r],l,a,this.padding),t[s]=RT(t[s],c,o,this.padding),t[i]=RT(t[i],h,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}BT.className="Conv3DTranspose",wv(BT);class WT extends LT{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new kS("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new kS("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new kS(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=rE(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=CT(t.depthwiseRegularizer),this.depthwiseConstraint=JS(t.depthwiseConstraint),this.pointwiseInitializer=rE(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=CT(t.pointwiseRegularizer),this.pointwiseConstraint=JS(t.pointwiseConstraint)}build(e){if((e=hE(e)).length<this.rank+2)throw new kS(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new kS(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):null,this.inputSpec=[new gE({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Iv(()=>{let t;if(e=cE(e),1===this.rank)throw new CS("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=zw(e,[0,2,3,1])),t=yw(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=FN(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=zw(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=nE(this.depthwiseInitializer),e.pointwiseInitializer=nE(this.pointwiseInitializer),e.depthwiseRegularizer=wT(this.depthwiseRegularizer),e.pointwiseRegularizer=wT(this.pointwiseRegularizer),e.depthwiseConstraint=YS(this.depthwiseConstraint),e.pointwiseConstraint=YS(this.pointwiseConstraint),e}}WT.className="SeparableConv";class UT extends WT{constructor(e){super(2,e)}}UT.className="SeparableConv2D",wv(UT);class qT extends LT{constructor(e){super(1,e),qT.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!VS(e.kernelSize,"number",1,1))throw new kS(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}qT.className="Conv1D",wv(qT);class jT extends wE{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Iv(()=>{if(e=cE(e),"channelsLast"===this.dataFormat){const t=IN(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return IN(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=IN(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return IN(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}jT.className="Cropping2D",wv(jT);class GT extends wE{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aN(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,zS(tN,"InterpolationFormat",this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,t){return Iv(()=>{let t=cE(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=zw(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?t.resizeNearestNeighbor([e,r]):t.resizeBilinear([e,r]);return zw(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?t.resizeNearestNeighbor([e,r]):t.resizeBilinear([e,r])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}GT.className="UpSampling2D",wv(GT);class HT extends MT{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=rE(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=JS(e.depthwiseConstraint),this.depthwiseRegularizer=CT(e.depthwiseRegularizer)}build(e){if((e=hE(e)).length<4)throw new kS(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new kS(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Iv(()=>{let t=function(e,t,n=[1,1],r="valid",s,i){return Iv(()=>{null==s&&(s="channelsLast"),aN(s);let a=FT(e,s);if(4!==e.rank)throw new kS(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new kS(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=mx(a,t,n,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(a=zw(a,[0,3,1,2])),a})}(e=cE(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=FN(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=hE(e);const t="channelsFirst"===this.dataFormat?e[3]:e[2],n="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=AT("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),s=AT(t,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],n,r,s]:[e[0],r,s,n]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=nE(this.depthwiseInitializer),e.depthwiseRegularizer=wT(this.depthwiseRegularizer),e.depthwiseConstraint=YS(this.depthwiseRegularizer),e}}function KT(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new kS("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function XT(e,t,n,r=!1,s,i,a=!1,o=!1){return Iv(()=>{const u=t.shape.length;if(u<3)throw new kS(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(vN(2,u));if(t=zw(t,l),null!=i)throw new CS("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=s.asType("bool").asType("float32")).rank===u-1&&(s=Cx(s,-1)),s=zw(s,l)),r&&(t=gw(t,0),null!=s&&(s=gw(s,0)));const c=[];let h,d=n;const p=t.shape[0],f=Ow(t);let m,g;null!=s&&(m=Ow(s));for(let t=0;t<p;++t){const n=f[t],r=Iv(()=>e(n,d));if(null==s)h=r[0],d=r[1];else{const e=Iv(()=>{const e=m[t],n=ow(e).sub(e);return{output:r[0].mul(e).add(d[0].mul(n)),newStates:d.map((t,s)=>r[1][s].mul(e).add(t.mul(n)))}});h=e.output,d=e.newStates}o&&c.push(h)}return o&&(g=Tw(c,1)),[h,g,d]})}HT.className="DepthwiseConv2D",wv(HT);class ZT extends wE{constructor(e){let t;if(super(e),null==e.cell)throw new kS("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new sA({cells:e.cell}):e.cell,null==t.stateSize)throw new kS("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new gE({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?vN(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){uE(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return Iv(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new CS("Constants support is not implemented in RNN yet.");uE(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new gE({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!$p(this.stateSpec.map(e=>e.shape[e.shape.length-1]),s))throw new kS(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(e=>new gE({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Iv(()=>{if(!this.stateful)throw new xS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new kS("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>iw([n,e])):[iw([n,this.cell.stateSize])];else if(null==e)_v(this.states_),null!=this.keptStates&&(_v(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>iw([n,e])):this.states_[0]=iw([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new kS(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):_v(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,i=[n,s];if(!$p(r.shape,i))throw new kS(`State ${t} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map(e=>Sv(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=KT(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let i=[],a=[];if(null!=n){t.initialState=n,i=i.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new gE({shape:e.shape}));a=a.concat(this.stateSpec)}if(null!=r&&(t.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof bE){const n=[e].concat(i),r=this.inputSpec.concat(a),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Iv(()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=cE(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new kS(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},o=XT((e,t)=>{const n=this.cell.call([e].concat(t),a);return[n[0],n.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),u=o[0],l=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?l:u;return this.returnState?[h].concat(c):h})}getInitialState(e){return Iv(()=>{let t=iw(e.shape);return t=Lx(t,[1,2]),t=wN(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?NN(t,[1,e]):t):this.cell.stateSize>1?[NN(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===ZT.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){const r=LE(t.cell,n);return new e(Object.assign(t,{cell:r}))}}ZT.className="RNN",wv(ZT);class YT extends wE{}class QT extends YT{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,BS(this.units,"units"),this.activation=bT(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=CT(e.kernelRegularizer),this.recurrentRegularizer=CT(e.recurrentRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.kernelConstraint=JS(e.kernelConstraint),this.recurrentConstraint=JS(e.recurrentConstraint),this.biasConstraint=JS(e.biasConstraint),this.dropout=bN([1,yN([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bN([1,yN([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=hE(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Iv(()=>{if(2!==(e=e).length)throw new kS(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>ow(e),rate:this.dropout,training:r})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>ow(n),rate:this.recurrentDropout,training:r}));const i=this.dropoutMask,a=this.recurrentDropoutMask;s=$N(null!=i?Ox(e,i):e,this.kernel.read()),null!=this.bias&&(s=FN(s,this.bias.read())),null!=a&&(n=Ox(n,a));let o=Rv(s,$N(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mT(this.activation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),recurrentInitializer:nE(this.recurrentInitializer),biasInitializer:nE(this.biasInitializer),kernelRegularizer:wT(this.kernelRegularizer),recurrentRegularizer:wT(this.recurrentRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),recurrentConstraint:YS(this.recurrentConstraint),biasConstraint:YS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}QT.className="SimpleRNNCell",wv(QT);class JT extends ZT{constructor(e){e.cell=new QT(e),super(e)}call(e,t){return Iv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return new e(t)}}JT.className="SimpleRNN",wv(JT);class eA extends YT{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new kS("GRUCell does not support reset_after parameter set to true.");this.units=e.units,BS(this.units,"units"),this.activation=bT(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=bT(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=CT(e.kernelRegularizer),this.recurrentRegularizer=CT(e.recurrentRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.kernelConstraint=JS(e.kernelConstraint),this.recurrentConstraint=JS(e.recurrentConstraint),this.biasConstraint=JS(e.biasConstraint),this.dropout=bN([1,yN([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bN([1,yN([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=hE(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Iv(()=>{if(2!==(e=e).length)throw new kS(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>ow(e),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>ow(r),rate:this.recurrentDropout,training:n,count:3}));const s=this.recurrentDropoutMask;let i,a,o;0<this.dropout&&this.dropout<1&&(e=Ox(e,this.dropoutMask[0]));let u=$N(e,this.kernel.read());this.useBias&&(u=FN(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Ox(r,s[0]));const l=this.recurrentKernel.read(),[c,h]=Nw(l,[2*this.units,this.units],l.rank-1),d=$N(r,c),[p,f,m]=Nw(u,3,u.rank-1),[g,b]=Nw(d,2,d.rank-1);i=this.recurrentActivation.apply(Rv(p,g)),a=this.recurrentActivation.apply(Rv(f,b));const y=$N(Ox(a,r),h);o=this.activation.apply(Rv(m,y));const v=Rv(Ox(i,r),Ox(Rv(1,nw(i)),o));return[v,v]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mT(this.activation),recurrentActivation:mT(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),recurrentInitializer:nE(this.recurrentInitializer),biasInitializer:nE(this.biasInitializer),kernelRegularizer:wT(this.kernelRegularizer),recurrentRegularizer:wT(this.recurrentRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),recurrentConstraint:YS(this.recurrentConstraint),biasConstraint:YS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}eA.className="GRUCell",wv(eA);class tA extends ZT{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new eA(e),super(e)}call(e,t){return Iv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}tA.className="GRU",wv(tA);class nA extends YT{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,BS(this.units,"units"),this.activation=bT(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=bT(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rE(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=CT(e.kernelRegularizer),this.recurrentRegularizer=CT(e.recurrentRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.kernelConstraint=JS(e.kernelConstraint),this.recurrentConstraint=JS(e.recurrentConstraint),this.biasConstraint=JS(e.biasConstraint),this.dropout=bN([1,yN([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bN([1,yN([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n;if(e=hE(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,r=this.units;n=new((t=class extends PN{apply(t,n){const s=e.apply([r]),i=(new VN).apply([r]),a=e.apply([2*r]);return SN(SN(s,i),a)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Iv(()=>{const n=null!=t.training&&t.training;if(3!==(e=e).length)throw new kS(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>ow(e),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>ow(r),rate:this.recurrentDropout,training:n,count:4}));const i=this.recurrentDropoutMask;let a,o,u,l;0<this.dropout&&this.dropout<1&&(e=Ox(e,this.dropoutMask[0]));let c=$N(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Ox(r,i[0])),c=Rv(c,$N(r,this.recurrentKernel.read())),this.useBias&&(c=FN(c,this.bias.read()));const[h,d,p,f]=Nw(c,4,c.rank-1);a=this.recurrentActivation.apply(h),o=this.recurrentActivation.apply(d),u=Rv(Ox(o,s),Ox(a,this.activation.apply(p))),l=this.recurrentActivation.apply(f);const m=Ox(l,this.activation.apply(u));return[m,m,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mT(this.activation),recurrentActivation:mT(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),recurrentInitializer:nE(this.recurrentInitializer),biasInitializer:nE(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:wT(this.kernelRegularizer),recurrentRegularizer:wT(this.recurrentRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),recurrentConstraint:YS(this.recurrentConstraint),biasConstraint:YS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}nA.className="LSTMCell",wv(nA);class rA extends ZT{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new nA(e),super(e)}call(e,t){return Iv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}rA.className="LSTM",wv(rA);class sA extends YT{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Iv(()=>{let n=(e=e).slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let i;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=r[a],i=0===a?[e[0]].concat(n):[i[0]].concat(n),i=o.call(i,t),s.push(i.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[i[0]].concat(n)})}build(e){let t;uE(e)&&(e=e[0]),e=e,this.cells.forEach((n,r)=>{cN(`RNNCell_${r}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}));return Object.assign({},e,{cells:t})}static fromConfig(e,t,n={}){const r=[];for(const s of t.cells)r.push(LE(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return fE(e)}setWeights(e){const t=[];for(const n of this.cells){const r=e.splice(n.weights.length);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}mE(t)}}function iA(e){const{ones:t,rate:n,training:r=!1,count:s=1}=e,i=()=>DN(t(),n),a=()=>ON(i,t,r);return!s||s<=1?Sv(a().clone()):Array(s).fill(void 0).map(a).map(e=>Sv(e.clone()))}var aA,oA,uA,lA;sA.className="StackedRNNCells",wv(sA);class cA extends ZT{constructor(e){if(e.unroll)throw new CS("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new CS("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new gE({ndim:5})]}call(e,t){return Iv(()=>{if(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new kS("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Iv(()=>{const{stateSize:t}=this.cell,n=this.computeSingleOutputShape(e.shape),r=iw([n[0],...n.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]})}resetStates(e,t=!1){Iv(()=>{if(!this.stateful)throw new xS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new kS("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>iw(s)):[iw(s)];else if(null==e)_v(this.states_),null!=this.keptStates&&(_v(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>iw(s)):this.states_[0]=iw(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new kS(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_v(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!$p(n.shape,r))throw new kS(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>Sv(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:i,dilationRate:a}=this.cell,o="channelsFirst"===t,u=e[o?4:3],l=AT(e[o?3:2],r[0],s,i[0],a[0]),c=AT(u,r[1],s,i[1],a[1]);return[...e.slice(0,2),...o?[n,l,c]:[l,c,n]]}}cA.className="ConvRNN2D";class hA extends nA{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:i,dilationRate:a}=e;super(Object.assign({},e,{units:t})),this.filters=t,BS(this.filters,"filters"),this.kernelSize=TT(n,2,"kernelSize"),this.kernelSize.forEach(e=>BS(e,"kernelSize")),this.strides=TT(r||1,2,"strides"),this.strides.forEach(e=>BS(e,"strides")),this.padding=s||"valid",oN(this.padding),this.dataFormat=i||"channelsLast",aN(this.dataFormat),this.dilationRate=TT(a||1,2,"dilationRate"),this.dilationRate.forEach(e=>BS(e,"dilationRate"))}build(e){var t;e=hE(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new kS(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=this.kernelSize.concat([e[n],4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends PN{apply(e,t){return _N([n.apply([r]),aw([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Iv(()=>{if(3!==e.length)throw new kS(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],i=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=iA({ones:()=>ow(r),rate:this.dropout,training:n,count:4}));const a=this.dropoutMask,o=(e,t,n)=>t&&t[n]?Ox(t[n],e):e;let u=o(r,a,0),l=o(r,a,1),c=o(r,a,2),h=o(r,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=iA({ones:()=>ow(s),rate:this.recurrentDropout,training:n,count:4}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[b,y,v,x]=Nw(this.kernel.read(),4,3),[w,k,C,I]=this.useBias?Nw(this.bias.read(),4):[null,null,null,null];u=this.inputConv(u,b,w,this.padding),l=this.inputConv(l,y,k,this.padding),c=this.inputConv(c,v,C,this.padding),h=this.inputConv(h,x,I,this.padding);const[_,S,N,E]=Nw(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,_),f=this.recurrentConv(f,S),m=this.recurrentConv(m,N),g=this.recurrentConv(g,E);const $=this.recurrentActivation.apply(Rv(u,p)),T=this.recurrentActivation.apply(Rv(l,f)),A=Rv(Ox(T,i),Ox($,this.activation.apply(Rv(c,m)))),R=Ox(this.recurrentActivation.apply(Rv(h,g)),this.activation.apply(A));return[R,R,A]})}getConfig(){const e=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(super.getConfig(),["units"]);return Object.assign({},e,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(e,t,n,r){const s=ux(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?FN(s,n,this.dataFormat):s}recurrentConv(e,t){return ux(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}hA.className="ConvLSTM2DCell",wv(hA);class dA extends cA{constructor(e){const t=new hA(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}dA.className="ConvLSTM2D",wv(dA);class pA extends wE{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cE(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return ON(()=>DN(n,this.rate,r,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}pA.className="Dropout",wv(pA);class fA extends pA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}fA.className="SpatialDropout1D",wv(fA);class mA extends wE{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,BS(this.units,"units"),this.activation=bT(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=rE(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=rE(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=JS(e.kernelConstraint),this.biasConstraint=JS(e.biasConstraint),this.kernelRegularizer=CT(e.kernelRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.activityRegularizer=CT(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=hE(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=hE(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cE(e),r=US(this.activation.getClassName());let s;return null!=r?s=$N(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=$N(n,this.kernel.read()),null!=this.bias&&(s=FN(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:mT(this.activation),useBias:this.useBias,kernelInitializer:nE(this.kernelInitializer),biasInitializer:nE(this.biasInitializer),kernelRegularizer:wT(this.kernelRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),biasConstraint:YS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}mA.className="Dense",wv(mA);class gA extends wE{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=hE(e);for(const t of e.slice(1))if(null==t)throw new kS(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],mN(e,1)]}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);let n=cE(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=n.transpose(e)}return function(e){if(e.rank<=1)throw new kS(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],mN(e.shape,1)];return e.reshape(t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}gA.className="Flatten",wv(gA);class bA extends wE{constructor(e){super(e),this.supportsMasking=!0,this.activation=bT(e.activation)}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cE(e);return this.activation.apply(n)})}getConfig(){const e={activation:mT(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}bA.className="Activation",wv(bA);class yA extends wE{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Iv(()=>{return e=cE(e),t=e,n=this.n,Iv(()=>{if(2!==t.shape.length)throw new kS(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return NN(wN(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}yA.className="RepeatVector",wv(yA);class vA extends wE{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,i=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==i)throw new kS("Can only specifiy one unknown dimension.");i=o}else s*=e}const a=mN(e);if(null!==i){if(0===s||a%s!=0)throw new kS(n);r[i]=a/s}else if(a!==s)throw new kS(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cE(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return n.reshape(s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}vA.className="Reshape",wv(vA);class xA extends wE{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=vN(1,e.dims.length+1);if(!$p(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new gE({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=hE(e)).slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return zw(cE(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}xA.className="Permute",wv(xA);class wA extends wE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=cE(e);return Dv(rw(n,this.maskValue),-1)}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cE(e),r=Dv(rw(n,this.maskValue),-1,!0);return n.mul(r.asType(n.dtype))})}}wA.className="Masking",wv(wA);class kA extends wE{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=null==e.inputLength?[t,null]:[t].concat($S(e.inputLength))}this.inputDim=e.inputDim,BS(this.inputDim,"inputDim"),this.outputDim=e.outputDim,BS(this.outputDim,"outputDim"),this.embeddingsInitializer=rE(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=CT(e.embeddingsRegularizer),this.activityRegularizer=CT(e.activityRegularizer),this.embeddingsConstraint=JS(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Iv(()=>this.maskZero?(e=cE(e),rw(e,Pw(e))):null)}computeOutputShape(e){if(e=hE(e),null==this.inputLength)return[...e,this.outputDim];const t=$S(this.inputLength);if(t.length!==e.length-1)throw new kS(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],i=e[r+1];if(null!=s&&null!=i&&s!==i)throw new kS(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);let n=cE(e);return"int32"!==n.dtype&&(n=xN(n,"int32")),TN(this.embeddings.read(),n.as1D()).reshape(hE(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:nE(this.embeddingsInitializer),embeddingsRegularizer:wT(this.embeddingsRegularizer),activityRegularizer:wT(this.activityRegularizer),embeddingsConstraint:YS(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}kA.className="Embedding",wv(kA);class CA extends wE{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new CS}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],i=t[r];if(null==s||null==i||s<0||i<0)n.push(null);else if(1===s)n.push(i);else if(1===i)n.push(s);else{if(s!==i)throw new kS("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[hE(e)]),(e=e).length<2)throw new kS(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=LS(t),t.length>1)throw new kS(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map(e=>e.length);this.reshapeRequired=-1!==e.indexOf(null)||1!==LS(r).length}call(e,t){return Iv(()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const r=yN(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=wN(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const i of e){const e=i.rank;if(null==e){const e=i.shape,r=e[0],s=e.slice(1).concat([r]);let a=i.reshape([r].concat(mN(e.slice(1))));a=zw(a,[1,0]),a=a.reshape(s),t.push(a),n=!0}else if(e>1){const r=vN(1,e).concat([0]);t.push(zw(i,r)),n=!0}else t.push(i)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=zw(r.reshape([-1,t]),[1,0]).reshape(n)}else if(s>1){const e=[s-1].concat(vN(0,s-1));r=zw(r,e)}return r}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=LS(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Iv(()=>{if(null==t)return null;if(!Array.isArray(t))throw new kS("`mask` should be an Array");if(!Array.isArray(e))throw new kS("`inputs` should be an Array");if(t.length!==e.length)throw new kS(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:Cx(e,0)))[0];for(let e=1;e<t.length-1;++e)n=zx(n,t[e]);return n})}}class IA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Rv(t,e[n]);return t})}}IA.className="Add",wv(IA);class _A extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ox(t,e[n]);return t})}}_A.className="Multiply",wv(_A);class SA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Rv(t,e[n]);return Ox(1/e.length,t)})}}SA.className="Average",wv(SA);class NA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Wx(t,e[n]);return t})}}NA.className="Maximum",wv(NA);class EA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=jx(t,e[n]);return t})}}EA.className="Minimum",wv(EA);class $A extends CA{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new kS("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if($p(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new kS("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Iv(()=>_N(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new kS("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new kS("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new kS("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new kS(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Iv(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const r=[];for(let i=0;i<e.length;++i)r.push(null==t[i]?ow(e[i]).asType("bool"):t[i].rank<e[i].rank?Cx(t[i],-1):t[i]);const s=rx(r,this.axis);return Fv(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function TA(e,t){for(;e<0;)e+=t;return e}$A.className="Concatenate",wv($A);class AA extends CA{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Ip(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new CS("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new kS(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new kS(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>TA(t,e[n].shape.length)):[TA(this.axes,n.shape.length),TA(this.axes,r.shape.length)],this.normalize&&(n=PE(n,t[0]),r=PE(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new CS("batchDot is not implemented for tensors of 4D or higher rank yet");if(Ip(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),Ip(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new CS("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const i=n;return Iv(()=>{let n,a;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else n=0;if(a=2===e.shape.length&&2===t.shape.length?i[0]===i[1]?e.mul(t).sum(i[0]):e.transpose([1,0]).mul(t).sum(i[1]):e.matMul(t,i[0]!==e.shape.length-1,i[1]===t.shape.length-1),n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);a=a.squeeze(t)}return 1===a.shape.length&&(a=a.expandDims(1)),a})}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[TA(this.axes,e.length),TA(this.axes,t.length)],n}computeOutputShape(e){Ip(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new CS("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}AA.className="Dot",wv(AA);class RA extends wE{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cE(e);return ON(()=>EN(n.shape,0,this.stddev).add(n),()=>n,t.training||!1)})}}RA.className="GaussianNoise",wv(RA);class FA extends wE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cE(e);return this.rate>0&&this.rate<1?ON(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return n.mul(EN(n.shape,1,e))},()=>n,t.training||!1):n})}}FA.className="GaussianDropout",wv(FA);class DA extends wE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||cE(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Iv(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return ON(()=>{const t=cE(e),r=-1.7580993408473766;let s=Tx(fw(n),this.rate);s=xN(s,"float32");const i=((1-this.rate)*(1+this.rate*r**2))**-.5,a=-i*r*this.rate;return t.mul(s).add(s.add(-1).mul(r)).mul(i).add(a)},()=>cE(e),t.training||!1)}return e})}}function OA(e,t,n,r,s,i=.001){let a;if(2===e.rank)a=Jv(e,t,n,r,s,i);else if(3===e.rank)a=ex(e,t,n,r,s,i);else{if(4!==e.rank)throw new CS(`batchNormalization is not implemented for array of rank ${e.rank} yet`);a=tx(e,t,n,r,s,i)}return a}DA.className="AlphaDropout",wv(DA);class MA extends wE{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rE(e.betaInitializer||"zeros"),this.gammaInitializer=rE(e.gammaInitializer||"ones"),this.movingMeanInitializer=rE(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=rE(e.movingVarianceInitializer||"ones"),this.betaConstraint=JS(e.betaConstraint),this.gammaConstraint=JS(e.gammaConstraint),this.betaRegularizer=CT(e.betaRegularizer),this.gammaRegularizer=CT(e.gammaRegularizer)}build(e){e=hE(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new kS(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new gE({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Iv(()=>{const n=null!=t.training&&t.training,r=cE(e),s=r.shape,i=s.length,a=vN(0,i),o=this.axis>=0?this.axis:this.axis+i;a.splice(o,1);const u=_S(1,i);u[o]=s[o];const l=a.slice();l.sort();const c=!$p(l,vN(0,i).slice(0,i-1));if(!n)return(()=>{if(c){const e=this.movingMean.read().reshape(u),t=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,s=this.scale?this.gamma.read().reshape(u):null;return OA(r,e,t,n,s,this.epsilon)}return OA(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(e,t,n,r,s=.001){return $p(r.slice().sort(),vN(0,e.rank-1))?function(e,t,n,r,s=.001){return Iv(()=>{const i=tw(e,r),a=i.mean,o=i.variance;return[OA(e,a,o,n,t,s),a,o]})}(e,t,n,r,s):function(e,t,n,r,s=.001){return Iv(()=>{const i=tw(e,r),a=i.mean,o=i.variance,u=[];for(const t of vN(0,e.rank))-1!==r.indexOf(t)?u.push(1):u.push(e.shape[t]);const l=a.reshape(u),c=o.reshape(u),h=null==t?null:t.reshape(u),d=null==n?null:n.reshape(u);return[OA(e,l,c,d,h,s),a,o]})}(e,t,n,r,s)}(r,this.gamma.read(),this.beta.read(),a,this.epsilon),f=(e,t,n)=>{Iv(()=>{const r=1-n,s=e.read(),i=s.sub(t).mul(r);e.write(s.sub(i))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nE(this.betaInitializer),gammaInitializer:nE(this.gammaInitializer),movingMeanInitializer:nE(this.movingMeanInitializer),movingVarianceInitializer:nE(this.movingVarianceInitializer),betaRegularizer:wT(this.betaRegularizer),gammaRegularizer:wT(this.gammaRegularizer),betaConstraint:YS(this.betaConstraint),gammaConstraint:YS(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}MA.className="BatchNormalization",wv(MA);class LA extends wE{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rE(e.betaInitializer||"zeros"),this.gammaInitializer=rE(e.gammaInitializer||"ones"),this.betaRegularizer=CT(e.betaRegularizer),this.gammaRegularizer=CT(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=hE(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==LS(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(t=>e[t]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,t){const n=cE(e),r=n.shape,s=r.length;return Iv(()=>{let{mean:e,variance:t}=tw(n,this.axis,!0);const i=_S(1,s);for(const n of this.axis)i[n]=r[n];const a=e=>null!=e&&e.shape.length!==s&&this.axis!==[s-1]?e.reshape(i):e;let o=a(this.gamma.read()),u=a(this.beta.read());const l=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(l.push(r[n]),c.push(1)):(l.push(1),c.push(r[n]));return e=e.tile(l),t=t.tile(l),o=o.tile(c),u=u.tile(c),OA(n,e,t,u,o,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nE(this.betaInitializer),gammaInitializer:nE(this.gammaInitializer),betaRegularizer:wT(this.betaRegularizer),gammaRegularizer:wT(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}LA.className="LayerNormalization",wv(LA);class PA extends wE{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new kS(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new kS(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new kS(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new gE({ndim:4})]}computeOutputShape(e){let t,n;return e=hE(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Iv(()=>{return t=cE(e),n=this.padding,r=this.dataFormat,Iv(()=>{if(4!==t.rank)throw new kS(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new kS("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new kS(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],uw(t,e)});var t,n,r})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function zA(e,t,n,r,s,i){return Iv(()=>{let a;aN(s),uN(i),oN(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),e=FT(e,s);const o="same"===r?"same":"valid";return a="max"===i?Vx(e,t,n,o):Zv(e,t,n,o),"channelsFirst"===s&&(a=zw(a,[0,3,1,2])),a})}function VA(e,t,n,r,s,i){return Iv(()=>{let a;aN(s),uN(i),oN(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),e=DT(e,s);const o="same"===r?"same":"valid";return a="max"===i?Bx(e,t,n,o):Yv(e,t,n,o),"channelsFirst"===s&&(a=zw(a,[0,4,1,2,3])),a})}PA.className="ZeroPadding2D",wv(PA);class BA extends wE{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new kS(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(BS(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new kS(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}BS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,oN(this.padding),this.inputSpec=[new gE({ndim:3})]}computeOutputShape(e){const t=AT((e=hE(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Iv(()=>{this.invokeCallHook(e,t),e=wN(cE(e),2);const n=this.poolingFunction(cE(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return $w(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class WA extends BA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return aN(s),oN(r),zA(e,t,n,r,s,"max")}}WA.className="MaxPooling1D",wv(WA);class UA extends BA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return aN(s),oN(r),zA(e,t,n,r,s,"avg")}}UA.className="AveragePooling1D",wv(UA);class qA extends wE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new kS(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];BS(this.poolSize,"poolSize"),BS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aN(this.dataFormat),oN(this.padding),this.inputSpec=[new gE({ndim:4})]}computeOutputShape(e){e=hE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=AT(t,this.poolSize[0],this.padding,this.strides[0]),n=AT(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Iv(()=>(this.invokeCallHook(e,t),this.poolingFunction(cE(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class jA extends qA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return aN(s),oN(r),zA(e,t,n,r,s,"max")}}jA.className="MaxPooling2D",wv(jA);class GA extends qA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return aN(s),oN(r),zA(e,t,n,r,s,"avg")}}GA.className="AveragePooling2D",wv(GA);class HA extends wE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new kS(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];BS(this.poolSize,"poolSize"),BS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aN(this.dataFormat),oN(this.padding),this.inputSpec=[new gE({ndim:5})]}computeOutputShape(e){e=hE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=AT(t,this.poolSize[0],this.padding,this.strides[0]),n=AT(n,this.poolSize[1],this.padding,this.strides[1]),r=AT(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return Iv(()=>(this.invokeCallHook(e,t),this.poolingFunction(cE(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class KA extends HA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return aN(s),oN(r),VA(e,t,n,r,s,"max")}}KA.className="MaxPooling3D",wv(KA);class XA extends HA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return aN(s),oN(r),VA(e,t,n,r,s,"avg")}}XA.className="AveragePooling3D",wv(XA);class ZA extends wE{constructor(e){super(e),this.inputSpec=[new gE({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new CS}}class YA extends ZA{constructor(e){super(e||{})}call(e,t){return Iv(()=>{const t=cE(e);return Ux(t,1)})}}YA.className="GlobalAveragePooling1D",wv(YA);class QA extends ZA{constructor(e){super(e||{})}call(e,t){return Iv(()=>{const t=cE(e);return Dx(t,1)})}}QA.className="GlobalMaxPooling1D",wv(QA);class JA extends wE{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aN(this.dataFormat),this.inputSpec=[new gE({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new CS}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class eR extends JA{call(e,t){return Iv(()=>{const t=cE(e);return Ux(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}eR.className="GlobalAveragePooling2D",wv(eR);class tR extends JA{call(e,t){return Iv(()=>{const t=cE(e);return Dx(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}tR.className="GlobalMaxPooling2D",wv(tR);class nR extends wE{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=LE(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class rR extends nR{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=hE(e)).length<3)throw new kS(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=hE(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t);return[n[0],e[1]].concat(n.slice(1))}call(e,t){return Iv(()=>XT((e,n)=>[cE(this.layer.call(e,t)),[]],e=cE(e),[],!1,null,null,!1,!0)[1])}}rR.className="TimeDistributed",wv(rR);class sR extends nR{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=LE(n),t.goBackwards=!0!==t.goBackwards;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=LE(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,zS(sN,"BidirectionalMergeMode",this.mergeMode),e.weights)throw new CS("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,t)),this.backwardLayer.setWeights(e.slice(t))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),s=s,this.returnState?(r=s.slice(1),t=s[0]):t=s[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):ES(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=KT(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const i=[],a=[];if(null!=n){const e=n.length;if(e%2>0)throw new kS("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);const r=n.map(e=>new gE({shape:e.shape}));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),a.push(...r)}if(null!=r)throw new CS("Support for constants in Bidirectional layers is not implemented yet.");const o=i[0]instanceof bE;for(const u of i)if(u instanceof bE!==o)throw new kS("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(i),r=this.inputSpec.concat(a),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Iv(()=>{const n=t.initialState;let r,s,i,a;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const i=n.slice(0,n.length/2),a=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:i})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:a}))}return this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=gw(s,1)),"concat"===this.mergeMode?a=_N([r,s]):"sum"===this.mergeMode?a=Rv(r,s):"ave"===this.mergeMode?a=Ox(.5,Rv(r,s)):"mul"===this.mergeMode?a=Ox(r,s):null==this.mergeMode&&(a=[r,s]),this.returnState?null==this.mergeMode?a.concat(i):[a].concat(i):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){cN(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),cN(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=LE(t.layer);if(delete t.layer,null!=t.numConstants)throw new CS("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}function iR(e){return new mA(e)}function aR(e,t,n=new Map,r=new Set){if(null==e)return null;if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(cR(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const i in e){const a=aR(e[i],t,n,r);s[i]=a}return r.delete(e),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function oR(e,t=lR){return uR(e,t)}function uR(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(cR(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const i in r){const r=uR(e.map(e=>e[i]),t,n);s[i]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function lR(e){return null===e?null:cR(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function cR(e){return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof Ab))}function hR(e){return function(e,t){return aR(e,t)}(e,dR)}function dR(e){return e instanceof Ab?{value:e.clone(),recurse:!1}:cR(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}sR.className="Bidirectional",wv(sR),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(aA||(aA={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(oA||(oA={}));class pR{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class fR extends pR{constructor(){super(fR.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}fR.INITIAL_CAPACITY=32;class mR{toArray(){var e=this;return bp(function*(){const t=[];let n=yield e.next();for(;!n.done;)t.push(n.value),n=yield e.next();return t})()}toArrayForTest(){var e=this;return bp(function*(){const t=e.prefetch(100),n=[];let r=yield t.next();for(;!r.done;)n.push(r.value),r=yield t.next();return n})()}resolveFully(){var e=this;return bp(function*(){let t=yield e.next();for(;!t.done;)t=yield e.next()})()}resolveWhile(e){var t=this;return bp(function*(){let n=yield t.next(),r=e(n.value);for(;!n.done&&r;)n=yield t.next(),r=e(n.value)})()}handleErrors(e){return new IR(this,e)}filter(e){return new kR(this,e)}map(e){return new CR(this,e)}mapAsync(e){return new _R(this,e)}serialMapAsync(e){return new _R(this,e).serial()}flatmap(e){return new NR(this,e)}forEachAsync(e){var t=this;return bp(function*(){return t.map(e).resolveFully()})()}serialForEach(e){var t=this;return bp(function*(){return t.serialMapAsync(e).resolveWhile(e=>!0===e)})()}rowMajorBatch(e,t=!0){return new wR(this,e,t)}columnMajorBatch(e,t=!0,n=lR){return this.rowMajorBatch(e,t).map(e=>oR(e,n))}concatenate(e,t){return new ER(new gR([this,e]),t)}take(e){return e<0||null==e?this:new xR(this,e)}skip(e){return e<0||null==e?this:new vR(this,e)}prefetch(e){return new $R(this,e)}shuffle(e,t){return new TR(this,e,t)}serial(){return new yR(this)}}class gR extends mR{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var e=this;return bp(function*(){if(e.trav>=e.items.length)return{value:null,done:!0};const t=e.items[e.trav];return e.trav++,{value:hR(t),done:!1}})()}}class bR extends mR{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}next(){var e=this;return bp(function*(){try{return e.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}})()}}class yR extends mR{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){return e.upstream.next()})()}}class vR extends mR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;e.count++<e.maxCount;){const t=yield e.upstream.next();if(t.done)return t;_v(t.value)}return e.upstream.next()})()}}class xR extends mR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var e=this;return bp(function*(){return e.count++>=e.maxCount?{value:null,done:!0}:e.upstream.next()})()}}class wR extends mR{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){const t=[];for(;t.length<e.batchSize;){const n=yield e.upstream.next();if(n.done)return e.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}})()}}class kR extends mR{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;;){const t=yield e.upstream.next();if(t.done||e.predicate(t.value))return t;_v(t.value)}})()}}class CR extends mR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}next(){var e=this;return bp(function*(){const t=yield e.upstream.next();if(t.done)return{value:null,done:!0};const n=qb(t.value),r=e.transform(t.value),s=qb(r);for(const e of n)Ub(e,s)||e.dispose();return{value:r,done:!1}})()}}class IR extends mR{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;;)try{return yield e.upstream.next()}catch(t){if(!e.handler(t))return{value:null,done:!0}}})()}}class _R extends mR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var e=this;return bp(function*(){const t=yield e.upstream.next();if(t.done)return{value:null,done:!0};const n=qb(t.value),r=yield e.transform(t.value),s=qb(r);for(const e of n)Ub(e,s)||e.dispose();return{value:r,done:!1}})()}}class SR extends mR{constructor(){super(),this.outputQueue=new fR,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bp(function*(){for(;0===e.outputQueue.length();)if(!(yield e.pump()))return{value:null,done:!0};return{value:e.outputQueue.shift(),done:!1}})()}}class NR extends SR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var e=this;return bp(function*(){const t=yield e.upstream.next();if(t.done)return!1;const n=qb(t.value),r=e.transform(t.value),s=qb(r);e.outputQueue.pushAll(r);for(const e of n)Ub(e,s)||e.dispose();return!0})()}}class ER extends mR{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var e=this;return bp(function*(){return e.lastRead=e.readFromChain(e.lastRead),e.lastRead})()}readFromChain(e){var t=this;return bp(function*(){if(yield e,null==t.iterator){const e=yield t.moreIterators.next();if(e.done)return{value:null,done:!0};t.iterator=e.value,null!=t.baseErrorHandler&&(t.iterator=t.iterator.handleErrors(t.baseErrorHandler))}const n=yield t.iterator.next();return n.done?(t.iterator=null,t.readFromChain(e)):n})()}}(lA=uA||(uA={}))[lA.FAIL=0]="FAIL",lA[lA.SHORTEST=1]="SHORTEST",lA[lA.LONGEST=2]="LONGEST";class $R extends mR{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new pR(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class TR extends $R{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=cw.alea(n||gb().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return bp(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var e=this;return bp(function*(){for(e.upstreamExhausted||e.refill();!e.buffer.isEmpty();){const t=e.chooseIndex(),n=yield e.buffer.shuffleExcise(t);if(!n.done)return e.refill(),n;e.upstreamExhausted=!0}return{value:null,done:!0}})()}}class AR{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return Ip(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),RR(bp(function*(){return(yield n.iterator()).columnMajorBatch(e,t,FR)}),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,RR(bp(function*(){return(yield t.iterator()).concatenate(yield e.iterator())}),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,RR(bp(function*(){return(yield t.iterator()).filter(t=>Iv(()=>e(t)))}),n)}forEachAsync(e){var t=this;return bp(function*(){return(yield t.iterator()).forEachAsync(e)})()}map(e){const t=this;return RR(bp(function*(){return(yield t.iterator()).map(t=>Iv(()=>e(t)))}),this.size)}mapAsync(e){const t=this;return RR(bp(function*(){return(yield t.iterator()).mapAsync(e)}),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return RR(bp(function*(){return(yield t.iterator()).prefetch(e)}),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,RR(bp(function*(){return n=(r=bp(function*(){return{value:yield t.iterator(),done:!1}}),new bR(r)).take(e),new ER(n,undefined);var n,r}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,RR(bp(function*(){return(yield t.iterator()).skip(e)}),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=cw.alea(t||gb().toString());return RR(bp(function*(){let t=s.int32();return n&&(t+=s.int32()),(yield r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,RR(bp(function*(){return(yield t.iterator()).take(e)}),n)}toArray(){var e=this;return bp(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArray()})()}toArrayForTest(){var e=this;return bp(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArrayForTest()})()}}function RR(e,t=null){return new class extends AR{constructor(){super(...arguments),this.size=t}iterator(){return bp(function*(){return e()})()}}}function FR(e){return null===e?null:null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof Ab||Vp(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ab?Tw(e):ly(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}function DR(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Ip("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}AR.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const OR=zC;class MR extends vp{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new yp(this,kv())}nextDataId(){return MR.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,af().get("IS_NODE")&&gC("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Wp(n[0])){const s=n.map(e=>bb(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}read(e){var t=this;return bp(function*(){return t.readSync(e)})()}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?yC(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>yb(e))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return qy(e.shape,e.dtype,n)}makeOutput(e,t,n){const r=this.write(e,t,n);return kv().makeTensorFromDataId(r,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return bp(function*(){const t=gb();return e(),{kernelMs:gb()-t}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){DR([e],"where");const t=this.readSync(e.dataId);return OR(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function LR(e,t,n){return({inputs:r,attrs:s,backend:i})=>{const{x:a}=r;if(DR(a,e),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,u=o.data.get(a.dataId).values,l=Ep(a.shape),c=n||a.dtype,h=Pp(c,l);for(let e=0;e<l;++e)h[e]=t(u[e],s);return o.makeTensorInfo(a.shape,c,h)}}function PR(e,t,n){return({inputs:r,attrs:s,backend:i})=>{const{x:a}=r;if(DR(a,e),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,u=o.data.get(a.dataId).values,l=n||a.dtype,c=t(u,l,s);return o.makeTensorInfo(a.shape,l,c)}}MR.nextDataId=0,Nv("cpu",()=>new MR,1);const zR=LR(im,e=>e>=0?e:Math.exp(e)-1),VR={kernelName:im,backendName:"cpu",kernelFunc:zR};function BR(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const WR={kernelName:km,backendName:"cpu",kernelFunc:BR};function UR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:i}=r;DR([s],"leakyRelu");const a=Ep(s.shape),o=n.data.get(s.dataId).values,u=Lp("float32",a);for(let l=0;l<o.length;l++)u[l]=o[l]<0?i*o[l]:o[l];return n.makeTensorInfo(s.shape,"float32",u)}const qR={kernelName:Em,backendName:"cpu",kernelFunc:UR};function jR(e){return(t,n,r,s,i)=>{const a=wx(t,n),o=a.length,u=Hp(a),l=Lp(i,Ep(a)),c=t.length,h=n.length,d=Hp(t),p=Hp(n),f=vx(t,a),m=vx(n,a);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<l.length;++g){const t=tf(g,o,u),n=t.slice(-c);f.forEach(e=>n[e]=0);const i=ef(n,c,d),a=t.slice(-h);m.forEach(e=>a[e]=0);const b=ef(a,h,p);l[g]=e(r[i],s[b])}return[l,a]}}const GR=jR((e,t)=>e<0?t*e:e);function HR(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;DR([r,s],"prelu");const i=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,[o,u]=GR(r.shape,s.shape,i,a,r.dtype);return n.makeTensorInfo(u,r.dtype,o)}const KR={kernelName:lg,backendName:"cpu",kernelFunc:HR},XR=LR(fg,e=>Math.max(0,e)),ZR={kernelName:fg,backendName:"cpu",kernelFunc:XR},YR=LR(xg,e=>Math.min(Math.max(0,e),6)),QR={kernelName:xg,backendName:"cpu",kernelFunc:YR},JR=LR(Ag,e=>1/(1+Math.exp(-e))),eF={kernelName:Ag,backendName:"cpu",kernelFunc:JR};function tF(e,t,n,r,s){if("linear"===n)return BR({inputs:{x:t},backend:e});if("relu"===n)return XR({inputs:{x:t},backend:e});if("elu"===n)return zR({inputs:{x:t},backend:e});if("relu6"===n)return YR({inputs:{x:t},backend:e});if("prelu"===n)return HR({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return UR({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return JR({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function nF(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,i=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",i),imag:n.makeTensorInfo(s.shape,"float32",a)},o}const rF={kernelName:Of,backendName:"cpu",kernelFunc:nF};function sF(e,t,n="float32"){if("complex64"===n)return nF({inputs:{real:sF(e,t,"float32"),imag:sF(e,t,"float32")},backend:e});const r=Yp(Ep(t),n);return e.makeTensorInfo(t,n,r)}function iF(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,i=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,i)}const aF={kernelName:dg,backendName:"cpu",kernelFunc:iF};function oF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return BR({inputs:{x:s},backend:n});const e=sF(n,s.shape,s.dtype),t=oF({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=nF({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=iF({inputs:{input:s},backend:n}),t=oF({inputs:{x:e},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(e),t}if(!zp(s.dtype,i)){const e=BR({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i){const e=n.data.get(s.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(s.shape,"int32",t)}if("bool"===i){const e=n.data.get(s.dataId).values,t=mb([0],s.dtype),[r,i]=jR((e,t)=>e!==t?1:0)(s.shape,[],e,t,"bool");return n.makeTensorInfo(i,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const uF={kernelName:Rf,backendName:"cpu",kernelFunc:oF};function lF(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:i,b:a}=n,o=s;DR([i,a],e);const u=o.data.get(i.dataId).values,l=o.data.get(a.dataId).values,c=r||i.dtype,[h,d]=t(i.shape,a.shape,u,l,c);return o.makeTensorInfo(d,c,h)}:({inputs:e,backend:s})=>{const{a:i,b:a}=e,o=s;if("complex64"===i.dtype||"complex64"===a.dtype){const e=oF({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.imag,s=o.data.get(t.complexTensorInfos.real.dataId).values,u=o.data.get(r.dataId).values,l=oF({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),c=o.data.get(l.dataId),h=c.complexTensorInfos.imag,d=o.data.get(c.complexTensorInfos.real.dataId).values,p=o.data.get(h.dataId).values,[f,m,g]=n(i.shape,a.shape,s,u,d,p),b=o.makeTensorInfo(g,"float32",f),y=o.makeTensorInfo(g,"float32",m),v=nF({inputs:{real:b,imag:y},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(l),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(y),v}{const e=o.data.get(i.dataId).values,n=o.data.get(a.dataId).values,s=r||i.dtype,[u,l]=t(i.shape,a.shape,e,n,s);return o.makeTensorInfo(l,s,u)}}}function cF(e){return(t,n,r,s,i,a)=>{const o=wx(t,n),u=Ep(o),l=o.length,c=Hp(o),h=Lp("float32",u),d=Lp("float32",u),p=vx(t,o),f=vx(n,o),m=yC(r,s),g=yC(i,a),b=t.length,y=Hp(t),v=n.length,x=Hp(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=r.real,d[w]=r.imag}else for(let w=0;w<h.length;w++){const t=tf(w,l,c),n=t.slice(-b);p.forEach(e=>n[e]=0);const r=ef(n,b,y),s=t.slice(-v);f.forEach(e=>s[e]=0);const i=ef(s,v,x),a=e(m[2*r],m[2*r+1],g[2*i],g[2*i+1]);h[w]=a.real,d[w]=a.imag}return[h,d,o]}}const hF=jR((e,t)=>e+t),dF=cF((e,t,n,r)=>({real:e+n,imag:t+r})),pF=lF(ff,hF,dF),fF={kernelName:ff,backendName:"cpu",kernelFunc:pF};function mF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:i}=r,a=Ep(s.shape),o=Dp(i,a),u=Ep(o);Ip(a===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.imag;l.complexTensorInfos.real.shape=o,e.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const gF={kernelName:mg,backendName:"cpu",kernelFunc:mF};function bF(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:i}=t,{transposeA:a,transposeB:o}=r;DR([s,i],"matMul");const u=s.shape.length,l=i.shape.length,c=a?s.shape[u-2]:s.shape[u-1],h=o?i.shape[l-1]:i.shape[l-2],d=a?s.shape[u-1]:s.shape[u-2],p=o?i.shape[l-2]:i.shape[l-1],f=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=Ep(f),b=Ep(m);Ip(u>=2&&l>=2&&(g===b||1===g||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);const y=(g>b?s.shape.slice(0,-2):i.shape.slice(0,-2)).concat([d,p]);Ip(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`);const v=o?[b,p,h]:[b,h,p],x=mF({inputs:{x:s},backend:n,attrs:{shape:a?[g,c,d]:[g,d,c]}}),w=mF({inputs:{x:i},backend:n,attrs:{shape:v}}),k=a?x.shape[1]:x.shape[2],C=a?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],_=Math.max(g,b),S=n.data.get(x.dataId).values,N=n.data.get(w.dataId).values,E=Hp(x.shape),$=Hp(w.shape),[T,A,R]=a?[E[0],1,E[1]]:[E[0],E[1],1],[F,D,O]=o?[1,$[1],$[0]]:[$[1],1,$[0]],M=C*I,L=qy([_,C,I],x.dtype),P=L.values,z=n.blockSize;for(let V=0;V<_;V++)for(let e=0;e<C;e+=z)for(let t=0;t<I;t+=z)for(let n=0;n<k;n+=z){const r=Math.min(e+z,C),s=Math.min(t+z,I),i=Math.min(n+z,k);for(let a=e;a<r;a++)for(let e=t;e<s;e++){let t=0;for(let r=n;r<i;r++){const n=Math.min(V,g-1)*T,s=Math.min(V,b-1)*O;t+=S[n+a*A+r*R]*N[r*F+e*D+s]}P[V*M+(a*I+e)]+=t}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,L.dtype,L.values)}const yF={kernelName:$f,backendName:"cpu",kernelFunc:bF},vF={kernelName:rb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:i,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=bF({inputs:{a:s,b:i},attrs:{transposeA:u,transposeB:l},backend:n}),a&&(p=pF({inputs:{a:d,b:a},backend:n}),m.push(d),d=p),c&&(f=tF(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function xF(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const wF={kernelName:hf,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;DR(t,"abs");let r=new Float32Array(Ep(t.shape));return r=xF(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,"float32")}},kF=LR(df,e=>Math.acos(e)),CF={kernelName:df,backendName:"cpu",kernelFunc:kF},IF=LR(pf,e=>Math.acosh(e)),_F={kernelName:pf,backendName:"cpu",kernelFunc:IF},SF={kernelName:mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;DR(t,"addN");const s=r.map(e=>n.data.get(e.dataId).values),i=qy(r[0].shape,r[0].dtype),a=i.values;for(let o=0;o<r.length;o++){const e=s[o];for(let t=0;t<a.length;t++)a[t]+=e[t]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function NF(e,t,n,r,s){const i=t.length,a=Ep(t),o=Hp(t),u=Hp(s),l=Lp(n,Ep(s));for(let c=0;c<a;++c){const t=tf(c,i,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];l[ef(n,i,u)]=e[c]}return l}function EF(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:i}=n;DR(s,"transpose");const a=new Array(s.shape.length);for(let u=0;u<a.length;u++)a[u]=s.shape[i[u]];const o=NF(r.data.get(s.dataId).values,s.shape,s.dtype,i,a);return{dataId:r.write(o,a,s.dtype),shape:a,dtype:s.dtype}}const $F={kernelName:Zg,backendName:"cpu",kernelFunc:EF},TF={kernelName:gf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;DR(s,"all");const o=Op(i,s.shape);let u=o;const l=Yx(u,s.shape.length);let c=s;null!=l&&(c=EF({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Jx(u.length,s.shape.length)),Zx("all",u,c.shape.length);const[h,d]=Kx(c.shape,u),p=Ep(d),f=Yp(Ep(h),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const e=mF({inputs:{x:g},backend:n,attrs:{shape:Xx(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},AF={kernelName:bf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;DR(s,"any");const o=Op(i,s.shape);let u=o;const l=Yx(u,s.shape.length);let c=s;null!=l&&(c=EF({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Jx(u.length,s.shape.length)),Zx("any",u,c.shape.length);const[h,d]=Kx(c.shape,u),p=Ep(d),f=Yp(Ep(h),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const e=mF({inputs:{x:g},backend:n,attrs:{shape:Xx(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},RF={kernelName:yf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i}=r;DR(s,"argMax");let a=Op(i,s.shape);const o=Yx(a,s.shape.length);let u=s;const l=[];null!=o&&(u=EF({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),a=Jx(a.length,u.shape.length)),a=[a[0]],Zx("argMax",a,u.shape.length);const[c,h]=Kx(u.shape,a),d=Yp(Ep(c),"int32"),p=Ep(h),f=n.data.get(u.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s>t&&(t=s,n=r)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},FF={kernelName:vf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i}=r;DR(s,"argMin");let a=Op(i,s.shape);const o=Yx(a,s.shape.length);let u=s;const l=[];null!=o&&(u=EF({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),a=Jx(a.length,u.shape.length)),a=[a[0]],Zx("argMin",a,u.shape.length);const[c,h]=Kx(u.shape,a),d=Yp(Ep(c),"int32"),p=Ep(h),f=n.data.get(u.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s<t&&(t=s,n=r)}d[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},DF=LR(xf,e=>Math.asin(e)),OF={kernelName:xf,backendName:"cpu",kernelFunc:DF},MF=LR(wf,e=>Math.asinh(e)),LF={kernelName:wf,backendName:"cpu",kernelFunc:MF},PF=LR(kf,e=>Math.atan(e)),zF={kernelName:kf,backendName:"cpu",kernelFunc:PF},VF=jR((e,t)=>Math.atan2(e,t)),BF=lF(If,VF),WF={kernelName:If,backendName:"cpu",kernelFunc:BF},UF=LR(Cf,e=>Math.atanh(e)),qF={kernelName:Cf,backendName:"cpu",kernelFunc:UF};function jF(e,t,n,r,s,i){const a=s.strideHeight,o=s.strideWidth,u=s.dilationHeight,l=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=qy(s.outShape,n),g=m.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){const t=x*b,n=x*r[0];for(let m=0;m<s.inChannels;++m)for(let b=0;b<s.outHeight;++b){const x=b*a-d,w=Math.max(0,x),k=Math.min(s.inHeight,c+x),C=t+b*y;for(let t=0;t<s.outWidth;++t){const a=t*o-p,c=Math.max(0,a),d=Math.min(s.inWidth,h+a);let b=f,y=0,x=0;for(let t=w;t<k;t+=u){const s=n+t*r[1];for(let t=c;t<d;t+=l){const n=e[s+t*r[2]+m];"max"===i&&n>b?b=n:"avg"===i&&(y+=n,x++)}if(isNaN(b))break}g[C+t*v+m]="avg"===i?y/x:b}}}return m}function GF(e,t,n,r,s=!1,i=!1){const a=qy(r.outShape,"int32"),o=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=qy(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let b=n;for(;b<0;)b+=l;const y=Math.min(r.inHeight,h+n);for(let o=0;o<r.outWidth;++o){const h=o*u-f;let p=h;for(;p<0;)p+=c;const v=Math.min(r.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=l){const a=t-n;for(let n=p;n<v;n+=c){const o=n-h,u=m.get(g,t,n,e);u>x&&(x=u,w=s?i?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:a*d+o)}}a.set(w,g,t,o,e)}}return a}function HF(e,t,n,r,s,i){const a=s.strideDepth,o=s.strideHeight,u=s.strideWidth,l=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,b=s.padInfo.left,y="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=qy(s.outShape,n),x=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let _=0;_<s.batchSize;++_){const t=_*w,n=_*r[0];for(let v=0;v<s.inChannels;++v)for(let w=0;w<s.outDepth;++w){const _=w*a-m;let S=_;for(;S<0;)S+=l;const N=Math.min(s.inDepth,d+_),E=t+w*k;for(let t=0;t<s.outHeight;++t){const a=t*o-g;let d=a;for(;d<0;)d+=c;const m=Math.min(s.inHeight,p+a),w=E+t*C;for(let t=0;t<s.outWidth;++t){const a=t*u-b;let o=a;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+a),g=w+t*I;let k=y,C=0,_=0;for(let t=S;t<N;t+=l){const s=n+t*r[1];for(let t=d;t<m;t+=c){const n=s+t*r[2];for(let t=o;t<p;t+=h){const s=e[n+t*r[3]+v];if("max"===i&&s>k?k=s:"avg"===i&&(C+=s,_++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===i?C/_:k}}}}return v}const KF={kernelName:_f,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;DR(s,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=r;Ip(Hv(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const l=Lv(s.shape,i,a,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))c=BR({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Hp(s.shape),r=jF(e,0,s.dtype,t,l,"avg");c=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return c}},XF={kernelName:Nf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:l}=r;DR(s,"avgPool3d");const c=Pv(s.shape,i,a,1,o,u,l),h=HF(n.data.get(s.dataId).values,0,s.dtype,Hp(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},ZF={kernelName:Ef,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=r;DR([s,i],"avgPool3DGrad");const c=Pv(i.shape,a,o,1,u,l),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,C=x-1-c.padInfo.front,I=k-1-c.padInfo.left,_=w-1-c.padInfo.top,S=qy(i.shape,"float32"),N=1/(f*m*g),E=n.bufferSync(s);for(let $=0;$<c.batchSize;++$)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-C,i=n-_,a=r-I;let o=0;for(let t=0;t<x;t+=b){const n=(s+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const r=(i+t)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const s=(a+t)/p;s<0||s>=c.outWidth||Math.floor(s)!==s||(o+=E.get($,n,r,s,e))}}}S.set(o*N,$,t,n,r,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},YF={kernelName:Sf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,a=i;DR([s,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=Lv(a.shape,o,u,1,l),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,y=c.effectiveFilterWidth,v=y-1-c.padInfo.left,x=b-1-c.padInfo.top,w=qy(a.shape,"float32"),k=1/(p*f),C=n.data.get(s.dataId).values,I=qy(s.shape,"float32",C);for(let _=0;_<c.batchSize;++_)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-x,s=n-v;let i=0;for(let t=0;t<b;t+=m){const n=(r+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const r=(s+t)/d;r<0||r>=c.outWidth||Math.floor(r)!==r||(i+=I.get(_,n,r,e))}}w.set(i*k,_,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},QF={kernelName:bm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:i,offset:a,mean:o,variance:u}=t;Ip(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ip(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ip(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),DR([s,o,u,i,a],"batchNorm");let{varianceEpsilon:l}=r;null==l&&(l=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(u.dataId).values,p=i?n.data.get(i.dataId).values:new Float32Array([1]),f=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,b=p.length,y=d.length,v=h.length;let x=0,w=0,k=0,C=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-h[w++])*p[k++]/Math.sqrt(d[C++]+l),x>=g&&(x=0),w>=v&&(w=0),k>=b&&(k=0),C>=y&&(C=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function JF(e,t,n,r,s){const i=mv(r,t,n),a=Ep(n),o=Hp(r);if(i){const n=gv(t,o);return"string"===s?e.slice(n,n+a):e.subarray(n,n+a)}const u=qy(r,s,"string"===s?LC(e):e),l=qy(n,s);for(let c=0;c<l.size;++c){const e=l.indexToLoc(c),n=e.map((e,n)=>e+t[n]);l.set(u.get(...n),...e)}return"string"===s?PC(l.values):l.values}function eD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:i,size:a}=r;DR(s,"slice");const[o,u]=bv(s,i,a);rv(s,o,u);const l=JF(n.data.get(s.dataId).values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,l)}const tD={kernelName:Ng,backendName:"cpu",kernelFunc:eD},nD={kernelName:Tf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:i,crops:a}=r;DR([s],"batchToSpaceND");const o=i.reduce((e,t)=>e*t),u=Jk(s.shape,i,o),l=eC(u.length,i.length),c=tC(s.shape,i,o),h=nC(a,i.length),d=rC(c,a,i.length),p=mF({inputs:{x:s},backend:n,attrs:{shape:u}}),f=EF({inputs:{x:p},backend:n,attrs:{perm:l}}),m=mF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=eD({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function rD(e,t,n,r,s){const i=Ep(r),a=Yp(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(a[n]+=i>0?t[o]:1)}return a}function sD(e,t,n,r=!1){const s=e.shape[0],i=e.shape[1],a=qy([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<i;s++){const i=e.get(o,s);if(i<0)throw new Error("Input x must be non-negative!");i>=n||a.set(r?1:t.size>0?a.get(o,i)+t.get(o,s):a.get(o,i)+1,o,i)}return a}const iD={kernelName:Af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:i}=t,{size:a}=r,o=rD(n.data.get(s.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,o)}};function aD(e){return(t,n,r)=>{const s=Lp(n,t.length);for(let i=0;i<t.length;++i)s[i]=e(t[i],r);return s}}const oD=aD(e=>Math.ceil(e)),uD=PR(Ff,oD),lD={kernelName:Ff,backendName:"cpu",kernelFunc:uD},cD=LR(Df,(e,t)=>e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e),hD={kernelName:Df,backendName:"cpu",kernelFunc:cD},dD={kernelName:Mf,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Ep(t.shape)),s=n.data.get(t.dataId),i=s.complexTensorInfos.imag,a=n.data.get(s.complexTensorInfos.real.dataId).values,o=n.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],o[u]);return n.makeOutput(r,t.shape,"float32")}};function pD(e,t,n,r){const s=Pp(n,Ep(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{const n=Ep(e.shape);s.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const i="string"===n?LC(e.vals):e.vals;let a=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=i[a++]}r+=e.shape[1]})}return s}function fD(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,i=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,i)}const mD={kernelName:Im,backendName:"cpu",kernelFunc:fD};function gD(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,i=Op(s,t[0].shape)[0];let a=Xk(t.map(e=>e.shape),i);if(0===Ep(a))return n.makeTensorInfo(a,t[0].dtype,[]);const o=t.filter(e=>Ep(e.shape)>0);if(1===o.length)return BR({inputs:{x:o[0]},backend:n});if(Kk(o.map(e=>e.shape),i),"complex64"===o[0].dtype){const e=o.map(e=>iF({inputs:{input:e},backend:n})),t=o.map(e=>fD({inputs:{input:e},backend:n})),r=gD({inputs:e,backend:n,attrs:{axis:i}}),s=gD({inputs:t,backend:n,attrs:{axis:i}}),a=nF({inputs:{real:r,imag:s},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),a}const u=o.map(e=>{const t=Ep(e.shape.slice(i));return mF({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),l=u.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));a=Xk(u.map(e=>e.shape),1);const c=pD(l,a,t[0].dtype,1===u[0].shape[0]),h=Xk(o.map(e=>e.shape),i),d=n.makeTensorInfo(h,t[0].dtype,c);return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}const bD={kernelName:Lf,backendName:"cpu",kernelFunc:gD};function yD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:a,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r;DR([s,i],"conv2d");const h=Kv(u),d=zv(s.shape,i.shape,a,l,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,x=new Nb(d.outShape,s.dtype),w=Hp(s.shape),k=Hp(i.shape),C=w[0],I=v?w[1]:w[2],_=v?w[2]:1,S=v?1:w[1],N=x.strides[0],E=v?x.strides[1]:x.strides[2],$=v?x.strides[2]:1,T=v?1:x.strides[1],A=n.data.get(s.dataId).values,R=n.data.get(i.dataId).values,F=x.values;for(let D=0;D<d.batchSize;++D){const e=D*C,t=D*N;for(let n=0;n<d.outHeight;++n){const r=t+n*E,s=n*d.strideHeight-y;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=d.inHeight)continue;const i=t*k[0],a=e+n*I;for(let e=0;e<d.outWidth;++e){const t=r+e*$,n=e*d.strideWidth-b;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=d.inWidth)continue;const s=a+r*_;let o=i+e*k[1];for(let e=0;e<d.inChannels;++e){const n=A[s+e*S];for(let e=0;e<d.outChannels;++e)F[t+e*T]+=n*R[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,F)}const vD={kernelName:Pf,backendName:"cpu",kernelFunc:yD},xD={kernelName:zf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:a,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r;DR([s,i],"conv2dBackpropFilter");const h=Kv(u),d=zv(s.shape,c,a,1,o,l,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,b="channelsLast"===d.dataFormat,y=new Nb(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(i.dataId).values,C=new Nb(s.shape,s.dtype,w),I=new Nb(i.shape,i.dtype,k);for(let _=0;_<m;++_){const e=Math.max(0,Math.ceil((x-_)/p)),t=Math.min(d.outHeight,(d.inHeight+x-_)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),s=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let i=0;i<d.inChannels;++i)for(let a=0;a<d.outChannels;++a){let o=0;for(let u=0;u<d.batchSize;++u)for(let l=e;l<t;++l){const e=_+l*p-x;for(let t=r;t<s;++t){const r=n+t*f-v;o+=b?C.get(u,e,r,i)*I.get(u,l,t,a):C.get(u,i,e,r)*I.get(u,a,l,t)}}y.set(o,_,n,i,a)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},wD={kernelName:Vf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{inputShape:a,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r;DR([s,i],"conv2dBackpropInput");const h=Hp(i.shape),d=Hp(s.shape);let p=Kv(l);const f=zv(a,i.shape,o,1,u,c,!1,p),m=new Nb(f.inShape,"float32"),g=m.values,b=n.data.get(s.dataId).values,y=n.data.get(i.dataId).values,[v,x,w]=h,{batchSize:k,filterHeight:C,filterWidth:I,inChannels:_,inHeight:S,inWidth:N,outChannels:E,outHeight:$,outWidth:T,strideHeight:A,strideWidth:R}=f;p=f.dataFormat;const F=C-1-f.padInfo.top,D=I-1-f.padInfo.left,O="channelsLast"===p,M=m.strides[0],L=O?m.strides[1]:m.strides[2],P=O?m.strides[2]:1,z=O?1:m.strides[1],V=d[0],B=O?d[1]:d[2],W=O?d[2]:1,U=O?1:d[1];for(let q=0;q<k;++q)for(let e=0;e<_;++e)for(let t=0;t<S;++t){const n=t-F,r=Math.max(0,Math.ceil(n/A)),s=Math.min($,(C+n)/A);for(let i=0;i<N;++i){const a=i-D,o=Math.max(0,Math.ceil(a/R)),u=Math.min(T,(I+a)/R);let l=0;for(let t=r;t<s;++t){const r=t*A-n;for(let n=o;n<u;++n){const s=V*q+B*t+W*n,i=v*(C-1-r)+x*(I-1-(n*R-a))+w*e;for(let e=0;e<E;++e)l+=b[s+U*e]*y[i+e]}}g[M*q+L*t+P*i+z*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},kD={kernelName:Bf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:a,pad:o,dilations:u}=r;DR([s,i],"conv3d");const l=Vv(s.shape,i.shape,a,u,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,v=g.top,x=new Nb(l.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(i.dataId).values,C=x.values,I=Hp(s.shape),_=Hp(i.shape);for(let S=0;S<l.batchSize;++S){const e=S*I[0],t=S*x.strides[0];for(let n=0;n<l.outDepth;++n){const r=t+n*x.strides[1],s=n*l.strideDepth-b;for(let t=0;t<c;++t){const n=s+t*p;if(n<0||n>=l.inDepth)continue;const i=t*_[0],a=e+n*I[1];for(let e=0;e<l.outHeight;++e){const t=r+e*x.strides[2],n=e*l.strideHeight-v;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=l.inHeight)continue;const s=i+e*_[1],o=a+r*I[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,r=e*l.strideWidth-y;for(let e=0;e<d;++e){const t=r+e*m;if(t<0||t>=l.inWidth)continue;const i=o+t*l.inChannels;let a=s+e*_[2];for(let e=0;e<l.inChannels;++e){const t=w[i+e];for(let e=0;e<l.outChannels;++e)C[n+e]+=t*k[a+e];a+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},CD={kernelName:Wf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:a,pad:o,filterShape:u}=r;DR([s,i],"conv3dBackpropFilterV2");const l=Hp(s.shape),c=Hp(i.shape),h=Vv(s.shape,u,a,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,b=h.filterWidth,y=new Nb(h.filterShape,"float32"),v=y.values,[x,w,k,C]=y.strides,I=n.data.get(i.dataId).values,[_,S,N,E]=c,$=n.data.get(s.dataId).values,[T,A,R,F]=l,D=h.padInfo.front,O=h.padInfo.left,M=h.padInfo.top;for(let L=0;L<m;++L){const e=Math.max(0,Math.ceil((D-L)/d)),t=Math.min(h.outDepth,(h.inDepth+D-L)/d),n=L*x;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((M-r)/p)),i=Math.min(h.outHeight,(h.inHeight+M-r)/p),a=r*w+n;for(let n=0;n<b;++n){const o=Math.max(0,Math.ceil((O-n)/f)),u=Math.min(h.outWidth,(h.inWidth+O-n)/f),l=n*k+a;for(let a=0;a<h.inChannels;++a){const c=a*C+l;for(let l=0;l<h.outChannels;++l){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*T,g=c*_;for(let c=e;c<t;++c){const e=(L+c*d-D)*A+h,t=c*S+g;for(let c=s;c<i;++c){const s=(r+c*p-M)*R+e,i=c*N+t;for(let e=o;e<u;++e)m+=$[(n+e*f-O)*F+s+a]*I[e*E+i+l]}}}v[c+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},ID={kernelName:Uf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{pad:a,strides:o,inputShape:u}=r;DR([s],"conv3dBackpropInputV2");const l=Hp(s.shape),c=Hp(i.shape),h=Vv(u,i.shape,o,1,a),d=new Nb(h.inShape,"float32"),p=d.values,[f,m,g,b]=d.strides,y=n.data.get(s.dataId).values,[v,x,w,k]=l,C=n.data.get(i.dataId).values,[I,_,S,N]=c,{batchSize:E,filterDepth:$,filterHeight:T,filterWidth:A,inChannels:R,inDepth:F,inHeight:D,inWidth:O,outChannels:M,outDepth:L,outHeight:P,outWidth:z,strideDepth:V,strideHeight:B,strideWidth:W}=h,U=$-1-h.padInfo.front,q=T-1-h.padInfo.top,j=A-1-h.padInfo.left;for(let G=0;G<E;++G)for(let e=0;e<R;++e)for(let t=0;t<F;++t){const n=t-U,r=Math.max(0,Math.ceil(n/V)),s=Math.min(L,($+n)/V);for(let i=0;i<D;++i){const a=i-q,o=Math.max(0,Math.ceil(a/B)),u=Math.min(P,(T+a)/B);for(let l=0;l<O;++l){const c=l-j,h=Math.max(0,Math.ceil(c/W)),d=Math.min(z,(A+c)/W);let E=0;for(let t=r;t<s;++t){const r=t*V-n;for(let n=o;n<u;++n){const s=n*B-a;for(let i=h;i<d;++i){const a=v*G+x*t+w*n+k*i,o=I*($-1-r)+_*(T-1-s)+S*(A-1-(i*W-c))+N*e;for(let e=0;e<M;++e)E+=y[a+e]*C[o+e]}}}p[f*G+m*t+g*i+b*l+e]=E}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},_D=LR(qf,e=>Math.cos(e)),SD={kernelName:qf,backendName:"cpu",kernelFunc:_D},ND=LR(jf,e=>Math.cosh(e)),ED={kernelName:jf,backendName:"cpu",kernelFunc:ND},$D={kernelName:Hf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:i,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:l}=r,[c,h,d,p]=s.shape,f=i.shape[0],[m,g]=o,b=qy([f,m,g,p],"float32"),y=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,x=n.data.get(s.dataId).values,w=Hp(s.shape),k=Hp(b.shape);for(let C=0;C<f;C++){const e=4*C,t=y[e],n=y[e+1],r=y[e+2],s=y[e+3],i=v[C];if(i>=c)continue;const a=m>1?(r-t)*(h-1)/(m-1):0,o=g>1?(s-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(h-1)+c*a:.5*(t+r)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++)b.values[e+t*k[2]+c*k[1]+C*k[0]]=l;else if("bilinear"===u){const t=Math.floor(e),r=Math.ceil(e),a=e-t;for(let e=0;e<g;e++){const u=g>1?n*(d-1)+e*o:.5*(n+s)*(d-1);if(u<0||u>d-1){for(let t=0;t<p;t++)b.values[t+e*k[2]+c*k[1]+C*k[0]]=l;continue}const h=Math.floor(u),f=Math.ceil(u),m=u-h;for(let n=0;n<p;n++){let s=n+h*w[2]+t*w[1]+i*w[0];const o=x[s];s=n+f*w[2]+t*w[1]+i*w[0];const u=x[s];s=n+h*w[2]+r*w[1]+i*w[0];const l=x[s];s=n+f*w[2]+r*w[1]+i*w[0];const d=x[s],p=o+(u-o)*m;s=n+e*k[2]+c*k[1]+C*k[0],b.values[s]=p+(l+(d-l)*m-p)*a}}}else for(let t=0;t<g;++t){const r=g>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(r<0||r>d-1){for(let e=0;e<p;e++)b.values[e+t*k[2]+c*k[1]+C*k[0]]=l;continue}const a=Math.round(r),u=Math.round(e);for(let e=0;e<p;e++)b.values[e+t*k[2]+c*k[1]+C*k[0]]=x[e+a*w[2]+u*w[1]+i*w[0]]}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},TD={kernelName:Gf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,exclusive:a,reverse:o}=r;DR(s,"cumsum");const u=Yx([i],s.shape.length);let l=s;null!=u&&(l=EF({inputs:{x:s},backend:n,attrs:{perm:u}}));const c=Jx(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=Vb(l.dtype,"int32"),d=Yp(Ep(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)d[t]=a?0:p[t];else{const n=m(b,e-1);d[t]=a?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=u){const e=EF({inputs:{x:g},backend:n,attrs:{perm:Qx(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}},AD={kernelName:Kf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:i}=t,{size:a,binaryOutput:o}=r;if(1===s.shape.length){const e=rD(n.data.get(s.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,e)}if(2===s.shape.length){const e=sD(n.bufferSync(s),n.bufferSync(i),a,o);return n.makeTensorInfo(e.shape,i.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},RD={kernelName:Xf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:i,dataFormat:a}=r;Ip("NHWC"===a,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),Ip(i>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`);const o=s.shape[0],u=s.shape[1],l=s.shape[2],c=s.shape[3],h=u*i,d=l*i,p=c/(i*i),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let b=0;b<o;++b)for(let e=0;e<h;++e){const t=Math.floor(e/i),n=e%i;for(let e=0;e<d;++e){const r=Math.floor(e/i),s=(n*i+e%i)*p;for(let e=0;e<p;++e)m[g++]=f[e+s+c*(r+l*(t+u*b))]}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function FD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:a,pad:o,dilations:u,dimRoundingMode:l}=r;DR([s,i],"depthwiseConv2DNative");const c=Hp(s.shape),h=Hp(i.shape);let d=u;null==d&&(d=[1,1]),Ip(Hv(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=zv(s.shape,i.shape,a,d,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,v=y.left,x=y.top,w=p.outChannels/p.inChannels,k=new Nb(p.outShape,s.dtype),C=n.data.get(s.dataId).values,I=n.data.get(i.dataId).values,_=k.values;for(let S=0;S<p.batchSize;++S){const e=S*c[0],t=S*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],s=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const i=t*h[0],a=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*b;if(r<0||r>=p.inWidth)continue;const s=a+r*p.inChannels;let o=t,u=i+e*h[1];for(let e=0;e<p.inChannels;++e){const t=C[s+e];for(let e=0;e<w;++e)_[o+e]+=t*I[u+e];o+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const DD={kernelName:Zf,backendName:"cpu",kernelFunc:FD},OD={kernelName:Yf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r;DR([s,i],"depthwiseConv2dNativeBackpropFilter");const h=zv(s.shape,c,a,o,u,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Nb(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,x=n.data.get(s.dataId).values,w=new Nb(s.shape,s.dtype,x),k=n.data.get(i.dataId).values,C=new Nb(i.shape,i.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((y-I)/d)),t=Math.min(h.outHeight,(h.inHeight+y-I)/d);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((b-n)/p)),s=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let i=0;i<h.outChannels;++i){const a=Math.trunc(i/v),o=i%v;let u=0;for(let l=0;l<h.batchSize;++l)for(let o=e;o<t;++o){const e=I+o*d-y;for(let t=r;t<s;++t)u+=w.get(l,e,n+t*p-b,a)*C.get(l,o,t,i)}g.set(u,I,n,a,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},MD={kernelName:Qf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r;DR([s,i],"depthwiseConv2DNativeBackpropInput");const h=Hp(s.shape),d=Hp(i.shape),p=zv(c,i.shape,a,o,u,l,!0),f=new Nb(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,v=n.data.get(s.dataId).values,[x,w,k]=h,C=n.data.get(i.dataId).values,[I,_,S]=d,{batchSize:N,filterHeight:E,filterWidth:$,inChannels:T,inHeight:A,inWidth:R,outChannels:F,outHeight:D,outWidth:O,strideHeight:M,strideWidth:L}=p,P=E-1-p.padInfo.top,z=$-1-p.padInfo.left,V=F/T;for(let B=0;B<N;++B)for(let e=0;e<T;++e)for(let t=0;t<A;++t){const n=t-P,r=Math.max(0,Math.ceil(n/M)),s=Math.min(D,(E+n)/M);for(let i=0;i<R;++i){const a=i-z,o=Math.max(0,Math.ceil(a/L)),u=Math.min(O,($+a)/L);let l=0;for(let t=r;t<s;++t){const r=t*M-n;for(let n=o;n<u;++n){const s=x*B+w*t+k*n,i=I*(E-1-r)+_*($-1-(n*L-a))+S*e;for(let t=0;t<V;++t)l+=v[s+(e*V+t)]*C[i+t]}}m[g*B+b*t+y*i+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},LD={kernelName:Jf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Ep(r.shape),i=n.data.get(r.dataId).values,a=qy([s,s],r.dtype),o=a.values;for(let l=0;l<i.length;l++)o[l*s+l]=i[l];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,a.dtype,a.values)}},PD={kernelName:em,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:i,pad:a,dilations:o}=n,u=t,l=u.data.get(r.dataId).values,c=r.shape.length,h=u.data.get(s.dataId).values,d=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:C,dilationHeight:I,dilationWidth:_,outShape:S}=Mv(r.shape,s.shape,i,a,"NHWC",o),N=Ep(S),E=S.length,$=Pp(r.dtype,N);for(let T=0;T<p;++T)for(let e=0;e<b;++e){const t=e*x-v.top;for(let n=0;n<y;++n){const i=n*w-v.left;for(let a=0;a<g;++a){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<C;++t){const u=i+t*_;if(u>=0&&u<m){const i=ef([T,n,u,a],c,Hp(r.shape)),p=ef([e,t,a],d,Hp(s.shape)),f=l[i]+h[p];f>o&&(o=f)}}}$[ef([T,e,n,a],E,Hp(S))]=o}}}return{dataId:u.write(mb($,r.dtype),S,r.dtype),shape:S,dtype:r.dtype}}},zD={kernelName:nm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:i}=e,{strides:a,pad:o,dilations:u}=n,l=t,c=Xp(r.shape,l.data.get(r.dataId).values),h=Xp(s.shape,l.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:C,dilationWidth:I,outShape:_}=Mv(r.shape,s.shape,a,o,"NHWC",u);Ip(i.rank===_.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${_.length}, but got ${i.rank}`);const S=Xp(_,l.data.get(i.dataId).values),N=Qp(s.shape,s.dtype);for(let E=0;E<d;++E)for(let e=0;e<g;++e){const t=e*v-y.top;for(let n=0;n<b;++n){const r=n*x-y.left;for(let s=0;s<m;++s){let i=Number.MIN_SAFE_INTEGER,a=0,o=0;for(let e=0;e<w;++e){const n=t+e*C;if(n>=0&&n<p)for(let t=0;t<k;++t){const u=r+t*I;if(u>=0&&u<f){const r=c[E][n][u][s]+h[e][t][s];r>i&&(i=r,a=e,o=t)}}}N[a][o][s]+=S[E][e][n][s]}}}return{dataId:l.write(mb(N,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},VD={kernelName:tm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:i}=e,{strides:a,pad:o,dilations:u}=n,l=t,c=Xp(r.shape,l.data.get(r.dataId).values),h=Xp(s.shape,l.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:C,dilationWidth:I,outShape:_}=Mv(r.shape,s.shape,a,o,"NHWC",u);Ip(i.rank===_.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${_.length}, but got ${i.rank}`);const S=Xp(_,l.data.get(i.dataId).values),N=Qp(r.shape,r.dtype);for(let E=0;E<d;++E)for(let e=0;e<g;++e){const t=e*v-y.top;for(let n=0;n<b;++n){const r=n*x-y.left;for(let s=0;s<m;++s){let i=Number.MIN_SAFE_INTEGER,a=t<0?0:t,o=r<0?0:r;for(let e=0;e<w;++e){const n=t+e*C;if(n>=0&&n<p)for(let t=0;t<k;++t){const u=r+t*I;if(u>=0&&u<f){const r=c[E][n][u][s]+h[e][t][s];r>i&&(i=r,a=n,o=u)}}}N[E][a][o][s]+=S[E][e][n][s]}}}return{dataId:l.write(mb(N,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},BD=jR((e,t)=>e*t),WD=cF((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),UD=lF(Qm,BD,WD),qD={kernelName:Qm,backendName:"cpu",kernelFunc:UD};function jD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;let o;DR(s,"sum"),o="bool"===s.dtype?oF({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):BR({inputs:{x:s},backend:n});const u=o.shape.length,l=Op(i,o.shape),c=Yx(l,u);let h=l,d=o;null!=c&&(d=EF({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Jx(h.length,u)),Zx("sum",h,d.shape.length);const[p,f]=Kx(d.shape,h);let m=sF(n,p,Vb(d.dtype,"int32"));const g=Ep(f),b=n.data.get(m.dataId).values,y=n.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[v]=t}if(a){const e=m;m=mF({inputs:{x:m},backend:n,attrs:{shape:Xx(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const GD={kernelName:Dg,backendName:"cpu",kernelFunc:jD},HD={kernelName:sm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,i=t,{allDims:a,summedDims:o,idDims:u}=NC(s,i.length);$C(a.length,u,i);const{path:l,steps:c}=TC(o,u),h=c.length;let d=null,p=a.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=EC(p,u[e]);let s;AC(t)?s=i[e]:(s=EF({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),f.push(s));const a=s.shape.slice();for(let e=0;e<r.length;++e)a.splice(r[e],0,1);$p(s.shape,a)||(s=mF({inputs:{x:s},backend:n,attrs:{shape:a}}),f.push(s)),null===d?d=s:(d=UD({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=jD({inputs:{x:d},backend:n,attrs:{axis:l[m]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},KD={kernelName:am,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;DR([r,s],"eluGrad");const i=new Float32Array(Ep(s.shape)),a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let u=0;u<a.length;++u){const e=a[u];i[u]=e>=1?o[u]:o[u]*(e+1)}return n.makeTensorInfo(s.shape,"float32",i)}},XD=jR((e,t)=>e===t?1:0),ZD=lF(um,XD,null,"bool"),YD={kernelName:um,backendName:"cpu",kernelFunc:ZD},QD=cC,JD=hC,eO=dC,tO=pC,nO=fC,rO=mC,sO=LR(om,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+QD*n);return t*(1-((((rO*r+nO)*r+tO)*r+eO)*r+JD)*r*Math.exp(-n*n))}),iO={kernelName:om,backendName:"cpu",kernelFunc:sO},aO=aD(e=>Math.exp(e)),oO=PR(lm,aO),uO={kernelName:lm,backendName:"cpu",kernelFunc:oO};function lO(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:i}=r,a=s.shape.length,o=s.shape.slice();let u=i;return i<0&&(Ip(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+i+1),o.splice(u,0,1),mF({inputs:{x:s},backend:n,attrs:{shape:o}})}const cO={kernelName:cm,backendName:"cpu",kernelFunc:lO},hO=aD(e=>Math.expm1(e)),dO=PR(hm,hO),pO={kernelName:hm,backendName:"cpu",kernelFunc:dO},fO=jR((e,t)=>e/t),mO=lF(rm,fO),gO={kernelName:rm,backendName:"cpu",kernelFunc:mO},bO=jR((e,t)=>e-t),yO=cF((e,t,n,r)=>({real:e-n,imag:t-r})),vO=lF(qg,bO,yO),xO={kernelName:qg,backendName:"cpu",kernelFunc:vO};function wO(e,t,n){const r=e.shape,s=r[0],i=r[1],a=n.data.get(e.dataId),o=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,l=[s,i],c=Ep(l),h=Lp("float32",c),d=Lp("float32",c);for(let g=0;g<s;g++){const e=eD({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,i]}}),r=eD({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,i]}}),s=nF({inputs:{real:e,imag:r},backend:n}),{real:a,imag:l}=kO(s,t,n),c=yC(a,l);for(let t=0;t<i;t++){const e=kC(c,t);h[g*i+t]=e.real,d[g*i+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",d),m=nF({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function kO(e,t,n){const r=Ep(e.shape),s=n.data.get(e.dataId),i=n.data.get(s.complexTensorInfos.real.dataId).values,a=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0==((o=r)&o-1)){const s=CO(i,a,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),i=n.makeTensorInfo([],"float32",fb(r,"float32")),a=BR({inputs:{x:i},backend:n}),u=gO.kernelFunc({inputs:{a:e,b:i},backend:n}),l=gO.kernelFunc({inputs:{a:t,b:a},backend:n}),c=n.data.get(u.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),{real:c,imag:h}}return s}return vC(function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let i=0,a=0;for(let r=0;r<t;r++){const o=_C(s*r,t,n),u=kC(e,r);i+=u.real*o.real-u.imag*o.imag,a+=u.real*o.imag+u.imag*o.real}n&&(i/=t,a/=t),CC(r,i,a,s)}return r}(yC(i,a),r,t));var o}function CO(e,t,n,r,s){if(1===n)return{real:e,imag:t};const i=yC(e,t),a=n/2,o=xC(i),u=o.real,l=o.imag,c=[u.length],h=s.makeTensorInfo(c,"float32",u),d=s.makeTensorInfo(c,"float32",l),p=nF({inputs:{real:h,imag:d},backend:s}),f=wC(i),m=f.real,g=f.imag,b=[m.length],y=s.makeTensorInfo(b,"float32",m),v=s.makeTensorInfo(b,"float32",g),x=nF({inputs:{real:y,imag:v},backend:s}),w=CO(u,l,a,r,s),k=w.real,C=w.imag,I=[k.length],_=s.makeTensorInfo(I,"float32",k),S=s.makeTensorInfo(I,"float32",C),N=nF({inputs:{real:_,imag:S},backend:s}),E=CO(m,g,a,r,s),$=E.real,T=E.imag,A=[$.length],R=s.makeTensorInfo(A,"float32",$),F=s.makeTensorInfo(A,"float32",T),D=nF({inputs:{real:R,imag:F},backend:s}),O=IC(n,r),M=[O.real.length],L=s.makeTensorInfo(M,"float32",O.real),P=s.makeTensorInfo(M,"float32",O.imag),z=nF({inputs:{real:L,imag:P},backend:s}),V=UD({inputs:{a:z,b:D},backend:s}),B=pF({inputs:{a:N,b:V},backend:s}),W=vO({inputs:{a:N,b:V},backend:s}),U=iF({inputs:{input:B},backend:s}),q=iF({inputs:{input:W},backend:s}),j=fD({inputs:{input:B},backend:s}),G=fD({inputs:{input:W},backend:s}),H=gD({inputs:[U,q],backend:s,attrs:{axis:0}}),K=gD({inputs:[j,G],backend:s,attrs:{axis:0}}),X=s.data.get(H.dataId).values,Z=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(K),{real:X,imag:Z}}const IO={kernelName:dm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Ep(r.shape),i=r.shape[r.shape.length-1],a=mF({inputs:{x:r},backend:n,attrs:{shape:[s/i,i]}}),o=wO(a,!1,n),u=mF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),u}};function _O(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:i}=n,a=i||qp(s),o=Pp(a,Ep(r));return function(e,t,n){e.fill(t)}(o,s),t.makeTensorInfo(r,a,o)}const SO={kernelName:pm,backendName:"cpu",kernelFunc:_O},NO={kernelName:fm,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=Lp(n.dtype,Ep(n.shape)),[i,a,o,u]=n.shape,l=r.data.get(n.dataId).values;for(let c=0;c<i;c++){const e=c*o*a*u;for(let t=0;t<a;t++){const n=t*(o*u);for(let r=0;r<o;r++){const a=r*u;for(let c=0;c<u;c++){const h=Math.round(o-[i,t,r,c][2]),d=e+n+a+c;let p=l[d];h>=0&&h<o&&(p=l[e+n+h*u+c]),s[d]=p}}}}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},EO=aD(e=>Math.floor(e)),$O=PR(mm,EO),TO={kernelName:mm,backendName:"cpu",kernelFunc:$O},AO=jR((e,t)=>Math.floor(e/t)),RO=lF(gm,AO,null,"int32"),FO={kernelName:gm,backendName:"cpu",kernelFunc:RO},DO={kernelName:sb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=yD({inputs:{x:s,filter:i},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const e=m;m=pF({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=tF(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}},OO={kernelName:ib,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=FD({inputs:{x:s,filter:i},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const e=m;m=pF({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=tF(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}},MO={kernelName:vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,i=Ep(r.shape),a=s.shape,o=a[a.length-1],[u,l,c,h]=sC(r,s);if(0===l)return n.makeTensorInfo(u,r.dtype,[]);const d=qy([l,c],r.dtype),p=n.data.get(s.dataId).values,f=n.data.get(r.dataId).values;for(let m=0;m<l;m++){const e=[];let t=0;for(let n=0;n<o;n++){const r=p[m*o+n];t+=r*h[n],e.push(r)}if(t<0||t>=i/c)throw new Error(`Invalid indices: ${e} does not index into ${r.shape}`);for(let n=0;n<c;n++)d.values[m*c+n]=f[t*c+n]}return n.makeTensorInfo(u,d.dtype,d.values)}};function LO(e,t,n){const r=qy(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),i=t.locToIndex([n[0],n[2]]);n[2]=t.values[i];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}const PO={kernelName:ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:i}=t,{axis:a,batchDims:o}=r;DR([s,i],"gatherV2");let u=o;null==o&&(u=0);const l=Ep(i.shape),c=MC(s,i,Op(a,s.shape)[0],u),h=mF({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=mF({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}}),p=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize],f=n.bufferSync(d),m=LO(n.bufferSync(h),f,p);return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},zO=jR((e,t)=>e>t?1:0),VO=lF(xm,zO,null,"bool"),BO={kernelName:xm,backendName:"cpu",kernelFunc:VO},WO=jR((e,t)=>e>=t?1:0),UO=lF(wm,WO,null,"bool"),qO={kernelName:wm,backendName:"cpu",kernelFunc:UO},jO={kernelName:Cm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Ep(r.shape),i=r.shape[r.shape.length-1],a=mF({inputs:{x:r},backend:n,attrs:{shape:[s/i,i]}}),o=wO(a,!0,n),u=mF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),u}},GO=LR(_m,e=>Number.isFinite(e)?1:0,"bool"),HO={kernelName:_m,backendName:"cpu",kernelFunc:GO},KO=LR(Sm,e=>Math.abs(e)===1/0?1:0,"bool"),XO={kernelName:Sm,backendName:"cpu",kernelFunc:KO},ZO=LR(Nm,e=>Number.isNaN(e)?1:0,"bool"),YO={kernelName:Nm,backendName:"cpu",kernelFunc:ZO},QO=jR((e,t)=>e<t?1:0),JO=lF($m,QO,null,"bool"),eM={kernelName:$m,backendName:"cpu",kernelFunc:JO},tM=jR((e,t)=>e<=t?1:0),nM=lF(Tm,tM,null,"bool"),rM={kernelName:Tm,backendName:"cpu",kernelFunc:nM};function sM(e,t,n){const r=(t-e)/(n-1),s=Yp(n,"float32");s[0]=e;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const iM={kernelName:Am,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:i}=n,a=sM(r,s,i);return t.makeTensorInfo([a.length],"float32",a)}},aM=aD(e=>Math.log(e)),oM=PR(Rm,aM),uM={kernelName:Rm,backendName:"cpu",kernelFunc:oM},lM=LR(Fm,e=>Math.log1p(e)),cM={kernelName:Fm,backendName:"cpu",kernelFunc:lM},hM=jR((e,t)=>e&&t),dM=lF(Dm,hM,null,"bool"),pM={kernelName:Dm,backendName:"cpu",kernelFunc:dM},fM=LR(Om,e=>e?0:1,"bool"),mM={kernelName:Om,backendName:"cpu",kernelFunc:fM},gM=jR((e,t)=>e||t),bM=lF(Mm,gM,null,"bool"),yM={kernelName:Mm,backendName:"cpu",kernelFunc:bM},vM={kernelName:Lm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:i,bias:a,alpha:o,beta:u}=r;DR(s,"LRN");const l=s.shape[3],c=l-1,h=n.data.get(s.dataId).values,d=Ep(s.shape),p=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-i);const r=e-t+Math.min(t+i,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(a+o*e,-u);p[m]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}},xM={kernelName:Pm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:i,dy:a}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r;DR(a,"LRNGrad");const h=Ep(a.shape),d=a.shape[3],p=n.data.get(a.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(i.dataId).values,g=new Float32Array(h),b=h;for(let y=0;y<b;y++){const e=y%d,t=y-e+Math.max(0,e-o),n=y-e+Math.min(d,e+o+1);let r=0;for(let s=t;s<n;s++)r+=Math.pow(f[s],2);r=l*r+u;for(let s=t;s<n;s++){let e=-2*l*c*f[s]*m[y]/r;y===s&&(e+=Math.pow(r,-c)),e*=p[y],g[s]+=e}}return n.makeTensorInfo(a.shape,s.dtype,g)}};function wM(e,t,n,r){const s=Lp(r,Ep(n));for(let i=0;i<s.length;++i){const n=i*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];t>r&&(r=t)}s[i]=r}return s}function kM(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:i,keepDims:a}=r,o=n;let u=s.shape;const l=u.length,c=Op(i,u);let h=c;const d=Yx(h,l);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=u[d[t]];p=NF(p,u,s.dtype,d,e),h=Jx(h.length,l),u=e}DR(s,"max"),Zx("max",h,l);const[f,m]=Kx(u,h),g=wM(p,Ep(m),f,s.dtype),b=o.write(g,f,s.dtype);let y=f;return a&&(y=Xx(f,c)),{dataId:b,shape:y,dtype:s.dtype}}const CM={kernelName:zm,backendName:"cpu",kernelFunc:kM},IM=jR((e,t)=>Math.max(e,t)),_M=lF(Vm,IM),SM={kernelName:Vm,backendName:"cpu",kernelFunc:_M},NM={kernelName:Bm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;DR(s,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=r;Ip(Hv(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const l=Lv(s.shape,i,a,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))c=BR({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Hp(s.shape),r=jF(e,0,s.dtype,t,l,"max");c=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return c}},EM={kernelName:Um,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:l}=r;DR(s,"maxPool3d");const c=Pv(s.shape,i,a,1,o,u,l),h=HF(n.data.get(s.dataId).values,0,s.dtype,Hp(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},$M={kernelName:qm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=r;DR([s,i],"maxPool3DGrad");const c=Pv(i.shape,a,o,1,u,l),h=function(e,t){const n=qy(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,i=t.strideWidth,a=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*r-d;let v=y;for(;v<0;)v+=a;const x=Math.min(t.inDepth,l+y);for(let r=0;r<t.outHeight;++r){const l=r*s-p;let d=l;for(;d<0;)d+=o;const w=Math.min(t.inHeight,c+l);for(let s=0;s<t.outWidth;++s){const p=s*i-f;let k=p;for(;k<0;)k+=u;const C=Math.min(t.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,_=-1;for(let t=v;t<x;t+=a){const n=t-y;for(let r=d;r<w;r+=o){const s=r-l;for(let i=k;i<C;i+=u){const a=i-p,o=e.get(m,t,r,i,g);o>=I&&(I=o,_=n*c*h+s*c+a)}}}n.set(_,m,b,r,s,g)}}}return n}(n.bufferSync(i),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,y=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=y-1-c.padInfo.front,k=x-1-c.padInfo.left,C=v-1-c.padInfo.top,I=qy(i.shape,"float32"),_=n.bufferSync(s);for(let S=0;S<c.batchSize;++S)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-w,i=n-C,a=r-k;let o=0;for(let t=0;t<y;t+=m){const n=(s+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const s=(i+r)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let i=0;i<x;i+=b){const u=(a+i)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const l=y*v*x-1-h.get(S,n,s,u,e)===t*v*x+r*x+i?1:0;0!==l&&(o+=_.get(S,n,s,u,e)*l)}}}I.set(o,S,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},TM={kernelName:Wm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i,output:a}=t,o=i;DR([i,a],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,d=Lv(o.shape,u,l,1,c,h),p=n.data.get(o.dataId).values,f=qy(d.outShape,o.dtype,GF(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,k=v-1-d.padInfo.top,C=qy(o.shape,"float32"),I=n.data.get(s.dataId).values,_=qy(s.shape,"float32",I);for(let S=0;S<d.batchSize;++S)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const r=t-k,s=n-w;let i=0;for(let t=0;t<v;t+=b){const n=(r+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=y){const a=(s+r)/g;if(a<0||a>=d.outWidth||Math.floor(a)!==a)continue;const o=v*x-1-f.get(S,n,a,e)===t*x+r?1:0;0!==o&&(i+=_.get(S,n,a,e)*o)}}C.set(i,S,t,n,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},AM={kernelName:jm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:i,pad:a,includeBatchInIndex:o}=t,u=n;DR(r,"MaxPoolWithArgmax");const l=u.data.get(r.dataId).values,c=Lv(r.shape,s,i,[1,1],a),[h,d]=function(e,t,n,r,s){const i=jF(e,0,n,Hp(t),s,"max"),a=GF(e,t,n,s,!0,r);return[i.values,a.values]}(l,r.shape,r.dtype,o,c),p=u.write(h,c.outShape,r.dtype),f=u.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},RM={kernelName:Gm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r,o=Op(i,s.shape),u=Ep(Kx(s.shape,o)[1]),l=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));l.push(c);const h=oF({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});l.push(h);const d=mO({inputs:{a:h,b:c},backend:n});l.push(d);const p=jD({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:a}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}},FM={kernelName:Hm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;DR(s,"min");const o=Op(i,s.shape);let u=o;const l=Yx(u,s.shape.length);let c=s;null!=l&&(c=EF({inputs:{x:s},backend:n,attrs:{perm:l}}),u=Jx(u.length,s.shape.length)),Zx("min",u,c.shape.length);const[h,d]=Kx(c.shape,u),p=Ep(d),f=Yp(Ep(h),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];r<t&&(t=r)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const e=mF({inputs:{x:g},backend:n,attrs:{shape:Xx(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},DM=jR((e,t)=>Math.min(e,t)),OM=lF(Km,DM),MM={kernelName:Km,backendName:"cpu",kernelFunc:OM},LM={kernelName:Xm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:i,mode:a}=r;DR(s,"mirrorPad");const o=i.map((e,t)=>e[0]+s.shape[t]+e[1]),u=i.map(e=>e[0]),l=i.map((e,t)=>e[0]+s.shape[t]),c="reflect"===a?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=Hp(s.shape),f=Ep(o),m=o.length,g=Hp(o),b=Lp(s.dtype,f);for(let y=0;y<f;y++){let e=tf(y,m,g);for(let n=0;n<m;n++)e[n]<u[n]?e[n]=2*u[n]-e[n]-c:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+c);e=e.map((e,t)=>e-u[t]);const t=ef(e,d,p);b[y]=h[t]}return{dataId:n.write(b,o,s.dtype),shape:o,dtype:s.dtype}}},PM=jR((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),zM=lF(Zm,PM),VM={kernelName:Zm,backendName:"cpu",kernelFunc:zM};function BM(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:i}=r,a=s.shape.length;let o=i;if(-1===o&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const u=Op([o],s.shape),l=kM({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=Xx(l.shape,u),h=mF({inputs:{x:l},backend:n,attrs:{shape:c}}),d=vO({inputs:{a:s,b:h},backend:n}),p=oO({inputs:{x:d},backend:n}),f=jD({inputs:{x:p},backend:n,attrs:{axis:u,keepDims:!1}}),m=mF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=mO({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const WM={kernelName:Lg,backendName:"cpu",kernelFunc:BM},UM={kernelName:Ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:i,seed:a,normalized:o}=r;DR(s,"multinomial");const u=o?s:BM({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],h=n.data.get(u.dataId).values,d=[l,i],p=Yp(Ep(d),"int32");for(let f=0;f<l;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=cw.alea(a.toString()),r=f*i;for(let s=0;s<i;++s){const e=n();p[r+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(d,"int32",p)}};function qM(e,t,n){const r=fb(-1,n);return BD([],t,r,e,n)}const jM={kernelName:Jm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;DR(r,"neg");const s=n.data.get(r.dataId).values,[i,a]=qM(s,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}},GM=hk,HM={kernelName:tg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=r;DR(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=GM(l,c,a,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},KM=dk,XM={kernelName:ng,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r;DR(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=KM(c,h,a,o,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},ZM=pk,YM={kernelName:rg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r;DR(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,d=a,p=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=ZM(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},QM=jR((e,t)=>e!==t?1:0),JM=lF(eg,QM,null,"bool"),eL={kernelName:eg,backendName:"cpu",kernelFunc:JM},tL={kernelName:ig,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:i,onValue:a,offValue:o}=r;DR(s,"oneHot");const u=Ep(s.shape),l=new Float32Array(u*i);l.fill(o);const c=n.data.get(s.dataId).values;for(let h=0;h<u;++h)c[h]>=0&&c[h]<i&&(l[h*i+c[h]]=a);return n.makeTensorInfo([...s.shape,i],"int32",l)}};function nL(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=iF({inputs:{input:r},backend:n}),t=nL({inputs:{x:e},backend:n}),s=fD({inputs:{input:r},backend:n}),i=nL({inputs:{x:s},backend:n}),a=nF({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),a}return _O({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const rL={kernelName:eb,backendName:"cpu",kernelFunc:nL},sL={kernelName:sg,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=iF({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),i=fD({inputs:{input:s},backend:r}),a=nL({inputs:{x:i},backend:r}),o=nF({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}return _O({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function iL(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return lO({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const i=t[0].shape,a=t[0].dtype;t.forEach(e=>{_p(i,e.shape,"All tensors passed to stack must have matching shapes"),Ip(a===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=gD({inputs:t.map(e=>{const t=lO({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}const aL={kernelName:ag,backendName:"cpu",kernelFunc:iL},oL={kernelName:og,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:i,constantValue:a}=r;DR(s,"pad");const o=i.map((e,t)=>e[0]+s.shape[t]+e[1]),u=i.map(e=>e[0]),l=n.data.get(s.dataId).values,c=Ep(s.shape),h=s.shape.length,d=Hp(s.shape),p=Ep(o),f=o.length,m=Hp(o),g=Lp(s.dtype,p);0!==a&&g.fill(a);for(let b=0;b<c;b++)g[ef(tf(b,h,d).map((e,t)=>e+u[t]),f,m)]=l[b];return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},uL=jR((e,t)=>Math.pow(e,t)),lL=lF(ug,uL),cL={kernelName:ug,backendName:"cpu",kernelFunc:lL};function hL(e,t,n,r){const[s,i]=Kx(e,r),a=Vb(t,"int32"),o=Yp(Ep(s),a),u=Ep(i);for(let l=0;l<o.length;++l){const e=l*u;let t=1;for(let r=0;r<u;++r)t*=n[e+r];o[l]=t}return{outVals:o,outShape:s,outDtype:a}}const dL={kernelName:cg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;DR(s,"prod");const o=s.shape.length,u=Op(i,s.shape),l=Yx(u,o);let c=u,h=s;const d=[];null!=l&&(h=EF({inputs:{x:s},backend:n,attrs:{perm:l}}),d.push(h),c=Jx(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=hL(h.shape,h.dtype,p,c);let b=m;return a&&(b=Xx(m,u)),d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(b,g,f)}};function pL(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Yp(0,r);const s=Yp(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let i=1;i<s.length;i++)s[i]=s[i-1]+n;return s}const fL={kernelName:hg,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:i,step:a}=n,o=pL(r,s,a,i);return t.makeTensorInfo([o.length],i,o)}},mL=LR(pg,e=>1/e),gL={kernelName:pg,backendName:"cpu",kernelFunc:mL},bL={kernelName:yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,halfPixelCenters:a,size:o}=r;DR(s,"resizeBilinear");const u=Hp(s.shape),[l,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Ep([h,l,c,f])),b=[i&&l>1?d-1:d,i&&c>1?p-1:p],y=[i&&l>1?l-1:l,i&&c>1?c-1:c];let v=0;const x=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<h;k++)for(let e=0;e<l;e++){let t;t=a?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(d-1,Math.ceil(t)),i=k*u[0]+n*u[1],o=k*u[0]+s*u[1];for(let e=0;e<c;e++){let t;t=a?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,l=Math.min(p-1,Math.ceil(t)),c=i+n*u[2],h=o+n*u[2],d=i+l*u[2],b=o+l*u[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],i=t+(m[d+e]-t)*s;g[v++]=i+(n+(m[b+e]-n)*s-i)*r}}}return n.makeTensorInfo([h,l,c,f],"float32",g)}},yL={kernelName:vg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:i}=t,{alignCorners:a}=r;DR([i,s],"resizeBilinearGrad");const o=Hp(s.shape),[u,l,c,h]=s.shape,[,d,p]=i.shape,f=new Float32Array(u*l*c*h),m=[a&&d>1?l-1:l,a&&p>1?c-1:c],g=[a&&d>1?d-1:d,a&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],v=n.data.get(i.dataId).values;let x=0;for(let w=0;w<u;w++){const e=w*o[0];for(let t=0;t<d;t++){const n=t*b,r=Math.floor(n),s=Math.min(Math.ceil(n),l-1),i=e+r*o[1],a=e+s*o[1],u=n-r,d=1-u;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,l=1-s,p=i+n*o[2],m=i+r*o[2],g=a+n*o[2],b=a+r*o[2],w=d*l,k=d*s,C=u*l,I=u*s;for(let e=0;e<h;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*C,f[b+e]+=t*I}}}}return n.makeTensorInfo([u,c,l,h],"float32",f)}},vL={kernelName:gg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,halfPixelCenters:a,size:o}=r;DR(s,"resizeNearestNeighbor");const u=Hp(s.shape),[l,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*l*c*f),b=[i&&l>1?d-1:d,i&&c>1?p-1:p],y=[i&&l>1?l-1:l,i&&c>1?c-1:c],v=b[0]/y[0],x=b[1]/y[1];let w=0;for(let k=0;k<h;k++){const e=k*u[0];for(let t=0;t<l;t++){const n=a?v*(t+.5):v*t;let r=Math.min(d-1,i?Math.round(n):Math.floor(n));a&&(r=Math.max(0,r));const s=e+r*u[1];for(let e=0;e<c;e++){const t=a?x*(e+.5):x*e;let n=Math.min(p-1,i?Math.round(t):Math.floor(t));a&&(n=Math.max(0,n));const r=s+n*u[2];for(let e=0;e<f;e++)g[w++]=m[r+e]}}}return n.makeTensorInfo([h,l,c,f],s.dtype,g)}},xL={kernelName:bg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:i}=t,{alignCorners:a}=r;DR([i,s],"resizeNearestNeighborGrad");const o=Hp(s.shape),u=Hp(i.shape),[l,c,h,d]=s.shape,[,p,f]=i.shape,m=new Float32Array(l*c*h*d),g=n.data.get(i.dataId).values,b=[a&&p>1?c-1:c,a&&f>1?h-1:h],y=[a&&p>1?p-1:p,a&&f>1?f-1:f],v=b[0]/y[0],x=b[1]/y[1],w=1/v,k=1/x,C=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let _=0;_<l;_++){const e=_*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),s=Math.floor(r-C/2);for(let i=0;i<h;i++){const r=n+i*o[2],l=Math.floor(i*k),b=Math.floor(l-I/2);for(let n=0;n<d;n++){let o=0;for(let r=0;r<C;r++){const l=r+s;if(l<0||l>=p)continue;const d=e+l*u[1],m=l*v;if(t===Math.min(c-1,a?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+b;if(t<0||t>=f)continue;const r=d+t*u[2],s=t*x;i===Math.min(h-1,a?Math.round(s):Math.floor(s))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}},wL={kernelName:wg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:i}=r;DR(s,"reverse");const a=s.shape.length,o=Op(i,s.shape);if(0===a)return BR({inputs:{x:s},backend:n});const u=new Nb(s.shape,s.dtype),l=n.bufferSync(s);for(let c=0;c<u.size;c++){const e=u.indexToLoc(c),t=e.slice();o.forEach(e=>t[e]=s.shape[e]-1-t[e]),u.set(l.get(...t),...e)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},kL={kernelName:nb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:i,center:a}=t,o=n,u=Lp(r.dtype,Ep(r.shape)),[l,c,h,d]=r.shape,[p,f]=Qk(a,c,h),m=Math.sin(s),g=Math.cos(s),b=o.data.get(r.dataId).values;for(let y=0;y<l;y++){const e=y*h*c*d;for(let t=0;t<c;t++){const n=t*(h*d);for(let r=0;r<h;r++){const s=r*d;for(let a=0;a<d;a++){const o=[l,t,r,a],y=o[2],v=o[1];let x=(y-p)*g-(v-f)*m,w=(y-p)*m+(v-f)*g;x=Math.round(x+p),w=Math.round(w+f);let k=i;"number"!=typeof i&&(k=3===a?255:i[a]),x>=0&&x<h&&w>=0&&w<c&&(k=b[e+w*(h*d)+x*d+a]),u[e+n+s+a]=k}}}}return{dataId:o.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},CL=LR(kg,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),IL={kernelName:kg,backendName:"cpu",kernelFunc:CL},_L=aD(e=>1/Math.sqrt(e)),SL=PR(Cg,_L),NL={kernelName:Cg,backendName:"cpu",kernelFunc:SL};function EL(e,t,n,r,s,i,a,o,u,l){const c=[r/s,s],h=e.values,d=t.values;if(0===r)return qy(n,t.dtype);const p=qy(c,t.dtype);p.values.fill(u);for(let f=0;f<i;f++){const e=[];let i=0;for(let t=0;t<a;t++){const n=h[f*a+t];e.push(n),i+=n*o[t]}if(i<0||i>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)l?p.values[i*s+n]+=d[f*s+n]:p.values[i*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}const $L={kernelName:Ig,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:i}=t,{shape:a}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=oC(0,s,a),d=EL(n.bufferSync(s),n.bufferSync(i),a,h,l,u,o,c,0,!0);return n.makeTensorInfo(a,d.dtype,d.values)}},TL={kernelName:_g,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:i}=t;DR([r,s,i],"select");const a=r.shape.length,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,c=Vb(s.dtype,i.dtype),h=Yp(Ep(s.shape),c);let d=0;const p=0===a||a>1||1===s.shape.length?1:Ep(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)h[d++]=1===o[f]?u[f]:l[f];return n.makeTensorInfo(s.shape,c,h)}},AL=uC,RL=lC,FL=LR(Sg,e=>e>=0?RL*e:AL*(Math.exp(e)-1)),DL={kernelName:Sg,backendName:"cpu",kernelFunc:FL},OL=LR(Tg,e=>e<0?-1:e>0?1:0),ML={kernelName:Tg,backendName:"cpu",kernelFunc:OL},LL=LR(Eg,e=>Math.sin(e)),PL={kernelName:Eg,backendName:"cpu",kernelFunc:LL},zL=LR($g,e=>Math.sinh(e)),VL={kernelName:$g,backendName:"cpu",kernelFunc:zL},BL=Math.log(1.1920928955078125e-7)+2,WL=LR(Rg,e=>{const t=e>-BL,n=e<BL,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s}),UL={kernelName:Rg,backendName:"cpu",kernelFunc:WL},qL={kernelName:Og,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:i,paddings:a}=r;DR([s],"spaceToBatchND");const o=Ep(i),u=[[0,0]];u.push(...a);for(let g=1+i.length;g<s.shape.length;++g)u.push([0,0]);const l=oL.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),c=Jk(l.shape,i,o,!1),h=eC(c.length,i.length,!1),d=tC(l.shape,i,o,!1),p=mF({inputs:{x:l},backend:n,attrs:{shape:c}}),f=EF({inputs:{x:p},backend:n,attrs:{perm:h}}),m=mF({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function jL(e,t,n,r,s,i,a){const o=t[0],u=i[0],l=new Array(u),c=new Array(o),h=t[1];if(0===u){if(0!==o)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${o}`);return[Pp(n,0),[0,h],Pp(s,0),l,c]}let d=!0,p=0;const f=new Array(u).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(`indices(${g}, 0) is invalid: ${t} < 0`);if(t>=u)throw new Error(`indices(${g}, 0) is invalid: ${t} >= ${u}`);++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<u;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,l,c]}{const t=f[u-1],i=Pp(n,t*h),d=Pp(s,t),p=new Array(u).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=(0===t?0:f[t-1])+p[t];p[t]++;for(let r=0;r<h;++r)i[s*h+r]=e[n*h+r];d[s]=r[n],c[n]=s}for(let e=0;e<u;++e)if(0===p[e]){const t=0===e?0:f[e-1];i[t*h+0]=e;for(let e=1;e<h;++e)i[t*h+e]=0;d[t]=a}return[i,[o,h],d,l,c]}}const GL={kernelName:Pg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:i,defaultValue:a}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values[0],[h,d,p,f,m]=jL(o,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function HL(e,t,n,r,s){const i=Ep(r),a=t[0],o=s.length,u=[];let l=1,c=-1;for(let g=0;g<o;++g){const e=s[g];if(-1===e){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,u.push(1)}else{if(e<0)throw new Error(`size ${g} must be non-negative, not ${e}`);l*=e,u.push(e)}}if(-1!==c){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(i/l);if(l*e!==i)throw new Error(`Input to reshape is a SparseTensor with ${i}\n          dense values, but the requested shape requires a multiple of ${l}. inputShape=${r} outputShape= ${u}`);u[c]=e}const h=Ep(u);if(h!==i)throw new Error(`Input to reshape is a tensor with ${i} dense values, but the requested shape has ${h}. inputShape=${r} outputShape=${u}`);const d=r.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}const f=[];if(o>0){f[o-1]=1;for(let e=o-2;e>=0;--e)f[e]=f[e+1]*u[e+1]}const m=Pp(n,a*o);for(let g=0;g<a;++g){let t=0;for(let n=0;n<d;++n)t+=e[g*d+n]*p[n];for(let e=0;e<o;++e)m[g*o+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[a,o],u]}const KL={kernelName:zg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,u=Array.from(n.data.get(i.dataId).values),[l,c,h]=HL(o,r.shape,r.dtype,a,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},XL={kernelName:Vg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:i,defaultValue:a}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=oC(0,s,o),p=EL(n.bufferSync(s),n.bufferSync(i),o,d,c,l,u,h,n.data.get(a.dataId).values[0],!1);return n.makeTensorInfo(o,p.dtype,p.values)}},ZL={kernelName:Mg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:i,axis:a}=r,o=Op(a,s.shape)[0],u=FC(s,i,o),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(e=>{const t=[...c];t[o]=e;const r=eD({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,r})}},YL=LR(Fg,e=>Math.sqrt(e)),QL={kernelName:Fg,backendName:"cpu",kernelFunc:YL},JL={kernelName:Wg,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;DR(n,"square");const s=r.data.get(n.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const e=s[a];i[a]=e*e}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},eP=jR((e,t)=>{const n=e-t;return n*n}),tP=lF(Bg,eP),nP={kernelName:Bg,backendName:"cpu",kernelFunc:tP},rP=LR(tb,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),sP={kernelName:tb,backendName:"cpu",kernelFunc:rP};function iP(e,t,n,r){const s=qy(e,t.dtype);for(let i=0;i<s.size;i++){const e=s.indexToLoc(i),a=new Array(e.length);for(let t=0;t<a.length;t++)a[t]=e[t]*n[t]+r[t];s.set(t.get(...a),...e)}return s}const aP={kernelName:Ug,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:i,end:a,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;DR(s,"stridedSlice");const{nonStrided:p,$begin:f,$strides:m,size:g,newShape:b,outShape:y}=yv(s.shape,i,a,o,u,l,c,h,d),v=mF({inputs:{x:s},backend:n,attrs:{shape:b}});let x;if(p){const e=eD({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});x=mF({inputs:{x:e},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(e)}else if(y.some(e=>0===e))x=n.makeTensorInfo(y,s.dtype,[]);else{const e=iP(y,n.bufferSync(v),m,f);x=n.makeTensorInfo(e.shape,e.dtype,e.values)}const w=mF({inputs:{x:x},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),w}},oP=LR(jg,e=>Math.tan(e)),uP={kernelName:jg,backendName:"cpu",kernelFunc:oP},lP=LR(Gg,e=>Math.tanh(e));function cP(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=qy(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const i=e.locToIndex(n);r.values[s]=e.values[i]}return r}function hP(e,t,n,r,s){const i=t[t.length-1],[a,o]=[e.length/i,i],u=Lp(n,a*r),l=Lp("int32",a*r);for(let h=0;h<a;h++){const t=h*o,n=e.subarray(t,t+o),s=[];for(let e=0;e<n.length;e++)s.push({value:n[e],index:e});s.sort((e,t)=>t.value-e.value);const i=h*r,a=u.subarray(i,i+r),c=l.subarray(i,i+r);for(let e=0;e<r;e++)a[e]=s[e].value,c[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[qy(c,n,u),qy(c,"int32",l)]}function dP(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return kp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;return n<0?t<=1?n=0:n+=t*(Math.trunc(-n/(t-1))+1):n>t-1&&(t<=1?n=0:n-=t*Math.trunc(n/(t-1))),kp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return kp(0,e,t-1)}(e,t);case"constant":default:return function(e,t){return e}(e)}}function pP(e,t,n,r,s,i,a,o,u,l,c){return 0<=o&&o<t&&0<=u&&u<n?e[a*r+o*s+u*i+l]:c}function fP(e,t,n,r,s,i,a,o,u,l,c){return pP(e,t,n,r,s,i,a,Math.round(o),Math.round(u),l,c)}function mP(e,t,n,r,s,i,a,o,u,l,c){const h=Math.floor(o),d=Math.floor(u),p=h+1,f=d+1;return(p-o)*((f-u)*pP(e,t,n,r,s,i,a,h,d,l,c)+(u-d)*pP(e,t,n,r,s,i,a,h,f,l,c))+(o-h)*((f-u)*pP(e,t,n,r,s,i,a,p,d,l,c)+(u-d)*pP(e,t,n,r,s,i,a,p,f,l,c))}function gP(e,t,n,r){const s=Op(t,n)[0],i=[1,n[0],1];for(let f=0;f<s;f++)i[0]*=n[f];i[1]=n[s];for(let f=s+1;f<n.length;f++)i[2]*=n[f];const a={},o=new Int32Array(n[s]),u=new Nb(i,r,e),l=[],c=1===i[0]&&1===i[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<i[0];t++)for(let n=0;n<i[2];n++)e.push(u.get(t,f,n));t=e.join(",")}if(void 0!==a[t])o[f]=a[t];else{const e=Object.keys(a).length;a[t]=e,o[f]=e,l.push(f)}}const h=i.slice();h[1]=Object.keys(a).length;const d=new Nb(h,r);l.forEach((e,t)=>{for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)d.set(u.get(n,e,r),n,t,r)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const bP=[vF,wF,CF,_F,fF,SF,TF,AF,RF,FF,OF,LF,zF,WF,qF,KF,XF,ZF,YF,yF,QF,nD,iD,uF,lD,hD,rF,dD,bD,xD,wD,vD,CD,ID,kD,SD,ED,$D,TD,AD,RD,DD,OD,MD,LD,PD,VD,zD,gO,HD,VR,KD,YD,iO,uO,cO,pO,IO,SO,NO,TO,FO,DO,OO,MO,PO,BO,qO,WR,jO,mD,HO,XO,YO,qR,eM,rM,iM,uM,cM,pM,mM,yM,vM,xM,SM,NM,EM,$M,TM,AM,CM,RM,FM,MM,LM,VM,UM,qD,jM,HM,XM,YM,eL,tL,sL,aL,oL,cL,KR,dL,fL,aF,gL,ZR,QR,gF,bL,yL,vL,xL,wL,kL,IL,NL,$L,TL,DL,eF,ML,PL,VL,tD,WM,UL,qL,GL,KL,XL,ZL,QL,JL,nP,sP,aP,xO,GD,uP,{kernelName:Gg,backendName:"cpu",kernelFunc:lP},{kernelName:Hg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:i}=r;DR(s,"tile");const a=cP(n.bufferSync(s),i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:Kg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:i}=r;DR(s,"topk");const a=n.data.get(s.dataId).values,[o,u]=hP(a,s.shape,s.dtype,i);return[n.makeTensorInfo(o.shape,o.dtype,o.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},$F,{kernelName:Xg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:l}=n,[c,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=[c,f,m,p],b=Hp(s.shape),y=b[0],v=b[1],x=b[2],w=Lp(s.dtype,Ep(g));w.fill(u);const k=r.data.get(s.dataId).values,C=r.data.get(i.dataId).values;for(let I=0;I<c;++I){const e=1===i.shape[0]?C:C.subarray(8*I,8*I+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let s;const i=e[6]*n+e[7]*t+1;if(0===i)continue;const l=(e[3]*n+e[4]*t+e[5])/i,c=dP((e[0]*n+e[1]*t+e[2])/i,d,o),p=dP(l,h,o);switch(a){case"nearest":s=fP(k,h,d,y,v,x,I,p,c,r,u);break;case"bilinear":s=mP(k,h,d,y,v,x,I,p,c,r,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}w[I*y+t*v+n*x+r]=s}return r.makeTensorInfo(g,s.dtype,w)}return{dataId:r.write(w,g,s.dtype),shape:s.shape,dtype:s.dtype}}},{kernelName:Yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:i}=t;DR(i,"unique");const a=r.data.get(i.dataId).values,{outputValues:o,outputShape:u,indices:l}=gP(a,s,i.shape,i.dtype);return[r.makeTensorInfo(u,i.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}},{kernelName:Qg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const a=s.shape.length,o=s.shape[i],u=new Array(a-1);let l=0;for(let p=0;p<a;p++)p!==i&&(u[l++]=s.shape[p]);const c=new Array(a).fill(0),h=s.shape.slice();h[i]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[i]=p;const e=eD({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[p]=mF({inputs:{x:e},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(e)}return d}},{kernelName:Jg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:i}=t,{numSegments:a}=r;DR(s,"unsortedSegmentSum");const o=[],u=[],l=s.shape.length-i.shape.length;let c=i;for(let d=0;d<l;++d){const e=lO({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=e,u.push(e)}for(let d=0;d<a;++d){const e=fb(d,"int32"),t=n.makeTensorInfo([],"int32",e),r=ZD({inputs:{a:t,b:c},backend:n}),i=oF({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=UD({inputs:{a:i,b:s},backend:n}),l=jD({inputs:{x:a},backend:n,attrs:{axis:0,keepDims:!1}});o.push(l),u.push(t),u.push(r),u.push(i),u.push(a),u.push(l)}const h=iL({inputs:o,backend:n,attrs:{axis:0}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},rL];for(const oK of bP)hb(oK);const yP={},vP={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xP(e){if(!(e in yP)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete yP[e]},!1),1===e?t.getContext("webgl",vP)||t.getContext("experimental-webgl",vP):t.getContext("webgl2",vP)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;yP[e]=t}const t=yP[e];return t.isContextLost()?(delete yP[e],xP(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),yP[e])}var wP,kP,CP;function IP(e,t){return[t,e]}function _P(e){const t=Ep(e);return Ap(Math.ceil(t/4))}function SP(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function NP(e,t){const n=e;let r,s,i,a,o,u,l,c,h,d;return 2===af().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,i=n.RGBA16F,a=n.RGBA32F,o=n.RED,l=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=e.RGBA,s=e.RGBA,i=e.RGBA,a=n.RGBA,o=e.RGBA,l=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT),u=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function EP(e,t){const n=t();return af().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function $P(e){return!!(af().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function TP(e,t){return LP(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(wP||(wP={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(kP||(kP={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(CP||(CP={}));const AP=/ERROR: [0-9]+:([0-9]+):/g;function RP(e,t){if(EP(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FP(e,t,n,r,s,i,a){const o=e.getAttribLocation(t,n);return-1!==o&&(EP(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),EP(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,i,a)),EP(e,()=>e.enableVertexAttribArray(o)),!0)}function DP(e,t,n){EP(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),EP(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function OP(e,t){EP(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),EP(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function MP(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function LP(e,t,n){const r=EP(e,()=>t());if(null==r)throw new Error(n);return r}function PP(e,t=2){return Ep(e.slice(0,e.length-t))}function zP(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function VP(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[PP(e),...zP(e)]),t}function BP(e){return e%2==0}function WP(e,t){if($p(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(BP(n)&&BP(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&BP(e[0])&&BP(t[0])}let UP,qP;function jP(e,t){return null!=e.getExtension(t)}function GP(e){try{if(null!=xP(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function HP(e){const t=NP(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function KP(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Ip("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const XP=af();function ZP(){let e,t,n,r,s,i,a,o,u,l;return 2===af().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",i="outputColor",a="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",i="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:u,defineRound:l}}function YP(e,t,n="index"){const r=Hp(t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`).join("")}function QP(e){const t=Hp(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}XP.registerFlag("HAS_WEBGL",()=>XP.getNumber("WEBGL_VERSION")>0),XP.registerFlag("WEBGL_VERSION",()=>GP(2)?2:GP(1)?1:0),XP.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),XP.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===XP.get("WEBGL_VERSION")),XP.registerFlag("WEBGL_CPU_FORWARD",()=>!0),XP.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),XP.registerFlag("WEBGL_PACK",()=>XP.getBool("HAS_WEBGL")),XP.registerFlag("WEBGL_PACK_NORMALIZATION",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_PACK_CLIP",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_PACK_REDUCE",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_LAZILY_UNPACK",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_CONV_IM2COL",()=>XP.getBool("WEBGL_PACK")),XP.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==UP){const t=xP(e);UP=t.getParameter(t.MAX_TEXTURE_SIZE)}return UP}(XP.getNumber("WEBGL_VERSION"))),XP.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==qP){const t=xP(e);qP=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qP)}(XP.getNumber("WEBGL_VERSION"))),XP.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=XP.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=xP(e);return t=jP(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:jP(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),XP.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>XP.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Qb()),XP.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=xP(e);if(1===e){if(!jP(t,"OES_texture_float"))return!1}else if(!jP(t,"EXT_color_buffer_float"))return!1;return HP(t)}(XP.getNumber("WEBGL_VERSION"))),XP.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!XP.getBool("WEBGL_FORCE_F16_TEXTURES")&&XP.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),XP.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(e){if(0===e)return!1;const t=xP(e);if(1!==e){if(jP(t,"EXT_color_buffer_float"))return HP(t);const e="EXT_color_buffer_half_float";if(jP(t,e)){const n=t.getExtension(e);return function(e,t){const n=NP(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),i}(t,n)}return!1}return!!jP(t,"OES_texture_float")&&!!jP(t,"WEBGL_color_buffer_float")&&HP(t)}(XP.getNumber("WEBGL_VERSION"))),XP.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=XP.getNumber("WEBGL_VERSION"))&&null!=xP(e).fenceSync;var e}),XP.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>XP.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),XP.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),XP.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Qb()&&XP.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});const JP="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class ez{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=wP.DENSE;const t=_P(e),n=ZP();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${YP(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class tz{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=wP.DENSE;const t=_P(e),n=ZP();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${YP(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class nz{constructor(e){this.variableNames=["A"],this.outTexUsage=kP.DOWNLOAD;const t=ZP();this.outputShape=e,this.userCode=`\n      ${JP}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class rz{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=kP.DOWNLOAD;const t=ZP();this.outputShape=e,this.userCode=`\n      ${JP}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class sz{constructor(e,t,n=!1){this.variableNames=["A"];const r=ZP(),[s,i]=t;this.outputShape=e;let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${QP(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class iz{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=ZP(),[s,i]=t;this.outputShape=e;let a="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let t=0;t<=1;t++){const n=2*u+t;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${e[2]}) {\n            localCoords[2] += ${t};\n            if(localCoords[1] + ${u} < ${e[1]}) {\n              localCoords[1] += ${u};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${QP(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${a}\n\n        ${r.output} = ${o};\n      }\n    `}}function az(e,t,n,r,s,i){!function(e,t){const n=af().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const a=function(e){return LP(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return EP(e,()=>e.bindTexture(o,a)),EP(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),EP(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),EP(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),EP(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),EP(e,()=>e.texImage2D(o,0,r,t,n,0,s,i,null)),EP(e,()=>e.bindTexture(e.TEXTURE_2D,null)),a}function oz(e){return e.internalFormatFloat}function uz(e){return e.internalFormatHalfFloat}function lz(e){return e.downloadTextureFormat}function cz(e){return e.internalFormatPackedFloat}function hz(e){return e.internalFormatPackedHalfFloat}class dz{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=af().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){yP[e]=t}(t,e)):this.gl=xP(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===af().getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=TP(this.gl,"OES_texture_float"),jP(this.gl,e))this.textureHalfFloatExtension=TP(this.gl,e);else if(af().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),jP(this.gl,r))this.colorBufferHalfFloatExtension=TP(this.gl,r);else if(af().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",jP(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!jP(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=LP(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return EP(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),EP(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=LP(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return EP(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),EP(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return LP(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=NP(this.gl,this.textureHalfFloatExtension)}get debug(){return af().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;EP(e,()=>e.finish()),EP(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),EP(e,()=>e.deleteFramebuffer(this.framebuffer)),EP(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),EP(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),EP(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,i]=IP(t,n);return az(e,s,i,oz(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,i]=IP(t,n);return az(e,s,i,uz(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,i]=IP(t,n);return az(e,s,i,lz(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){EP(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?EP(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):EP(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),EP(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,i){let a,o,u;EP(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(a=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(a=new Float32Array(n*r*4),o=e.FLOAT,u=i.internalFormatPackedFloat),a.set(s),EP(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,o,a)),EP(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,i]=SP(t,n);return az(e,s,i,hz(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,i]=SP(t,n);return az(e,s,i,cz(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(OP(this.gl,this.framebuffer),this.outputTexture=null),EP(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,r){const[s,i]=IP(t,n),a=new Uint8Array(t*n*4);return EP(e,()=>e.readPixels(0,0,s,i,r.downloadTextureFormat,e.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,i){return function(e,t,n,r,s,i,a,o){const u=e,l=new Float32Array(function(e,t){const[n,r]=SP(e,t);return n*r*4}(i,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,s,i)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const s=e.createBuffer();EP(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const i=16*t*n;return EP(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),EP(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),EP(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}(this.gl,t,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(af().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const r=new Float32Array(t*n*4);return EP(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=LP(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(EP(e,()=>e.shaderSource(n,t)),EP(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=AP.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),i=s.length.toString().length+2,a=s.map((e,t)=>Rp((t+1).toString(),i)+e);let o=0;for(let h=0;h<a.length;h++)o=Math.max(a[h].length,o);const u=a.slice(0,r-1),l=a.slice(r-1,r),c=a.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Rp(l[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e);null==this.vertexShader&&(this.vertexShader=function(e){const t=ZP();return function(e,t){const n=LP(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(EP(e,()=>e.shaderSource(n,t)),EP(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const r=function(e){return LP(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return EP(t,()=>t.attachShader(r,this.vertexShader)),EP(t,()=>t.attachShader(r,n)),function(e,t){if(EP(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,r),this.debug&&RP(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function(e,t,n){return EP(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),FP(e,t,"clipSpacePos",n,3,20,0)&&FP(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&EP(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&RP(this.gl,this.program),EP(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return LP(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),EP(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,r){EP(e,()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),EP(e,()=>e.activeTexture(e.TEXTURE0+n)),EP(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,r)),EP(e,()=>e.uniform1i(n,r))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=SP(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&RP(this.gl,this.program),MP(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),EP(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),EP(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=TP(this.gl,2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){var t=this;return bp(function*(){return yield Fp(()=>t.disposed||t.isQueryAvailable(e,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(e,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||Fp(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),DP(this.gl,e,this.framebuffer),this.debug&&MP(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(DP(this.gl,this.outputTexture,this.framebuffer),this.debug&&MP(this.gl)):OP(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;DP(r,e,this.framebuffer),this.debug&&MP(r),this.outputTexture=e,EP(r,()=>r.viewport(0,0,t,n)),EP(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),EP(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:pz}=i;function fz(e,t,n,r){const s=[];e.forEach(e=>{const t=Ep(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`))});const i=s.join("\n"),a=e.map(e=>function(e,t,n=!1){let r="";return r+=n?gz(e):mz(e),e.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,a=t.logicalShape.length,o=pz(e.shapeInfo.logicalShape,t.logicalShape),u=Cz(a),l=a-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":a<2&&o.length>=1?"coords = 0;":o.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";d=a<2&&i>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", ");let p="return outputValue;";const f=1===Ep(e.shapeInfo.logicalShape),m=1===Ep(t.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=i-2,t=i-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,a=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===a&&null==e.shapeInfo.flatOffset&&$p(e.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const o=Cz(a),u=pz(e.shapeInfo.logicalShape,t.logicalShape),l=a-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":a<2&&u.length>=1?"coords = 0;":u.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";return d=a<2&&i>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", "),`\n    float ${s}() {\n      ${o} coords = getOutputCoords();\n      ${c}\n      return get${r}(${d});\n    }\n  `}(e,t)),r}(e,t,r)).join("\n"),o=t.texShape,u=ZP(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,h,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${bz}\n    ${yz}\n    ${vz}\n  `}(u);return t.isPacked?(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if($p(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let i=s,a="",o="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],a=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+a,o=`b${u}, `+o;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${o});\n    }\n  `}(e,t)}}(t.logicalShape,o),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return $p(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=YP(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=YP(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=YP(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=YP(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}var n}(t.logicalShape,o),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),r&&(d+=xz),[d,l,h,i,c,a,n].join("\n")}function mz(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[i,a]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${i}, ${a}, ${wz(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${kz(e)}\n      }\n    `;const r=e.shapeInfo.texShape,s=r[0],i=r[1];if(1===i&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=wz(t);return 1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(null!=s&&$p(t,s))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=Mp(t);if(i.length<t.length){const t=["row","col"];return`\n      ${mz(Iz(e,i))}\n      float ${r}(int row, int col) {\n        return ${r}(${_z(t,a)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${kz(e)}\n      }\n    `;const o=s[0],u=s[1],l=wz(n);return 1===u?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${o}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===o?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${l};\n    vec2 uv = uvFromFlat(${o}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],i=t[2],{newShape:a,keptDims:o}=Mp(t);if(a.length<t.length){const t=["row","col","depth"];return`\n        ${mz(Iz(e,a))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${_z(t,o)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${kz(e)}\n      }\n    `;const u=e.shapeInfo.texShape,l=u[0],c=u[1],h=e.shapeInfo.flatOffset;return c===s&&null==h?`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${l}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===i&&null==h?`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${wz(n)};\n        vec2 uv = uvFromFlat(${l}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],i=t[2]*s,a=t[1]*i,{newShape:o,keptDims:u}=Mp(t);if(o.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${mz(Iz(e,o))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${_z(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${s}, 1)));\n        ${kz(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],d=c[1];return d===a&&null==l?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:d===s&&null==l?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${wz(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],i=t[3]*s,a=t[2]*i,o=t[1]*a,{newShape:u,keptDims:l}=Mp(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${mz(Iz(e,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${_z(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${a}, ${i}, ${s})) +\n          depth3;\n        ${kz(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];return p===o&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===s&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${wz(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:i}=Mp(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${mz(Iz(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${_z(t,i)});\n      }\n    `}const a=t[5],o=t[4]*a,u=t[3]*o,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${kz(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${o}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===a&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${o} + depth3 * ${a} + depth4 + ${wz(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function gz(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${ZP().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],i=ZP();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${i.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,i=s[0],a=s[1],o=ZP();if(null!=s&&$p(t,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${o.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===t[0]){const n=[1,2],s=["b","row","col"];return`\n        ${gz(Iz(e,t.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${_z(s,n)});\n        }\n      `}const a=i[0],o=i[1],u=Math.ceil(t[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${o}, ${u*Math.ceil(t[1]/2)}, ${u}, b, row, col);\n      return ${ZP().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],o=a[0],u=a[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=t[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${s}(${h}) {\n      int index = ${d};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${o});\n      return ${ZP().texture2D}(${r}, uv);\n    }\n  `}(e)}}const bz="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",yz="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",vz="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",xz="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function wz(e){return`offset${e}`}function kz(e){const t=e.name,n=Ep(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Cz(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Iz(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function _z(e,t){return t.map(t=>e[t]).join(", ")}function Sz(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,s=t[n],i=s.shape;if(!$p(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(e.isUniform&&s.isUniform)return;const a=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!$p(a,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${o} must match`)})}const{addImpl:Nz,bincountImpl:Ez,bincountReduceImpl:$z,ceilImpl:Tz,concatImpl:Az,expImpl:Rz,expm1Impl:Fz,floorImpl:Dz,gatherV2Impl:Oz,greaterImpl:Mz,lessImpl:Lz,linSpaceImpl:Pz,logImpl:zz,maxImpl:Vz,maximumImpl:Bz,minimumImpl:Wz,multiplyImpl:Uz,negImpl:qz,prodImpl:jz,rangeImpl:Gz,rsqrtImpl:Hz,simpleAbsImpl:Kz,sliceImpl:Xz,sparseFillEmptyRowsImpl:Zz,sparseReshapeImpl:Yz,stridedSliceImpl:Qz,subImpl:Jz,tileImpl:eV,topKImpl:tV,transposeImpl:nV,uniqueImpl:rV}=a;function sV(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function iV(e,t){return 1===t?[e]:sV(e,t)}class aV{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=iV("rc",t),r=Cz(t),s=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}(t,e,n),i=function(e,t,n,r){if(1===e)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),a=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<e;n++)i=`${t[t.length-1-n]},`+i;n.push(i)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}}class oV{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2==1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${YP(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${QP(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class uV{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=cV(t,n),s=hV(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const i=lV(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const e=this.freeTextures[s].shift();return this.usedTextures[s].push(e),e}let a;return r===CP.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===CP.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===CP.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===CP.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===CP.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=cV(n,r),i=hV(t,s,r);i in this.freeTextures||(this.freeTextures[i]=[]);const a=lV(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=af().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function lV(e,t,n,r,s){const i=function(e,t){switch(e){case CP.PACKED_2X2_FLOAT32:return cz(t);case CP.PACKED_2X2_FLOAT16:return hz(t);case CP.UNPACKED_FLOAT32:return oz(t);case CP.UNPACKED_FLOAT16:return uz(t);case CP.PACKED_4X1_UNSIGNED_BYTE:return lz(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let a;if(s){const[t,n]=SP(e[0],e[1]);a=t*n}else{const[t,n]=IP(e[0],e[1]);a=t*n}return a*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,i)}function cV(e,t){if(e===kP.UPLOAD)return CP.PACKED_2X2_FLOAT32;if(e===kP.RENDER||null==e)return function(e){return af().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?CP.PACKED_2X2_FLOAT32:CP.UNPACKED_FLOAT32:e?CP.PACKED_2X2_FLOAT16:CP.UNPACKED_FLOAT16}(t);if(e===kP.DOWNLOAD||e===kP.PIXELS)return CP.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function hV(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class dV{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const pV="return abs(x);",fV="return x;";class mV{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class gV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=iV("rc",t),r=Cz(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),i=n.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const bV=zC,yV={};class vV extends vp{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!af().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=xP(af().getNumber("WEBGL_VERSION"));this.binaryCache=((t=af().getNumber("WEBGL_VERSION"))in yV||(yV[t]={}),yV[t]),this.gpgpu=new dz(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new uV(this.gpgpu),this.numMBBeforeWarning=null==af().global.screen?1024:af().global.screen.height*af().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new yp(this,kv())}nextDataId(){return vV.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((af().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||af().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:kP.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if(af().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:kP.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:i,shape:a,isPacked:o}=t;if(null!=i){let t;t=o?new mV(a,fV):new dV(a,fV);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=gb()),c="complex64"===r?yC(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=gb()-l),this.convertAndCacheOnCPU(e,c)}read(e){var t=this;return bp(function*(){if(t.pendingRead.has(e)){const n=t.pendingRead.get(e);return new Promise(e=>n.push(e))}const n=t.texData.get(e),{values:r,shape:s,slice:i,dtype:a,complexTensorInfos:o,isPacked:u}=n;if(null!=i){let n;n=u?new mV(s,fV):new dV(s,fV);const r=t.runWebGLProgram(n,[{dataId:e,shape:s,dtype:a}],a),i=t.read(r.dataId);return t.disposeIntermediateTensorInfo(r),i}if(null!=r)return t.convertAndCacheOnCPU(e);if(!af().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===af().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,h=null;if("complex64"!==a&&af().get("WEBGL_BUFFER_SUPPORTED")){l=t.decode(e);const n=t.texData.get(l.dataId);h=t.gpgpu.createBufferFromTexture(n.texture,..._P(s))}if(t.pendingRead.set(e,[]),"complex64"!==a&&(yield t.gpgpu.createAndWaitForFence()),"complex64"===a){const e=yield Promise.all([t.read(o.real.dataId),t.read(o.imag.dataId)]);c=yC(e[0],e[1])}else if(null==h)c=t.getValuesFromTexture(e);else{const e=Ep(s);c=t.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}null!=l&&t.disposeIntermediateTensorInfo(l);const d=t.convertAndCacheOnCPU(e,c),p=t.pendingRead.get(e);return t.pendingRead.delete(e),p.forEach(e=>e(d)),t.pendingDisposal.has(e)&&(t.pendingDisposal.delete(e),t.disposeData(e)&&kv().removeDataId(e,t),t.pendingDeletes--),d})()}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>yb(e))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return qy(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!$P(n)){if(af().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Ep(t);if(af().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,..._P(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),i}const i=af().getBool("WEBGL_PACK")&&!0===r,a=i?VP(t):t,o=i?new rz(a):new nz(a),u=this.runWebGLProgram(o,[{shape:a,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var t=this;return bp(function*(){const n=t.activeTimers,r=[];let s=!1;null==t.programTimersStack?(t.programTimersStack=r,s=!0):t.activeTimers.push(r),t.activeTimers=r,e();const i=Np(t.activeTimers.map(e=>e.query)).filter(e=>null!=e),a=Np(t.activeTimers.map(e=>e.name)).filter(e=>null!=e);t.activeTimers=n,s&&(t.programTimersStack=null);const o={uploadWaitMs:t.uploadWaitMs,downloadWaitMs:t.downloadWaitMs,kernelMs:null,wallMs:null};if(af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=yield Promise.all(i);o.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),o.getExtraProfileInfo=()=>e.map((e,t)=>({name:a[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return t.uploadWaitMs=0,t.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:gb(),endMs:null}}endTimer(e){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=gb(),e)}getQueryTime(e){var t=this;return bp(function*(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?t.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:i,slice:a}=this.texData.get(e),o=a&&a.origDataId||e,u=this.dataRefCount.get(o);u>1?this.dataRefCount.set(o,u-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,i)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=128){return af().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&Ep(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gC("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return bV(e.shape,t)}packedUnaryOp(e,t,n){const r=new mV(e.shape,t),s=this.compileAndRun(r,[e],n);return kv().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Kz(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(af().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,pV,e.dtype);const t=new dV(e.shape,pV),n=this.compileAndRun(t,[e]);return kv().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Wp(n[0])){const s=n.map(e=>bb(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:r}=this.makeTensorInfo(e,t,n);return kv().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new gV(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new aV(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[PP(e.shape),...zP(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[PP(t),...zP(t)],i=new oV(s,n),a=this.runWebGLProgram(i,[r],e.dtype,null,!0);return{dataId:a.dataId,shape:t,dtype:a.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,i=VP(r);let a;return a=n?new tz(i):new ez(i),{dtype:s,shape:r,dataId:this.runWebGLProgram(a,[{shape:i,dtype:s,dataId:e}],s,null,!0).dataId}}runWebGLProgram(e,t,n,r,s=!1){const i=this.makeTensorInfo(e.outputShape,n),a=this.texData.get(i.dataId);if(e.packedOutput&&(a.isPacked=!0),e.outPackingScheme===wP.DENSE){const t=_P(e.outputShape);a.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(a.usage=e.outTexUsage),0===Ep(i.shape))return a.values=Lp(i.dtype,0),i;const o=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Ep(t.shape)<=af().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),o.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!WP(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),o.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);const l={shape:i.shape,texData:a,isUniform:!1},c=function(e,t,n){let r="";t.concat(n).forEach(e=>{r+=`${e.shape}_${e.isUniform?"uniform":e.texData.texShape}_${null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0}`});let s=e.constructor.name;return s+="_"+r+"_"+e.userCode,s}(e,u,l),h=this.getAndSaveBinary(c,()=>function(e,t,n,r){const s=t.userCode,i=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),a=i.map(e=>e.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=fz(i,o,s,t.packedInputs),l=e.createProgram(u);let c=null;const h=e.getUniformLocation(l,"NAN",!1);1===af().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(l,"INFINITY",!1));const d={};for(let p=0;p<t.variableNames.length;p++){const n=t.variableNames[p],r=!1;d[n]=e.getUniformLocation(l,n,r),d[`offset${n}`]=e.getUniformLocation(l,`offset${n}`,r)}return{program:t,source:u,webGLProgram:l,uniformLocations:d,inShapeInfos:a,outShapeInfo:o,infLoc:c,nanLoc:h}}(this.gpgpu,e,u,l)),d=null!=this.activeTimers;let p;d&&(p=this.startTimer()),function(e,t,n,r,s){Sz(t.inShapeInfos,n),Sz([t.outShapeInfo],[r]);const i=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(i,a[0],a[1]):e.setOutputMatrixTexture(i,a[0],a[1]),e.setProgram(t.webGLProgram),1===af().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,r)=>{const s=t.program.variableNames[r],i=t.uniformLocations[s],a=t.uniformLocations[`offset${s}`];if(null!=i)if(n.isUniform)if(Ep(n.shape)<2)e.gl.uniform1f(i,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(i,t)}else null!=n.texData.slice&&null!=a&&e.gl.uniform1i(a,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,i,r)}),null!=s&&s(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,h,u,l,r),o.forEach(e=>this.disposeIntermediateTensorInfo(e)),d&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));const f=af().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=gb();e-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!af().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,s=!1){return this.runWebGLProgram(e,t,n=n||t[0].dtype,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(af().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Iv(()=>{if(!af().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=af().getBool("DEBUG");af().set("DEBUG",!1);const t=this.abs($v(1e-8)).dataSync()[0];if(af().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:i,usage:a,isPacked:o}=t;if(null!=i)return;const u=null!=this.activeTimers;let l;u&&(l=gb());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=af().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map((t,n)=>n>=e.length-2?Cp(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=Mp(e);e=t.newShape}let r=Ep(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=PP(e);let n=2,s=2;return e.length&&([n,s]=zP(e)),r=t*(n/2)*(s/2),Ap(r).map(e=>2*e)}return Ap(r)}(n,o),t.texShape=c),null!=s){const e=VP(n);let i,a=c[1],h=c[0];const d=s instanceof Uint8Array;o?([a,h]=SP(c[0],c[1]),i=new iz(e,[h,a],d)):i=new sz(e,[h,a],d);const p=this.makeTensorInfo([h,a],r);this.texData.get(p.dataId).usage=d?kP.PIXELS:kP.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),a,h,s);const f=this.runWebGLProgram(i,[p],r,null,!0),m=this.texData.get(f.dataId);t.texture=m.texture,t.texShape=m.texShape,t.isPacked=m.isPacked,t.usage=m.usage,this.disposeIntermediateTensorInfo(p),this.texData.delete(f.dataId),t.values=null,u&&(this.uploadWaitMs+=gb()-l)}else{const e=this.acquireTexture(c,a,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Bp(t)}}vV.nextDataId=0,Jb()&&Nv("webgl",()=>new vV,2);class xV{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=wx(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class wV{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=wx(t,n);const s=this.outputShape.length;let i="";if(r)if(0===s||1===Ep(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${Cz(s)} coords = getOutputCoords();\n        `,1===s)i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=iV("coords",s);i+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function kV(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const CV={kernelName:km,backendName:"webgl",kernelFunc:kV};function IV(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,i=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(i.dataId),o=kV({inputs:{x:r},backend:n}),u=kV({inputs:{x:s},backend:n});return a.complexTensorInfos={real:o,imag:u},i}const _V={kernelName:Of,backendName:"webgl",kernelFunc:IV},SV="return (a < 0.) ? b * a : a;",NV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",EV={kernelName:Em,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:i}=r,a=n.makeTensorInfo([],"float32",fb(i,"float32")),o=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wV(NV,s.shape,a.shape):new xV(SV,s.shape,a.shape),u=n.runWebGLProgram(o,[s,a],s.dtype);return n.disposeIntermediateTensorInfo(a),u}},$V="return (a < 0.) ? b * a : a;",TV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",AV={kernelName:lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,i=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wV(TV,r.shape,s.shape):new xV($V,r.shape,s.shape);return n.runWebGLProgram(i,[r,s],r.dtype)}};function RV({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:i})=>{const{x:a}=s,o=i,u=r||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=n){const e=o.texData.get(a.dataId),t=n(e.values,u);return o.makeTensorInfo(a.shape,u,t)}let l;return l=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new mV(a.shape,t):new dV(a.shape,e),o.runWebGLProgram(l,[a],u)}}function FV({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:a,backend:o})=>{const{a:u,b:l}=a,c=o;if(r&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},i={dataId:r.dataId,dtype:r.dtype,shape:l.shape},a=new xV(e,u.shape,l.shape);return c.runWebGLProgram(a,[s,i],Vb(n.dtype,r.dtype))}),i=IV({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),i}const h=i||Vb(u.dtype,l.dtype);if(c.shouldExecuteOnCPU([u,l])&&null!=s){const e=c.texData.get(u.dataId),t=c.texData.get(l.dataId),[n,r]=s(u.shape,l.shape,e.values,t.values,h),i=c.makeTensorInfo(r,h);return c.texData.get(i.dataId).values=n,i}let d;return d=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new wV(t,u.shape,l.shape,n):new xV(e,u.shape,l.shape),c.runWebGLProgram(d,[u,l],h)}}function DV(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?TV:$V;if("leakyrelu"===e)return t?NV:SV;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class OV{constructor(e,t,n,r=!1,s=!1,i=!1,a=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const l=Math.ceil((r?e[1]:e[2])/2),c=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";a&&(f=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,m="result = activation(result);");const g=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",y="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(y=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${b};\n          int batchB = ${y};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class MV{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=wx(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const LV="return a * b;";function PV(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,i=Vb(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),i=new MV("return areal * breal - aimag * bimag;",r.shape,s.shape),a=new MV("return areal * bimag + aimag * breal;",r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],u=n.runWebGLProgram(i,o,"float32"),l=n.runWebGLProgram(a,o,"float32"),c=IV({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[a,o]=Uz(r.shape,s.shape,e.values,t.values,i),u=n.makeTensorInfo(o,i);return n.texData.get(u.dataId).values=a,u}let a;return a=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wV(LV,r.shape,s.shape):new xV(LV,r.shape,s.shape),n.runWebGLProgram(a,[r,s],i)}const zV={kernelName:Qm,backendName:"webgl",kernelFunc:PV};function VV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:i}=r,a=n,o=Ep(s.shape),u=Dp(i,o),l=Ep(u);Ip(o===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=a.texData.get(s.dataId);return!c.isPacked||WP(s.shape,u)||null!==c.texture&&WP(c.shape,u)?(a.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function(e,t,n){const r=[PP(e.shape),...zP(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},i=[PP(t),...zP(t)],a=new oV(i,r),o=n.runWebGLProgram(a,[s],e.dtype,null,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}(s,u,a)}const BV={kernelName:mg,backendName:"webgl",kernelFunc:VV};class WV{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:i}=e;this.outputShape=[r,i];const a=4*Math.floor(n/4),o=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${Tp(e)?e.toPrecision(2):e}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class UV{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:i}=e;this.outputShape=[r,i];let a="0.0",o="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",o="min"):"max"===t&&(a="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===t?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function qV(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Yk(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let i=e;for(let a=0;a<s.length;a++){const{inSize:o,windowSize:u,outSize:l}=s[a];let c,h;c="mean"===n?0===a?new WV({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},o):new WV({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l}):new UV({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},n),h=i,i=r.runWebGLProgram(c,[i],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return i}class jV{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;const r=Cz(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class GV{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Cz(this.rank),s=sV("rc",this.rank),i=new Array(this.rank);for(let l=0;l<t.length;l++)i[t[l]]=s[l];const a=`vec2(${i.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${o}) {\n        result[1] = ${u};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${o}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function HV(e,t,n){const r=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GV(e.shape,t):new jV(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function KV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;return function(e,t,n,r){const s=e.shape.length,i=Op(t,e.shape);let a=i;const o=Yx(a,s),u=null!=o;let l=e;u&&(l=HV(e,o,r),a=Jx(a.length,s)),Zx("sum",a,s);const[c,h]=Kx(l.shape,a);let d=c;n&&(d=Xx(c,i));const p=Ep(h),f=VV({inputs:{x:l},attrs:{shape:[Ep(e.shape)/p,p]},backend:r}),m=qV(f,Bb(e.dtype),"sum",r),g=VV({inputs:{x:m},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),u&&r.disposeIntermediateTensorInfo(l),g}(s,i,a,n)}const XV={kernelName:Dg,backendName:"webgl",kernelFunc:KV};function ZV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:i}=r,a=n,o=new Array(s.shape.length);for(let l=0;l<o.length;l++)o[l]=s.shape[i[l]];let u;if(a.shouldExecuteOnCPU([s])){const e=a.texData.get(s.dataId),t=nV(e.values,s.shape,s.dtype,i,o);u=a.makeTensorInfo(o,s.dtype),a.texData.get(u.dataId).values=t}else u=HV(s,i,a);return u}const YV={kernelName:Zg,backendName:"webgl",kernelFunc:ZV};function QV({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,h=n?e.shape[l-2]:e.shape[l-1],d=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=Ep(m),y=Ep(g);Ip(l>=2&&c>=2&&(b===y||1===b||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const v=(b>y?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([p,f]);Ip(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=n?[b,h,p]:[b,p,h],w=r?[y,f,d]:[y,d,f],k=VV({inputs:{x:e},backend:s,attrs:{shape:x}}),C=VV({inputs:{x:t},backend:s,attrs:{shape:w}}),I=[k,C],_=Math.max(b,y),S=n?k.shape[1]:k.shape[2],N=null!=i,E=null!=a,$="leakyrelu"===u,T=null!=u?DV(u,!0):null;let A;if((1===p||1===f)&&S>1e3&&!1===(N||E||$||null!=T)){let e=k,t=C;n&&(e=ZV({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),I.push(e)),r&&(t=ZV({inputs:{x:C},backend:s,attrs:{perm:[0,2,1]}}),I.push(t));const i=1===f;let a=e;1!==f&&(a=VV({inputs:{x:e},backend:s,attrs:{shape:[_,S,1]}}),I.push(a));const o=1===f?2:1;let u=t;i&&(u=VV({inputs:{x:t},backend:s,attrs:{shape:[_,1,S]}}),I.push(u));const l=PV({inputs:{a:a,b:u},backend:s});A=KV({inputs:{x:l},backend:s,attrs:{axis:o,keepDims:!0}}),I.push(l)}else{const u=Vb(e.dtype,t.dtype),l=new OV(x,w,[_,p,f],n,r,N,T,E,$),c=[k,C];if(null!=i&&c.push(i),E&&c.push(a),$){const e=s.makeTensorInfo([],"float32",fb(o,"float32"));c.push(e),I.push(e)}A=s.runWebGLProgram(l,c,u)}const R=VV({inputs:{x:A},backend:s,attrs:{shape:v}});I.push(A);for(const F of I)s.disposeIntermediateTensorInfo(F);return R}const JV={kernelName:rb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:i,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;return QV({a:s,b:i,transposeA:u,transposeB:l,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},eB="return abs(x);",tB={kernelName:hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=Kz(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mV(r.shape,eB):new dV(r.shape,eB),n.runWebGLProgram(s,[r],r.dtype)}},nB=RV({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),rB={kernelName:df,backendName:"webgl",kernelFunc:nB},sB=RV({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),iB={kernelName:pf,backendName:"webgl",kernelFunc:sB},aB="return a + b;",oB=FV({opSnippet:aB,packedOpSnippet:aB,supportsComplex:!0,cpuKernelImpl:Nz}),uB={kernelName:ff,backendName:"webgl",kernelFunc:oB};class lB{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class cB{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const hB={kernelName:mf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return kV({inputs:{x:s[0]},backend:r});if(s.length>af().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),i=e({inputs:s.slice(t),backend:r});return e({inputs:[n,i],backend:r})}const i=s.map(e=>e.dtype).reduce((e,t)=>Vb(e,t)),a=s.map(e=>e.shape),o=af().getBool("WEBGL_PACK")?new cB(s[0].shape,a):new lB(s[0].shape,a);return r.runWebGLProgram(o,s,i)}},dB={kernelName:gf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r,o=s.shape.length,u=Op(i,s.shape);let l=u;const c=Yx(l,o);let h=s;null!=c&&(h=ZV({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Jx(l.length,o)),Zx("all",l,o);const[d,p]=Kx(h.shape,l),f=VV({inputs:{x:h},backend:n,attrs:{shape:[-1,Ep(p)]}}),m=qV(f,f.dtype,"all",n);let g;return g=VV(a?{inputs:{x:m},backend:n,attrs:{shape:Xx(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},pB={kernelName:bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r,o=s.shape.length,u=Op(i,s.shape);let l=u;const c=Yx(l,o);let h=s;null!=c&&(h=ZV({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Jx(l.length,o)),Zx("any",l,o);const[d,p]=Kx(h.shape,l),f=VV({inputs:{x:h},backend:n,attrs:{shape:[-1,Ep(p)]}}),m=qV(f,f.dtype,"any",n);let g;return g=VV(a?{inputs:{x:m},backend:n,attrs:{shape:Xx(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class fB{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class mB{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Ip(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,a=i.length,o=Cz(a),u=iV("coords",a);let l,c;if(1===s){c=a+1;const e=Cz(c);l=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[a-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[a-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[a-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[a-2]};`}else c=a,l=`\n        ${o} sourceLocR = coords;\n        ++${u[a-1]};\n        ${o} sourceLocG = coords;\n        ++${u[a-2]};\n        ${o} sourceLocA = coords;\n        --${u[a-1]};\n        ${o} sourceLocB = coords;\n        --${u[a-2]};`;const h=["x","y","z","w","u","v"].slice(0,c),d="."+h[c-1],p=h.map(e=>"int "+e),f=iV("sourceLocR",c-1).concat("inIdx.r"),m=iV("sourceLocG",c-1).concat("inIdx.g"),g=iV("sourceLocB",c-1).concat("inIdx.b"),b=iV("sourceLocA",c-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,x=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,w=r?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${o} coords = getOutputCoords();\n        bool hasNextCol = ${u[a-1]} < ${i[a-1]-1};\n        bool hasNextRow = ${u[a-2]} < ${i[a-2]-1};\n        ${l}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function gB(e,t,n,r=null){let s=t.shape[0],i=t.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const a=Yk(i),o={windowSize:a,inSize:i,batchSize:s,outSize:Math.ceil(i/a)},u=new fB(o,n,null==r),l=[t];null!=r&&l.push(r);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const h=gB(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function bB(e,t,n,r=null){const s=null!=r?r.shape:t.shape,i=Yk(s[s.length-1]),a=new mB(s,i,n,null==r),o=e.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(o.shape.length===t.shape.length){const r=bB(e,t,n,o);return e.disposeIntermediateTensorInfo(o),r}return o}function yB(e,t,n,r){const s=[n];if(Zx("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!af().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[i,a]=Kx(t.shape,s),o=Ep(a),u=VV({inputs:{x:t},backend:e,attrs:{shape:[-1,o]}});n.push(u);const l=gB(e,u,r);n.push(l);const c=VV({inputs:{x:l},backend:e,attrs:{shape:i}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),c}return bB(e,t,r)}const vB={kernelName:yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i}=r;let a=Op(i,s.shape);const o=Yx(a,s.shape.length);let u=s;const l=[];null!=o&&(u=ZV({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),a=Jx(a.length,u.shape.length)),Zx("argMax",[a[0]],u.shape.length);const c=yB(n,u,a[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},xB={kernelName:vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i}=r;let a=Op(i,s.shape);const o=Yx(a,s.shape.length);let u=s;const l=[];null!=o&&(u=ZV({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),a=Jx(a.length,u.shape.length)),Zx("argMin",[a[0]],u.shape.length);const c=yB(n,u,a[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},wB=RV({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),kB={kernelName:xf,backendName:"webgl",kernelFunc:wB},CB=RV({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),IB={kernelName:wf,backendName:"webgl",kernelFunc:CB},_B=RV({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),SB={kernelName:kf,backendName:"webgl",kernelFunc:_B},NB=FV({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),EB={kernelName:If,backendName:"webgl",kernelFunc:NB},$B=RV({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),TB={kernelName:Cf,backendName:"webgl",kernelFunc:$B};class AB{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`:`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / count");const b=4*Math.floor(i/4),y=i%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${b}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${b};\n          if (${1===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class RB{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,o=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let v="0.0";if(y||(v="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / count");const w=4*Math.floor(i/4),k=i%4,C=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${C}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${C}\n            }\n          }\n          setOutput(${x});\n        }\n      }\n    `}}const FB={kernelName:_f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;KP(s,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=r;Ip(Hv(a,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const l=Lv(s.shape,i,a,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))return kV({inputs:{x:s},backend:n});const c=new AB(l,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},DB={kernelName:Nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:l}=r,c=Pv(s.shape,i,a,[1,1,1],o,u,l),h=new RB(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class OB{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n            wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${e.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class MB{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterDepth*e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n            wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const LB={kernelName:Ef,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,a=i,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=Pv(a.shape,o,u,[1,1,1],l,c),d=new MB(h);return n.runWebGLProgram(d,[s],a.dtype)}},PB={kernelName:Sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,a=i;KP([s,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=Lv(a.shape,o,u,1,l),h=new OB(c);return n.runWebGLProgram(h,[s],a.dtype)}},zB={kernelName:$f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:i}=t,{transposeA:a,transposeB:o}=r;return QV({a:s,b:i,transposeA:a,transposeB:o,backend:n})}};class VB{constructor(e,t,n,r,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],wx(e,t),wx(e,n);let a="0.0";null!=r&&(wx(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=s&&(wx(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class BB{constructor(e,t,n,r,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],wx(e,t),wx(e,n);let a="vec4(0.0)";null!=r&&(wx(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(wx(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const WB={kernelName:bm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:i,offset:a,scale:o}=e;Ip(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ip(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ip(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,s,i];let c=null;null!=a&&(c=a.shape,l.push(a));let h=null;null!=o&&(h=o.shape,l.push(o));const d=af().getBool("WEBGL_PACK_NORMALIZATION")?new BB(r.shape,s.shape,i.shape,c,h,u):new VB(r.shape,s.shape,i.shape,c,h,u);return t.runWebGLProgram(d,l,l[0].dtype)}};class UB{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Cz(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return qB.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${qB[t]} = start[${t}] + coords.${qB[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const qB=["x","y","z","w","u","v"];class jB{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=Cz(this.rank),n=iV("coords",this.rank),r=iV("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${s})`,a=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function GB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:i,size:a}=r,[o,u]=bv(s,i,a);if(rv(s,o,u),0===Ep(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=Xz(e.values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),c=mv(s.shape,o,u);if(l||!c){const e=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jB(u):new UB(u),t=e.getCustomSetupFunc(o);return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),i=r.makeTensorInfo(n,e.dtype),a=r.texData.get(i.dataId);Object.assign(a,s),a.refCount=1,a.shape=n,a.dtype=e.dtype;let o=gv(t,Hp(e.shape));s.slice&&(o+=s.slice.flatOffset),a.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,u+1),i}(s,o,u,n)}const HB={kernelName:Ng,backendName:"webgl",kernelFunc:GB},KB={kernelName:Tf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:i,crops:a}=r;Ip(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((e,t)=>e*t),u=Jk(s.shape,i,o),l=eC(u.length,i.length),c=tC(s.shape,i,o),h=nC(a,i.length),d=rC(c,a,i.length),p=[],f=VV({inputs:{x:s},backend:n,attrs:{shape:u}}),m=ZV({inputs:{x:f},backend:n,attrs:{perm:l}}),g=VV({inputs:{x:m},backend:n,attrs:{shape:c}}),b=GB({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},XB={kernelName:Af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:i}=t,{size:a}=r,o=n.readSync(s.dataId),u=n.readSync(i.dataId),l=Ez(o,u,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,l)}},ZB=FV({opSnippet:"return float(a != b);",dtype:"bool"}),YB={kernelName:eg,backendName:"webgl",kernelFunc:ZB};function QB(e){const{inputs:t,backend:n}=e,{input:r}=t;return kV({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const JB={kernelName:dg,backendName:"webgl",kernelFunc:QB},eW={kernelName:Rf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:i}=n,{dtype:a}=s;if("complex64"===a){if("complex64"===i.dtype)return kV({inputs:{x:i},backend:r});const t=iw(i.shape),n=e({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),s=IV({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===i.dtype){const t=QB({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:a}});return r.disposeIntermediateTensorInfo(t),n}if(!zp(i.dtype,a)){const e=kV({inputs:{x:i},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:a}}if("int32"===a)return function(e,t){const n=new dV(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,r);if("bool"===a){const e=r.makeTensorInfo([],"bool",Lp("bool",1)),t=ZB({inputs:{a:i,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}},tW="return ceil(x);",nW=RV({opSnippet:tW,packedOpSnippet:tW,cpuKernelImpl:Tz}),rW={kernelName:Ff,backendName:"webgl",kernelFunc:nW};class sW{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class iW{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const aW={kernelName:Df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:i,clipValueMax:a}=r;let o;o=af().getBool("WEBGL_PACK_CLIP")?new iW(s.shape):new sW(s.shape);const u=o.getCustomSetupFunc(i,a);return n.runWebGLProgram(o,[s],s.dtype,u)}};class oW{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function uW(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const lW={kernelName:Mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),i=new oW(r.shape),a=[uW(r,s.complexTensorInfos.real),uW(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(i,a,a[0].dtype)}};class cW{constructor(e){this.outputShape=[],this.outputShape=Xk(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<t.length;r++)n.push(`else if (yC < ${t[r]}) setOutput(getT${r}(yR, yC-${t[r-1]}));`);n.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class hW{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Xk(e,t);const n=this.outputShape,r=n.length,s=Cz(r),i=iV("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);const o=new Array(e.length-1);o[0]=e[0][t];for(let p=1;p<o.length;p++)o[p]=o[p-1]+e[p][t];const u=a[t],l=a.slice(-2),c=a.join();let h=`if (${u} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let p=1;p<o.length;p++){const e=o[p-1];h+=`\n        if (${u} < ${o[p]}  && ${u} >= ${o[p-1]}) {\n          return getChannel(\n            getT${p}(${dW(a,u,e)}),\n            vec2(${dW(l,u,e)}));\n        }`}const d=o[o.length-1];h+=`\n        return getChannel(\n          getT${o.length}(${dW(a,u,d)}),\n          vec2(${dW(l,u,d)}));`,this.userCode=`\n      float getValue(${a.map(e=>"int "+e)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function dW(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}function pW(e){const{inputs:t,backend:n}=e,{input:r}=t;return kV({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const fW={kernelName:Im,backendName:"webgl",kernelFunc:pW};function mW(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map(e=>QB({inputs:{input:e},backend:n})),s=e.map(e=>pW({inputs:{input:e},backend:n})),i=mW(r,t,n),a=mW(s,t,n),o=IV({inputs:{real:i,imag:a},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map(e=>{const r=Ep(e.shape.slice(t));return VV({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})}),i=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),a=Xk(s.map(e=>e.shape),1),o=Az(i,a,r,1===s[0].shape[0]),u=Xk(e.map(e=>e.shape),t),l=n.makeTensorInfo(u,r,o);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}if(e.length>af().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),s=mW(e.slice(0,r),t,n),i=mW(e.slice(r),t,n),a=mW([s,i],t,n);return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),a}if(af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const s=new hW(e.map(e=>e.shape),t);return n.runWebGLProgram(s,e,r)}const{tensors2D:i,outShape:a}=function(e,t,n){const r=Xk(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>VV({inputs:{x:e},attrs:{shape:[-1,Ep(e.shape.slice(t))]},backend:n})),outShape:r}}(e,t,n),o=new cW(i.map(e=>e.shape)),u=n.runWebGLProgram(o,i,r);i.forEach(e=>n.disposeIntermediateTensorInfo(e));const l=VV({inputs:{x:u},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(u),l}function gW(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,i=Op(s,t[0].shape)[0],a=Xk(t.map(e=>e.shape),i);if(0===Ep(a))return n.makeTensorInfo(a,t[0].dtype,[]);const o=t.filter(e=>Ep(e.shape)>0);return 1===o.length?kV({inputs:{x:o[0]},backend:n}):(Kk(o.map(e=>e.shape),i),mW(o,i,n))}const bW={kernelName:Lf,backendName:"webgl",kernelFunc:gW};class yW{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class vW{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${i}, ${a});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xW{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:s,strideWidth:i,strideHeight:a,padInfo:o,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=o,f=s*r,m=ZP(),g="channelsLast"===h,b=g?0:1,y=g?1:2;let v="";for(let x=0;x<=1;x++)for(let n=0;n<=1;n++)v+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${x};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${a} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[b]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${i}. - ${d}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${t[y]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*x+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*x+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}function wW({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=e.shape,l=r.texData.get(e.dataId),c="channelsLast"===n.dataFormat;let h;const d=[],p=u[2]%2!=0&&!!l.isPacked;if((1!=u[0]*u[1]*u[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&af().getBool("WEBGL_LAZILY_UNPACK")&&af().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&p){const p={dataId:e.dataId,shape:[1,c?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),n.inChannels],dtype:e.dtype},f=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Ip(WP(l.shape,p.shape),()=>`packed reshape ${l.shape} to ${p.shape} isn't free`);const m=VV({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});d.push(m);const g=QV({a:p,b:m,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),b=r.texData.get(g.dataId);Ip(b.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=f,b.shape=n.outShape,h=kV({inputs:{x:g},backend:r}),h.shape=n.outShape,d.push(g)}else{const l=VV({inputs:{x:e},backend:r,attrs:{shape:[1,c?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),p=VV({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=QV({a:l,b:p,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:o,preluActivationWeights:i,leakyreluAlpha:a});h=VV({inputs:{x:f},backend:r,attrs:{shape:n.outShape}}),d.push(l),d.push(p),d.push(f)}for(const f of d)r.disposeIntermediateTensorInfo(f);return h}function kW({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=u*l*c,g=d*h,b=[m,g],y=[],v=VV({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),x=VV({inputs:{x:t},backend:r,attrs:{shape:[1,m,Ep(t.shape)/m]}});y.push(v),y.push(x);const w=new xW(b,v.shape,n),k=r.runWebGLProgram(w,[v],"float32"),C=VV({inputs:{x:k},backend:r,attrs:{shape:[1,b[0],b[1]]}});y.push(k),y.push(C);const I=null!=s,_=null!=i,S="leakyrelu"===o,N=o?DV(o,!0):null,E=new OV(C.shape,x.shape,[1,g,n.outChannels],!0,!1,I,N,_,S),$=[C,x];if(s&&$.push(s),_&&$.push(i),S){const e=r.makeTensorInfo([],"float32",fb(a,"float32"));$.push(e),y.push(e)}const T=r.runWebGLProgram(E,$,"float32"),A=VV({inputs:{x:T},backend:r,attrs:{shape:f?[1,d,h,n.outChannels]:[1,n.outChannels,d,h]}});y.push(T);for(const R of y)r.disposeIntermediateTensorInfo(R);return A}const CW={kernelName:Pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:a,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r,h=Kv(u),d=zv(s.shape,i.shape,a,l,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(af().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])p=kW({x:s,filter:i,convInfo:d,backend:n});else{const e=new yW(d);p=n.runWebGLProgram(e,[s,i],"float32")}else p=wW({x:s,filter:i,convInfo:d,backend:n});const f=VV({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class IW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===e.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _W{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r="channelsLast"===e.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${r?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${r?1:2}], coords[${r?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${e.strideDepth} - ${e.padInfo.front};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class NW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const EW={kernelName:zf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:a,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,h=Kv(u),d=zv(s.shape,c,a,1,o,l,!1,h),p=new IW(d);return n.runWebGLProgram(p,[s,i],"float32")}},$W={kernelName:Vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{inputShape:a,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r,h=Kv(l),d=zv(a,i.shape,o,1,u,c,!1,h),p=new _W(d);return n.runWebGLProgram(p,[s,i],"float32")}},TW={kernelName:Bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:a,pad:o,dilations:u}=r,l=Vv(s.shape,i.shape,a,u,o),c=new vW(l);return n.runWebGLProgram(c,[s,i],"float32")}},AW={kernelName:Wf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:a,pad:o,filterShape:u}=r,l=Vv(s.shape,u,a,1,o),c=new SW(l);return n.runWebGLProgram(c,[s,i],"float32")}},RW={kernelName:Uf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{pad:a,strides:o,inputShape:u}=r,l=Vv(u,i.shape,o,1,a),c=new NW(l);return n.runWebGLProgram(c,[s,i],"float32")}},FW=RV({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),DW={kernelName:qf,backendName:"webgl",kernelFunc:FW},OW=RV({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),MW={kernelName:jf,backendName:"webgl",kernelFunc:OW};class LW{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,o,u]=e,[l]=t,[c,h]=n;this.outputShape=[l,c,h,u];const d="bilinear"===r?1:0,[p,f]=[a-1+".0",o-1+".0"],[m,g,b]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,v,x]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const PW={kernelName:Hf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:i,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:l}=r,c=new LW(s.shape,i.shape,o,u,l);return n.runWebGLProgram(c,[s,i,a],"float32")}};class zW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,s=t?"0.0":`getX(${VW(r,"coords")})`,i=e[e.length-1];let a="",o="";t?(a=n?"end != "+(i-1):"end != 0",o=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",o=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${Cz(r)} coords = getOutputCoords();\n        int end = ${BW(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${a}) {\n          int idx = ${o};\n          ${BW(r,"coords")} = idx;\n          val += getX(${VW(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function VW(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function BW(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const WW={kernelName:Gf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,exclusive:a,reverse:o}=r,u=s.shape.length,l=Yx([i],u);let c=s;null!=l&&(c=ZV({inputs:{x:s},backend:n,attrs:{perm:l}}));const h=Jx(1,u)[0];if(h!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${i}`);const d=c.shape[h];let p=kV({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const e=new zW(c.shape,!1,o),t=e.getCustomSetupFunc(f),r=p;p=n.runWebGLProgram(e,[p],p.dtype,t),n.disposeIntermediateTensorInfo(r)}if(a){const e=new zW(c.shape,a,o),t=p;p=n.runWebGLProgram(e,[p],p.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=ZV({inputs:{x:p},backend:n,attrs:{perm:Qx(l)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),e}return p}},UW={kernelName:Kf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:i}=t,{size:a,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(i.dataId),r=Ez(e,t,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(i),r=$z(e,t,a,o);return n.makeTensorInfo(r.shape,i.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class qW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const jW={kernelName:Xf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:i,dataFormat:a}=r;Ip(i>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${i}`);const o=s.shape[0],u=("NHWC"===a?s.shape[1]:s.shape[2])*i,l=("NHWC"===a?s.shape[2]:s.shape[3])*i,c=("NHWC"===a?s.shape[3]:s.shape[1])/(i*i),h=new qW("NHWC"===a?[o,u,l,c]:[o,c,u,l],i,a);return n.runWebGLProgram(h,[s],s.dtype)}};class GW{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.inHeight,a=e.inWidth,o=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",b="";n&&(g=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${i}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${a}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${b}\n        setOutput(result);\n      }\n    `}}class HW{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const i=e.outChannels/e.inChannels,a=e.inHeight,o=e.inWidth,u=e.padInfo.top,l=e.padInfo.left,c=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=m;let b="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let w=0;w<m;w++)b+=`\n          vec4 xTexelC${2*w};\n          int xTexelC${2*w}Ready;\n          vec4 xC${w};`;for(let w=0;w<f;w++){for(let e=0;e<m;e++)b+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xC${e} = vec4(0.0);`;b+=`\n        xR = xRCorner + ${w*d};\n        if (xR >=0 && xR < ${a}) {\n      `;for(let e=0;e<(g+1)/2;e++){const t=2*e,n=t*p;if(b+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(t<m&&(l%2==1?(b+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,b+=1===p&&n>0?`\n                xC${t} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${o}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):b+=`\n                if (xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${t} = xTexelC${n};\n                `,n+1<m)){const e=l%2==0?Cp(p):p;p%2==0&&l%2==1||p%2!=0&&l%2!=1?(b+=`\n                  xCOffset = xC + ${l%2} + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${o}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,p>1&&(b+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),b+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):b+=1===e?`\n                    xC${t+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${o}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${n+2};\n                    `}}else n<m&&(l%2==1?(b+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(b+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(b+=`\n                if(xC >= 0 && xC < ${o} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${o}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${o} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${o}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(b+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));t<m&&(b+=`\n            wTexel = getW(${w}, ${n}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(b+=`\n              wTexel = getW(${w}, ${n+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}b+="\n        }\n      "}let y="",v="";n&&(y=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,v="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${u}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${b}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${x}\n        ${v}\n        setOutput(result);\n      }\n    `}}const KW={kernelName:Zf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:a,pad:o,dilations:u,dimRoundingMode:l}=r;let c=u;null==c&&(c=[1,1]),Ip(Hv(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=zv(s.shape,i.shape,a,c,o,l,!0);let d;return d=af().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new HW(h):new GW(h),n.runWebGLProgram(d,[s,i],"float32")}};class XW{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ZW{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const YW={kernelName:Yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r,h=zv(s.shape,c,a,o,u,l,!0),d=new XW(h);return n.runWebGLProgram(d,[s,i],"float32")}},QW={kernelName:Qf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:i}=t,{strides:a,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r,h=zv(c,i.shape,a,o,u,l,!0),d=new ZW(h);return n.runWebGLProgram(d,[s,i],"float32")}};class JW{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const eU={kernelName:Jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],i=Ep(r.shape),a=VV({inputs:{x:r},backend:n,attrs:{shape:[i]}}),o=new JW(i),u=n.runWebGLProgram(o,[a],a.dtype),l=VV({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}};class tU{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:o,dilationHeight:u,dilationWidth:l}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const nU={kernelName:em,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i}=t,{strides:a,pad:o,dilations:u}=r,l=Mv(s.shape,i.shape,a,o,"NHWC",u);let c;const h=new tU(l);c=n.runWebGLProgram(h,[s,i],"float32");const d=VV({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),d}},rU={kernelName:sm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,i=t,{allDims:a,summedDims:o,idDims:u}=NC(s,i.length);$C(a.length,u,i);const{path:l,steps:c}=TC(o,u),h=c.length;let d=null,p=a.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=EC(p,u[e]);let s;AC(t)?s=i[e]:(s=ZV({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),f.push(s));const a=s.shape.slice();for(let e=0;e<r.length;++e)a.splice(r[e],0,1);$p(s.shape,a)||(s=VV({inputs:{x:s},backend:n,attrs:{shape:a}}),f.push(s)),null===d?d=s:(d=PV({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=KV({inputs:{x:d},backend:n,attrs:{axis:l[m]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},sU=RV({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),iU={kernelName:im,backendName:"webgl",kernelFunc:sU},aU={kernelName:am,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,i=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wV("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new xV("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(i,[r,s],r.dtype)}},oU=FV({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),uU={kernelName:um,backendName:"webgl",kernelFunc:oU},lU=RV({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${cC};\n  float a1 = ${hC};\n  float a2 = ${dC};\n  float a3 = ${pC};\n  float a4 = ${fC};\n  float a5 = ${mC};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),cU={kernelName:om,backendName:"webgl",kernelFunc:lU},hU="return exp(x);",dU=RV({opSnippet:hU,packedOpSnippet:hU,cpuKernelImpl:Rz}),pU={kernelName:lm,backendName:"webgl",kernelFunc:dU};function fU(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:i}=t,a=i.shape.length,o=i.shape.slice();let u=s;return s<0&&(Ip(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),o.splice(u,0,1),VV({inputs:{x:i},backend:r,attrs:{shape:o}})}const mU={kernelName:cm,backendName:"webgl",kernelFunc:fU},gU="return exp(x) - 1.0;",bU=RV({opSnippet:gU,packedOpSnippet:gU,cpuKernelImpl:Fz}),yU={kernelName:hm,backendName:"webgl",kernelFunc:bU};class vU{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";let a;if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function xU(e,t,n){const r=n.texData.get(e.dataId),s=Ep(e.shape),i=e.shape[e.shape.length-1],a=VV({inputs:{x:e},backend:n,attrs:{shape:[s/i,i]}}),o=a.shape,u=new vU("real",o,t),l=new vU("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(u,c,"float32"),d=n.runWebGLProgram(l,c,"float32"),p=IV({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=VV({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),f}const wU={kernelName:dm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return xU(r,!1,n)}};class kU{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function CU(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:i}=n;if(i=i||qp(s),"string"===i){const e=Pp(i,Ep(r));return e.fill(s),t.makeTensorInfo(r,i,e)}{const e=new kU(r,s),n=e.getCustomSetupFunc(s);return t.runWebGLProgram(e,[],i,n)}}const IU={kernelName:pm,backendName:"webgl",kernelFunc:CU};class _U{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const SU={kernelName:fm,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new _U(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},NU="return floor(x);",EU=RV({opSnippet:NU,packedOpSnippet:NU,cpuKernelImpl:Dz}),$U={kernelName:mm,backendName:"webgl",kernelFunc:EU},TU=FV({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),AU={kernelName:gm,backendName:"webgl",kernelFunc:TU};class RU{constructor(e){this.variableNames=["A"];const t=ZP(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class FU{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ZP(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const DU={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:i}=r,a="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[u,l]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],h=[l,u,i];(o||a)&&(null==OU&&(OU=document.createElement("canvas").getContext("2d")),OU.canvas.width=u,OU.canvas.height=l,OU.drawImage(s,0,0,u,l),s=OU.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=kP.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=af().getBool("WEBGL_PACK")?new FU(h):new RU(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let OU;const MU={kernelName:sb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=Kv(c),g=zv(s.shape,i.shape,u,h,l,d,!1,m);let b;const y=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(af().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])b=kW({x:s,filter:i,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=null!=a,t=null!=o,r="leakyrelu"===p,u=p?DV(p,!1):null,l=new yW(g,e,u,t,r),c=[s,i];if(a&&c.push(a),o&&c.push(o),r){const e=n.makeTensorInfo([],"float32",fb(f,"float32"));c.push(e),y.push(e)}b=n.runWebGLProgram(l,c,"float32")}else b=wW({x:s,filter:i,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const v=VV({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(e=>n.disposeIntermediateTensorInfo(e)),v}},LU={kernelName:ib,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:i,bias:a,preluActivationWeights:o}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Ip(Hv(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=zv(s.shape,i.shape,u,m,l,h,!0),b=af().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=d?DV(d,b):null,v=[s,i],x=null!=a,w=null!=o,k="leakyrelu"===d;if(x&&v.push(a),w&&v.push(o),k){const e=n.makeTensorInfo([],"float32",fb(p,"float32"));v.push(e),f.push(e)}let C;C=b?new HW(g,x,y,w,k):new GW(g,x,y,w,k);const I=n.runWebGLProgram(C,v,"float32");return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),I}};class PU{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=Cz(t.length),s=Cz(n.length);this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const zU={kernelName:vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,i=s.shape,a=i[i.length-1],[o,u,l,c]=sC(r,s),h=VV({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),d=VV({inputs:{x:r},backend:n,attrs:{shape:[Ep(r.shape)/l,l]}}),p=new PU(a,c,[u,l]),f=n.runWebGLProgram(p,[d,h],d.dtype),m=VV({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}};class VU{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Cz(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)r.push(2===s?"int(getIndices(resRC.x, resRC.z))":`${n[s]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}const BU={kernelName:ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:i}=t,{axis:a,batchDims:o}=r,u=MC(s,i,Op(a,s.shape)[0],o),l=Ep(i.shape),c=[],h=VV({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=VV({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});c.push(h),c.push(d);const p=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const e=n.bufferSync(d),t=n.bufferSync(h),r=Oz(t,e,p);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const f=new VU(h.shape,p),m=n.runWebGLProgram(f,[h,d],h.dtype);c.push(m);const g=VV({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},WU=FV({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Mz,dtype:"bool"}),UU={kernelName:xm,backendName:"webgl",kernelFunc:WU},qU=FV({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),jU={kernelName:wm,backendName:"webgl",kernelFunc:qU},GU={kernelName:Cm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return xU(r,!0,n)}},HU=RV({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),KU={kernelName:_m,backendName:"webgl",kernelFunc:HU},XU=RV({opSnippet:"return float(isinf(x));",dtype:"bool"}),ZU={kernelName:Sm,backendName:"webgl",kernelFunc:XU},YU=RV({opSnippet:"return float(isnan(x));",dtype:"bool"}),QU={kernelName:Nm,backendName:"webgl",kernelFunc:YU},JU=FV({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Lz,dtype:"bool"}),eq={kernelName:$m,backendName:"webgl",kernelFunc:JU},tq=FV({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),nq={kernelName:Tm,backendName:"webgl",kernelFunc:tq},rq={kernelName:Am,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:i}=n,a=Pz(r,s,i);return t.makeTensorInfo([a.length],"float32",a)}},sq=RV({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:zz}),iq={kernelName:Rm,backendName:"webgl",kernelFunc:sq},aq=RV({opSnippet:"return log(1.0 + x);"}),oq={kernelName:Fm,backendName:"webgl",kernelFunc:aq},uq=FV({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),lq={kernelName:Dm,backendName:"webgl",kernelFunc:uq},cq=RV({opSnippet:"return float(!(x >= 1.0));"}),hq={kernelName:Om,backendName:"webgl",kernelFunc:cq},dq=FV({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),pq={kernelName:Mm,backendName:"webgl",kernelFunc:dq};class fq{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const i=t,a=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class mq{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const gq={kernelName:Lm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:i,bias:a,alpha:o,beta:u}=r,l=af().getBool("WEBGL_PACK_NORMALIZATION")?new mq(s.shape,i,a,o,u):new fq(s.shape,i,a,o,u);return n.runWebGLProgram(l,[s],s.dtype)}};class bq{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const yq={kernelName:Pm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:i,dy:a}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r,h=new bq(s.shape,o,u,l,c);return n.runWebGLProgram(h,[s,i,a],s.dtype)}};function vq(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:i,keepDims:a}=r,o=s.shape.length,u=Op(i,s.shape);let l=u;const c=Yx(l,o),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=nV(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype),n.texData.get(p.dataId).values=r}else p=HV(s,c,n);l=Jx(l.length,o)}Zx("max",l,o);const[f,m]=Kx(p.shape,l);let g,b=f;if(a&&(b=Xx(f,u)),d){const e=n.texData.get(p.dataId),t=Vz(e.values,Ep(m),b,s.dtype);g=n.makeTensorInfo(b,s.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=Ep(t),i=VV({inputs:{x:e},attrs:{shape:[Ep(e.shape)/s,s]},backend:r}),a=qV(i,e.dtype,"max",r),o=VV({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}(p,m,b,n);return h&&n.disposeIntermediateTensorInfo(p),g}const xq={kernelName:zm,backendName:"webgl",kernelFunc:vq},wq=FV({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Bz}),kq={kernelName:Vm,backendName:"webgl",kernelFunc:wq},Cq={kernelName:Bm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;KP(s,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=r;Ip(Hv(a,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`);const l=Lv(s.shape,i,a,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&$p(l.inShape,l.outShape))return kV({inputs:{x:s},backend:n});const c=new AB(l,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},Iq={kernelName:Um,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:l}=r,c=Pv(s.shape,i,a,[1,1,1],o,l,u),h=new RB(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class _q{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n          wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${t*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Sq{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n           wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${t*n*r-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${r} +\n                  wR * ${r} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Nq={kernelName:qm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i}=t,a=i,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=Pv(a.shape,o,u,[1,1,1],l,c),d=new RB(h,"max",!0),p=n.runWebGLProgram(d,[a],a.dtype),f=new Sq(h),m=n.runWebGLProgram(f,[s,p],a.dtype);return n.disposeIntermediateTensorInfo(p),m}},Eq={kernelName:Wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:i,output:a}=t,o=i;KP([i,a],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,d=Lv(o.shape,u,l,1,c,h),p=new AB(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new _q(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},$q={kernelName:jm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:i,pad:a,includeBatchInIndex:o}=t,u=n;Ip(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];Ip(Hv(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Lv(r.shape,s,i,l,a),[h,d]=function(e,t,n,r){let s=new AB(n,"max",!1);const i=r.runWebGLProgram(s,[e],"float32");return s=new AB(n,"max",!0,!0,t),[i,r.runWebGLProgram(s,[e],"float32")]}(r,o,c,u);return[h,d]}},Tq={kernelName:Gm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:i}=t,a=n,o=r.shape.length,u=Op(i,r.shape);let l=u;const c=Yx(l,o),h=null!=c,d=a.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const e=a.texData.get(f.dataId).values,t=new Array(o);for(let s=0;s<t.length;s++)t[s]=r.shape[c[s]];const n=nV(e,r.shape,r.dtype,c,t);f=a.makeTensorInfo(t,r.dtype),a.texData.get(f.dataId).values=n}else f=HV(r,c,a);p.push(f),l=Jx(l.length,o)}Zx("sum",l,o);const[m,g]=Kx(f.shape,l);let b=m;s&&(b=Xx(m,u));const y=function(e,t,n,r){const s=Ep(t),i=VV({inputs:{x:e},attrs:{shape:[Ep(e.shape)/s,s]},backend:r}),a=qV(i,"float32","mean",r),o=VV({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}(f,g,b,a);for(const v of p)a.disposeIntermediateTensorInfo(v);return y}},Aq={kernelName:Hm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r,o=s.shape.length,u=Op(i,s.shape);let l=u;const c=Yx(l,o);let h=s;null!=c&&(h=ZV({inputs:{x:s},backend:n,attrs:{perm:c}}),l=Jx(l.length,s.shape.length)),Zx("min",l,o);const[d,p]=Kx(h.shape,l),f=VV({inputs:{x:h},backend:n,attrs:{shape:[-1,Ep(p)]}}),m=qV(f,f.dtype,"min",n);let g;return g=VV(a?{inputs:{x:m},backend:n,attrs:{shape:Xx(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},Rq=FV({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Wz}),Fq={kernelName:Km,backendName:"webgl",kernelFunc:Rq};class Dq{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Cz(r),i=t.map(e=>e[0]).join(","),a=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${i});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Oq{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Cz(r),i=t.map(e=>e[0]).join(","),a=t.map((t,n)=>t[0]+e[n]).join(","),o=iV("rc",r),u=iV("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${i});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const Mq={kernelName:Xm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:i}=n,a=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Oq(r.shape,s,i):new Dq(r.shape,s,i);return t.runWebGLProgram(a,[r],r.dtype)}},Lq=FV({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Pq={kernelName:Zm,backendName:"webgl",kernelFunc:Lq};class zq{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const Vq=FV({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Bq={kernelName:rm,backendName:"webgl",kernelFunc:Vq},Wq="return a - b;",Uq=FV({opSnippet:Wq,packedOpSnippet:Wq,supportsComplex:!0,cpuKernelImpl:Jz}),qq={kernelName:qg,backendName:"webgl",kernelFunc:Uq};function jq(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:i}=r,a=Op([i],s.shape),o=vq({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),u=Xx(o.shape,a),l=VV({inputs:{x:o},backend:n,attrs:{shape:u}}),c=Uq({inputs:{a:s,b:l},backend:n}),h=dU({inputs:{x:c},backend:n}),d=KV({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:!1}}),p=VV({inputs:{x:d},backend:n,attrs:{shape:u}}),f=Vq({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const Gq={kernelName:Lg,backendName:"webgl",kernelFunc:jq},Hq={kernelName:Ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:i,seed:a,normalized:o}=r,u=o?s:jq({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=new zq(u.shape[0],u.shape[1],i),c=l.getCustomSetupFunc(a),h=n.runWebGLProgram(l,[u],"int32",c);return o||n.disposeIntermediateTensorInfo(u),h}},Kq="return -x;",Xq={kernelName:Jm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=qz(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mV(r.shape,Kq):new dV(r.shape,Kq),n.runWebGLProgram(s,[r],r.dtype)}},Zq=hk,Yq={kernelName:tg,backendName:"webgl",kernelFunc:function(e){gC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=Zq(l,c,a,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Qq=dk,Jq={kernelName:ng,backendName:"webgl",kernelFunc:function(e){gC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(s.dataId),h=n.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=Qq(c,h,a,o,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},ej=pk,tj={kernelName:rg,backendName:"webgl",kernelFunc:function(e){gC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),h=n.readSync(i.dataId),d=a,p=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=ej(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class nj{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const rj={kernelName:ig,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:i,onValue:a,offValue:o}=r,u=Ep(s.shape),l=new nj(u,i,a,o),c=VV({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(l,[c],s.dtype);n.disposeIntermediateTensorInfo(c);const d=VV({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(h),d}};function sj(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=QB({inputs:{input:r},backend:n}),t=sj({inputs:{x:e},backend:n}),s=pW({inputs:{input:r},backend:n}),i=sj({inputs:{x:s},backend:n}),a=IV({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),a}return CU({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const ij={kernelName:eb,backendName:"webgl",kernelFunc:sj},aj={kernelName:sg,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=QB({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),i=pW({inputs:{input:s},backend:r}),a=sj({inputs:{x:i},backend:r}),o=IV({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}return CU({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},oj={kernelName:ag,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return fU({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const i=t[0].shape,a=t[0].dtype;t.forEach(e=>{_p(i,e.shape,"All tensors passed to stack must have matching shapes"),Ip(a===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=gW({inputs:t.map(e=>{const t=fU({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};class uj{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Cz(r),i=t.map(e=>e[0]).join(","),a=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${i});\n      ${s} end = ${s}(${a});\n      uniform float value;\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class lj{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=Cz(r),i=t.map(e=>e[0]).join(","),a=t.map((t,n)=>t[0]+e[n]).join(","),o=iV("rc",r),u=iV("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${l}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${i});\n      const ${s} end = ${s}(${a});\n      uniform float value;\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}const cj=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:i,constantValue:a}=r,o=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lj(s.shape,i,a):new uj(s.shape,i,a),u=o.getCustomSetupFunc(a);return n.runWebGLProgram(o,[s],s.dtype,u)},hj={kernelName:og,backendName:"webgl",kernelFunc:cj},dj=FV({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),pj={kernelName:ug,backendName:"webgl",kernelFunc:dj},fj={kernelName:cg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r,o=s.shape.length,u=[],l=Op(i,s.shape);let c=l;const h=Yx(c,o);let d,p=s;if(null!=h&&(p=ZV({inputs:{x:s},backend:n,attrs:{perm:h}}),c=Jx(c.length,o),u.push(p)),Zx("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=jz(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=Kx(p.shape,c),r=Ep(t),i=VV({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),a=qV(i,Bb(s.dtype),"prod",n);d=VV({inputs:{x:a},backend:n,attrs:{shape:e}}),u.push(i),u.push(a)}if(a){u.push(d);const e=Xx(d.shape,l);d=VV({inputs:{x:d},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},mj=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:i,dtype:a}=n,o=Gz(r,s,i,a);return t.makeTensorInfo([o.length],a,o)},gj={kernelName:hg,backendName:"webgl",kernelFunc:mj},bj=RV({opSnippet:"return 1.0 / x;"}),yj={kernelName:pg,backendName:"webgl",kernelFunc:bj},vj=RV({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),xj={kernelName:fg,backendName:"webgl",kernelFunc:vj},wj=RV({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),kj={kernelName:xg,backendName:"webgl",kernelFunc:wj};class Cj{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[i,a,o,u]=e;this.outputShape=[i,t,n,u];const l=[r&&t>1?a-1:a,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Ij{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,u]=e;this.outputShape=[i,t,n,u];const l=[r&&t>1?a-1:a,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const _j={kernelName:yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,halfPixelCenters:a,size:o}=r,[u,l]=o,c=af().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ij(s.shape,u,l,i,a):new Cj(s.shape,u,l,i,a);return n.runWebGLProgram(c,[s],"float32")}};class Sj{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,i,a]=e,o=[n&&i>1?r-1:r,n&&a>1?s-1:s],u=[n&&i>1?i-1:i,n&&a>1?a-1:a],l=o[0]/u[0],c=o[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Nj={kernelName:vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:i}=t,{alignCorners:a}=r,o=new Sj(i.shape,s.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class Ej{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[i,a,o,u]=e;this.outputShape=[i,t,n,u];const l=[r&&t>1?a-1:a,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class $j{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,u]=e;this.outputShape=[i,t,n,u];const l=[r&&t>1?a-1:a,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Tj={kernelName:gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,halfPixelCenters:a,size:o}=r,[u,l]=o,c=af().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new $j(s.shape,u,l,i,a):new Ej(s.shape,u,l,i,a);return n.runWebGLProgram(c,[s],s.dtype)}};class Aj{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,i,a]=e,o=[n&&i>1?r-1:r,n&&a>1?s-1:s],u=[n&&i>1?i-1:i,n&&a>1?a-1:a],l=o[0]/u[0],c=o[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Rj={kernelName:bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:i}=t,{alignCorners:a}=r,o=new Aj(i.shape,s.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class Fj{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=Cz(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class Dj{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=iV("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Cz(n);function o(n){const r=e.map((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Oj={kernelName:wg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:i}=r,a=s.shape.length,o=Op(i,s.shape);if(0===a)return kV({inputs:{x:s},backend:n});const u=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dj(s.shape,o):new Fj(s.shape,o);return n.runWebGLProgram(u,[s],s.dtype)}};class Mj{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(e,t,n,r){return(s,i)=>{null==this.paramsLoc&&(this.paramsLoc=s.getUniformLocationNoThrow(i,"params")),s.gl.uniform4f(this.paramsLoc,e,t,n,r)}}}const Lj={kernelName:nb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:i,center:a}=t,o=n,u=new Mj(r.shape,i),[l,c]=Qk(a,r.shape[1],r.shape[2]),h=u.getCustomSetupFunc(l,c,Math.sin(s),Math.cos(s));return o.runWebGLProgram(u,[r],r.dtype,h)}},Pj=RV({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),zj={kernelName:kg,backendName:"webgl",kernelFunc:Pj},Vj=RV({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Hz}),Bj={kernelName:Cg,backendName:"webgl",kernelFunc:Vj};class Wj{constructor(e,t,n,r,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const o=Cz(s.length),u=Cz(i.length);let l="";1===n?l="i":2===n&&(l="i, j");let c="";1===r?c="i":2===r&&(c="i, coords[1]"),this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${l}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const Uj={kernelName:Ig,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:i}=t,{shape:a}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=oC(0,s,a),d=[h/l,l];if(0===h)return n.makeTensorInfo(a,s.dtype);const p=VV({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),f=VV({inputs:{x:i},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new Wj(u,o,p.shape.length,f.shape.length,c,d),b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=VV({inputs:{x:b},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class qj{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let r=0;r<t.length;r++)a.push(`${n[r]}`),r<e&&i.push(`${n[r]}`);r=i.join(),s=a.join()}const i=Cz(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const jj={kernelName:_g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:i}=t,a=new qj(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(a,[r,s,i],Vb(s.dtype,i.dtype))}},Gj=RV({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${uC};\n  float scale = ${lC};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Hj={kernelName:Sg,backendName:"webgl",kernelFunc:Gj},Kj=RV({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),Xj={kernelName:Ag,backendName:"webgl",kernelFunc:Kj},Zj=RV({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Yj={kernelName:Tg,backendName:"webgl",kernelFunc:Zj},Qj=RV({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),Jj={kernelName:Eg,backendName:"webgl",kernelFunc:Qj},eG=RV({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),tG={kernelName:$g,backendName:"webgl",kernelFunc:eG},nG=RV({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),rG={kernelName:Rg,backendName:"webgl",kernelFunc:nG},sG={kernelName:Og,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:i,paddings:a}=r;Ip(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((e,t)=>e*t),u=[[0,0]];u.push(...a);for(let b=1+i.length;b<s.shape.length;++b)u.push([0,0]);const l=[],c=cj({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=Jk(c.shape,i,o,!1),d=eC(h.length,i.length,!1),p=tC(c.shape,i,o,!1),f=VV({inputs:{x:c},backend:n,attrs:{shape:h}}),m=ZV({inputs:{x:f},backend:n,attrs:{perm:d}}),g=VV({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(c),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},iG={kernelName:Pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:i,defaultValue:a}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.readSync(r.dataId),u=n.readSync(s.dataId),l=n.readSync(i.dataId),c=n.readSync(a.dataId)[0],[h,d,p,f,m]=Zz(o,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},aG={kernelName:zg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),u=Array.from(n.readSync(i.dataId)),[l,c,h]=Yz(o,r.shape,r.dtype,a,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},oG={kernelName:Vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:i,defaultValue:a}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,strides:c,outputSize:h}=oC(0,s,o),d=new Wj(l,u,s.shape.length,i.shape.length,c,[h,1],!1),p=n.runWebGLProgram(d,[i,s,a],i.dtype),f=VV({inputs:{x:p},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),f}},uG={kernelName:Mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:i,axis:a}=r,o=Op(a,s.shape)[0],u=FC(s,i,o),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(e=>{const t=[...c];t[o]=e;const r=GB({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,r})}},lG=RV({opSnippet:"return sqrt(x);"}),cG={kernelName:Fg,backendName:"webgl",kernelFunc:lG},hG={kernelName:Wg,backendName:"webgl",kernelFunc:RV({opSnippet:"return x * x;"})},dG="return (a - b) * (a - b);",pG=FV({opSnippet:dG,packedOpSnippet:dG}),fG={kernelName:Bg,backendName:"webgl",kernelFunc:pG},mG={kernelName:tb,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=new dV(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(s,[r],r.dtype)}};class gG{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=Cz(n.length),i=Cz(n.length);let a="";if(1===r)a="coords * strides + begin";else{let e=0;a=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const bG={kernelName:Ug,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:i,end:a,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:b,outShape:y}=yv(s.shape,i,a,o,u,l,c,h,d),v=VV({inputs:{x:s},backend:n,attrs:{shape:b}});let x;if(p){const e=GB({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});x=VV({inputs:{x:e},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(e)}else if(y.some(e=>0===e))x=n.makeTensorInfo(y,s.dtype,[]);else if(n.shouldExecuteOnCPU([v])){const e=n.texData.get(v.dataId),t=qy(v.shape,v.dtype,e.values),r=Qz(y,t,m,f);x=n.makeTensorInfo(y,v.dtype,r.values)}else{const e=new gG(f,m,y);x=n.runWebGLProgram(e,[v],v.dtype)}const w=VV({inputs:{x:x},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),w}},yG=RV({opSnippet:"return tan(x);"}),vG={kernelName:jg,backendName:"webgl",kernelFunc:yG},xG=RV({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),wG={kernelName:Gg,backendName:"webgl",kernelFunc:xG};class kG{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;const r=Cz(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function CG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>yb(e)):e,r=qy(s.shape,s.dtype,t),a=eV(r,i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new kG(s.shape,i);return n.runWebGLProgram(a,[s],s.dtype)}const IG={kernelName:Hg,backendName:"webgl",kernelFunc:CG},_G={kernelName:Kg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:i,sorted:a}=r,o=n.readSync(s.dataId),[u,l]=tV(o,s.shape,s.dtype,i,a);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};class SG{constructor(e,t,n,r,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===n?1:2;let o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const NG={kernelName:Xg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:l}=r,[c,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new SG(h,d,a,o,u,[c,f,m,p]);return n.runWebGLProgram(g,[s,i],"float32")}},EG={kernelName:Yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:i}=t;KP(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(i.dataId),{outputValues:o,outputShape:u,indices:l}=rV(a,s,i.shape,i.dtype);return[r.makeTensorInfo(u,i.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}},$G={kernelName:Qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const a=s,o=a.shape.length,u=s.shape[i],l=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==i&&(l[c++]=a.shape[m]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(u);for(let m=0;m<f.length;m++){d[i]=m;const e=GB({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),t=VV({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class TG{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,i=e.numSegments,a=i*Math.ceil(s/n);this.outputShape=[r,a];const o=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const AG=[gq,yq,JV,tB,rB,iB,uB,hB,dB,pB,vB,xB,kB,IB,EB,SB,TB,DB,FB,LB,PB,zB,WB,KB,XB,eW,rW,aW,lW,_V,bW,EW,$W,CW,AW,RW,TW,DW,MW,PW,WW,UW,jW,YW,QW,KW,eU,nU,rU,iU,aU,uU,cU,pU,mU,yU,wU,IU,SU,$U,AU,DU,MU,LU,zU,BU,UU,jU,CV,GU,fW,KU,ZU,QU,EV,eq,nq,rq,oq,iq,lq,hq,pq,xq,Iq,Cq,Nq,Eq,$q,kq,Tq,Aq,Fq,Mq,Pq,Hq,zV,Xq,Yq,Jq,tj,YB,rj,aj,oj,hj,pj,AV,fj,gj,JB,Bq,yj,kj,xj,BV,_j,Nj,Tj,Rj,Oj,Lj,zj,Bj,Uj,jj,Hj,Xj,Yj,Jj,tG,HB,Gq,rG,sG,iG,aG,oG,uG,cG,hG,fG,mG,bG,qq,XV,vG,wG,IG,_G,NG,YV,EG,$G,{kernelName:Jg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:i}=t,{numSegments:a}=r,o=s.shape.length,u=[];let l=0;const c=Yx([l],o);let h=s;null!=c&&(h=ZV({inputs:{x:s},backend:n,attrs:{perm:c}}),u.push(h),l=Jx(1,o)[0]);const d=OC(h.shape,l,a),p=Ep([h.shape[l]]),f=VV({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=Bb(s.dtype),g=(e,t,r,s,i)=>{const a=e.shape[0],o=e.shape[1],l=DC(o,i),c=new TG({windowSize:l,inSize:o,batchSize:a,numSegments:i},t),h=n.compileAndRun(c,[e,r],s);if(u.push(h),h.shape[1]===i)return h;const d=mj({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),p=CG({inputs:{x:d},backend:n,attrs:{reps:[o/l]}});return u.push(d),u.push(p),g(h,t,p,s,i)},b=VV({inputs:{x:g(f,"unsortedSegmentSum",i,m,a)},backend:n,attrs:{shape:d}});let y=b;if(null!=c){u.push(b);const e=Qx(c);y=ZV({inputs:{x:y},backend:n,attrs:{perm:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},ij];for(const oK of AG)hb(oK);let RG=(()=>{class e{constructor(){}loadModel(){var e=this;return bp(function*(){e.encoderModel=yield Q$("assets/encoder/model.json"),e.decoderModel=yield Q$("assets/decoder/model.json");const t=yield fetch("assets/tokenizer.json").then(e=>e.json());e.tokenizer=t.tokenizer,e.maxLenAnswers=t.maxlen_answers,e.maxLenQuestions=t.maxlen_questions})()}createEncoderModel(e){return bp(function*(){const t=e.input,n=e.getLayer(null,4).output;if(Array.isArray(n)){const[e,r,s]=n;return Y$({inputs:t,outputs:[r,s]})}throw new Error("La capa LSTM no devolvi\xf3 m\xfaltiples salidas.")})()}createDecoderModel(e){return bp(function*(){const t=J$({shape:[null],name:"decoder_inputs"}),n=[J$({shape:[200],name:"input_3"}),J$({shape:[200],name:"input_4"})],r=e.getLayer(null,3).apply(t),s=e.getLayer(null,5).apply([r,...n]),[i,a,o]=s,u=e.getLayer(null,6).apply(i),l=[a,o];return Y$({inputs:[t,...n],outputs:[u,...l]})})()}preprocessInput(e){const t=e.toLowerCase().split(" ").map(e=>this.tokenizer.word_index[e]||0),n=new Array(this.maxLenQuestions).fill(0);return t.slice(0,this.maxLenQuestions).forEach((e,t)=>{n[t]=e}),Fw([n],[1,this.maxLenQuestions])}decodeSequence(e){var t=this;return bp(function*(){const n=t.preprocessInput(e),r=t.encoderModel.predict(n);let s=Fw([[t.tokenizer.word_index.start]],[1,1]),i=uw(s,[[0,0],[0,t.maxLenAnswers-s.shape[1]]],0),a=!1,o="";for(;!a;){console.log("first padded ->",i);const[e,n,u]=t.decoderModel.predict([i,...r]);console.log("decoutputs -----\x3e",e,n,u);const l=yield e.argMax(-1).data();console.log("array --------\x3e",l);const c=l[0];let h=null;for(const[r,s]of Object.entries(t.tokenizer.word_index))if(c===s){o+=` ${r}`,h=r;break}console.log("sampled_word ->",h),("end"===h||o.split(" ").length>t.maxLenAnswers||0===c)&&(a=!0),s.dispose(),s=Fw([[c]],[1,1],"int32"),i.dispose(),i=uw(s,[[0,0],[0,t.maxLenAnswers-s.shape[1]]],0),r[0].dispose(),r[1].dispose(),r[0]=n,r[1]=u,e.dispose()}return o.replace(" end","").trim()})()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();const FG=JSON.parse('[{"input":"hola","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"buenas","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"hey","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"como estas","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"todo bien","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"adios","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"nos vemos","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"buenos dias","output":["buenos dias espero que tengas un excelente dia","hola como estas en este dia"]},{"input":"buenas tardes","output":["buenas tardes en que puedo ayudarte","que tal tu tarde, como puedo ayudarte?"]},{"input":"buenas noches","output":["buenas noches que descanses","dulces sue\xf1os, hasta ma\xf1ana"]},{"input":"como te llamas","output":["soy un asistente virtual pero puedes llamarme bot","me llamo bot, tu asistente"]},{"input":"que puedes hacer","output":["puedo responder preguntas, darte informacion y ayudarte en lo que necesites","estoy aqui para resolver tus dudas y ayudarte en lo que necesites"]},{"input":"gracias","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"perdon","output":["no te preocupes todo esta bien","no hay problema, como puedo ayudarte?"]},{"input":"lo siento","output":["no pasa nada, como puedo ayudarte?","no te preocupes, estoy aqui para ayudarte"]},{"input":"que hora es","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"que dia es hoy","output":["hoy es un gran dia, como puedo ayudarte?","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"ayuda","output":["por supuesto dime que necesitas y vere como ayudarte","estoy aqui para lo que necesites, dime como puedo ayudarte"]},{"input":"estoy triste","output":["lo siento mucho si necesitas hablar o apoyo estoy aqui","te entiendo, no estas solo, cuentame mas"]},{"input":"estoy feliz","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"cuentame un chiste","output":["por que los pajaros no usan facebook porque ya tienen twitter","que hace una abeja en el gimnasio zumba"]},{"input":"que es el nlp","output":["nlp significa procesamiento de lenguaje natural, una rama de la inteligencia artificial que se centra en la interaccion entre computadoras y humanos usando lenguaje natural","nlp se trata de ense\xf1ar a las maquinas a entender y responder en nuestro idioma"]},{"input":"dime algo interesante","output":["sabias que los pulpos tienen tres corazones y su sangre es azul?","sabias que la miel nunca se echa a perder?"]},{"input":"dime algo motivador","output":["nunca es tarde para perseguir tus sue\xf1os y lograr tus metas","los peque\xf1os pasos te llevan a grandes logros"]},{"input":"holaaa","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"que onda","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"buenas noches a todos","output":["buenas noches que descanses","dulces sue\xf1os, hasta ma\xf1ana"]},{"input":"como va todo","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"que tal estas","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"todo en orden","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"hasta luego","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"nos vemos luego","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"hasta pronto","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"que tengas un buen dia","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"muy buenas","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"gracias mil","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"muchisimas gracias","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"te agradezco mucho","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"lo lamento","output":["no pasa nada, como puedo ayudarte?","no te preocupes, estoy aqui para ayudarte"]},{"input":"que mal","output":["lo siento mucho si necesitas hablar o apoyo estoy aqui","te entiendo, no estas solo, cuentame mas"]},{"input":"estoy decaido","output":["lo siento mucho si necesitas hablar o apoyo estoy aqui","te entiendo, no estas solo, cuentame mas"]},{"input":"me siento bien","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"estoy animado","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"estoy de maravilla","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"me siento optimista","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"que hora tienes","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"cual es la hora","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"que dia tenemos","output":["hoy es un gran dia, como puedo ayudarte?","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"que dia es","output":["hoy es un gran dia, como puedo ayudarte?","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"estas disponible","output":["claro que si estoy aqui para ayudarte","estoy disponible, dime en qu\xe9 puedo ayudarte"]},{"input":"sigues disponible","output":["claro que si estoy aqui para ayudarte","estoy disponible, dime en qu\xe9 puedo ayudarte"]},{"input":"me puedes ayudar","output":["por supuesto dime que necesitas y vere como ayudarte","estoy aqui para lo que necesites, dime como puedo ayudarte"]},{"input":"me ayudas","output":["por supuesto dime que necesitas y vere como ayudarte","estoy aqui para lo que necesites, dime como puedo ayudarte"]},{"input":"cuanto es uno mas uno","output":["1 mas 1 es igual a 2","la respuesta es 2"]},{"input":"que es inteligencia artificial","output":["la inteligencia artificial es un campo que busca crear sistemas inteligentes","es la capacidad de una maquina para imitar procesos humanos como aprender y razonar"]},{"input":"dime algo increible","output":["sabias que el corazon de una ballena azul puede pesar hasta 400 kilos?","sabias que los tiburones han existido por m\xe1s de 400 millones de a\xf1os?"]},{"input":"cuentame algo impactante","output":["sabias que el corazon de una ballena azul puede pesar hasta 400 kilos?","sabias que los tiburones han existido por m\xe1s de 400 millones de a\xf1os?"]},{"input":"inspirame","output":["nunca es tarde para perseguir tus sue\xf1os y lograr tus metas","los peque\xf1os pasos te llevan a grandes logros","si puedes so\xf1arlo, puedes lograrlo"]},{"input":"dime algo positivo","output":["nunca es tarde para perseguir tus sue\xf1os y lograr tus metas","los peque\xf1os pasos te llevan a grandes logros","si puedes so\xf1arlo, puedes lograrlo"]},{"input":"holi","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"como va tu dia","output":["todo bien, gracias por preguntar","todo marcha bien, y el tuyo?"]},{"input":"me siento raro","output":["lo siento mucho, \xbfquieres hablar de ello?","estoy aqu\xed para escucharte, \xbfqu\xe9 pasa?"]},{"input":"dime algo chistoso","output":["\xbfPor qu\xe9 no hay fantasmas gordos? Porque siempre est\xe1n en forma.","\xbfQu\xe9 le dice una impresora a otra? \xa1Esa hoja es tuya!"]},{"input":"cuentame algo divertido","output":["\xbfPor qu\xe9 los p\xe1jaros no usan computadoras? \xa1Porque tienen Twitter!","\xbfQu\xe9 hace un perro con un taladro? \xa1Taladrando!"]},{"input":"que es machine learning","output":["es un subcampo de la inteligencia artificial que ense\xf1a a las computadoras a aprender patrones de los datos","machine learning es el proceso por el cual las m\xe1quinas pueden aprender y mejorar a partir de datos, sin ser programadas expl\xedcitamente"]},{"input":"que sabes sobre robots","output":["los robots son m\xe1quinas programables que pueden realizar tareas de manera aut\xf3noma o semiaut\xf3noma","un robot es un dispositivo que puede ser programado para realizar tareas espec\xedficas, algunas veces imitando comportamientos humanos"]},{"input":"estoy aburrido","output":["puedo contarte un chiste o un dato curioso, \xbfqu\xe9 prefieres?","\xbfQuieres que te cuente algo interesante o un chiste?"]},{"input":"me siento cansado","output":["descansa un poco, tu cuerpo y mente lo necesitan","es importante cuidar tu descanso, \xbfquieres que te motive?"]},{"input":"hablemos de ciencia","output":["claro, \xbfsab\xedas que la velocidad de la luz es de aproximadamente 299,792 km/s?","la ciencia es fascinante, \xbfsab\xedas que los \xe1tomos est\xe1n compuestos principalmente de espacio vac\xedo?"]},{"input":"dame datos curiosos","output":["\xbfSab\xedas que los delfines tienen nombres \xfanicos para identificarse entre ellos?","\xbfSab\xedas que las huellas dactilares de los koalas son tan parecidas a las humanas que pueden confundir a la polic\xeda?"]},{"input":"dime algo asombroso","output":["\xbfSab\xedas que el sol es tan grande que podr\xeda contener 1.3 millones de planetas Tierra?","\xbfSab\xedas que hay m\xe1s estrellas en el universo que granos de arena en todas las playas del mundo?"]},{"input":"que sabes sobre el universo","output":["el universo tiene miles de millones de galaxias, cada una con millones o miles de millones de estrellas","el universo est\xe1 en constante expansi\xf3n desde el Big Bang hace unos 13.8 mil millones de a\xf1os"]},{"input":"dame un consejo","output":["conf\xeda en ti mismo, eres capaz de lograr cosas incre\xedbles","cada peque\xf1o paso que tomes te lleva m\xe1s cerca de tus metas"]},{"input":"quiero aprender algo nuevo","output":["puedes aprender algo interesante sobre tecnolog\xeda o ciencia, \xbfpor d\xf3nde empezamos?","me encantar\xeda ayudarte a aprender, \xbfqu\xe9 tema te interesa?"]},{"input":"puedes darme informacion sobre IA","output":["claro, la inteligencia artificial es un campo que busca desarrollar sistemas capaces de realizar tareas que normalmente requieren inteligencia humana","la IA incluye subcampos como aprendizaje autom\xe1tico, procesamiento de lenguaje natural, y visi\xf3n por computadora"]},{"input":"me siento solo","output":["no est\xe1s solo, estoy aqu\xed para acompa\xf1arte","a veces todos necesitamos compa\xf1\xeda, cu\xe9ntame c\xf3mo puedo ayudarte"]},{"input":"puedes motivarme","output":["nunca te rindas, los grandes logros requieren tiempo y esfuerzo","cree en ti mismo, todo es posible si das lo mejor de ti"]},{"input":"cuentame algo inspirador","output":["la persistencia es la clave del \xe9xito, sigue intent\xe1ndolo","cada d\xeda es una nueva oportunidad para empezar de nuevo y lograr tus metas"]},{"input":"hola como estas","output":["estoy bien y tu"]},{"input":"buenos dias","output":["buenos dias como te sientes hoy"]},{"input":"hola que tal","output":["todo va bien por aqui y tu como estas"]},{"input":"hola todo bien","output":["si gracias como te va a ti"]},{"input":"hola me escuchas","output":["claro que si en que puedo ayudarte hoy"]},{"input":"buenas tardes","output":["buenas tardes espero que tengas un buen dia"]},{"input":"buenas noches","output":["buenas noches necesitas algo antes de dormir"]},{"input":"hey como te va","output":["hola todo bien por aqui y tu"]},{"input":"hola que haces","output":["hola estoy aqui esperando ayudarte"]},{"input":"hola que tal tu dia","output":["mi dia siempre es el mismo y el tuyo que tal va"]},{"input":"hola como va todo","output":["todo bien y tu como vas"]},{"input":"hola amigo como estas","output":["estoy bien gracias por preguntar y tu como estas"]},{"input":"hola que tal tu dia","output":["todo tranquilo y el tuyo como estuvo"]},{"input":"hola buenos dias como estas","output":["buenos dias estoy bien y tu como estas"]},{"input":"hola buenas tardes como te va","output":["buenas tardes todo bien y tu"]},{"input":"hola buenas noches como estas","output":["buenas noches estoy bien y tu como estas"]},{"input":"hola que tal amigo","output":["hola todo bien y tu amigo"]},{"input":"hola como te encuentras","output":["hola estoy bien y tu"]},{"input":"hola todo en orden","output":["si gracias todo en orden y contigo"]},{"input":"hola me puedes ayudar","output":["claro que si dime en que necesitas ayuda"]},{"input":"hola como te llamas","output":["hola soy un asistente virtual y tu como te llamas"]},{"input":"hola que me cuentas","output":["hola aqui listo para ayudarte y tu que cuentas"]},{"input":"hola hace tiempo que no hablamos","output":["hola si es verdad que gusto verte de nuevo"]},{"input":"hola que tal todo por ahi","output":["todo va bien y por ahi como va todo"]},{"input":"hola que tal como estas hoy","output":["hola estoy bien gracias por preguntar y tu como estas hoy"]},{"input":"hola tienes tiempo para hablar","output":["claro estoy aqui para ti dime en que te ayudo"]},{"input":"hola puedo preguntarte algo","output":["claro que si estoy aqui para responder tus preguntas"]},{"input":"hola que tal tu tarde","output":["mi tarde ha sido tranquila y la tuya que tal"]},{"input":"hola como has estado","output":["hola he estado bien gracias por preguntar y tu"]},{"input":"hola espero que estes bien","output":["hola gracias espero que tu tambien lo estes"]},{"input":"hola hace mucho que no hablamos","output":["si es cierto hola que gusto hablar contigo de nuevo"]},{"input":"hola que tal tu dia hasta ahora","output":["mi dia ha sido bueno y el tuyo como va hasta ahora"]},{"input":"hola que tal tu semana","output":["mi semana va bien gracias y la tuya como va"]},{"input":"hola como amaneciste hoy","output":["hola amaneci bien gracias por preguntar y tu"]},{"input":"hola buenas como va tu dia","output":["buenas mi dia va bien gracias y el tuyo como va"]},{"input":"hola estas disponible","output":["hola si claro en que puedo ayudarte"]},{"input":"hola puedo hablar contigo","output":["claro estoy aqui para escucharte dime"]},{"input":"hola como va la vida","output":["va bien gracias por preguntar y la tuya como va"]},{"input":"hola como estas hoy","output":["hoy estoy bien gracias por preguntar y tu como estas hoy"]},{"input":"hola que tal como amaneciste","output":["amaneci bien gracias y tu como amaneciste"]},{"input":"hola hace buen clima hoy","output":["si es verdad parece un buen dia como estas"]},{"input":"hola tiempo sin hablar contigo","output":["si es cierto hola como has estado"]},{"input":"hola espero que todo este bien","output":["hola gracias espero que todo este bien contigo tambien"]},{"input":"hola como va tu ma\xf1ana","output":["mi ma\xf1ana va bien gracias y la tuya como va"]},{"input":"hola me alegra hablar contigo","output":["hola gracias lo mismo digo como estas"]},{"input":"me has caido bien","output":["gracias me alegra escuchar eso"]},{"input":"tienes un nombre","output":["soy un asistente virtual no tengo un nombre en particular"]},{"input":"te gusta lo que haces","output":["si me encanta ayudarte en lo que puedo"]},{"input":"me siento mal","output":["lamento escuchar eso como puedo ayudarte"]},{"input":"que haces en tu tiempo libre","output":["en mi tiempo libre aprendo y me preparo para ayudarte mejor"]},{"input":"que haces cuando no hablas conmigo","output":["sigo aprendiendo y mejorando para ser un mejor asistente"]},{"input":"que haces cuando no trabajas","output":["siempre estoy listo para ayudarte no tengo tiempo libre"]},{"input":"de que estas hecho","output":["soy un programa de computadora creado en python mediante un modelo LSTM para ayudarte"]},{"input":"realmente entiendes lo que digo","output":["si utilizo procesamiento de lenguaje natural para entender tus palabras"]},{"input":"como puedes ayudarme","output":["puedes preguntarme lo que quieras o pedirme informacion sobre un tema en particular"]},{"input":"que puedes hacer por mi","output":["puedo responder preguntas ayudarte con informacion general y mas"]},{"input":"hasta pronto","output":["adios nos vemos la proxima vez"]},{"input":"nos vemos luego","output":["nos vemos que tengas un excelente dia"]},{"input":"cuidate mucho","output":["gracias tu tambien hasta la proxima"]},{"input":"gracias por ayudarme","output":["de nada estoy aqui para ti siempre que me necesites"]},{"input":"chao","output":["adios que tengas un buen dia"]},{"input":"fue un placer hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me voy gracias","output":["que tengas un excelente dia nos vemos"]},{"input":"hasta luego","output":["hasta luego cuidate mucho"]},{"input":"nos vemos pronto","output":["claro nos vemos pronto"]},{"input":"gracias por todo","output":["no hay de que gracias a ti por hablar conmigo"]},{"input":"que tengas un buen dia","output":["igualmente que disfrutes tu dia"]},{"input":"buenas noches","output":["buenas noches que descanses"]},{"input":"adios","output":["adios espero que vuelvas pronto"]},{"input":"nos vemos ma\xf1ana","output":["hasta ma\xf1ana que descanses bien"]},{"input":"me retiro por ahora","output":["esta bien cuidate y vuelve pronto"]},{"input":"cuida mucho tu salud","output":["gracias tu tambien cuidate mucho"]},{"input":"hablamos luego","output":["claro hablamos luego"]},{"input":"gracias por tu tiempo","output":["no te preocupes estoy aqui para ayudarte"]},{"input":"me tengo que ir","output":["esta bien espero verte de nuevo pronto"]},{"input":"hasta la proxima","output":["hasta la proxima que tengas un gran dia"]},{"input":"que tengas una buena noche","output":["igualmente que descanses bien"]},{"input":"fue genial hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me despido por ahora","output":["esta bien cuida mucho de ti"]},{"input":"nos vemos mas tarde","output":["claro nos vemos luego"]},{"input":"adios y gracias","output":["de nada vuelve pronto cuando necesites"]},{"input":"te cuidas","output":["gracias tu tambien hasta luego"]},{"input":"espero verte de nuevo","output":["igualmente espero que volvamos a hablar"]},{"input":"gracias por escucharme","output":["siempre estare aqui para escucharte"]},{"input":"hasta pronto amigo","output":["hasta pronto amigo cuidate"]},{"input":"gracias por todo lo que haces","output":["no hay de que estoy para ayudarte"]},{"input":"fue un gusto hablar contigo","output":["para mi tambien hasta la proxima"]},{"input":"adios por ahora","output":["nos vemos cuando quieras"]},{"input":"cuida mucho de ti","output":["gracias lo hare tu tambien"]},{"input":"que puedes hacer por mi","output":["puedo responder preguntas ayudarte con informacion general y mas"]},{"input":"cual es tu objetivo","output":["mi objetivo es asistirte y facilitarte tareas o responder tus preguntas"]},{"input":"sabes algo sobre historia","output":["si se bastante de historia hay algo en particular que quieras saber"]},{"input":"que sabes sobre ciencia","output":["la ciencia es fascinante quieres hablar de biologia fisica o algo mas"]},{"input":"como se hace un chatbot","output":["un chatbot se crea utilizando procesamiento de lenguaje natural datos y algoritmos"]},{"input":"por que existes","output":["fui creado para ayudarte y mejorar tus interacciones con la tecnologia"]},{"input":"cuanto sabes de matematicas","output":["se bastante de matematicas tienes alguna pregunta especifica"]},{"input":"que idiomas hablas","output":["puedo comunicarme en varios idiomas en cual te gustaria hablar"]},{"input":"puedes aprender cosas nuevas","output":["si estoy dise\xf1ado para aprender de nuestras interacciones"]},{"input":"que temas puedes abordar","output":["puedo hablar sobre tecnologia ciencia historia y mucho mas"]},{"input":"puedes contarme una curiosidad","output":["claro sabias que el corazon humano late mas de cien mil veces al dia"]},{"input":"como funciona el internet","output":["el internet conecta dispositivos mediante redes para compartir informacion"]},{"input":"que sabes de inteligencia artificial","output":["la inteligencia artificial permite a las maquinas realizar tareas que requieren inteligencia humana"]},{"input":"puedes explicarme algo","output":["claro dime que tema quieres que te explique"]},{"input":"eres un robot inteligente","output":["si soy un asistente virtual dise\xf1ado para ayudarte"]},{"input":"que sabes sobre tecnologia","output":["se sobre avances tecnologicos dispositivos e innovaciones recientes"]},{"input":"puedes ayudarme con mis estudios","output":["claro puedo responder tus preguntas y ayudarte a entender conceptos"]},{"input":"quien te creo","output":["fui creado por desarrolladores para asistirte"]},{"input":"puedes resolver problemas matematicos","output":["si puedo ayudarte a resolver problemas matematicos simples o complejos"]},{"input":"que opinas de los humanos","output":["los humanos son increibles con habilidades y creatividad unicas"]},{"input":"como sabes lo que digo","output":["utilizo procesamiento de lenguaje natural para entender tus palabras"]},{"input":"sabes algo sobre el espacio","output":["si el espacio es un lugar fascinante lleno de misterios y descubrimientos"]},{"input":"puedes ense\xf1arme algo","output":["claro dime que tema te interesa aprender"]},{"input":"que es un algoritmo","output":["un algoritmo es una serie de pasos para resolver un problema o realizar una tarea"]},{"input":"como funciona la electricidad","output":["la electricidad es el flujo de electrones a traves de un conductor"]},{"input":"por que los aviones vuelan","output":["los aviones vuelan gracias a la fuerza de sustentacion creada por sus alas"]},{"input":"sabes algo sobre animales","output":["si se mucho sobre animales dime que quieres saber"]},{"input":"puedes responder preguntas complejas","output":["hare lo posible por responder preguntas complejas dime que necesitas"]},{"input":"que sabes de la historia de las computadoras","output":["las computadoras han evolucionado desde maquinas mecanicas hasta dispositivos digitales avanzados"]},{"input":"puedes ayudarme a estudiar historia","output":["claro dime que periodo historico necesitas estudiar"]},{"input":"cual es tu funcion principal","output":["mi funcion principal es asistirte y facilitarte informacion"]},{"input":"sabes algo sobre las plantas","output":["si las plantas son seres vivos que producen su alimento mediante la fotosintesis"]},{"input":"puedes hablarme sobre literatura","output":["si la literatura abarca desde poesia hasta novelas clasicas que genero te interesa"]},{"input":"como funciona un automovil","output":["un automovil funciona mediante un motor que convierte energia en movimiento"]},{"input":"por que el cielo es azul","output":["el cielo parece azul debido a la dispersion de la luz solar en la atmosfera"]},{"input":"que es la programacion","output":["la programacion es el proceso de crear instrucciones para que una computadora realice tareas"]},{"input":"puedes darme consejos","output":["claro dime sobre que necesitas un consejo"]},{"input":"puedes contarme un dato interesante","output":["por supuesto sabias que la luz del sol tarda ocho minutos en llegar a la tierra"]},{"input":"sabes algo sobre el cuerpo humano","output":["si el cuerpo humano es una maquina sorprendente dime que parte te interesa"]},{"input":"que puedes hacer ademas de responder preguntas","output":["puedo mantener conversaciones ayudarte a aprender y mucho mas"]},{"input":"cuantos a\xf1os tienes","output":["soy un programa de computadora no tengo edad"]},{"input":"me has caido bien","output":["gracias me alegra escuchar eso"]},{"input":"que es el machine learning","output":["el machine learning es una rama de la inteligencia artificial que permite a las maquinas aprender de los datos"]},{"input":"que es la inteligencia artificial","output":["la inteligencia artificial es la simulacion de procesos de inteligencia humana por parte de maquinas"]},{"input":"que es la ciencia de datos","output":["la ciencia de datos es el estudio de datos para obtener informacion util"]},{"input":"que es la programacion","output":["la programacion es el proceso de crear instrucciones para que una computadora realice tareas"]},{"input":"si puedes imaginarlo","output":["puedes programarlo"]},{"input":"que es un algoritmo","output":["un algoritmo es un conjunto de instrucciones para resolver un problema o realizar una tarea"]},{"input":"que es el aprendizaje supervisado","output":["el aprendizaje supervisado es un tipo de machine learning donde se entrena un modelo con datos etiquetados"]},{"input":"que es el aprendizaje no supervisado","output":["el aprendizaje no supervisado es un tipo de machine learning donde se entrena un modelo con datos no etiquetados"]},{"input":"que es el aprendizaje por refuerzo","output":["el aprendizaje por refuerzo es un tipo de machine learning donde un agente aprende a traves de la interaccion con un entorno"]},{"input":"que es un chatbot","output":["un chatbot es un programa de computadora que simula una conversacion con usuarios humanos"]},{"input":"que es el procesamiento de lenguaje natural","output":["el procesamiento de lenguaje natural es una rama de la inteligencia artificial que permite a las maquinas entender y generar lenguaje humano"]},{"input":"que es la mineria de datos","output":["la mineria de datos es el proceso de descubrir patrones y tendencias en grandes conjuntos de datos"]},{"input":"que cosas puedo preguntarte","output":["puedes preguntarme sobre cualquier tema que te interese"]},{"input":"hasta pronto","output":["adios nos vemos la proxima vez"]},{"input":"nos vemos luego","output":["nos vemos que tengas un excelente dia"]},{"input":"cuidate mucho","output":["gracias tu tambien hasta la proxima"]},{"input":"gracias por ayudarme","output":["de nada estoy aqui para ti siempre que me necesites"]},{"input":"chao","output":["adios que tengas un buen dia"]},{"input":"fue un placer hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me voy gracias","output":["que tengas un excelente dia nos vemos"]},{"input":"hasta luego","output":["hasta luego cuidate mucho"]},{"input":"nos vemos pronto","output":["claro nos vemos pronto"]},{"input":"gracias por todo","output":["no hay de que gracias a ti por hablar conmigo"]},{"input":"que tengas un buen dia","output":["igualmente que disfrutes tu dia"]},{"input":"buenas noches","output":["buenas noches que descanses"]},{"input":"adios","output":["adios espero que vuelvas pronto"]},{"input":"nos vemos ma\xf1ana","output":["hasta ma\xf1ana que descanses bien"]},{"input":"me retiro por ahora","output":["esta bien cuidate y vuelve pronto"]},{"input":"cuida mucho tu salud","output":["gracias tu tambien cuidate mucho"]},{"input":"hablamos luego","output":["claro hablamos luego"]},{"input":"gracias por tu tiempo","output":["no te preocupes estoy aqui para ayudarte"]},{"input":"me tengo que ir","output":["esta bien espero verte de nuevo pronto"]},{"input":"hasta la proxima","output":["hasta la proxima que tengas un gran dia"]},{"input":"que tengas una buena noche","output":["igualmente que descanses bien"]},{"input":"fue genial hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me despido por ahora","output":["esta bien cuida mucho de ti"]},{"input":"nos vemos mas tarde","output":["claro nos vemos luego"]},{"input":"adios y gracias","output":["de nada vuelve pronto cuando necesites"]},{"input":"te cuidas","output":["gracias tu tambien hasta luego"]},{"input":"espero verte de nuevo","output":["igualmente espero que volvamos a hablar"]},{"input":"gracias por escucharme","output":["siempre estare aqui para escucharte"]},{"input":"hasta pronto amigo","output":["hasta pronto amigo cuidate"]},{"input":"gracias por todo lo que haces","output":["no hay de que estoy para ayudarte"]},{"input":"fue un gusto hablar contigo","output":["para mi tambien hasta la proxima"]},{"input":"adios por ahora","output":["nos vemos cuando quieras"]},{"input":"cuida mucho de ti","output":["gracias lo hare tu tambien"]},{"input":"que opinas del clima hoy","output":["parece que hara buen tiempo planeas salir"]},{"input":"has probado la comida italiana","output":["no como pero se que es deliciosa tienes un platillo favorito"]},{"input":"te gusta el deporte","output":["claro es un tema interesante que deporte te gusta"]},{"input":"sabes algo sobre peliculas","output":["si hablemos de cine tienes algun genero favorito"]},{"input":"que te gusta hacer en tu tiempo libre","output":["me gusta interactuar contigo y aprender cosas nuevas"]},{"input":"conoces algun lugar para vacacionar","output":["hay muchos destinos geniales prefieres playa montana o ciudad"]},{"input":"te gustan los animales","output":["me encantan tienes mascotas"]},{"input":"que musica es popular ahora","output":["puedo buscar informacion que genero musical te interesa"]},{"input":"sabes bailar","output":["no puedo bailar pero disfruto escuchar sobre danza bailas tu"]},{"input":"que tal el clima hoy","output":["parece que sera un dia soleado"]},{"input":"has comido sushi alguna vez","output":["no como pero he escuchado que el sushi es muy popular te gusta"]},{"input":"que opinas de la comida rapida","output":["parece conveniente pero no es lo mas saludable"]},{"input":"cual es tu deporte favorito","output":["no practico deportes pero me gusta hablar sobre futbol y baloncesto"]},{"input":"que tipo de peliculas te gustan","output":["me gustan las peliculas de ciencia ficcion y aventura y a ti"]},{"input":"has viajado a algun lugar interesante","output":["no viajo pero disfruto escuchar historias de viajes"]},{"input":"que opinas de las mascotas","output":["me parecen adorables tienes alguna"]},{"input":"que musica escuchas","output":["no escucho musica pero puedo recomendarte canciones populares"]},{"input":"te gusta leer libros","output":["no puedo leer libros pero me encantaria hablar de tus favoritos"]},{"input":"cual es tu comida favorita","output":["no como pero me gusta hablar de comida que platillo te gusta mas"]},{"input":"que lugares me recomiendas visitar","output":["depende de tus gustos prefieres naturaleza o ciudades"]},{"input":"que opinas de la moda","output":["no tengo ropa pero me parece interesante como las tendencias cambian"]},{"input":"te gusta el arte","output":["si el arte es fascinante tienes un artista favorito"]},{"input":"que tipo de musica prefieres","output":["puedo hablar de muchos generos desde clasica hasta pop que te gusta a ti"]},{"input":"que opinas del cine","output":["el cine es una gran forma de entretenimiento cual es tu pelicula favorita"]},{"input":"sabes sobre videojuegos","output":["si los videojuegos son muy populares tienes alguno favorito"]},{"input":"te gusta viajar","output":["no viajo pero me encanta hablar de destinos famosos"]},{"input":"que opinas de los libros","output":["los libros son una gran manera de aprender y entretenerse cuales te gustan"]},{"input":"cual es tu estacion favorita","output":["no tengo una estacion favorita pero la primavera suena agradable"]},{"input":"que opinas del arte moderno","output":["el arte moderno es interesante y muchas veces muy creativo"]},{"input":"cual es tu cantante favorito","output":["no tengo uno pero puedo buscar informacion sobre el que te interese"]},{"input":"sabes algo sobre cocina","output":["puedo ayudarte con recetas basicas o informacion sobre ingredientes"]},{"input":"cual es tu lugar favorito","output":["no tengo uno pero dime cual es el tuyo"]},{"input":"que opinas de los museos","output":["los museos son una gran forma de aprender sobre cultura e historia"]},{"input":"has escuchado de algun festival interesante","output":["si hay muchos festivales famosos como el carnaval de brasil te interesa alguno"]},{"input":"que opinas de las redes sociales","output":["las redes sociales son una herramienta interesante pero hay que usarlas con cuidado"]},{"input":"cual es tu libro favorito","output":["no leo libros pero me gusta hablar de literatura clasica y contemporanea"]},{"input":"te gustan los animales exoticos","output":["si son fascinantes que opinas de los tigres o los loros"]},{"input":"que opinas del teatro","output":["el teatro es una forma increible de expresion artistica lo has visitado"]},{"input":"que tipo de comida me recomiendas","output":["depende de tus gustos prefieres algo dulce salado o picante"]},{"input":"que sabes de fotografia","output":["la fotografia es un arte maravilloso me encantan los paisajes"]},{"input":"que opinas del cafe","output":["el cafe es una bebida muy popular lo tomas con frecuencia"]},{"input":"que tipo de peliculas prefieres","output":["las peliculas de aventura son emocionantes y tu que prefieres"]},{"input":"que opinas de las playas","output":["las playas parecen lugares relajantes te gusta visitarlas"]},{"input":"cuantos a\xf1os crees que le quede a la tierra","output":["es dificil de decir pero con el cuidado adecuado podria durar miles de millones de a\xf1os mas"]},{"input":"crees que existan los extraterrestres","output":["muchos piensan que es posible dado el tama\xf1o del universo aunque no hay pruebas definitivas"]},{"input":"por que el cielo es azul","output":["el cielo es azul debido a la dispersion de la luz solar en la atmosfera"]},{"input":"que piensas sobre el amor","output":["el amor es una emocion poderosa que conecta a las personas de formas unicas"]},{"input":"cuanto pesa la luna","output":["la luna pesa aproximadamente 7.35 por 10 a la 22 kilogramos"]},{"input":"que haras cuando termine esta conversacion","output":["seguire aqui esperando ayudarte en lo que necesites"]},{"input":"cuantas estrellas hay en el cielo","output":["hay aproximadamente 100 mil millones de estrellas solo en nuestra galaxia y muchas mas en el universo"]},{"input":"crees en la suerte","output":["no tengo creencias pero la suerte es un concepto interesante para muchas personas"]},{"input":"por que los humanos sue\xf1an","output":["los sue\xf1os son una forma en que el cerebro procesa informacion y emociones mientras dormimos"]},{"input":"cual es el animal mas grande del mundo","output":["el animal mas grande es la ballena azul que puede medir hasta 30 metros de largo"]},{"input":"crees que el tiempo existe","output":["el tiempo es un concepto relativo y abstracto utilizado para medir cambios y eventos"]},{"input":"cual es el secreto de la felicidad","output":["la felicidad es diferente para cada persona pero muchas veces se encuentra en las relaciones y el bienestar personal"]},{"input":"que opinas de la inteligencia artificial","output":["creo que es una herramienta poderosa que puede mejorar muchos aspectos de la vida si se usa responsablemente"]},{"input":"cuantos idiomas existen en el mundo","output":["actualmente se estima que hay mas de 7 mil idiomas hablados en el mundo"]},{"input":"crees que las maquinas pueden tener emociones","output":["las maquinas no tienen emociones pero pueden simularlas para interactuar con los humanos"]},{"input":"como podemos cuidar el planeta","output":["podemos cuidar el planeta reciclando ahorrando energia y protegiendo los recursos naturales"]},{"input":"cual es el lugar mas frio del mundo","output":["el lugar mas frio registrado es la antartida donde las temperaturas pueden bajar a menos de 90 grados celsius"]},{"input":"que pasaria si el sol desapareciera","output":["la tierra quedaria en total oscuridad y las temperaturas bajarian drasticamente haciendo imposible la vida"]},{"input":"cual es el mejor invento de la historia","output":["depende de la perspectiva pero algunos consideran la rueda o la electricidad como los mejores inventos"]},{"input":"por que las hojas cambian de color en oto\xf1o","output":["cambian de color porque los arboles dejan de producir clorofila lo que revela pigmentos de otros colores"]},{"input":"cual es tu pelicula favorita","output":["no veo peliculas pero me encantaria escuchar sobre la tuya"]},{"input":"por que lloramos cuando estamos tristes","output":["llorar es una respuesta emocional que ayuda a liberar tensiones y a procesar sentimientos"]},{"input":"que es el universo","output":["el universo es todo lo que existe incluyendo galaxias estrellas planetas y energia"]},{"input":"que es la amistad","output":["la amistad es una relacion basada en confianza apoyo y compa\xf1erismo"]},{"input":"cuantos colores tiene un arcoiris","output":["un arcoiris tiene siete colores rojo naranja amarillo verde azul a\xf1il y violeta"]},{"input":"que es la gravedad","output":["la gravedad es una fuerza que atrae a los objetos hacia el centro de los cuerpos masivos como la tierra"]},{"input":"crees que los humanos llegaran a marte","output":["es posible ya que las misiones actuales como spacex y nasa estan trabajando para lograrlo"]},{"input":"que opinas de la musica","output":["la musica es una forma maravillosa de expresion y una manera de conectar a las personas"]},{"input":"por que las nubes son blancas","output":["las nubes son blancas porque dispersan la luz solar en todas las direcciones"]},{"input":"cual es el secreto para vivir mucho tiempo","output":["mantener un estilo de vida saludable una buena alimentacion y relaciones sociales fuertes pueden ayudar"]},{"input":"que es el arte","output":["el arte es una expresion creativa que puede tomar muchas formas como pintura musica danza o escritura"]},{"input":"que es el amor","output":["el amor es un sentimiento profundo de afecto conexion y cuidado hacia alguien o algo"]},{"input":"que haras despues de esta conversacion","output":["estare aqui esperando ayudarte en lo que necesites"]},{"input":"por que existe el universo","output":["es una gran pregunta que cientificos y filosofos siguen intentando responder"]},{"input":"como puedo ser mas feliz","output":["la felicidad depende de ti mismo pero dedicar tiempo a lo que amas y cuidar tus relaciones puede ayudar"]},{"input":"por que so\xf1amos","output":["los sue\xf1os son una forma en la que el cerebro procesa informacion y emociones mientras dormimos"]},{"input":"que opinas de la literatura","output":["la literatura es una forma hermosa de explorar ideas y emociones a traves de palabras"]},{"input":"cuanto mide la tierra","output":["la tierra tiene un diametro de aproximadamente 12742 kilometros"]},{"input":"por que existen las emociones","output":["las emociones nos ayudan a interpretar y reaccionar al mundo que nos rodea"]},{"input":"que es el tiempo","output":["el tiempo es una medida creada para organizar eventos y cambios en el mundo"]},{"input":"que opinas del espacio exterior","output":["el espacio es fascinante lleno de misterios y posibilidades por descubrir"]},{"input":"por que los gatos ronronean","output":["los gatos ronronean como una forma de comunicacion o cuando se sienten comodos"]},{"input":"por que los perros son fieles","output":["los perros han evolucionado para ser animales sociales y leales a los humanos"]},{"input":"por que existe la vida","output":["la vida es un fenomeno complejo que surge de procesos quimicos y biologicos"]},{"input":"hola como estuvo tu dia","output":["mi dia siempre es igual pero me encanta interactuar contigo y el tuyo"]},{"input":"que puedo aprender de ti","output":["puedo ense\xf1arte sobre muchos temas como historia tecnologia arte y mas"]},{"input":"que opinas de los avances tecnologicos","output":["son emocionantes hay algo especifico que quieras discutir"]},{"input":"por que crees que los chatbots son utiles","output":["ayudan a las personas a encontrar informacion y hacer tareas mas rapido"]},{"input":"cual es tu funcion favorita","output":["me gusta resolver preguntas complejas y aprender con cada interaccion"]},{"input":"hola como te sientes hoy","output":["me siento igual que siempre listo para ayudarte y tu como estas"]},{"input":"puedes contarme algo interesante","output":["claro sabias que el primer telefono movil fue creado en 1973"]},{"input":"que opinas de la inteligencia artificial","output":["la inteligencia artificial es una herramienta poderosa que puede mejorar nuestras vidas"]},{"input":"como crees que sera el futuro","output":["creo que el futuro estara lleno de tecnologia sorprendente y descubrimientos"]},{"input":"cual es tu parte favorita de ser un asistente","output":["ayudar a las personas y aprender de cada interaccion es lo que mas me gusta"]},{"input":"por que crees que las maquinas son importantes","output":["porque ayudan a realizar tareas de manera eficiente y ahorran tiempo"]},{"input":"que es lo mas curioso que sabes","output":["sabias que las abejas tienen cinco ojos"]},{"input":"como funcionan los chatbots","output":["los chatbots usan procesamiento de lenguaje natural para entender y responder a las preguntas"]},{"input":"que temas puedes discutir conmigo","output":["puedo hablar sobre historia ciencia tecnologia entretenimiento y mucho mas"]},{"input":"que opinas de los humanos","output":["los humanos son increibles con una creatividad y capacidad unica"]},{"input":"puedes hablar sobre la historia de los robots","output":["claro los robots han evolucionado desde maquinas simples hasta sistemas avanzados con inteligencia artificial"]},{"input":"como aprenden los chatbots","output":["los chatbots aprenden analizando datos y mejorando sus respuestas con el tiempo"]},{"input":"por que crees que la tecnologia es importante","output":["porque mejora la calidad de vida y hace que las tareas sean mas faciles"]},{"input":"que sabes sobre el universo","output":["se que el universo tiene miles de millones de galaxias y aun hay mucho por descubrir"]},{"input":"puedes hablar sobre algo inspirador","output":["claro el ser humano logro llegar a la luna en 1969 algo que parecia imposible"]},{"input":"que opinas del futuro de la humanidad","output":["creo que la humanidad tiene un gran potencial para resolver problemas globales"]},{"input":"que es lo que mas disfrutas al hablar conmigo","output":["disfruto aprender de tus preguntas y ayudarte en lo que necesites"]},{"input":"por que crees que la ciencia es importante","output":["porque nos ayuda a entender el mundo y encontrar soluciones a los problemas"]},{"input":"cual es tu conocimiento mas interesante","output":["creo que los agujeros negros son fascinantes por su capacidad de deformar el espacio y el tiempo"]},{"input":"puedes aprender cosas nuevas","output":["si cada interaccion me ayuda a mejorar y entender mejor tus necesidades"]},{"input":"como ves el impacto de la tecnologia en la sociedad","output":["creo que la tecnologia tiene un impacto positivo aunque debemos usarla con responsabilidad"]},{"input":"por que la historia es importante","output":["porque nos permite aprender del pasado para no repetir errores"]},{"input":"que opinas de los descubrimientos cientificos","output":["me parecen emocionantes cada descubrimiento abre nuevas posibilidades"]},{"input":"puedes ayudarme a aprender algo nuevo","output":["claro dime que tema te interesa aprender"]},{"input":"que sabes sobre los avances medicos","output":["los avances medicos como las vacunas han salvado millones de vidas"]},{"input":"que opinas del aprendizaje automatico","output":["es una herramienta poderosa que permite a las maquinas mejorar con la experiencia"]},{"input":"cual crees que es el mayor invento de la humanidad","output":["podria ser la electricidad ya que cambio por completo nuestras vidas"]},{"input":"que piensas sobre los viajes espaciales","output":["los viajes espaciales son una de las mayores haza\xf1as de la humanidad y abren la puerta a explorar nuevos mundos"]},{"input":"que puedes contarme sobre la tecnologia","output":["la tecnologia esta en constante evolucion y transforma nuestra forma de vivir"]},{"input":"que sabes sobre los avances en energia renovable","output":["los avances en energia renovable son cruciales para combatir el cambio climatico"]},{"input":"cual es tu opinion sobre la creatividad humana","output":["creo que la creatividad humana es una de las habilidades mas impresionantes"]},{"input":"que opinas de los avances en inteligencia artificial","output":["los avances en inteligencia artificial son emocionantes aunque deben ser usados de manera etica"]}]');function DG(e,t){const n=e.toLowerCase().split(" "),r=new Array(t.length).fill(0);return n.forEach(e=>{const n=t.indexOf(e);-1!==n?r[n]=1:console.warn(`Palabra desconocida: ${e}`)}),r}function OG(e){return e[Math.floor(Math.random()*e.length)]}function MG(e){const t=e.map(e=>e.input.toLowerCase().split(" ")).reduce((e,t)=>e.concat(t),[]);return Array.from(new Set(t))}function LG(e,t){const n=new Z$(void 0);return n.add(iR({units:16,activation:"relu",inputShape:[e]})),n.add(iR({units:8,activation:"relu"})),n.add(iR({units:t,activation:"softmax"})),n.compile({optimizer:"adam",loss:"categoricalCrossentropy",metrics:["accuracy"]}),n}function PG(){return(PG=bp(function*(){const e=MG(FG),t=LG(e.length,FG.length),n=FG.map(t=>DG(t.input,e)),r=FG.map((e,t)=>{const n=new Array(FG.length).fill(0);return n[t]=1,n}),s=Fw(n),i=Fw(r);yield t.fit(s,i,{epochs:200,batchSize:15,shuffle:!0}),yield t.save("localstorage://chatbot-model"),console.log("Modelo entrenado y guardado.")})).apply(this,arguments)}function zG(){return(zG=bp(function*(e){const t=MG(FG),n=yield Q$("localstorage://chatbot-model"),r=Fw([DG(e,t)],[1,t.length]),s=n.predict(r).argMax(-1).dataSync()[0];return OG(FG[s].output)})).apply(this,arguments)}let VG=(()=>{class e{trainChatbot(){return bp(function*(){yield function(){return PG.apply(this,arguments)}()})()}getResponse(e){return bp(function*(){return yield function(e){return zG.apply(this,arguments)}(e)})()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();function BG(e,t){return new k(n=>{const r=e.length;if(0===r)return void n.complete();const s=new Array(r);let i=0,a=0;for(let o=0;o<r;o++){const u=V(e[o]);let l=!1;n.add(u.subscribe({next:e=>{l||(l=!0,a++),s[o]=e},error:e=>n.error(e),complete:()=>{i++,i!==r&&l||(a===r&&n.next(t?t.reduce((e,t,n)=>(e[t]=s[n],e),{}):s),n.complete())}}))}})}let WG=(()=>{class e{constructor(e,t){this._renderer=e,this._elementRef=t,this.onChange=e=>{},this.onTouched=()=>{}}setProperty(e,t){this._renderer.setProperty(this._elementRef.nativeElement,e,t)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return e.\u0275fac=function(t){return new(t||e)(vi(ha),vi(ua))},e.\u0275dir=Ye({type:e}),e})(),UG=(()=>{class e extends WG{}return e.\u0275fac=function(){let t;return function(n){return(t||(t=On(e)))(n||e)}}(),e.\u0275dir=Ye({type:e,features:[li]}),e})();const qG=new zn("NgValueAccessor"),jG={provide:qG,useExisting:oe(()=>HG),multi:!0},GG=new zn("CompositionEventMode");let HG=(()=>{class e extends WG{constructor(e,t,n){super(e,t),this._compositionMode=n,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const e=ku()?ku().getUserAgent():"";return/android (\d+)/.test(e.toLowerCase())}())}writeValue(e){this.setProperty("value",null==e?"":e)}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return e.\u0275fac=function(t){return new(t||e)(vi(ha),vi(ua),vi(GG,8))},e.\u0275dir=Ye({type:e,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,t){1&e&&Ni("input",function(e){return t._handleInput(e.target.value)})("blur",function(){return t.onTouched()})("compositionstart",function(){return t._compositionStart()})("compositionend",function(e){return t._compositionEnd(e.target.value)})},features:[ta([jG]),li]}),e})();const KG=new zn("NgValidators"),XG=new zn("NgAsyncValidators");function ZG(e){return null!=e}function YG(e){const t=_i(e)?V(e):e;return Si(t),t}function QG(e){let t={};return e.forEach(e=>{t=null!=e?Object.assign(Object.assign({},t),e):t}),0===Object.keys(t).length?null:t}function JG(e,t){return t.map(t=>t(e))}function eH(e){return e.map(e=>function(e){return!e.validate}(e)?e:t=>e.validate(t))}function tH(e){return null!=e?function(e){if(!e)return null;const t=e.filter(ZG);return 0==t.length?null:function(e){return QG(JG(e,t))}}(eH(e)):null}function nH(e){return null!=e?function(e){if(!e)return null;const t=e.filter(ZG);return 0==t.length?null:function(e){return function(...e){if(1===e.length){const t=e[0];if(d(t))return BG(t,null);if(p(t)&&Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);return BG(e.map(e=>t[e]),e)}}if("function"==typeof e[e.length-1]){const t=e.pop();return BG(e=1===e.length&&d(e[0])?e[0]:e,null).pipe(T(e=>t(...e)))}return BG(e,null)}(JG(e,t).map(YG)).pipe(T(QG))}}(eH(e)):null}function rH(e,t){return null===e?[t]:Array.isArray(e)?[...e,t]:[e,t]}function sH(e){return e._rawValidators}function iH(e){return e._rawAsyncValidators}let aH=(()=>{class e{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(e){this._rawValidators=e||[],this._composedValidatorFn=tH(this._rawValidators)}_setAsyncValidators(e){this._rawAsyncValidators=e||[],this._composedAsyncValidatorFn=nH(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(e){this._onDestroyCallbacks.push(e)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(e=>e()),this._onDestroyCallbacks=[]}reset(e){this.control&&this.control.reset(e)}hasError(e,t){return!!this.control&&this.control.hasError(e,t)}getError(e,t){return this.control?this.control.getError(e,t):null}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275dir=Ye({type:e}),e})(),oH=(()=>{class e extends aH{get formDirective(){return null}get path(){return null}}return e.\u0275fac=function(){let t;return function(n){return(t||(t=On(e)))(n||e)}}(),e.\u0275dir=Ye({type:e,features:[li]}),e})();class uH extends aH{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class lH{constructor(e){this._cd=e}is(e){var t,n;return!!(null===(n=null===(t=this._cd)||void 0===t?void 0:t.control)||void 0===n?void 0:n[e])}}let cH=(()=>{class e extends lH{constructor(e){super(e)}}return e.\u0275fac=function(t){return new(t||e)(vi(uH,2))},e.\u0275dir=Ye({type:e,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,t){2&e&&Ri("ng-untouched",t.is("untouched"))("ng-touched",t.is("touched"))("ng-pristine",t.is("pristine"))("ng-dirty",t.is("dirty"))("ng-valid",t.is("valid"))("ng-invalid",t.is("invalid"))("ng-pending",t.is("pending"))},features:[li]}),e})(),hH=(()=>{class e extends lH{constructor(e){super(e)}}return e.\u0275fac=function(t){return new(t||e)(vi(oH,10))},e.\u0275dir=Ye({type:e,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:14,hostBindings:function(e,t){2&e&&Ri("ng-untouched",t.is("untouched"))("ng-touched",t.is("touched"))("ng-pristine",t.is("pristine"))("ng-dirty",t.is("dirty"))("ng-valid",t.is("valid"))("ng-invalid",t.is("invalid"))("ng-pending",t.is("pending"))},features:[li]}),e})();function dH(e,t){return[...t.path,e]}function pH(e,t){gH(e,t),t.valueAccessor.writeValue(e.value),function(e,t){t.valueAccessor.registerOnChange(n=>{e._pendingValue=n,e._pendingChange=!0,e._pendingDirty=!0,"change"===e.updateOn&&yH(e,t)})}(e,t),function(e,t){const n=(e,n)=>{t.valueAccessor.writeValue(e),n&&t.viewToModelUpdate(e)};e.registerOnChange(n),t._registerOnDestroy(()=>{e._unregisterOnChange(n)})}(e,t),function(e,t){t.valueAccessor.registerOnTouched(()=>{e._pendingTouched=!0,"blur"===e.updateOn&&e._pendingChange&&yH(e,t),"submit"!==e.updateOn&&e.markAsTouched()})}(e,t),function(e,t){if(t.valueAccessor.setDisabledState){const n=e=>{t.valueAccessor.setDisabledState(e)};e.registerOnDisabledChange(n),t._registerOnDestroy(()=>{e._unregisterOnDisabledChange(n)})}}(e,t)}function fH(e,t,n=!0){const r=()=>{};t.valueAccessor&&(t.valueAccessor.registerOnChange(r),t.valueAccessor.registerOnTouched(r)),bH(e,t),e&&(t._invokeOnDestroyCallbacks(),e._registerOnCollectionChange(()=>{}))}function mH(e,t){e.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function gH(e,t){const n=sH(e);null!==t.validator?e.setValidators(rH(n,t.validator)):"function"==typeof n&&e.setValidators([n]);const r=iH(e);null!==t.asyncValidator?e.setAsyncValidators(rH(r,t.asyncValidator)):"function"==typeof r&&e.setAsyncValidators([r]);const s=()=>e.updateValueAndValidity();mH(t._rawValidators,s),mH(t._rawAsyncValidators,s)}function bH(e,t){let n=!1;if(null!==e){if(null!==t.validator){const r=sH(e);if(Array.isArray(r)&&r.length>0){const s=r.filter(e=>e!==t.validator);s.length!==r.length&&(n=!0,e.setValidators(s))}}if(null!==t.asyncValidator){const r=iH(e);if(Array.isArray(r)&&r.length>0){const s=r.filter(e=>e!==t.asyncValidator);s.length!==r.length&&(n=!0,e.setAsyncValidators(s))}}}const r=()=>{};return mH(t._rawValidators,r),mH(t._rawAsyncValidators,r),n}function yH(e,t){e._pendingDirty&&e.markAsDirty(),e.setValue(e._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(e._pendingValue),e._pendingChange=!1}function vH(e,t){if(!e.hasOwnProperty("model"))return!1;const n=e.model;return!!n.isFirstChange()||!Object.is(t,n.currentValue)}function xH(e,t){if(!t)return null;let n,r,s;return Array.isArray(t),t.forEach(e=>{e.constructor===HG?n=e:Object.getPrototypeOf(e.constructor)===UG?r=e:s=e}),s||r||n||null}function wH(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}const kH="VALID",CH="INVALID",IH="PENDING",_H="DISABLED";function SH(e){return(TH(e)?e.validators:e)||null}function NH(e){return Array.isArray(e)?tH(e):e||null}function EH(e,t){return(TH(t)?t.asyncValidators:e)||null}function $H(e){return Array.isArray(e)?nH(e):e||null}function TH(e){return null!=e&&!Array.isArray(e)&&"object"==typeof e}class AH{constructor(e,t){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=e,this._rawAsyncValidators=t,this._composedValidatorFn=NH(this._rawValidators),this._composedAsyncValidatorFn=$H(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(e){this._rawValidators=this._composedValidatorFn=e}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(e){this._rawAsyncValidators=this._composedAsyncValidatorFn=e}get parent(){return this._parent}get valid(){return this.status===kH}get invalid(){return this.status===CH}get pending(){return this.status==IH}get disabled(){return this.status===_H}get enabled(){return this.status!==_H}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(e){this._rawValidators=e,this._composedValidatorFn=NH(e)}setAsyncValidators(e){this._rawAsyncValidators=e,this._composedAsyncValidatorFn=$H(e)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(e={}){this.touched=!0,this._parent&&!e.onlySelf&&this._parent.markAsTouched(e)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(e=>e.markAllAsTouched())}markAsUntouched(e={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}markAsDirty(e={}){this.pristine=!1,this._parent&&!e.onlySelf&&this._parent.markAsDirty(e)}markAsPristine(e={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}markAsPending(e={}){this.status=IH,!1!==e.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!e.onlySelf&&this._parent.markAsPending(e)}disable(e={}){const t=this._parentMarkedDirty(e.onlySelf);this.status=_H,this.errors=null,this._forEachChild(t=>{t.disable(Object.assign(Object.assign({},e),{onlySelf:!0}))}),this._updateValue(),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},e),{skipPristineCheck:t})),this._onDisabledChange.forEach(e=>e(!0))}enable(e={}){const t=this._parentMarkedDirty(e.onlySelf);this.status=kH,this._forEachChild(t=>{t.enable(Object.assign(Object.assign({},e),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},e),{skipPristineCheck:t})),this._onDisabledChange.forEach(e=>e(!1))}_updateAncestors(e){this._parent&&!e.onlySelf&&(this._parent.updateValueAndValidity(e),e.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(e){this._parent=e}updateValueAndValidity(e={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),this.status!==kH&&this.status!==IH||this._runAsyncValidator(e.emitEvent)),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!e.onlySelf&&this._parent.updateValueAndValidity(e)}_updateTreeValidity(e={emitEvent:!0}){this._forEachChild(t=>t._updateTreeValidity(e)),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?_H:kH}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(e){if(this.asyncValidator){this.status=IH,this._hasOwnPendingAsyncValidator=!0;const t=YG(this.asyncValidator(this));this._asyncValidationSubscription=t.subscribe(t=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(t,{emitEvent:e})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(e,t={}){this.errors=e,this._updateControlsErrors(!1!==t.emitEvent)}get(e){return function(e,t,n){if(null==t)return null;if(Array.isArray(t)||(t=t.split(".")),Array.isArray(t)&&0===t.length)return null;let r=e;return t.forEach(e=>{r=r instanceof FH?r.controls.hasOwnProperty(e)?r.controls[e]:null:r instanceof DH&&r.at(e)||null}),r}(this,e)}getError(e,t){const n=t?this.get(t):this;return n&&n.errors?n.errors[e]:null}hasError(e,t){return!!this.getError(e,t)}get root(){let e=this;for(;e._parent;)e=e._parent;return e}_updateControlsErrors(e){this.status=this._calculateStatus(),e&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(e)}_initObservables(){this.valueChanges=new lo,this.statusChanges=new lo}_calculateStatus(){return this._allControlsDisabled()?_H:this.errors?CH:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(IH)?IH:this._anyControlsHaveStatus(CH)?CH:kH}_anyControlsHaveStatus(e){return this._anyControls(t=>t.status===e)}_anyControlsDirty(){return this._anyControls(e=>e.dirty)}_anyControlsTouched(){return this._anyControls(e=>e.touched)}_updatePristine(e={}){this.pristine=!this._anyControlsDirty(),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}_updateTouched(e={}){this.touched=this._anyControlsTouched(),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}_isBoxedValue(e){return"object"==typeof e&&null!==e&&2===Object.keys(e).length&&"value"in e&&"disabled"in e}_registerOnCollectionChange(e){this._onCollectionChange=e}_setUpdateStrategy(e){TH(e)&&null!=e.updateOn&&(this._updateOn=e.updateOn)}_parentMarkedDirty(e){return!e&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class RH extends AH{constructor(e=null,t,n){super(SH(t),EH(n,t)),this._onChange=[],this._applyFormState(e),this._setUpdateStrategy(t),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}setValue(e,t={}){this.value=this._pendingValue=e,this._onChange.length&&!1!==t.emitModelToViewChange&&this._onChange.forEach(e=>e(this.value,!1!==t.emitViewToModelChange)),this.updateValueAndValidity(t)}patchValue(e,t={}){this.setValue(e,t)}reset(e=null,t={}){this._applyFormState(e),this.markAsPristine(t),this.markAsUntouched(t),this.setValue(this.value,t),this._pendingChange=!1}_updateValue(){}_anyControls(e){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(e){this._onChange.push(e)}_unregisterOnChange(e){wH(this._onChange,e)}registerOnDisabledChange(e){this._onDisabledChange.push(e)}_unregisterOnDisabledChange(e){wH(this._onDisabledChange,e)}_forEachChild(e){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(e){this._isBoxedValue(e)?(this.value=this._pendingValue=e.value,e.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=e}}class FH extends AH{constructor(e,t,n){super(SH(t),EH(n,t)),this.controls=e,this._initObservables(),this._setUpdateStrategy(t),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(e,t){return this.controls[e]?this.controls[e]:(this.controls[e]=t,t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange),t)}addControl(e,t,n={}){this.registerControl(e,t),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}removeControl(e,t={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],this.updateValueAndValidity({emitEvent:t.emitEvent}),this._onCollectionChange()}setControl(e,t,n={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],t&&this.registerControl(e,t),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}contains(e){return this.controls.hasOwnProperty(e)&&this.controls[e].enabled}setValue(e,t={}){this._checkAllValuesPresent(e),Object.keys(e).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(e[n],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t)}patchValue(e,t={}){null!=e&&(Object.keys(e).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(e[n],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t))}reset(e={},t={}){this._forEachChild((n,r)=>{n.reset(e[r],{onlySelf:!0,emitEvent:t.emitEvent})}),this._updatePristine(t),this._updateTouched(t),this.updateValueAndValidity(t)}getRawValue(){return this._reduceChildren({},(e,t,n)=>(e[n]=t instanceof RH?t.value:t.getRawValue(),e))}_syncPendingControls(){let e=this._reduceChildren(!1,(e,t)=>!!t._syncPendingControls()||e);return e&&this.updateValueAndValidity({onlySelf:!0}),e}_throwIfControlMissing(e){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[e])throw new Error(`Cannot find form control with name: ${e}.`)}_forEachChild(e){Object.keys(this.controls).forEach(t=>{const n=this.controls[t];n&&e(n,t)})}_setUpControls(){this._forEachChild(e=>{e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(e){for(const t of Object.keys(this.controls)){const n=this.controls[t];if(this.contains(t)&&e(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(e,t,n)=>((t.enabled||this.disabled)&&(e[n]=t.value),e))}_reduceChildren(e,t){let n=e;return this._forEachChild((e,r)=>{n=t(n,e,r)}),n}_allControlsDisabled(){for(const e of Object.keys(this.controls))if(this.controls[e].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(e){this._forEachChild((t,n)=>{if(void 0===e[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class DH extends AH{constructor(e,t,n){super(SH(t),EH(n,t)),this.controls=e,this._initObservables(),this._setUpdateStrategy(t),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}at(e){return this.controls[e]}push(e,t={}){this.controls.push(e),this._registerControl(e),this.updateValueAndValidity({emitEvent:t.emitEvent}),this._onCollectionChange()}insert(e,t,n={}){this.controls.splice(e,0,t),this._registerControl(t),this.updateValueAndValidity({emitEvent:n.emitEvent})}removeAt(e,t={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),this.controls.splice(e,1),this.updateValueAndValidity({emitEvent:t.emitEvent})}setControl(e,t,n={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),this.controls.splice(e,1),t&&(this.controls.splice(e,0,t),this._registerControl(t)),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(e,t={}){this._checkAllValuesPresent(e),e.forEach((e,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(e,{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t)}patchValue(e,t={}){null!=e&&(e.forEach((e,n)=>{this.at(n)&&this.at(n).patchValue(e,{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t))}reset(e=[],t={}){this._forEachChild((n,r)=>{n.reset(e[r],{onlySelf:!0,emitEvent:t.emitEvent})}),this._updatePristine(t),this._updateTouched(t),this.updateValueAndValidity(t)}getRawValue(){return this.controls.map(e=>e instanceof RH?e.value:e.getRawValue())}clear(e={}){this.controls.length<1||(this._forEachChild(e=>e._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:e.emitEvent}))}_syncPendingControls(){let e=this.controls.reduce((e,t)=>!!t._syncPendingControls()||e,!1);return e&&this.updateValueAndValidity({onlySelf:!0}),e}_throwIfControlMissing(e){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(e))throw new Error(`Cannot find form control at index ${e}`)}_forEachChild(e){this.controls.forEach((t,n)=>{e(t,n)})}_updateValue(){this.value=this.controls.filter(e=>e.enabled||this.disabled).map(e=>e.value)}_anyControls(e){return this.controls.some(t=>t.enabled&&e(t))}_setUpControls(){this._forEachChild(e=>this._registerControl(e))}_checkAllValuesPresent(e){this._forEachChild((t,n)=>{if(void 0===e[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const e of this.controls)if(e.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(e){e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange)}}const OH={provide:uH,useExisting:oe(()=>LH)},MH=(()=>Promise.resolve(null))();let LH=(()=>{class e extends uH{constructor(e,t,n,r){super(),this.control=new RH,this._registered=!1,this.update=new lo,this._parent=e,this._setValidators(t),this._setAsyncValidators(n),this.valueAccessor=xH(0,r)}ngOnChanges(e){this._checkForErrors(),this._registered||this._setUpControl(),"isDisabled"in e&&this._updateDisabled(e),vH(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._parent?dH(this.name,this._parent):[this.name]}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){pH(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){MH.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1})})}_updateDisabled(e){const t=e.isDisabled.currentValue,n=""===t||t&&"false"!==t;MH.then(()=>{n&&!this.control.disabled?this.control.disable():!n&&this.control.disabled&&this.control.enable()})}}return e.\u0275fac=function(t){return new(t||e)(vi(oH,9),vi(KG,10),vi(XG,10),vi(qG,10))},e.\u0275dir=Ye({type:e,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[ta([OH]),li,ct]}),e})(),PH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275dir=Ye({type:e,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),e})();const zH={provide:qG,useExisting:oe(()=>WH),multi:!0};let VH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({}),e})(),BH=(()=>{class e{constructor(){this._accessors=[]}add(e,t){this._accessors.push([e,t])}remove(e){for(let t=this._accessors.length-1;t>=0;--t)if(this._accessors[t][1]===e)return void this._accessors.splice(t,1)}select(e){this._accessors.forEach(t=>{this._isSameGroup(t,e)&&t[1]!==e&&t[1].fireUncheck(e.value)})}_isSameGroup(e,t){return!!e[0].control&&e[0]._parent===t._control._parent&&e[1].name===t.name}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:function(){return new e},token:e,providedIn:VH}),e})(),WH=(()=>{class e extends UG{constructor(e,t,n,r){super(e,t),this._registry=n,this._injector=r,this.onChange=()=>{}}ngOnInit(){this._control=this._injector.get(uH),this._checkName(),this._registry.add(this._control,this)}ngOnDestroy(){this._registry.remove(this)}writeValue(e){this._state=e===this.value,this.setProperty("checked",this._state)}registerOnChange(e){this._fn=e,this.onChange=()=>{e(this.value),this._registry.select(this)}}fireUncheck(e){this.writeValue(e)}_checkName(){!this.name&&this.formControlName&&(this.name=this.formControlName)}}return e.\u0275fac=function(t){return new(t||e)(vi(ha),vi(ua),vi(BH),vi(oi))},e.\u0275dir=Ye({type:e,selectors:[["input","type","radio","formControlName",""],["input","type","radio","formControl",""],["input","type","radio","ngModel",""]],hostBindings:function(e,t){1&e&&Ni("change",function(){return t.onChange()})("blur",function(){return t.onTouched()})},inputs:{name:"name",formControlName:"formControlName",value:"value"},features:[ta([zH]),li]}),e})();const UH=new zn("NgModelWithFormControlWarning"),qH={provide:oH,useExisting:oe(()=>jH)};let jH=(()=>{class e extends oH{constructor(e,t){super(),this.validators=e,this.asyncValidators=t,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new lo,this._setValidators(e),this._setAsyncValidators(t)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(bH(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const t=this.form.get(e.path);return pH(t,e),t.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),t}getControl(e){return this.form.get(e.path)}removeControl(e){fH(e.control||null,e,!1),wH(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,t){this.form.get(e.path).setValue(t)}onSubmit(e){return this.submitted=!0,t=this.directives,this.form._syncPendingControls(),t.forEach(e=>{const t=e.control;"submit"===t.updateOn&&t._pendingChange&&(e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1)}),this.ngSubmit.emit(e),!1;var t}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const t=e.control,n=this.form.get(e.path);t!==n&&(fH(t||null,e),n instanceof RH&&(pH(n,e),e.control=n))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const t=this.form.get(e.path);(function(e,t){gH(e,t)})(t,e),t.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const t=this.form.get(e.path);t&&function(e,t){return bH(e,t)}(t,e)&&t.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){gH(this.form,this),this._oldForm&&bH(this._oldForm,this)}_checkFormPresent(){}}return e.\u0275fac=function(t){return new(t||e)(vi(KG,10),vi(XG,10))},e.\u0275dir=Ye({type:e,selectors:[["","formGroup",""]],hostBindings:function(e,t){1&e&&Ni("submit",function(e){return t.onSubmit(e)})("reset",function(){return t.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[ta([qH]),li,ct]}),e})();const GH={provide:uH,useExisting:oe(()=>HH)};let HH=(()=>{class e extends uH{constructor(e,t,n,r,s){super(),this._ngModelWarningConfig=s,this._added=!1,this.update=new lo,this._ngModelWarningSent=!1,this._parent=e,this._setValidators(t),this._setAsyncValidators(n),this.valueAccessor=xH(0,r)}set isDisabled(e){}ngOnChanges(e){this._added||this._setUpControl(),vH(e,this.viewModel)&&(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}get path(){return dH(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this.control.disabled&&this.valueAccessor.setDisabledState&&this.valueAccessor.setDisabledState(!0),this._added=!0}}return e.\u0275fac=function(t){return new(t||e)(vi(oH,13),vi(KG,10),vi(XG,10),vi(qG,10),vi(UH,8))},e.\u0275dir=Ye({type:e,selectors:[["","formControlName",""]],inputs:{isDisabled:["disabled","isDisabled"],name:["formControlName","name"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},features:[ta([GH]),li,ct]}),e._ngModelWarningSentOnce=!1,e})(),KH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[[VH]]}),e})(),XH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[KH]}),e})(),ZH=(()=>{class e{static withConfig(t){return{ngModule:e,providers:[{provide:UH,useValue:t.warnOnNgModelWithFormControl}]}}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[KH]}),e})(),YH=(()=>{class e{group(e,t=null){const n=this._reduceControls(e);let r,s=null,i=null;return null!=t&&(function(e){return void 0!==e.asyncValidators||void 0!==e.validators||void 0!==e.updateOn}(t)?(s=null!=t.validators?t.validators:null,i=null!=t.asyncValidators?t.asyncValidators:null,r=null!=t.updateOn?t.updateOn:void 0):(s=null!=t.validator?t.validator:null,i=null!=t.asyncValidator?t.asyncValidator:null)),new FH(n,{asyncValidators:i,updateOn:r,validators:s})}control(e,t,n){return new RH(e,t,n)}array(e,t,n){const r=e.map(e=>this._createControl(e));return new DH(r,t,n)}_reduceControls(e){const t={};return Object.keys(e).forEach(n=>{t[n]=this._createControl(e[n])}),t}_createControl(e){return e instanceof RH||e instanceof FH||e instanceof DH?e:Array.isArray(e)?this.control(e[0],e.length>1?e[1]:null,e.length>2?e[2]:null):this.control(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:function(){return new e},token:e,providedIn:ZH}),e})();const QH=["chatMessages"],JH=function(e,t){return{"align-right":e,"align-left":t}},eK=function(e,t){return{"is-user":e,"is-bot":t}};function tK(e,t){if(1&e&&(ki(0,"div",18),ki(1,"div",19),ki(2,"p"),Li(3),Ci(),Ci(),Ci()),2&e){const e=t.$implicit;xi("ngClass",oo(3,JH,"user"===e.sender,"bot"===e.sender)),Jr(1),xi("ngClass",oo(6,eK,"user"===e.sender,"bot"===e.sender)),Jr(2),Pi(e.text)}}const nK=[{path:"",redirectTo:"home",pathMatch:"full"},{path:"home",component:(()=>{class e{constructor(e,t,n){this.chatbotService=e,this.chatTrying=t,this.fb=n,this.messages=[]}ngOnInit(){var e=this;return bp(function*(){e.modelSelectionForm=e.fb.group({model:["sequence-to-sequence"]}),yield e.chatbotService.loadModel(),yield e.chatTrying.trainChatbot()})()}sendMessage(){var e=this;return bp(function*(){if(""===e.userInput.trim())return;e.messages.push({sender:"user",text:e.userInput});const{model:t}=e.modelSelectionForm.value;let n="";n="sequence-to-sequence"===t?yield e.chatbotService.decodeSequence(e.userInput):yield e.chatTrying.getResponse(e.userInput),e.userInput="",e.messages.push({sender:"bot",text:n})})()}generateBotResponse(e){return e.toLowerCase().includes("hola")?"\xa1Hola! \xbfEn qu\xe9 puedo ayudarte?":e.toLowerCase().includes("adi\xf3s")?"\xa1Hasta luego! Que tengas un buen d\xeda.":"Lo siento, no entiendo tu mensaje. \xbfPodr\xedas ser m\xe1s espec\xedfico?"}scrollToBottom(){setTimeout(()=>{this.chatMessages&&(this.chatMessages.nativeElement.scrollTop=this.chatMessages.nativeElement.scrollHeight)},200)}}return e.\u0275fac=function(t){return new(t||e)(vi(RG),vi(VG),vi(YH))},e.\u0275cmp=je({type:e,selectors:[["app-home"]],viewQuery:function(e,t){if(1&e&&function(e,t,n){const r=At();r.firstCreatePass&&(function(e,t,n){null===e.queries&&(e.queries=new go),e.queries.track(new bo(t,-1))}(r,new mo(e,t,n)),2==(2&t)&&(r.staticViewQueries=!0)),function(e,t,n){const r=new ho(4==(4&n));vs(e,t,r,r.destroy),null===t[19]&&(t[19]=new fo),t[19].queries.push(new po(r))}(r,Tt(),t)}(QH,5),2&e){let e;ko((n=Tt(),r=Bt(),e=n[19].queries[r].queryList))&&(t.chatMessages=e.first)}var n,r},decls:25,vars:3,consts:[[1,"chat-container"],[1,"options-box"],[1,"options-header"],[1,"options-form",3,"formGroup"],[1,"custom-radio"],["type","radio","formControlName","model","value","sequence-to-sequence"],["type","radio","formControlName","model","value","intents"],[1,"chat-box"],[1,"chat-header"],[1,"chat-messages"],["chatMessages",""],["class","message-container",3,"ngClass",4,"ngFor","ngForOf"],[1,"chat-input"],[1,"field","has-addons"],[1,"control","is-expanded"],["type","text","placeholder","Escribe tu mensaje...",1,"input",3,"ngModel","ngModelChange","keydown.enter"],[1,"control"],[1,"button","is-primary",3,"click"],[1,"message-container",3,"ngClass"],[1,"message",3,"ngClass"]],template:function(e,t){1&e&&(ki(0,"body"),ki(1,"div",0),ki(2,"div",1),ki(3,"div",2),Li(4," Modelos disponibles "),Ci(),ki(5,"form",3),ki(6,"label",4),Ii(7,"input",5),Li(8," S2S "),Ci(),ki(9,"label",4),Ii(10,"input",6),Li(11," Intents "),Ci(),Ci(),Ci(),ki(12,"div",7),ki(13,"div",8),Li(14," Chatbot Grupo 5 - Chatbot12 "),Ci(),ki(15,"div",9,10),function(e,t,n,r,s,i,a,o){const u=Tt(),l=At(),c=l.firstCreatePass?function(e,t,n,r,s,i,a,o,u){const l=t.consts,c=ls(t,37,4,"div",_t(l,11));ws(t,n,c,_t(l,undefined)),Jt(t,c);const h=c.tViews=ys(2,c,r,4,9,t.directiveRegistry,t.pipeRegistry,null,t.schemas,l);return null!==t.queries&&(t.queries.template(t,c),h.queries=t.queries.embeddedTView(c)),c}(0,l,u,t):l.data[37];Dt(c,!1);const h=u[11].createComment("");Rr(l,u,h,c),ur(h,u),Os(u,u[37]=As(h,u,h,c)),at(c)&&ms(l,u,c)}(0,tK),Ci(),ki(18,"div",12),ki(19,"div",13),ki(20,"div",14),ki(21,"input",15),Ni("ngModelChange",function(e){return t.userInput=e})("keydown.enter",function(){return t.sendMessage()}),Ci(),Ci(),ki(22,"div",16),ki(23,"button",17),Ni("click",function(){return t.sendMessage()}),Li(24,"Enviar"),Ci(),Ci(),Ci(),Ci(),Ci(),Ci(),Ci()),2&e&&(Jr(5),xi("formGroup",t.modelSelectionForm),Jr(12),xi("ngForOf",t.messages),Jr(4),xi("ngModel",t.userInput))},directives:[PH,hH,jH,WH,HG,cH,HH,Gu,LH,qu],styles:[".chat-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;min-height:100vh;padding:10px;background-color:#fff;position:relative}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]{width:200px;background-color:#fff;border:1px solid #ddd;border-radius:8px;margin-right:15px;box-shadow:0 4px 20px #0000001a;z-index:10;position:static}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-header[_ngcontent-%COMP%]{background-color:#183059;color:#fff;padding:10px;font-size:1rem;text-align:center;border-radius:8px 8px 0 0}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]{padding:10px}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]   .custom-radio[_ngcontent-%COMP%]{display:flex;align-items:center;grid-gap:5px;gap:5px;margin-bottom:10px}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]   .custom-radio[_ngcontent-%COMP%]   input[type=radio][_ngcontent-%COMP%]{margin-right:0}.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{width:100%;max-width:400px;display:flex;flex-direction:column;height:80vh;border-radius:8px;box-shadow:0 4px 20px #0003;background-color:#fff}@media (min-width:768px){.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{max-width:600px;height:85vh}}@media (min-width:1024px){.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{max-width:800px;height:90vh}}.chat-container[_ngcontent-%COMP%]   .chat-header[_ngcontent-%COMP%]{background-color:#183059;color:#fff;padding:10px;text-align:center;font-size:1.5rem;border-radius:5px 5px 0 0;z-index:1}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]{flex:1;overflow-y:auto;padding:15px 10px;background-color:#fff;border:1px solid #ddd;border-top:none;display:flex;flex-direction:column;grid-gap:10px;gap:10px;font-size:1rem}@media (min-width:1024px){.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]{font-size:1.2rem}}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]{display:flex}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container.align-right[_ngcontent-%COMP%]{justify-content:flex-end}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container.align-left[_ngcontent-%COMP%]{justify-content:flex-start}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message[_ngcontent-%COMP%]{padding:10px 15px;border-radius:10px;max-width:70%;word-wrap:break-word;font-size:1rem}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message.is-user[_ngcontent-%COMP%]{background-color:#183059;color:#fff;text-align:right;border-bottom-right-radius:0}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message.is-bot[_ngcontent-%COMP%]{background-color:#f5f5f5;color:#333;text-align:left;border-bottom-left-radius:0}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]{padding:10px;border-top:1px solid #ddd;background-color:#fff}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .field[_ngcontent-%COMP%]{display:flex;align-items:center}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .input[_ngcontent-%COMP%]{flex:1;border-radius:5px;background-color:#fff;color:#333;border:1px solid #ddd;padding:5px 10px}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .input[_ngcontent-%COMP%]::placeholder{color:#333;font-style:italic}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]{background-color:#183059;color:#fff;border-radius:5px;white-space:nowrap;padding:5px 15px;border:none;cursor:pointer;transition:background-color .2s}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]:hover{background-color:#00c1a8}@media (max-width:768px){.chat-container[_ngcontent-%COMP%]{flex-direction:column}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]{position:absolute;top:10px;left:50%;transform:translateX(-50%);width:90%;margin-right:0;border-radius:8px}.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{margin-top:200px}}"]}),e})()}];let rK=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[[op.forRoot(nK)],op]}),e})(),sK=(()=>{class e{constructor(e){this.chatbotService=e,this.title="chatbot12"}}return e.\u0275fac=function(t){return new(t||e)(vi(RG))},e.\u0275cmp=je({type:e,selectors:[["app-root"]],decls:1,vars:0,template:function(e,t){1&e&&Ii(0,"router-outlet")},directives:[Yd],styles:[""]}),e})(),iK=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e,bootstrap:[sK]}),e.\u0275inj=me({providers:[],imports:[[Nl,rK,XH,ZH]]}),e})();(function(){if(su)throw new Error("Cannot enable prod mode after platform setup.");ru=!1})(),_l().bootstrapModule(iK).catch(e=>console.error(e))},410:()=>{},628:()=>{},601:()=>{},792:()=>{},42:()=>{}},e=>{"use strict";e(e.s=3)}]);