(self.webpackChunkchatbot12=self.webpackChunkchatbot12||[]).push([[179],{255:e=>{function t(e){return Promise.resolve().then(()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}t.keys=()=>[],t.resolve=t,t.id=255,e.exports=t},566:(e,t,n)=>{var s=n(683),r=n(669),a=n(64),o=n(763),i=n(553),u=n(464),l=n(147);l.alea=s,l.xor128=r,l.xorwow=a,l.xorshift7=o,l.xor4096=i,l.tychei=u,e.exports=l},683:function(e,t,n){var s;!function(e,r,a){function o(e){var t,n=this,s=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var s=.02519603282416938*(t+=e.charCodeAt(n));s-=t=s>>>0,t=(s*=t)>>>0,t+=4294967296*(s-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=s(" "),n.s1=s(" "),n.s2=s(" "),n.s0-=s(e),n.s0<0&&(n.s0+=1),n.s1-=s(e),n.s1<0&&(n.s1+=1),n.s2-=s(e),n.s2<0&&(n.s2+=1),s=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new o(e),s=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,s&&("object"==typeof s&&i(s,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.alea=u}(0,e=n.nmd(e))},464:function(e,t,n){var s;!function(e,r,a){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,s=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-s|0,s=s<<24^s>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-s|0,t.d=s<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var s=0;s<n.length+20;s++)t.b^=0|n.charCodeAt(s),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new o(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&i(s,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.tychei=u}(0,e=n.nmd(e))},669:function(e,t,n){var s;!function(e,r,a){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var s=0;s<n.length+64;s++)t.x^=0|n.charCodeAt(s),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new o(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&i(s,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xor128=u}(0,e=n.nmd(e))},553:function(e,t,n){var s;!function(e,r,a){function o(e){var t=this;t.next=function(){var e,n,s=t.w,r=t.X,a=t.i;return t.w=s=s+1640531527|0,n=r[a+34&127],e=r[a=a+1&127],n^=n<<13,e^=e<<17,n=r[a]=(n^=n>>>15)^(e^=e>>>12),t.i=a,n+(s^s>>>16)|0},function(e,t){var n,s,r,a,o,i=[],u=128;for(t===(0|t)?(s=t,t=null):(t+="\0",s=0,u=Math.max(u,t.length)),r=0,a=-32;a<u;++a)t&&(s^=t.charCodeAt((a+32)%t.length)),0===a&&(o=s),s^=s<<10,s^=s>>>15,s^=s<<4,s^=s>>>13,a>=0&&(r=0==(n=i[127&a]^=s+(o=o+1640531527|0))?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,a=512;a>0;--a)s=i[r+34&127],n=i[r=r+1&127],s^=s<<13,n^=n<<17,i[r]=(s^=s>>>15)^(n^=n>>>12);e.w=o,e.X=i,e.i=r}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new o(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&(s.X&&i(s,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xor4096=u}(0,e=n.nmd(e))},763:function(e,t,n){var s;!function(e,r,a){function o(e){var t=this;t.next=function(){var e,n,s=t.x,r=t.i;return e=s[r],n=(e^=e>>>7)^e<<24,n^=(e=s[r+1&7])^e>>>10,n^=(e=s[r+3&7])^e>>>3,n^=(e=s[r+4&7])^e<<7,e=s[r+7&7],s[r]=n^=(e^=e<<13)^e<<9,t.i=r+1&7,n},function(e,t){var n,s=[];if(t===(0|t))s[0]=t;else for(t=""+t,n=0;n<t.length;++n)s[7&n]=s[7&n]<<15^t.charCodeAt(n)+s[n+1&7]<<13;for(;s.length<8;)s.push(0);for(n=0;n<8&&0===s[n];++n);for(8==n&&(s[7]=-1),e.x=s,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new o(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&(s.x&&i(s,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xorshift7=u}(0,e=n.nmd(e))},64:function(e,t,n){var s;!function(e,r,a){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var s=0;s<n.length+64;s++)t.x^=0|n.charCodeAt(s),s==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new o(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&i(s,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=u:n.amdD&&n.amdO?void 0===(s=(function(){return u}).call(t,n,t,r))||(r.exports=s):this.xorwow=u}(0,e=n.nmd(e))},147:(e,t,n)=>{var s;!function(r,a){var o,i=this,u=256,l=a.pow(u,6),c=a.pow(2,52),d=2*c,p=255;function h(e,t,n){var s=[],p=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(r)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(u):(e=new Uint8Array(u),(i.crypto||i.msCrypto).getRandomValues(e)),y(e)}catch(s){var t=i.navigator,n=t&&t.plugins;return[+new Date,i,n,i.screen,y(r)]}}():e,3),s),h=new f(s),v=function(){for(var e=h.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=h.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|h.g(4)},v.quick=function(){return h.g(4)/4294967296},v.double=v,b(y(h.S),r),(t.pass||n||function(e,t,n,s){return s&&(s.S&&m(s,h),e.state=function(){return m(h,{})}),n?(a.random=e,t):e})(v,p,"global"in t?t.global:this==a,t.state)}function f(e){var t,n=e.length,s=this,r=0,a=s.i=s.j=0,o=s.S=[];for(n||(e=[n++]);r<u;)o[r]=r++;for(r=0;r<u;r++)o[r]=o[a=p&a+e[r%n]+(t=o[r])],o[a]=t;(s.g=function(e){for(var t,n=0,r=s.i,a=s.j,o=s.S;e--;)t=o[r=p&r+1],n=n*u+o[p&(o[r]=o[a=p&a+t])+(o[a]=t)];return s.i=r,s.j=a,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,s=[],r=typeof e;if(t&&"object"==r)for(n in e)try{s.push(g(e[n],t-1))}catch(a){}return s.length?s:"string"==r?e:e+"\0"}function b(e,t){for(var n,s=e+"",r=0;r<s.length;)t[p&r]=p&(n^=19*t[p&r])+s.charCodeAt(r++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(a.seedrandom=h,b(a.random(),r),e.exports){e.exports=h;try{o=n(42)}catch(v){}}else void 0===(s=(function(){return h}).call(t,n,t,e))||(e.exports=s)}([],Math)},862:(e,t,n)=>{"use strict";var s={};n.r(s),n.d(s,{assertParamsValid:()=>sv,computeFlatOffset:()=>gv,computeOutShape:()=>av,getNormalizedAxes:()=>lv,isSliceContinous:()=>mv,maskToAxes:()=>rv,parseSliceParams:()=>bv,sliceInfo:()=>yv,startForAxis:()=>hv,startIndicesWithElidedDims:()=>cv,stopForAxis:()=>fv,stopIndicesWithElidedDims:()=>dv,stridesForAxis:()=>pv,stridesWithElidedDims:()=>ov});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>qC,computeOutShape:()=>OC,segOpComputeOptimalWindowSize:()=>DC});var a={};n.r(a),n.d(a,{ERF_A1:()=>dC,ERF_A2:()=>pC,ERF_A3:()=>hC,ERF_A4:()=>fC,ERF_A5:()=>mC,ERF_P:()=>cC,PARALLELIZE_THRESHOLD:()=>Zk,SELU_SCALE:()=>lC,SELU_SCALEALPHA:()=>uC,applyActivation:()=>Qw,assertAndGetBroadcastShape:()=>wx,assertAxesAreInnerMostDims:()=>Zx,assertParamsConsistent:()=>Kk,assignToTypedArray:()=>CC,axesAreInnerMostDims:()=>Gx,calculateShapes:()=>iC,checkEinsumDimSizes:()=>$C,combineLocations:()=>Hx,complexWithEvenIndex:()=>xC,complexWithOddIndex:()=>wC,computeConv2DInfo:()=>Lv,computeConv3DInfo:()=>Pv,computeDefaultPad:()=>Vv,computeDilation2DInfo:()=>qv,computeOptimalWindowSize:()=>Yk,computeOutAndReduceShapes:()=>Kx,computeOutShape:()=>Xk,computePool2DInfo:()=>zv,computePool3DInfo:()=>Mv,convertConv2DDataFormat:()=>Kv,decodeEinsumEquation:()=>EC,eitherStridesOrDilationsAreOne:()=>Hv,expandShapeToKeepDim:()=>Xx,exponent:()=>_C,exponents:()=>IC,fromStringArrayToUint8:()=>MC,fromUint8ToStringArray:()=>zC,getAxesPermutation:()=>Yx,getBroadcastDims:()=>vx,getComplexWithIndex:()=>kC,getEinsumComputePath:()=>TC,getEinsumPermutation:()=>NC,getFusedBiasGradient:()=>Yw,getFusedDyActivation:()=>Zw,getImageCenter:()=>Qk,getInnerMostAxes:()=>Jx,getPermuted:()=>eC,getReductionAxes:()=>xx,getReshaped:()=>Jk,getReshapedPermuted:()=>tC,getSliceBeginCoords:()=>nC,getSliceSize:()=>sC,getUndoAxesPermutation:()=>Qx,isIdentityPermutation:()=>AC,log:()=>bC,mergeRealAndImagArrays:()=>yC,prepareAndValidate:()=>rC,prepareSplitSize:()=>FC,segment_util:()=>r,shouldFuse:()=>Jw,slice_util:()=>s,splitRealAndImagArrays:()=>vC,tupleValuesAreOne:()=>Gv,upcastType:()=>Pb,validateInput:()=>oC,validateUpdateShape:()=>aC,warn:()=>gC});var o={};function i(e){return"function"==typeof e}n.r(o),n.d(o,{addImpl:()=>dF,bincountImpl:()=>sD,bincountReduceImpl:()=>rD,ceilImpl:()=>iD,concatImpl:()=>hD,expImpl:()=>oO,expm1Impl:()=>dO,floorImpl:()=>NO,gatherV2Impl:()=>zO,greaterImpl:()=>LO,lessImpl:()=>QO,linSpaceImpl:()=>rq,logImpl:()=>oq,maxImpl:()=>wq,maximumImpl:()=>Iq,minimumImpl:()=>Dq,multiplyImpl:()=>VD,negImpl:()=>Wq,notEqualImpl:()=>Qq,prodImpl:()=>dz,rangeImpl:()=>hz,rsqrtImpl:()=>_z,simpleAbsImpl:()=>xF,sliceImpl:()=>JF,sparseFillEmptyRowsImpl:()=>Uz,sparseReshapeImpl:()=>Hz,squaredDifferenceImpl:()=>eM,stridedSliceImpl:()=>aM,subImpl:()=>bO,tileImpl:()=>cM,topKImpl:()=>dM,transposeImpl:()=>EF,uniqueImpl:()=>gM});let u=!1;const l={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else u&&console.log("RxJS: Back to a better error behavior. Thank you. <3");u=e},get useDeprecatedSynchronousErrorHandling(){return u}};function c(e){setTimeout(()=>{throw e},0)}const d={closed:!0,next(e){},error(e){if(l.useDeprecatedSynchronousErrorHandling)throw e;c(e)},complete(){}},p=(()=>Array.isArray||(e=>e&&"number"==typeof e.length))();function h(e){return null!==e&&"object"==typeof e}const f=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();let m=(()=>{class e{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._ctorUnsubscribe=!0,this._unsubscribe=e)}unsubscribe(){let t;if(this.closed)return;let{_parentOrParents:n,_ctorUnsubscribe:s,_unsubscribe:r,_subscriptions:a}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof e)n.remove(this);else if(null!==n)for(let e=0;e<n.length;++e)n[e].remove(this);if(i(r)){s&&(this._unsubscribe=void 0);try{r.call(this)}catch(o){t=o instanceof f?g(o.errors):[o]}}if(p(a)){let e=-1,n=a.length;for(;++e<n;){const n=a[e];if(h(n))try{n.unsubscribe()}catch(o){t=t||[],o instanceof f?t=t.concat(g(o.errors)):t.push(o)}}}if(t)throw new f(t)}add(t){let n=t;if(!t)return e.EMPTY;switch(typeof t){case"function":n=new e(t);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof e)){const t=n;n=new e,n._subscriptions=[t]}break;default:throw new Error("unrecognized teardown "+t+" added to Subscription.")}let{_parentOrParents:s}=n;if(null===s)n._parentOrParents=this;else if(s instanceof e){if(s===this)return n;n._parentOrParents=[s,this]}else{if(-1!==s.indexOf(this))return n;s.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[n]:r.push(n),n}remove(e){const t=this._subscriptions;if(t){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}}}return e.EMPTY=function(e){return e.closed=!0,e}(new e),e})();function g(e){return e.reduce((e,t)=>e.concat(t instanceof f?t.errors:t),[])}const b=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class y extends m{constructor(e,t,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=d;break;case 1:if(!e){this.destination=d;break}if("object"==typeof e){e instanceof y?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new v(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new v(this,e,t,n)}}[b](){return this}static create(e,t,n){const s=new y(e,t,n);return s.syncErrorThrowable=!1,s}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class v extends y{constructor(e,t,n,s){let r;super(),this._parentSubscriber=e;let a=this;i(t)?r=t:t&&(r=t.next,n=t.error,s=t.complete,t!==d&&(a=Object.create(t),i(a.unsubscribe)&&this.add(a.unsubscribe.bind(a)),a.unsubscribe=this.unsubscribe.bind(this))),this._context=a,this._next=r,this._error=n,this._complete=s}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;l.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:n}=l;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):c(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;c(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);l.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(n){if(this.unsubscribe(),l.useDeprecatedSynchronousErrorHandling)throw n;c(n)}}__tryOrSetError(e,t,n){if(!l.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(s){return l.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=s,e.syncErrorThrown=!0,!0):(c(s),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const x=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function w(e){return e}let k=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const n=new e;return n.source=this,n.operator=t,n}subscribe(e,t,n){const{operator:s}=this,r=function(e,t,n){if(e){if(e instanceof y)return e;if(e[b])return e[b]()}return e||t||n?new y(e,t,n):new y(d)}(e,t,n);if(r.add(s?s.call(r,this.source):this.source||l.useDeprecatedSynchronousErrorHandling&&!r.syncErrorThrowable?this._subscribe(r):this._trySubscribe(r)),l.useDeprecatedSynchronousErrorHandling&&r.syncErrorThrowable&&(r.syncErrorThrowable=!1,r.syncErrorThrown))throw r.syncErrorValue;return r}_trySubscribe(e){try{return this._subscribe(e)}catch(t){l.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:n,isStopped:s}=e;if(t||s)return!1;e=n&&n instanceof y?n:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=C(t))((t,n)=>{let s;s=this.subscribe(t=>{try{e(t)}catch(r){n(r),s&&s.unsubscribe()}},n,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[x](){return this}pipe(...e){return 0===e.length?this:(0===(t=e).length?w:1===t.length?t[0]:function(e){return t.reduce((e,t)=>t(e),e)})(this);var t}toPromise(e){return new(e=C(e))((e,t)=>{let n;this.subscribe(e=>n=e,e=>t(e),()=>e(n))})}}return e.create=t=>new e(t),e})();function C(e){if(e||(e=l.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const I=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class _ extends m{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const n=t.indexOf(this.subscriber);-1!==n&&t.splice(n,1)}}class S extends y{constructor(e){super(e),this.destination=e}}let E=(()=>{class e extends k{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[b](){return new S(this)}lift(e){const t=new N(this,this);return t.operator=e,t}next(e){if(this.closed)throw new I;if(!this.isStopped){const{observers:t}=this,n=t.length,s=t.slice();for(let r=0;r<n;r++)s[r].next(e)}}error(e){if(this.closed)throw new I;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,n=t.length,s=t.slice();for(let r=0;r<n;r++)s[r].error(e);this.observers.length=0}complete(){if(this.closed)throw new I;this.isStopped=!0;const{observers:e}=this,t=e.length,n=e.slice();for(let s=0;s<t;s++)n[s].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new I;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new I;return this.hasError?(e.error(this.thrownError),m.EMPTY):this.isStopped?(e.complete(),m.EMPTY):(this.observers.push(e),new _(this,e))}asObservable(){const e=new k;return e.source=this,e}}return e.create=(e,t)=>new N(e,t),e})();class N extends E{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):m.EMPTY}}function $(e){return e&&"function"==typeof e.schedule}function T(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new A(e,t))}}class A{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new R(e,this.project,this.thisArg))}}class R extends y{constructor(e,t,n){super(e),this.project=t,this.count=0,this.thisArg=n||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const F=e=>t=>{for(let n=0,s=e.length;n<s&&!t.closed;n++)t.next(e[n]);t.complete()};function D(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const O=D(),q=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function z(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const M=e=>{if(e&&"function"==typeof e[x])return n=e,e=>{const t=n[x]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(q(e))return F(e);if(z(e))return(e=>t=>(e.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,c),t))(e);if(e&&"function"==typeof e[O])return t=e,e=>{const n=t[O]();for(;;){let t;try{t=n.next()}catch(s){return e.error(s),e}if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof n.return&&e.add(()=>{n.return&&n.return()}),e};{const t=h(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,n};function L(e,t){return new k(n=>{const s=new m;let r=0;return s.add(t.schedule(function(){r!==e.length?(n.next(e[r++]),n.closed||s.add(this.schedule())):n.complete()})),s})}function P(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[x]}(e))return function(e,t){return new k(n=>{const s=new m;return s.add(t.schedule(()=>{const r=e[x]();s.add(r.subscribe({next(e){s.add(t.schedule(()=>n.next(e)))},error(e){s.add(t.schedule(()=>n.error(e)))},complete(){s.add(t.schedule(()=>n.complete()))}}))})),s})}(e,t);if(z(e))return function(e,t){return new k(n=>{const s=new m;return s.add(t.schedule(()=>e.then(e=>{s.add(t.schedule(()=>{n.next(e),s.add(t.schedule(()=>n.complete()))}))},e=>{s.add(t.schedule(()=>n.error(e)))}))),s})}(e,t);if(q(e))return L(e,t);if(function(e){return e&&"function"==typeof e[O]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new k(n=>{const s=new m;let r;return s.add(()=>{r&&"function"==typeof r.return&&r.return()}),s.add(t.schedule(()=>{r=e[O](),s.add(t.schedule(function(){if(n.closed)return;let e,t;try{const n=r.next();e=n.value,t=n.done}catch(s){return void n.error(s)}t?n.complete():(n.next(e),this.schedule())}))})),s})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof k?e:new k(M(e))}class V extends y{constructor(e){super(),this.parent=e}_next(e){this.parent.notifyNext(e)}_error(e){this.parent.notifyError(e),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class j extends y{notifyNext(e){this.destination.next(e)}notifyError(e){this.destination.error(e)}notifyComplete(){this.destination.complete()}}function B(e,t){if(t.closed)return;if(e instanceof k)return e.subscribe(t);let n;try{n=M(e)(t)}catch(s){t.error(s)}return n}function W(e,t,n=Number.POSITIVE_INFINITY){return"function"==typeof t?s=>s.pipe(W((n,s)=>P(e(n,s)).pipe(T((e,r)=>t(n,e,s,r))),n)):("number"==typeof t&&(n=t),t=>t.lift(new U(e,n)))}class U{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new G(e,this.project,this.concurrent))}}class G extends j{constructor(e,t,n=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(s){return void this.destination.error(s)}this.active++,this._innerSub(t)}_innerSub(e){const t=new V(this),n=this.destination;n.add(t);const s=B(e,t);s!==t&&n.add(s)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e){this.destination.next(e)}notifyComplete(){const e=this.buffer;this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function H(e=Number.POSITIVE_INFINITY){return W(w,e)}function K(e,t){return t?L(e,t):new k(F(e))}function X(){return function(e){return e.lift(new Z(e))}}class Z{constructor(e){this.connectable=e}call(e,t){const{connectable:n}=this;n._refCount++;const s=new Y(e,n),r=t.subscribe(s);return s.closed||(s.connection=n.connect()),r}}class Y extends y{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:n}=this,s=e._connection;this.connection=null,!s||n&&s!==n||s.unsubscribe()}}class Q extends k{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new m,e.add(this.source.subscribe(new ee(this.getSubject(),this))),e.closed&&(this._connection=null,e=m.EMPTY)),e}refCount(){return X()(this)}}const J=(()=>{const e=Q.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class ee extends S{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function te(){return new E}function ne(e){for(let t in e)if(e[t]===ne)return t;throw Error("Could not find renamed property on target object.")}function se(e,t){for(const n in t)t.hasOwnProperty(n)&&!e.hasOwnProperty(n)&&(e[n]=t[n])}function re(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(re).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function ae(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const oe=ne({__forward_ref__:ne});function ie(e){return e.__forward_ref__=ie,e.toString=function(){return re(this())},e}function ue(e){return le(e)?e():e}function le(e){return"function"==typeof e&&e.hasOwnProperty(oe)&&e.__forward_ref__===ie}class ce extends Error{constructor(e,t){super(function(e,t){return`${e?`NG0${e}: `:""}${t}`}(e,t)),this.code=e}}function de(e){return"string"==typeof e?e:null==e?"":String(e)}function pe(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():de(e)}function he(e,t){const n=t?` in ${t}`:"";throw new ce("201",`No provider for ${pe(e)} found${n}`)}function fe(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function me(e){return{providers:e.providers||[],imports:e.imports||[]}}function ge(e){return be(e,ve)||be(e,we)}function be(e,t){return e.hasOwnProperty(t)?e[t]:null}function ye(e){return e&&(e.hasOwnProperty(xe)||e.hasOwnProperty(ke))?e[xe]:null}const ve=ne({"\u0275prov":ne}),xe=ne({"\u0275inj":ne}),we=ne({ngInjectableDef:ne}),ke=ne({ngInjectorDef:ne});var Ce=function(e){return e[e.Default=0]="Default",e[e.Host=1]="Host",e[e.Self=2]="Self",e[e.SkipSelf=4]="SkipSelf",e[e.Optional=8]="Optional",e}({});let Ie;function _e(e){const t=Ie;return Ie=e,t}function Se(e,t,n){const s=ge(e);return s&&"root"==s.providedIn?void 0===s.value?s.value=s.factory():s.value:n&Ce.Optional?null:void 0!==t?t:void he(re(e),"Injector")}function Ee(e){return{toString:e}.toString()}var Ne=function(e){return e[e.OnPush=0]="OnPush",e[e.Default=1]="Default",e}({}),$e=function(e){return e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",e}({});const Te="undefined"!=typeof globalThis&&globalThis,Ae="undefined"!=typeof window&&window,Re="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Fe="undefined"!=typeof global&&global,De=Te||Fe||Ae||Re,Oe={},qe=[],ze=ne({"\u0275cmp":ne}),Me=ne({"\u0275dir":ne}),Le=ne({"\u0275pipe":ne}),Pe=ne({"\u0275mod":ne}),Ve=ne({"\u0275loc":ne}),je=ne({"\u0275fac":ne}),Be=ne({__NG_ELEMENT_ID__:ne});let We=0;function Ue(e){return Ee(()=>{const t={},n={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===Ne.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||qe,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||$e.Emulated,id:"c",styles:e.styles||qe,_:null,setInput:null,schemas:e.schemas||null,tView:null},s=e.directives,r=e.features,a=e.pipes;return n.id+=We++,n.inputs=Ze(e.inputs,t),n.outputs=Ze(e.outputs),r&&r.forEach(e=>e(n)),n.directiveDefs=s?()=>("function"==typeof s?s():s).map(Ge):null,n.pipeDefs=a?()=>("function"==typeof a?a():a).map(He):null,n})}function Ge(e){return Qe(e)||function(e){return e[Me]||null}(e)}function He(e){return function(e){return e[Le]||null}(e)}const Ke={};function Xe(e){return Ee(()=>{const t={type:e.type,bootstrap:e.bootstrap||qe,declarations:e.declarations||qe,imports:e.imports||qe,exports:e.exports||qe,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&(Ke[e.id]=e.type),t})}function Ze(e,t){if(null==e)return Oe;const n={};for(const s in e)if(e.hasOwnProperty(s)){let r=e[s],a=r;Array.isArray(r)&&(a=r[1],r=r[0]),n[r]=s,t&&(t[r]=a)}return n}const Ye=Ue;function Qe(e){return e[ze]||null}function Je(e,t){const n=e[Pe]||null;if(!n&&!0===t)throw new Error(`Type ${re(e)} does not have '\u0275mod' property.`);return n}const et=20,tt=10;function nt(e){return Array.isArray(e)&&"object"==typeof e[1]}function st(e){return Array.isArray(e)&&!0===e[1]}function rt(e){return 0!=(8&e.flags)}function at(e){return 2==(2&e.flags)}function ot(e){return 1==(1&e.flags)}function it(e){return null!==e.template}function ut(e,t){return e.hasOwnProperty(je)?e[je]:null}class lt{constructor(e,t,n){this.previousValue=e,this.currentValue=t,this.firstChange=n}isFirstChange(){return this.firstChange}}function ct(){return dt}function dt(e){return e.type.prototype.ngOnChanges&&(e.setInput=ht),pt}function pt(){const e=ft(this),t=null==e?void 0:e.current;if(t){const n=e.previous;if(n===Oe)e.previous=t;else for(let e in t)n[e]=t[e];e.current=null,this.ngOnChanges(t)}}function ht(e,t,n,s){const r=ft(e)||function(e,t){return e.__ngSimpleChanges__=t}(e,{previous:Oe,current:null}),a=r.current||(r.current={}),o=r.previous,i=this.declaredInputs[n],u=o[i];a[i]=new lt(u&&u.currentValue,t,o===Oe),e[s]=t}function ft(e){return e.__ngSimpleChanges__||null}let mt;function gt(e){return!!e.listen}ct.ngInherit=!0;const bt={createRenderer:(e,t)=>void 0!==mt?mt:"undefined"!=typeof document?document:void 0};function yt(e){for(;Array.isArray(e);)e=e[0];return e}function vt(e,t){return yt(t[e])}function xt(e,t){return yt(t[e.index])}function wt(e,t){return e.data[t]}function kt(e,t){const n=t[e];return nt(n)?n:n[0]}function Ct(e){return 4==(4&e[2])}function It(e){return 128==(128&e[2])}function _t(e,t){return null==t?null:e[t]}function St(e){e[18]=0}function Et(e,t){e[5]+=t;let n=e,s=e[3];for(;null!==s&&(1===t&&1===n[5]||-1===t&&0===n[5]);)s[5]+=t,n=s,s=s[3]}const Nt={lFrame:Ht(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function $t(){return Nt.bindingsEnabled}function Tt(){return Nt.lFrame.lView}function At(){return Nt.lFrame.tView}function Rt(){let e=Ft();for(;null!==e&&64===e.type;)e=e.parent;return e}function Ft(){return Nt.lFrame.currentTNode}function Dt(e,t){const n=Nt.lFrame;n.currentTNode=e,n.isParent=t}function Ot(){return Nt.lFrame.isParent}function qt(){return Nt.isInCheckNoChangesMode}function zt(e){Nt.isInCheckNoChangesMode=e}function Mt(){return Nt.lFrame.bindingIndex++}function Lt(e,t){const n=Nt.lFrame;n.bindingIndex=n.bindingRootIndex=e,Pt(t)}function Pt(e){Nt.lFrame.currentDirectiveIndex=e}function Vt(){return Nt.lFrame.currentQueryIndex}function jt(e){Nt.lFrame.currentQueryIndex=e}function Bt(e){const t=e[1];return 2===t.type?t.declTNode:1===t.type?e[6]:null}function Wt(e,t,n){if(n&Ce.SkipSelf){let s=t,r=e;for(;s=s.parent,!(null!==s||n&Ce.Host||(s=Bt(r),null===s)||(r=r[15],10&s.type)););if(null===s)return!1;t=s,e=r}const s=Nt.lFrame=Gt();return s.currentTNode=t,s.lView=e,!0}function Ut(e){const t=Gt(),n=e[1];Nt.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function Gt(){const e=Nt.lFrame,t=null===e?null:e.child;return null===t?Ht(e):t}function Ht(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function Kt(){const e=Nt.lFrame;return Nt.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const Xt=Kt;function Zt(){const e=Kt();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function Yt(){return Nt.lFrame.selectedIndex}function Qt(e){Nt.lFrame.selectedIndex=e}function Jt(e,t){for(let n=t.directiveStart,s=t.directiveEnd;n<s;n++){const t=e.data[n].type.prototype,{ngAfterContentInit:s,ngAfterContentChecked:r,ngAfterViewInit:a,ngAfterViewChecked:o,ngOnDestroy:i}=t;s&&(e.contentHooks||(e.contentHooks=[])).push(-n,s),r&&((e.contentHooks||(e.contentHooks=[])).push(n,r),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,r)),a&&(e.viewHooks||(e.viewHooks=[])).push(-n,a),o&&((e.viewHooks||(e.viewHooks=[])).push(n,o),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,o)),null!=i&&(e.destroyHooks||(e.destroyHooks=[])).push(n,i)}}function en(e,t,n){sn(e,t,3,n)}function tn(e,t,n,s){(3&e[2])===n&&sn(e,t,n,s)}function nn(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function sn(e,t,n,s){const r=null!=s?s:-1,a=t.length-1;let o=0;for(let i=void 0!==s?65535&e[18]:0;i<a;i++)if("number"==typeof t[i+1]){if(o=t[i],null!=s&&o>=s)break}else t[i]<0&&(e[18]+=65536),(o<r||-1==r)&&(rn(e,n,t,i),e[18]=(4294901760&e[18])+i+2),i++}function rn(e,t,n,s){const r=n[s]<0,a=n[s+1],o=e[r?-n[s]:n[s]];if(r){if(e[2]>>11<e[18]>>16&&(3&e[2])===t){e[2]+=2048;try{a.call(o)}finally{}}}else try{a.call(o)}finally{}}const an=-1;class on{constructor(e,t,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=n}}function un(e,t,n){const s=gt(e);let r=0;for(;r<n.length;){const a=n[r];if("number"==typeof a){if(0!==a)break;r++;const o=n[r++],i=n[r++],u=n[r++];s?e.setAttribute(t,i,u,o):t.setAttributeNS(o,i,u)}else{const o=a,i=n[++r];cn(o)?s&&e.setProperty(t,o,i):s?e.setAttribute(t,o,i):t.setAttribute(o,i),r++}}return r}function ln(e){return 3===e||4===e||6===e}function cn(e){return 64===e.charCodeAt(0)}function dn(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let s=0;s<t.length;s++){const r=t[s];"number"==typeof r?n=r:0===n||pn(e,n,r,null,-1===n||2===n?t[++s]:null)}}return e}function pn(e,t,n,s,r){let a=0,o=e.length;if(-1===t)o=-1;else for(;a<e.length;){const n=e[a++];if("number"==typeof n){if(n===t){o=-1;break}if(n>t){o=a-1;break}}}for(;a<e.length;){const t=e[a];if("number"==typeof t)break;if(t===n){if(null===s)return void(null!==r&&(e[a+1]=r));if(s===e[a+1])return void(e[a+2]=r)}a++,null!==s&&a++,null!==r&&a++}-1!==o&&(e.splice(o,0,t),a=o+1),e.splice(a++,0,n),null!==s&&e.splice(a++,0,s),null!==r&&e.splice(a++,0,r)}function hn(e){return e!==an}function fn(e){return 32767&e}function mn(e,t){let n=e>>16,s=t;for(;n>0;)s=s[15],n--;return s}let gn=!0;function bn(e){const t=gn;return gn=e,t}let yn=0;function vn(e,t){const n=wn(e,t);if(-1!==n)return n;const s=t[1];s.firstCreatePass&&(e.injectorIndex=t.length,xn(s.data,e),xn(t,null),xn(s.blueprint,null));const r=kn(e,t),a=e.injectorIndex;if(hn(r)){const e=fn(r),n=mn(r,t),s=n[1].data;for(let r=0;r<8;r++)t[a+r]=n[e+r]|s[e+r]}return t[a+8]=r,a}function xn(e,t){e.push(0,0,0,0,0,0,0,0,t)}function wn(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function kn(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,s=null,r=t;for(;null!==r;){const e=r[1],t=e.type;if(s=2===t?e.declTNode:1===t?r[6]:null,null===s)return an;if(n++,r=r[15],-1!==s.injectorIndex)return s.injectorIndex|n<<16}return an}function Cn(e,t,n){!function(e,t,n){let s;"string"==typeof n?s=n.charCodeAt(0)||0:n.hasOwnProperty(Be)&&(s=n[Be]),null==s&&(s=n[Be]=yn++);const r=255&s;t.data[e+(r>>5)]|=1<<r}(e,t,n)}function In(e,t,n){if(n&Ce.Optional)return e;he(t,"NodeInjector")}function _n(e,t,n,s){if(n&Ce.Optional&&void 0===s&&(s=null),0==(n&(Ce.Self|Ce.Host))){const r=e[9],a=_e(void 0);try{return r?r.get(t,s,n&Ce.Optional):Se(t,s,n&Ce.Optional)}finally{_e(a)}}return In(s,t,n)}function Sn(e,t,n,s=Ce.Default,r){if(null!==e){const a=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(Be)?e[Be]:void 0;return"number"==typeof t?t>=0?255&t:Nn:t}(n);if("function"==typeof a){if(!Wt(t,e,s))return s&Ce.Host?In(r,n,s):_n(t,n,s,r);try{const e=a(s);if(null!=e||s&Ce.Optional)return e;he(n)}finally{Xt()}}else if("number"==typeof a){let r=null,o=wn(e,t),i=an,u=s&Ce.Host?t[16][6]:null;for((-1===o||s&Ce.SkipSelf)&&(i=-1===o?kn(e,t):t[o+8],i!==an&&Fn(s,!1)?(r=t[1],o=fn(i),t=mn(i,t)):o=-1);-1!==o;){const e=t[1];if(Rn(a,o,e.data)){const e=$n(o,t,n,r,s,u);if(e!==En)return e}i=t[o+8],i!==an&&Fn(s,t[1].data[o+8]===u)&&Rn(a,o,t)?(r=e,o=fn(i),t=mn(i,t)):o=-1}}}return _n(t,n,s,r)}const En={};function Nn(){return new Dn(Rt(),Tt())}function $n(e,t,n,s,r,a){const o=t[1],i=o.data[e+8],u=Tn(i,o,n,null==s?at(i)&&gn:s!=o&&0!=(3&i.type),r&Ce.Host&&a===i);return null!==u?An(t,o,u,i):En}function Tn(e,t,n,s,r){const a=e.providerIndexes,o=t.data,i=1048575&a,u=e.directiveStart,l=a>>20,c=r?i+l:e.directiveEnd;for(let d=s?i:i+l;d<c;d++){const e=o[d];if(d<u&&n===e||d>=u&&e.type===n)return d}if(r){const e=o[u];if(e&&it(e)&&e.type===n)return u}return null}function An(e,t,n,s){let r=e[n];const a=t.data;if(r instanceof on){const o=r;o.resolving&&function(e,t){throw new ce("200",`Circular dependency in DI detected for ${e}`)}(pe(a[n]));const i=bn(o.canSeeViewProviders);o.resolving=!0;const u=o.injectImpl?_e(o.injectImpl):null;Wt(e,s,Ce.Default);try{r=e[n]=o.factory(void 0,a,e,s),t.firstCreatePass&&n>=s.directiveStart&&function(e,t,n){const{ngOnChanges:s,ngOnInit:r,ngDoCheck:a}=t.type.prototype;if(s){const s=dt(t);(n.preOrderHooks||(n.preOrderHooks=[])).push(e,s),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,s)}r&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-e,r),a&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,a),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,a))}(n,a[n],t)}finally{null!==u&&_e(u),bn(i),o.resolving=!1,Xt()}}return r}function Rn(e,t,n){return!!(n[t+(e>>5)]&1<<e)}function Fn(e,t){return!(e&Ce.Self||e&Ce.Host&&t)}class Dn{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return Sn(this._tNode,this._lView,e,void 0,t)}}function On(e){return Ee(()=>{const t=e.prototype.constructor,n=t[je]||qn(t),s=Object.prototype;let r=Object.getPrototypeOf(e.prototype).constructor;for(;r&&r!==s;){const e=r[je]||qn(r);if(e&&e!==n)return e;r=Object.getPrototypeOf(r)}return e=>new e})}function qn(e){return le(e)?()=>{const t=qn(ue(e));return t&&t()}:ut(e)}const zn="__parameters__";function Mn(e,t,n){return Ee(()=>{const s=function(e){return function(...t){if(e){const n=e(...t);for(const e in n)this[e]=n[e]}}}(t);function r(...e){if(this instanceof r)return s.apply(this,e),this;const t=new r(...e);return n.annotation=t,n;function n(e,n,s){const r=e.hasOwnProperty(zn)?e[zn]:Object.defineProperty(e,zn,{value:[]})[zn];for(;r.length<=s;)r.push(null);return(r[s]=r[s]||[]).push(t),e}}return n&&(r.prototype=Object.create(n.prototype)),r.prototype.ngMetadataName=e,r.annotationCls=r,r})}class Ln{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=fe({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Pn=new Ln("AnalyzeForEntryComponents"),Vn=Function;function jn(e,t){void 0===t&&(t=e);for(let n=0;n<e.length;n++){let s=e[n];Array.isArray(s)?(t===e&&(t=e.slice(0,n)),jn(s,t)):t!==e&&t.push(s)}return t}function Bn(e,t){e.forEach(e=>Array.isArray(e)?Bn(e,t):t(e))}function Wn(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function Un(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}function Gn(e,t,n){let s=Kn(e,t);return s>=0?e[1|s]=n:(s=~s,function(e,t,n,s){let r=e.length;if(r==t)e.push(n,s);else if(1===r)e.push(s,e[0]),e[0]=n;else{for(r--,e.push(e[r-1],e[r]);r>t;)e[r]=e[r-2],r--;e[t]=n,e[t+1]=s}}(e,s,t,n)),s}function Hn(e,t){const n=Kn(e,t);if(n>=0)return e[1|n]}function Kn(e,t){return function(e,t,n){let s=0,r=e.length>>1;for(;r!==s;){const n=s+(r-s>>1),a=e[n<<1];if(t===a)return n<<1;a>t?r=n:s=n+1}return~(r<<1)}(e,t)}const Xn={},Zn=/\n/gm,Yn="__source",Qn=ne({provide:String,useValue:ne});let Jn;function es(e){const t=Jn;return Jn=e,t}function ts(e,t=Ce.Default){if(void 0===Jn)throw new Error("inject() must be called from an injection context");return null===Jn?Se(e,void 0,t):Jn.get(e,t&Ce.Optional?null:void 0,t)}function ns(e,t=Ce.Default){return(Ie||ts)(ue(e),t)}function ss(e){const t=[];for(let n=0;n<e.length;n++){const s=ue(e[n]);if(Array.isArray(s)){if(0===s.length)throw new Error("Arguments array must have arguments.");let e,n=Ce.Default;for(let t=0;t<s.length;t++){const r=s[t],a=r.__NG_DI_FLAG__;"number"==typeof a?-1===a?e=r.token:n|=a:e=r}t.push(ns(e,n))}else t.push(ns(s))}return t}function rs(e,t){return e.__NG_DI_FLAG__=t,e.prototype.__NG_DI_FLAG__=t,e}const as=rs(Mn("Inject",e=>({token:e})),-1),os=rs(Mn("Optional"),8),is=rs(Mn("SkipSelf"),4);function us(e,t){e.__ngContext__=t}function ls(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function cs(e){return e.ngDebugContext}function ds(e){return e.ngOriginalError}function ps(e,...t){e.error(...t)}class hs{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),n=this._findContext(e),s=function(e){return e.ngErrorLogger||ps}(e);s(this._console,"ERROR",e),t&&s(this._console,"ORIGINAL ERROR",t),n&&s(this._console,"ERROR CONTEXT",n)}_findContext(e){return e?cs(e)?cs(e):this._findContext(ds(e)):null}_findOriginalError(e){let t=ds(e);for(;t&&ds(t);)t=ds(t);return t}}const fs=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(De))();function ms(e){return e instanceof Function?e():e}var gs=function(e){return e[e.Important=1]="Important",e[e.DashCase=2]="DashCase",e}({});function bs(e,t){return(void 0)(e,t)}function ys(e){const t=e[3];return st(t)?t[3]:t}function vs(e){return ws(e[13])}function xs(e){return ws(e[4])}function ws(e){for(;null!==e&&!st(e);)e=e[4];return e}function ks(e,t,n,s,r){if(null!=s){let a,o=!1;st(s)?a=s:nt(s)&&(o=!0,s=s[0]);const i=yt(s);0===e&&null!==n?null==r?$s(t,n,i):Ns(t,n,i,r||null,!0):1===e&&null!==n?Ns(t,n,i,r||null,!0):2===e?function(e,t,n){const s=As(e,t);s&&function(e,t,n,s){gt(e)?e.removeChild(t,n,s):t.removeChild(n)}(e,s,t,n)}(t,i,o):3===e&&t.destroyNode(i),null!=a&&function(e,t,n,s,r){const a=n[7];a!==yt(n)&&ks(t,e,s,a,r);for(let o=tt;o<n.length;o++){const r=n[o];zs(r[1],r,e,t,s,a)}}(t,e,a,n,r)}}function Cs(e,t,n){return gt(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function Is(e,t){const n=e[9],s=n.indexOf(t),r=t[3];1024&t[2]&&(t[2]&=-1025,Et(r,-1)),n.splice(s,1)}function _s(e,t){if(e.length<=tt)return;const n=tt+t,s=e[n];if(s){const a=s[17];null!==a&&a!==e&&Is(a,s),t>0&&(e[n-1][4]=s[4]);const o=Un(e,tt+t);zs(s[1],r=s,r[11],2,null,null),r[0]=null,r[6]=null;const i=o[19];null!==i&&i.detachView(o[1]),s[3]=null,s[4]=null,s[2]&=-129}var r;return s}function Ss(e,t){if(!(256&t[2])){const n=t[11];gt(n)&&n.destroyNode&&zs(e,t,n,3,null,null),function(e){let t=e[13];if(!t)return Es(e[1],e);for(;t;){let n=null;if(nt(t))n=t[13];else{const e=t[10];e&&(n=e)}if(!n){for(;t&&!t[4]&&t!==e;)nt(t)&&Es(t[1],t),t=t[3];null===t&&(t=e),nt(t)&&Es(t[1],t),n=t&&t[4]}t=n}}(t)}}function Es(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let s=0;s<n.length;s+=2){const e=t[n[s]];if(!(e instanceof on)){const t=n[s+1];if(Array.isArray(t))for(let n=0;n<t.length;n+=2){const s=e[t[n]],r=t[n+1];try{r.call(s)}finally{}}else try{t.call(e)}finally{}}}}(e,t),function(e,t){const n=e.cleanup,s=t[7];let r=-1;if(null!==n)for(let a=0;a<n.length-1;a+=2)if("string"==typeof n[a]){const e=n[a+1],o="function"==typeof e?e(t):yt(t[e]),i=s[r=n[a+2]],u=n[a+3];"boolean"==typeof u?o.removeEventListener(n[a],i,u):u>=0?s[r=u]():s[r=-u].unsubscribe(),a+=2}else{const e=s[r=n[a+1]];n[a].call(e)}if(null!==s){for(let e=r+1;e<s.length;e++)(0,s[e])();t[7]=null}}(e,t),1===t[1].type&&gt(t[11])&&t[11].destroy();const n=t[17];if(null!==n&&st(t[3])){n!==t[3]&&Is(n,t);const s=t[19];null!==s&&s.detachView(e)}}}function Ns(e,t,n,s,r){gt(e)?e.insertBefore(t,n,s,r):t.insertBefore(n,s,r)}function $s(e,t,n){gt(e)?e.appendChild(t,n):t.appendChild(n)}function Ts(e,t,n,s,r){null!==s?Ns(e,t,n,s,r):$s(e,t,n)}function As(e,t){return gt(e)?e.parentNode(t):t.parentNode}function Rs(e,t,n,s){const r=function(e,t,n){return function(e,t,n){let s=t;for(;null!==s&&40&s.type;)s=(t=s).parent;if(null===s)return n[0];if(2&s.flags){const t=e.data[s.directiveStart].encapsulation;if(t===$e.None||t===$e.Emulated)return null}return xt(s,n)}(e,t.parent,n)}(e,s,t),a=t[11],o=function(e,t,n){return function(e,t,n){return 40&e.type?xt(e,n):null}(e,0,n)}(s.parent||t[6],0,t);if(null!=r)if(Array.isArray(n))for(let i=0;i<n.length;i++)Ts(a,r,n[i],o,!1);else Ts(a,r,n,o,!1)}function Fs(e,t){if(null!==t){const n=t.type;if(3&n)return xt(t,e);if(4&n)return Os(-1,e[t.index]);if(8&n){const n=t.child;if(null!==n)return Fs(e,n);{const n=e[t.index];return st(n)?Os(-1,n):yt(n)}}if(32&n)return bs(t,e)()||yt(e[t.index]);{const n=Ds(e,t);return null!==n?Array.isArray(n)?n[0]:Fs(ys(e[16]),n):Fs(e,t.next)}}return null}function Ds(e,t){return null!==t?e[16][6].projection[t.projection]:null}function Os(e,t){const n=tt+e+1;if(n<t.length){const e=t[n],s=e[1].firstChild;if(null!==s)return Fs(e,s)}return t[7]}function qs(e,t,n,s,r,a,o){for(;null!=n;){const i=s[n.index],u=n.type;if(o&&0===t&&(i&&us(yt(i),s),n.flags|=4),64!=(64&n.flags))if(8&u)qs(e,t,n.child,s,r,a,!1),ks(t,e,r,i,a);else if(32&u){const o=bs(n,s);let u;for(;u=o();)ks(t,e,r,u,a);ks(t,e,r,i,a)}else 16&u?Ms(e,t,s,n,r,a):ks(t,e,r,i,a);n=o?n.projectionNext:n.next}}function zs(e,t,n,s,r,a){qs(n,s,e.firstChild,t,r,a,!1)}function Ms(e,t,n,s,r,a){const o=n[16],i=o[6].projection[s.projection];if(Array.isArray(i))for(let u=0;u<i.length;u++)ks(t,e,r,i[u],a);else qs(e,t,i,o[3],r,a,!0)}function Ls(e,t,n){gt(e)?e.setAttribute(t,"style",n):t.style.cssText=n}function Ps(e,t,n){gt(e)?""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n):t.className=n}function Vs(e,t,n){let s=e.length;for(;;){const r=e.indexOf(t,n);if(-1===r)return r;if(0===r||e.charCodeAt(r-1)<=32){const n=t.length;if(r+n===s||e.charCodeAt(r+n)<=32)return r}n=r+1}}const js="ng-template";function Bs(e,t,n){let s=0;for(;s<e.length;){let r=e[s++];if(n&&"class"===r){if(r=e[s],-1!==Vs(r.toLowerCase(),t,0))return!0}else if(1===r){for(;s<e.length&&"string"==typeof(r=e[s++]);)if(r.toLowerCase()===t)return!0;return!1}}return!1}function Ws(e){return 4===e.type&&e.value!==js}function Us(e,t,n){return t===(4!==e.type||n?e.value:js)}function Gs(e,t,n){let s=4;const r=e.attrs||[],a=function(e){for(let t=0;t<e.length;t++)if(ln(e[t]))return t;return e.length}(r);let o=!1;for(let i=0;i<t.length;i++){const u=t[i];if("number"!=typeof u){if(!o)if(4&s){if(s=2|1&s,""!==u&&!Us(e,u,n)||""===u&&1===t.length){if(Hs(s))return!1;o=!0}}else{const l=8&s?u:t[++i];if(8&s&&null!==e.attrs){if(!Bs(e.attrs,l,n)){if(Hs(s))return!1;o=!0}continue}const c=Ks(8&s?"class":u,r,Ws(e),n);if(-1===c){if(Hs(s))return!1;o=!0;continue}if(""!==l){let e;e=c>a?"":r[c+1].toLowerCase();const t=8&s?e:null;if(t&&-1!==Vs(t,l,0)||2&s&&l!==e){if(Hs(s))return!1;o=!0}}}}else{if(!o&&!Hs(s)&&!Hs(u))return!1;if(o&&Hs(u))continue;o=!1,s=u|1&s}}return Hs(s)||o}function Hs(e){return 0==(1&e)}function Ks(e,t,n,s){if(null===t)return-1;let r=0;if(s||!n){let n=!1;for(;r<t.length;){const s=t[r];if(s===e)return r;if(3===s||6===s)n=!0;else{if(1===s||2===s){let e=t[++r];for(;"string"==typeof e;)e=t[++r];continue}if(4===s)break;if(0===s){r+=4;continue}}r+=n?1:2}return-1}return function(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const s=e[n];if("number"==typeof s)return-1;if(s===t)return n;n++}return-1}(t,e)}function Xs(e,t,n=!1){for(let s=0;s<t.length;s++)if(Gs(e,t[s],n))return!0;return!1}function Zs(e,t){return e?":not("+t.trim()+")":t}function Ys(e){let t=e[0],n=1,s=2,r="",a=!1;for(;n<e.length;){let o=e[n];if("string"==typeof o)if(2&s){const t=e[++n];r+="["+o+(t.length>0?'="'+t+'"':"")+"]"}else 8&s?r+="."+o:4&s&&(r+=" "+o);else""===r||Hs(o)||(t+=Zs(a,r),r=""),s=o,a=a||!Hs(s);n++}return""!==r&&(t+=Zs(a,r)),t}const Qs={};function Js(e){er(At(),Tt(),Yt()+e,qt())}function er(e,t,n,s){if(!s)if(3==(3&t[2])){const s=e.preOrderCheckHooks;null!==s&&en(t,s,n)}else{const s=e.preOrderHooks;null!==s&&tn(t,s,0,n)}Qt(n)}function tr(e,t){return e<<17|t<<2}function nr(e){return e>>17&32767}function sr(e){return 2|e}function rr(e){return(131068&e)>>2}function ar(e,t){return-131069&e|t<<2}function or(e){return 1|e}function ir(e,t){const n=e.contentQueries;if(null!==n)for(let s=0;s<n.length;s+=2){const r=n[s],a=n[s+1];if(-1!==a){const n=e.data[a];jt(r),n.contentQueries(2,t[a],a)}}}function ur(e,t,n,s,r,a,o,i,u,l){const c=t.blueprint.slice();return c[0]=r,c[2]=140|s,St(c),c[3]=c[15]=e,c[8]=n,c[10]=o||e&&e[10],c[11]=i||e&&e[11],c[12]=u||e&&e[12]||null,c[9]=l||e&&e[9]||null,c[6]=a,c[16]=2==t.type?e[16]:c,c}function lr(e,t,n,s,r){let a=e.data[t];if(null===a)a=function(e,t,n,s,r){const a=Ft(),o=Ot(),i=e.data[t]=function(e,t,n,s,r,a){return{type:n,index:s,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:a,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?a:a&&a.parent,n,t,s,r);return null===e.firstChild&&(e.firstChild=i),null!==a&&(o?null==a.child&&null!==i.parent&&(a.child=i):null===a.next&&(a.next=i)),i}(e,t,n,s,r),Nt.lFrame.inI18n&&(a.flags|=64);else if(64&a.type){a.type=n,a.value=s,a.attrs=r;const e=function(){const e=Nt.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();a.injectorIndex=null===e?-1:e.injectorIndex}return Dt(a,!0),a}function cr(e,t,n,s){if(0===n)return-1;const r=t.length;for(let a=0;a<n;a++)t.push(s),e.blueprint.push(s),e.data.push(null);return r}function dr(e,t,n){Ut(t);try{const s=e.viewQuery;null!==s&&Lr(1,s,n);const r=e.template;null!==r&&fr(e,t,r,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&ir(e,t),e.staticViewQueries&&Lr(2,e.viewQuery,n);const a=e.components;null!==a&&function(e,t){for(let n=0;n<t.length;n++)Dr(e,t[n])}(t,a)}catch(s){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),s}finally{t[2]&=-5,Zt()}}function pr(e,t,n,s){const r=t[2];if(256==(256&r))return;Ut(t);const a=qt();try{St(t),Nt.lFrame.bindingIndex=e.bindingStartIndex,null!==n&&fr(e,t,n,2,s);const o=3==(3&r);if(!a)if(o){const n=e.preOrderCheckHooks;null!==n&&en(t,n,null)}else{const n=e.preOrderHooks;null!==n&&tn(t,n,0,null),nn(t,0)}if(function(e){for(let t=vs(e);null!==t;t=xs(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const n=e[t],s=n[3];0==(1024&n[2])&&Et(s,1),n[2]|=1024}}}(t),function(e){for(let t=vs(e);null!==t;t=xs(t))for(let e=tt;e<t.length;e++){const n=t[e],s=n[1];It(n)&&pr(s,n,s.template,n[8])}}(t),null!==e.contentQueries&&ir(e,t),!a)if(o){const n=e.contentCheckHooks;null!==n&&en(t,n)}else{const n=e.contentHooks;null!==n&&tn(t,n,1),nn(t,1)}!function(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let e=0;e<n.length;e++){const s=n[e];if(s<0)Qt(~s);else{const r=s,a=n[++e],o=n[++e];Lt(a,r),o(2,t[r])}}}finally{Qt(-1)}}(e,t);const i=e.components;null!==i&&function(e,t){for(let n=0;n<t.length;n++)Rr(e,t[n])}(t,i);const u=e.viewQuery;if(null!==u&&Lr(2,u,s),!a)if(o){const n=e.viewCheckHooks;null!==n&&en(t,n)}else{const n=e.viewHooks;null!==n&&tn(t,n,2),nn(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),a||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,Et(t[3],-1))}finally{Zt()}}function hr(e,t,n,s){const r=t[10],a=!qt(),o=Ct(t);try{a&&!o&&r.begin&&r.begin(),o&&dr(e,t,s),pr(e,t,n,s)}finally{a&&!o&&r.end&&r.end()}}function fr(e,t,n,s,r){const a=Yt(),o=2&s;try{Qt(-1),o&&t.length>et&&er(e,t,et,qt()),n(s,r)}finally{Qt(a)}}function mr(e,t,n){$t()&&(function(e,t,n,s){const r=n.directiveStart,a=n.directiveEnd;e.firstCreatePass||vn(n,t),us(s,t);const o=n.initialInputs;for(let i=r;i<a;i++){const s=e.data[i],a=it(s);a&&Nr(t,n,s);const u=An(t,e,i,n);us(u,t),null!==o&&$r(0,i-r,u,s,0,o),a&&(kt(n.index,t)[8]=u)}}(e,t,n,xt(n,t)),128==(128&n.flags)&&function(e,t,n){const s=n.directiveStart,r=n.directiveEnd,a=n.index,o=Nt.lFrame.currentDirectiveIndex;try{Qt(a);for(let n=s;n<r;n++){const s=e.data[n],r=t[n];Pt(n),null===s.hostBindings&&0===s.hostVars&&null===s.hostAttrs||Cr(s,r)}}finally{Qt(-1),Pt(o)}}(e,t,n))}function gr(e,t,n=xt){const s=t.localNames;if(null!==s){let r=t.index+1;for(let a=0;a<s.length;a+=2){const o=s[a+1],i=-1===o?n(t,e):e[o];e[r++]=i}}}function br(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=yr(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function yr(e,t,n,s,r,a,o,i,u,l){const c=et+s,d=c+r,p=function(e,t){const n=[];for(let s=0;s<t;s++)n.push(s<e?null:Qs);return n}(c,d),h="function"==typeof l?l():l;return p[1]={type:e,blueprint:p,template:n,queries:null,viewQuery:i,declTNode:t,data:p.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof a?a():a,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:u,consts:h,incompleteFirstPass:!1}}function vr(e,t,n,s){const r=Vr(t);null===n?r.push(s):(r.push(n),e.firstCreatePass&&jr(e).push(s,r.length-1))}function xr(e,t,n){for(let s in e)if(e.hasOwnProperty(s)){const r=e[s];(n=null===n?{}:n).hasOwnProperty(s)?n[s].push(t,r):n[s]=[t,r]}return n}function wr(e,t,n,s){let r=!1;if($t()){const a=function(e,t,n){const s=e.directiveRegistry;let r=null;if(s)for(let a=0;a<s.length;a++){const o=s[a];Xs(n,o.selectors,!1)&&(r||(r=[]),Cn(vn(n,t),e,o.type),it(o)?(Ir(e,n),r.unshift(o)):r.push(o))}return r}(e,t,n),o=null===s?null:{"":-1};if(null!==a){r=!0,Sr(n,e.data.length,a.length);for(let e=0;e<a.length;e++){const t=a[e];t.providersResolver&&t.providersResolver(t)}let s=!1,i=!1,u=cr(e,t,a.length,null);for(let r=0;r<a.length;r++){const l=a[r];n.mergedAttrs=dn(n.mergedAttrs,l.hostAttrs),Er(e,n,t,u,l),_r(u,l,o),null!==l.contentQueries&&(n.flags|=8),null===l.hostBindings&&null===l.hostAttrs&&0===l.hostVars||(n.flags|=128);const c=l.type.prototype;!s&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n.index),s=!0),i||!c.ngOnChanges&&!c.ngDoCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n.index),i=!0),u++}!function(e,t){const n=t.directiveEnd,s=e.data,r=t.attrs,a=[];let o=null,i=null;for(let u=t.directiveStart;u<n;u++){const e=s[u],n=e.inputs,l=null===r||Ws(t)?null:Tr(n,r);a.push(l),o=xr(n,u,o),i=xr(e.outputs,u,i)}null!==o&&(o.hasOwnProperty("class")&&(t.flags|=16),o.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=a,t.inputs=o,t.outputs=i}(e,n)}o&&function(e,t,n){if(t){const s=e.localNames=[];for(let e=0;e<t.length;e+=2){const r=n[t[e+1]];if(null==r)throw new ce("301",`Export of name '${t[e+1]}' not found!`);s.push(t[e],r)}}}(n,s,o)}return n.mergedAttrs=dn(n.mergedAttrs,n.attrs),r}function kr(e,t,n,s,r,a){const o=a.hostBindings;if(o){let n=e.hostBindingOpCodes;null===n&&(n=e.hostBindingOpCodes=[]);const a=~t.index;(function(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(n)!=a&&n.push(a),n.push(s,r,o)}}function Cr(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function Ir(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function _r(e,t,n){if(n){if(t.exportAs)for(let s=0;s<t.exportAs.length;s++)n[t.exportAs[s]]=e;it(t)&&(n[""]=e)}}function Sr(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function Er(e,t,n,s,r){e.data[s]=r;const a=r.factory||(r.factory=ut(r.type)),o=new on(a,it(r),null);e.blueprint[s]=o,n[s]=o,kr(e,t,0,s,cr(e,n,r.hostVars,Qs),r)}function Nr(e,t,n){const s=xt(t,e),r=br(n),a=e[10],o=Or(e,ur(e,r,null,n.onPush?64:16,s,t,a,a.createRenderer(s,n),null,null));e[t.index]=o}function $r(e,t,n,s,r,a){const o=a[t];if(null!==o){const e=s.setInput;for(let t=0;t<o.length;){const r=o[t++],a=o[t++],i=o[t++];null!==e?s.setInput(n,i,r,a):n[a]=i}}}function Tr(e,t){let n=null,s=0;for(;s<t.length;){const r=t[s];if(0!==r)if(5!==r){if("number"==typeof r)break;e.hasOwnProperty(r)&&(null===n&&(n=[]),n.push(r,e[r],t[s+1])),s+=2}else s+=2;else s+=4}return n}function Ar(e,t,n,s){return new Array(e,!0,!1,t,null,0,s,n,null,null)}function Rr(e,t){const n=kt(t,e);if(It(n)){const e=n[1];80&n[2]?pr(e,n,e.template,n[8]):n[5]>0&&Fr(n)}}function Fr(e){for(let n=vs(e);null!==n;n=xs(n))for(let e=tt;e<n.length;e++){const t=n[e];if(1024&t[2]){const e=t[1];pr(e,t,e.template,t[8])}else t[5]>0&&Fr(t)}const t=e[1].components;if(null!==t)for(let n=0;n<t.length;n++){const s=kt(t[n],e);It(s)&&s[5]>0&&Fr(s)}}function Dr(e,t){const n=kt(t,e),s=n[1];!function(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(s,n),dr(s,n,n[8])}function Or(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function qr(e){for(;e;){e[2]|=64;const t=ys(e);if(0!=(512&e[2])&&!t)return e;e=t}return null}function zr(e,t,n){const s=t[10];s.begin&&s.begin();try{pr(e,t,e.template,n)}catch(r){throw Br(t,r),r}finally{s.end&&s.end()}}function Mr(e){!function(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],s=ls(n),r=s[1];hr(r,s,r.template,n)}}(e[8])}function Lr(e,t,n){jt(0),t(e,n)}const Pr=(()=>Promise.resolve(null))();function Vr(e){return e[7]||(e[7]=[])}function jr(e){return e.cleanup||(e.cleanup=[])}function Br(e,t){const n=e[9],s=n?n.get(hs,null):null;s&&s.handleError(t)}function Wr(e,t,n,s,r){for(let a=0;a<n.length;){const o=n[a++],i=n[a++],u=t[o],l=e.data[o];null!==l.setInput?l.setInput(u,r,s,i):u[i]=r}}function Ur(e,t,n){let s=n?e.styles:null,r=n?e.classes:null,a=0;if(null!==t)for(let o=0;o<t.length;o++){const e=t[o];"number"==typeof e?a=e:1==a?r=ae(r,e):2==a&&(s=ae(s,e+": "+t[++o]+";"))}n?e.styles=s:e.stylesWithoutHost=s,n?e.classes=r:e.classesWithoutHost=r}const Gr=new Ln("INJECTOR",-1);class Hr{get(e,t=Xn){if(t===Xn){const t=new Error(`NullInjectorError: No provider for ${re(e)}!`);throw t.name="NullInjectorError",t}return t}}const Kr=new Ln("Set Injector scope."),Xr={},Zr={};let Yr;function Qr(){return void 0===Yr&&(Yr=new Hr),Yr}function Jr(e,t=null,n=null,s){return new ea(e,n,t||Qr(),s)}class ea{constructor(e,t,n,s=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const r=[];t&&Bn(t,n=>this.processProvider(n,e,t)),Bn([e],e=>this.processInjectorType(e,[],r)),this.records.set(Gr,sa(void 0,this));const a=this.records.get(Kr);this.scope=null!=a?a.value:null,this.source=s||("object"==typeof e?null:re(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=Xn,n=Ce.Default){this.assertNotDestroyed();const s=es(this);try{if(!(n&Ce.SkipSelf)){let t=this.records.get(e);if(void 0===t){const n=("function"==typeof(r=e)||"object"==typeof r&&r instanceof Ln)&&ge(e);t=n&&this.injectableDefInScope(n)?sa(ta(e),Xr):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(n&Ce.Self?Qr():this.parent).get(e,t=n&Ce.Optional&&t===Xn?null:t)}catch(a){if("NullInjectorError"===a.name){if((a.ngTempTokenPath=a.ngTempTokenPath||[]).unshift(re(e)),s)throw a;return function(e,t,n,s){const r=e.ngTempTokenPath;throw t[Yn]&&r.unshift(t[Yn]),e.message=function(e,t,n,s=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let r=re(t);if(Array.isArray(t))r=t.map(re).join(" -> ");else if("object"==typeof t){let e=[];for(let n in t)if(t.hasOwnProperty(n)){let s=t[n];e.push(n+":"+("string"==typeof s?JSON.stringify(s):re(s)))}r=`{${e.join(", ")}}`}return`${n}${s?"("+s+")":""}[${r}]: ${e.replace(Zn,"\n  ")}`}("\n"+e.message,r,n,s),e.ngTokenPath=r,e.ngTempTokenPath=null,e}(a,e,"R3InjectorError",this.source)}throw a}finally{es(s)}var r}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,n)=>e.push(re(n))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,n){if(!(e=ue(e)))return!1;let s=ye(e);const r=null==s&&e.ngModule||void 0,a=void 0===r?e:r,o=-1!==n.indexOf(a);if(void 0!==r&&(s=ye(r)),null==s)return!1;if(null!=s.imports&&!o){let e;n.push(a);try{Bn(s.imports,s=>{this.processInjectorType(s,t,n)&&(void 0===e&&(e=[]),e.push(s))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:n,providers:s}=e[t];Bn(s,e=>this.processProvider(e,n,s||qe))}}this.injectorDefTypes.add(a);const i=ut(a)||(()=>new a);this.records.set(a,sa(i,Xr));const u=s.providers;if(null!=u&&!o){const t=e;Bn(u,e=>this.processProvider(e,t,u))}return void 0!==r&&void 0!==e.providers}processProvider(e,t,n){let s=aa(e=ue(e))?e:ue(e&&e.provide);const r=function(e,t,n){return ra(e)?sa(void 0,e.useValue):sa(na(e),Xr)}(e);if(aa(e)||!0!==e.multi)this.records.get(s);else{let t=this.records.get(s);t||(t=sa(void 0,Xr,!0),t.factory=()=>ss(t.multi),this.records.set(s,t)),s=e,t.multi.push(e)}this.records.set(s,r)}hydrate(e,t){var n;return t.value===Xr&&(t.value=Zr,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(n=t.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){if(!e.providedIn)return!1;const t=ue(e.providedIn);return"string"==typeof t?"any"===t||t===this.scope:this.injectorDefTypes.has(t)}}function ta(e){const t=ge(e),n=null!==t?t.factory:ut(e);if(null!==n)return n;if(e instanceof Ln)throw new Error(`Token ${re(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const n=function(e,t){const n=[];for(let s=0;s<e;s++)n.push("?");return n}(t);throw new Error(`Can't resolve all parameters for ${re(e)}: (${n.join(", ")}).`)}const n=function(e){const t=e&&(e[ve]||e[we]);if(t){const n=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Error("unreachable")}function na(e,t,n){let s;if(aa(e)){const t=ue(e);return ut(t)||ta(t)}if(ra(e))s=()=>ue(e.useValue);else if((r=e)&&r.useFactory)s=()=>e.useFactory(...ss(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))s=()=>ns(ue(e.useExisting));else{const t=ue(e&&(e.useClass||e.provide));if(!function(e){return!!e.deps}(e))return ut(t)||ta(t);s=()=>new t(...ss(e.deps))}var r;return s}function sa(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function ra(e){return null!==e&&"object"==typeof e&&Qn in e}function aa(e){return"function"==typeof e}const oa=function(e,t,n){return function(e,t=null,n=null,s){const r=Jr(e,t,n,s);return r._resolveInjectorDefTypes(),r}({name:n},t,e,n)};let ia=(()=>{class e{static create(e,t){return Array.isArray(e)?oa(e,t,""):oa(e.providers,e.parent,e.name||"")}}return e.THROW_IF_NOT_FOUND=Xn,e.NULL=new Hr,e.\u0275prov=fe({token:e,providedIn:"any",factory:()=>ns(Gr)}),e.__NG_ELEMENT_ID__=-1,e})();function ua(e,t){Jt(ls(e)[1],Rt())}function la(e){let t=Object.getPrototypeOf(e.type.prototype).constructor,n=!0;const s=[e];for(;t;){let r;if(it(e))r=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Error("Directives cannot inherit Components");r=t.\u0275dir}if(r){if(n){s.push(r);const t=e;t.inputs=ca(e.inputs),t.declaredInputs=ca(e.declaredInputs),t.outputs=ca(e.outputs);const n=r.hostBindings;n&&ha(e,n);const a=r.viewQuery,o=r.contentQueries;if(a&&da(e,a),o&&pa(e,o),se(e.inputs,r.inputs),se(e.declaredInputs,r.declaredInputs),se(e.outputs,r.outputs),it(r)&&r.data.animation){const t=e.data;t.animation=(t.animation||[]).concat(r.data.animation)}}const t=r.features;if(t)for(let s=0;s<t.length;s++){const r=t[s];r&&r.ngInherit&&r(e),r===la&&(n=!1)}}t=Object.getPrototypeOf(t)}!function(e){let t=0,n=null;for(let s=e.length-1;s>=0;s--){const r=e[s];r.hostVars=t+=r.hostVars,r.hostAttrs=dn(r.hostAttrs,n=dn(n,r.hostAttrs))}}(s)}function ca(e){return e===Oe?{}:e===qe?[]:e}function da(e,t){const n=e.viewQuery;e.viewQuery=n?(e,s)=>{t(e,s),n(e,s)}:t}function pa(e,t){const n=e.contentQueries;e.contentQueries=n?(e,s,r)=>{t(e,s,r),n(e,s,r)}:t}function ha(e,t){const n=e.hostBindings;e.hostBindings=n?(e,s)=>{t(e,s),n(e,s)}:t}let fa=null;function ma(){if(!fa){const e=De.Symbol;if(e&&e.iterator)fa=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const n=e[t];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(fa=n)}}}return fa}function ga(e){return!!ba(e)&&(Array.isArray(e)||!(e instanceof Map)&&ma()in e)}function ba(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function ya(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}function va(e,t=Ce.Default){const n=Tt();return null===n?ns(e,t):Sn(Rt(),n,ue(e),t)}function xa(e,t,n){const s=Tt();return ya(s,Mt(),t)&&function(e,t,n,s,r,a,o,i){const u=xt(t,n);let l,c=t.inputs;var d;null!=c&&(l=c[s])?(Wr(e,n,l,s,r),at(t)&&function(e,t){const n=kt(t,e);16&n[2]||(n[2]|=64)}(n,t.index)):3&t.type&&(s="class"===(d=s)?"className":"for"===d?"htmlFor":"formaction"===d?"formAction":"innerHtml"===d?"innerHTML":"readonly"===d?"readOnly":"tabindex"===d?"tabIndex":d,r=null!=o?o(r,t.value||"",s):r,gt(a)?a.setProperty(u,s,r):cn(s)||(u.setProperty?u.setProperty(s,r):u[s]=r))}(At(),function(){const e=Nt.lFrame;return wt(e.tView,e.selectedIndex)}(),s,e,t,s[11],n),xa}function wa(e,t,n,s,r){const a=r?"class":"style";Wr(e,n,t.inputs[a],a,s)}function ka(e,t,n,s){const r=Tt(),a=At(),o=et+e,i=r[11],u=r[o]=Cs(i,t,Nt.lFrame.currentNamespace),l=a.firstCreatePass?function(e,t,n,s,r,a,o){const i=t.consts,u=lr(t,e,2,r,_t(i,a));return wr(t,n,u,_t(i,o)),null!==u.attrs&&Ur(u,u.attrs,!1),null!==u.mergedAttrs&&Ur(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(o,a,r,0,t,n,s):a.data[o];Dt(l,!0);const c=l.mergedAttrs;null!==c&&un(i,u,c);const d=l.classes;null!==d&&Ps(i,u,d);const p=l.styles;null!==p&&Ls(i,u,p),64!=(64&l.flags)&&Rs(a,r,u,l),0===Nt.lFrame.elementDepthCount&&us(u,r),Nt.lFrame.elementDepthCount++,ot(l)&&(mr(a,r,l),function(e,t,n){if(rt(t)){const s=t.directiveEnd;for(let r=t.directiveStart;r<s;r++){const t=e.data[r];t.contentQueries&&t.contentQueries(1,n[r],r)}}}(a,l,r)),null!==s&&gr(r,l)}function Ca(){let e=Rt();Ot()?Nt.lFrame.isParent=!1:(e=e.parent,Dt(e,!1));const t=e;Nt.lFrame.elementDepthCount--;const n=At();n.firstCreatePass&&(Jt(n,e),rt(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&wa(n,t,Tt(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&wa(n,t,Tt(),t.stylesWithoutHost,!1)}function Ia(e,t,n,s){ka(e,t,n,s),Ca()}function _a(e){return!!e&&"function"==typeof e.then}const Sa=function(e){return!!e&&"function"==typeof e.subscribe};function Ea(e,t,n,s){const r=Tt(),a=At(),o=Rt();return function(e,t,n,s,r,a,o,i){const u=ot(s),l=e.firstCreatePass&&jr(e),c=Vr(t);let d=!0;if(3&s.type||i){const p=xt(s,t),h=i?i(p):p,f=c.length,m=i?e=>i(yt(e[s.index])):s.index;if(gt(n)){let o=null;if(!i&&u&&(o=function(e,t,n,s){const r=e.cleanup;if(null!=r)for(let a=0;a<r.length-1;a+=2){const e=r[a];if(e===n&&r[a+1]===s){const e=t[7],n=r[a+2];return e.length>n?e[n]:null}"string"==typeof e&&(a+=2)}return null}(e,t,r,s.index)),null!==o)(o.__ngLastListenerFn__||o).__ngNextListenerFn__=a,o.__ngLastListenerFn__=a,d=!1;else{a=$a(s,t,0,a,!1);const e=n.listen(h,r,a);c.push(a,e),l&&l.push(r,m,f,f+1)}}else a=$a(s,t,0,a,!0),h.addEventListener(r,a,o),c.push(a),l&&l.push(r,m,f,o)}else a=$a(s,t,0,a,!1);const p=s.outputs;let h;if(d&&null!==p&&(h=p[r])){const e=h.length;if(e)for(let n=0;n<e;n+=2){const e=t[h[n]][h[n+1]].subscribe(a),o=c.length;c.push(a,e),l&&l.push(r,s.index,o,-(o+1))}}}(a,r,r[11],o,e,t,!!n,s),Ea}function Na(e,t,n,s){try{return!1!==n(s)}catch(r){return Br(e,r),!1}}function $a(e,t,n,s,r){return function n(a){if(a===Function)return s;const o=2&e.flags?kt(e.index,t):t;0==(32&t[2])&&qr(o);let i=Na(t,0,s,a),u=n.__ngNextListenerFn__;for(;u;)i=Na(t,0,u,a)&&i,u=u.__ngNextListenerFn__;return r&&!1===i&&(a.preventDefault(),a.returnValue=!1),i}}function Ta(e,t,n,s,r){const a=e[n+1],o=null===t;let i=s?nr(a):rr(a),u=!1;for(;0!==i&&(!1===u||o);){const n=e[i+1];Aa(e[i],t)&&(u=!0,e[i+1]=s?or(n):sr(n)),i=s?nr(n):rr(n)}u&&(e[n+1]=s?sr(a):or(a))}function Aa(e,t){return null===e||null==t||(Array.isArray(e)?e[1]:e)===t||!(!Array.isArray(e)||"string"!=typeof t)&&Kn(e,t)>=0}function Ra(e,t){return function(e,t,n,s){const r=Tt(),a=At(),o=function(e){const t=Nt.lFrame,n=t.bindingIndex;return t.bindingIndex=t.bindingIndex+2,n}();a.firstUpdatePass&&function(e,t,n,s){const r=e.data;if(null===r[n+1]){const a=r[Yt()],o=function(e,t){return t>=e.expandoStartIndex}(e,n);(function(e,t){return 0!=(16&e.flags)})(a)&&null===t&&!o&&(t=!1),t=function(e,t,n,s){const r=function(e){const t=Nt.lFrame.currentDirectiveIndex;return-1===t?null:e[t]}(e);let a=t.residualClasses;if(null===r)0===t.classBindings&&(n=Da(n=Fa(null,e,t,n,s),t.attrs,s),a=null);else{const o=t.directiveStylingLast;if(-1===o||e[o]!==r)if(n=Fa(r,e,t,n,s),null===a){let n=function(e,t,n){const s=t.classBindings;if(0!==rr(s))return e[nr(s)]}(e,t);void 0!==n&&Array.isArray(n)&&(n=Fa(null,e,t,n[1],s),n=Da(n,t.attrs,s),function(e,t,n,s){e[nr(t.classBindings)]=s}(e,t,0,n))}else a=function(e,t,n){let s;const r=t.directiveEnd;for(let a=1+t.directiveStylingLast;a<r;a++)s=Da(s,e[a].hostAttrs,true);return Da(s,t.attrs,true)}(e,t)}return void 0!==a&&(t.residualClasses=a),n}(r,a,t,s),function(e,t,n,s,r,a){let o=t.classBindings,i=nr(o),u=rr(o);e[s]=n;let l,c=!1;if(Array.isArray(n)){const e=n;l=e[1],(null===l||Kn(e,l)>0)&&(c=!0)}else l=n;if(r)if(0!==u){const t=nr(e[i+1]);e[s+1]=tr(t,i),0!==t&&(e[t+1]=ar(e[t+1],s)),e[i+1]=131071&e[i+1]|s<<17}else e[s+1]=tr(i,0),0!==i&&(e[i+1]=ar(e[i+1],s)),i=s;else e[s+1]=tr(u,0),0===i?i=s:e[u+1]=ar(e[u+1],s),u=s;c&&(e[s+1]=sr(e[s+1])),Ta(e,l,s,!0),Ta(e,l,s,!1),function(e,t,n,s,r){const a=e.residualClasses;null!=a&&"string"==typeof t&&Kn(a,t)>=0&&(n[s+1]=or(n[s+1]))}(t,l,e,s),o=tr(i,u),t.classBindings=o}(r,a,t,n,o)}}(a,e,o,true),t!==Qs&&ya(r,o,t)&&function(e,t,n,s,r,a,o,i){if(!(3&t.type))return;const u=e.data,l=u[i+1];qa(1==(1&l)?Oa(u,t,n,r,rr(l),o):void 0)||(qa(a)||function(e){return 2==(2&e)}(l)&&(a=Oa(u,null,n,r,i,o)),function(e,t,n,s,r){const a=gt(e);r?a?e.addClass(n,s):n.classList.add(s):a?e.removeClass(n,s):n.classList.remove(s)}(s,0,vt(Yt(),n),r,a))}(a,a.data[Yt()],r,r[11],e,r[o+1]=function(e,t){return null==e||"object"==typeof e&&(e=re(function(e){return e instanceof class{constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}?e.changingThisBreaksApplicationSecurity:e}(e))),e}(t),true,o)}(e,t),Ra}function Fa(e,t,n,s,r){let a=null;const o=n.directiveEnd;let i=n.directiveStylingLast;for(-1===i?i=n.directiveStart:i++;i<o&&(a=t[i],s=Da(s,a.hostAttrs,r),a!==e);)i++;return null!==e&&(n.directiveStylingLast=i),s}function Da(e,t,n){const s=n?1:2;let r=-1;if(null!==t)for(let a=0;a<t.length;a++){const o=t[a];"number"==typeof o?r=o:r===s&&(Array.isArray(e)||(e=void 0===e?[]:["",e]),Gn(e,o,!!n||t[++a]))}return void 0===e?null:e}function Oa(e,t,n,s,r,a){const o=null===t;let i;for(;r>0;){const t=e[r],a=Array.isArray(t),u=a?t[1]:t,l=null===u;let c=n[r+1];c===Qs&&(c=l?qe:void 0);let d=l?Hn(c,s):u===s?c:void 0;if(a&&!qa(d)&&(d=Hn(t,s)),qa(d)&&(i=d,o))return i;const p=e[r+1];r=o?nr(p):rr(p)}if(null!==t){let e=a?t.residualClasses:t.residualStyles;null!=e&&(i=Hn(e,s))}return i}function qa(e){return void 0!==e}function za(e,t=""){const n=Tt(),s=At(),r=e+et,a=s.firstCreatePass?lr(s,r,1,t,null):s.data[r],o=n[r]=function(e,t){return gt(e)?e.createText(t):e.createTextNode(t)}(n[11],t);Rs(s,n,o,a),Dt(a,!1)}function Ma(e){return La("",e,""),Ma}function La(e,t,n){const s=Tt(),r=function(e,t,n,s){return ya(e,Mt(),n)?t+de(n)+s:Qs}(s,e,t,n);return r!==Qs&&function(e,t,n){const s=vt(t,e);!function(e,t,n){gt(e)?e.setValue(t,n):t.textContent=n}(e[11],s,n)}(s,Yt(),r),La}const Pa=void 0;var Va=["en",[["a","p"],["AM","PM"],Pa],[["AM","PM"],Pa,Pa],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Pa,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Pa,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Pa,"{1} 'at' {0}",Pa],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===n?1:5}];let ja={};function Ba(e){return e in ja||(ja[e]=De.ng&&De.ng.common&&De.ng.common.locales&&De.ng.common.locales[e]),ja[e]}var Wa=function(e){return e[e.LocaleId=0]="LocaleId",e[e.DayPeriodsFormat=1]="DayPeriodsFormat",e[e.DayPeriodsStandalone=2]="DayPeriodsStandalone",e[e.DaysFormat=3]="DaysFormat",e[e.DaysStandalone=4]="DaysStandalone",e[e.MonthsFormat=5]="MonthsFormat",e[e.MonthsStandalone=6]="MonthsStandalone",e[e.Eras=7]="Eras",e[e.FirstDayOfWeek=8]="FirstDayOfWeek",e[e.WeekendRange=9]="WeekendRange",e[e.DateFormat=10]="DateFormat",e[e.TimeFormat=11]="TimeFormat",e[e.DateTimeFormat=12]="DateTimeFormat",e[e.NumberSymbols=13]="NumberSymbols",e[e.NumberFormats=14]="NumberFormats",e[e.CurrencyCode=15]="CurrencyCode",e[e.CurrencySymbol=16]="CurrencySymbol",e[e.CurrencyName=17]="CurrencyName",e[e.Currencies=18]="Currencies",e[e.Directionality=19]="Directionality",e[e.PluralCase=20]="PluralCase",e[e.ExtraData=21]="ExtraData",e}({});const Ua="en-US";let Ga=Ua;function Ha(e){var t,n;n="Expected localeId to be defined",null==(t=e)&&function(e,t,n,s){throw new Error(`ASSERTION ERROR: ${e} [Expected=> null != ${t} <=Actual]`)}(n,t),"string"==typeof e&&(Ga=e.toLowerCase().replace(/_/g,"-"))}function Ka(e,t,n,s,r){if(e=ue(e),Array.isArray(e))for(let a=0;a<e.length;a++)Ka(e[a],t,n,s,r);else{const a=At(),o=Tt();let i=aa(e)?e:ue(e.provide),u=na(e);const l=Rt(),c=1048575&l.providerIndexes,d=l.directiveStart,p=l.providerIndexes>>20;if(aa(e)||!e.multi){const s=new on(u,r,va),h=Ya(i,t,r?c:c+p,d);-1===h?(Cn(vn(l,o),a,i),Xa(a,e,t.length),t.push(i),l.directiveStart++,l.directiveEnd++,r&&(l.providerIndexes+=1048576),n.push(s),o.push(s)):(n[h]=s,o[h]=s)}else{const h=Ya(i,t,c+p,d),f=Ya(i,t,c,c+p),m=h>=0&&n[h],g=f>=0&&n[f];if(r&&!g||!r&&!m){Cn(vn(l,o),a,i);const c=function(e,t,n,s,r){const a=new on(e,n,va);return a.multi=[],a.index=t,a.componentProviders=0,Za(a,r,s&&!n),a}(r?Ja:Qa,n.length,r,s,u);!r&&g&&(n[f].providerFactory=c),Xa(a,e,t.length,0),t.push(i),l.directiveStart++,l.directiveEnd++,r&&(l.providerIndexes+=1048576),n.push(c),o.push(c)}else Xa(a,e,h>-1?h:f,Za(n[r?f:h],u,!r&&s));!r&&s&&g&&n[f].componentProviders++}}}function Xa(e,t,n,s){const r=aa(t);if(r||t.useClass){const a=(t.useClass||t).prototype.ngOnDestroy;if(a){const o=e.destroyHooks||(e.destroyHooks=[]);if(!r&&t.multi){const e=o.indexOf(n);-1===e?o.push(n,[s,a]):o[e+1].push(s,a)}else o.push(n,a)}}}function Za(e,t,n){return n&&e.componentProviders++,e.multi.push(t)-1}function Ya(e,t,n,s){for(let r=n;r<s;r++)if(t[r]===e)return r;return-1}function Qa(e,t,n,s){return eo(this.multi,[])}function Ja(e,t,n,s){const r=this.multi;let a;if(this.providerFactory){const e=this.providerFactory.componentProviders,t=An(n,n[1],this.providerFactory.index,s);a=t.slice(0,e),eo(r,a);for(let n=e;n<t.length;n++)a.push(t[n])}else a=[],eo(r,a);return a}function eo(e,t){for(let n=0;n<e.length;n++)t.push((0,e[n])());return t}function to(e,t=[]){return n=>{n.providersResolver=(n,s)=>function(e,t,n){const s=At();if(s.firstCreatePass){const r=it(e);Ka(n,s.data,s.blueprint,r,!0),Ka(t,s.data,s.blueprint,r,!1)}}(n,s?s(e):e,t)}}class no{}class so{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${re(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}let ro=(()=>{class e{}return e.NULL=new so,e})();function ao(...e){}function oo(e,t){return new uo(xt(e,t))}const io=function(){return oo(Rt(),Tt())};let uo=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=io,e})();function lo(e){return e instanceof uo?e.nativeElement:e}class co{}let po=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>ho(),e})();const ho=function(){const e=Tt(),t=kt(Rt().index,e);return function(e){return e[11]}(nt(t)?t:e)};let fo=(()=>{class e{}return e.\u0275prov=fe({token:e,providedIn:"root",factory:()=>null}),e})();class mo{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const go=new mo("12.0.5");class bo{constructor(){}supports(e){return ga(e)}create(e){return new vo(e)}}const yo=(e,t)=>t;class vo{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||yo}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,n=this._removalsHead,s=0,r=null;for(;t||n;){const a=!n||t&&t.currentIndex<Co(n,s,r)?t:n,o=Co(a,s,r),i=a.currentIndex;if(a===n)s--,n=n._nextRemoved;else if(t=t._next,null==a.previousIndex)s++;else{r||(r=[]);const e=o-s,t=i-s;if(e!=t){for(let n=0;n<e;n++){const s=n<r.length?r[n]:r[n]=0,a=s+n;t<=a&&a<e&&(r[n]=s+1)}r[a.previousIndex]=t-e}}o!==i&&e(a,o,i)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!ga(e))throw new Error(`Error trying to diff '${re(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,n,s,r=this._itHead,a=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)n=e[t],s=this._trackByFn(t,n),null!==r&&Object.is(r.trackById,s)?(a&&(r=this._verifyReinsertion(r,n,s,t)),Object.is(r.item,n)||this._addIdentityChange(r,n)):(r=this._mismatch(r,n,s,t),a=!0),r=r._next}else t=0,function(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{const n=e[ma()]();let s;for(;!(s=n.next()).done;)t(s.value)}}(e,e=>{s=this._trackByFn(t,e),null!==r&&Object.is(r.trackById,s)?(a&&(r=this._verifyReinsertion(r,e,s,t)),Object.is(r.item,e)||this._addIdentityChange(r,e)):(r=this._mismatch(r,e,s,t),a=!0),r=r._next,t++}),this.length=t;return this._truncate(r),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,n,s){let r;return null===e?r=this._itTail:(r=e._prev,this._remove(e)),null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,r,s)):null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,s))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,r,s)):e=this._addAfter(new xo(t,n),r,s),e}_verifyReinsertion(e,t,n,s){let r=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==r?e=this._reinsertAfter(r,e._prev,s):e.currentIndex!=s&&(e.currentIndex=s,this._addToMoves(e,s)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const s=e._prevRemoved,r=e._nextRemoved;return null===s?this._removalsHead=r:s._nextRemoved=r,null===r?this._removalsTail=s:r._prevRemoved=s,this._insertAfter(e,t,n),this._addToMoves(e,n),e}_moveAfter(e,t,n){return this._unlink(e),this._insertAfter(e,t,n),this._addToMoves(e,n),e}_addAfter(e,t,n){return this._insertAfter(e,t,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,n){const s=null===t?this._itHead:t._next;return e._next=s,e._prev=t,null===s?this._itTail=e:s._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new ko),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,n=e._next;return null===t?this._itHead=n:t._next=n,null===n?this._itTail=t:n._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new ko),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class xo{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class wo{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===t||t<=n.currentIndex)&&Object.is(n.trackById,e))return n;return null}remove(e){const t=e._prevDup,n=e._nextDup;return null===t?this._head=n:t._nextDup=n,null===n?this._tail=t:n._prevDup=t,null===this._head}}class ko{constructor(){this.map=new Map}put(e){const t=e.trackById;let n=this.map.get(t);n||(n=new wo,this.map.set(t,n)),n.add(e)}get(e,t){const n=this.map.get(e);return n?n.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function Co(e,t,n){const s=e.previousIndex;if(null===s)return s;let r=0;return n&&s<n.length&&(r=n[s]),s+t+r}class Io{constructor(){}supports(e){return e instanceof Map||ba(e)}create(){return new _o}}class _o{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||ba(e)))throw new Error(`Error trying to diff '${re(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,n)=>{if(t&&t.key===n)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const s=this._getOrCreateRecordForKey(n,e);t=this._insertBeforeOrAppend(t,s)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const n=e._prev;return t._next=e,t._prev=n,e._prev=t,n&&(n._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const n=this._records.get(e);this._maybeAddToChanges(n,t);const s=n._prev,r=n._next;return s&&(s._next=r),r&&(r._prev=s),n._next=null,n._prev=null,n}const n=new So(e);return this._records.set(e,n),n.currentValue=t,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){Object.is(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(n=>t(e[n],n))}}class So{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Eo(){return new No([new bo])}let No=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(null!=n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Eo()),deps:[[e,new is,new os]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);var n}}return e.\u0275prov=fe({token:e,providedIn:"root",factory:Eo}),e})();function $o(){return new To([new Io])}let To=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||$o()),deps:[[e,new is,new os]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=fe({token:e,providedIn:"root",factory:$o}),e})();function Ao(e,t,n,s,r=!1){for(;null!==n;){const a=t[n.index];if(null!==a&&s.push(yt(a)),st(a))for(let e=tt;e<a.length;e++){const t=a[e],n=t[1].firstChild;null!==n&&Ao(t[1],t,n,s)}const o=n.type;if(8&o)Ao(e,t,n.child,s);else if(32&o){const e=bs(n,t);let r;for(;r=e();)s.push(r)}else if(16&o){const e=Ds(t,n);if(Array.isArray(e))s.push(...e);else{const n=ys(t[16]);Ao(n[1],n,e,s,!0)}}n=r?n.projectionNext:n.next}return s}class Ro{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const e=this._lView,t=e[1];return Ao(t,e,t.firstChild,[])}get context(){return this._lView[8]}set context(e){this._lView[8]=e}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const e=this._lView[3];if(st(e)){const t=e[8],n=t?t.indexOf(this):-1;n>-1&&(_s(e,n),Un(t,n))}this._attachedToViewContainer=!1}Ss(this._lView[1],this._lView)}onDestroy(e){vr(this._lView[1],this._lView,null,e)}markForCheck(){qr(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){zr(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,n){zt(!0);try{zr(e,t,n)}finally{zt(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var e;this._appRef=null,zs(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class Fo extends Ro{constructor(e){super(e),this._view=e}detectChanges(){Mr(this._view)}checkNoChanges(){!function(e){zt(!0);try{Mr(e)}finally{zt(!1)}}(this._view)}get context(){return null}}const Do=function(e){return function(e,t,n){if(at(e)&&!n){const n=kt(e.index,t);return new Ro(n,n)}return 47&e.type?new Ro(t[16],t):null}(Rt(),Tt(),16==(16&e))};let Oo=(()=>{class e{}return e.__NG_ELEMENT_ID__=Do,e})();const qo=[new Io],zo=new No([new bo]),Mo=new To(qo),Lo=function(){return Bo(Rt(),Tt())};let Po=(()=>{class e{}return e.__NG_ELEMENT_ID__=Lo,e})();const Vo=Po,jo=class extends Vo{constructor(e,t,n){super(),this._declarationLView=e,this._declarationTContainer=t,this.elementRef=n}createEmbeddedView(e){const t=this._declarationTContainer.tViews,n=ur(this._declarationLView,t,e,16,null,t.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const s=this._declarationLView[19];return null!==s&&(n[19]=s.createEmbeddedView(t)),dr(t,n,e),new Ro(n)}};function Bo(e,t){return 4&e.type?new jo(t,e,oo(e,t)):null}class Wo{}class Uo{}const Go=function(){return Qo(Rt(),Tt())};let Ho=(()=>{class e{}return e.__NG_ELEMENT_ID__=Go,e})();const Ko=Ho,Xo=class extends Ko{constructor(e,t,n){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=n}get element(){return oo(this._hostTNode,this._hostLView)}get injector(){return new Dn(this._hostTNode,this._hostLView)}get parentInjector(){const e=kn(this._hostTNode,this._hostLView);if(hn(e)){const t=mn(e,this._hostLView),n=fn(e);return new Dn(t[1].data[n+8],t)}return new Dn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){const t=Zo(this._lContainer);return null!==t&&t[e]||null}get length(){return this._lContainer.length-tt}createEmbeddedView(e,t,n){const s=e.createEmbeddedView(t||{});return this.insert(s,n),s}createComponent(e,t,n,s,r){const a=n||this.parentInjector;if(!r&&null==e.ngModule&&a){const e=a.get(Wo,null);e&&(r=e)}const o=e.create(a,s,void 0,r);return this.insert(o.hostView,t),o}insert(e,t){const n=e._lView,s=n[1];if(st(n[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=n[3],s=new Xo(t,t[6],t[3]);s.detach(s.indexOf(e))}}const r=this._adjustIndex(t),a=this._lContainer;!function(e,t,n,s){const r=tt+s,a=n.length;s>0&&(n[r-1][4]=t),s<a-tt?(t[4]=n[r],Wn(n,tt+s,t)):(n.push(t),t[4]=null),t[3]=n;const o=t[17];null!==o&&n!==o&&function(e,t){const n=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===n?e[9]=[t]:n.push(t)}(o,t);const i=t[19];null!==i&&i.insertView(e),t[2]|=128}(s,n,a,r);const o=Os(r,a),i=n[11],u=As(i,a[7]);return null!==u&&function(e,t,n,s,r,a){s[0]=r,s[6]=t,zs(e,s,n,1,r,a)}(s,a[6],i,n,u,o),e.attachToViewContainerRef(),Wn(Yo(a),r,e),e}move(e,t){return this.insert(e,t)}indexOf(e){const t=Zo(this._lContainer);return null!==t?t.indexOf(e):-1}remove(e){const t=this._adjustIndex(e,-1),n=_s(this._lContainer,t);n&&(Un(Yo(this._lContainer),t),Ss(n[1],n))}detach(e){const t=this._adjustIndex(e,-1),n=_s(this._lContainer,t);return n&&null!=Un(Yo(this._lContainer),t)?new Ro(n):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}};function Zo(e){return e[8]}function Yo(e){return e[8]||(e[8]=[])}function Qo(e,t){let n;const s=t[e.index];if(st(s))n=s;else{let r;if(8&e.type)r=yt(s);else{const n=t[11];r=n.createComment("");const s=xt(e,t);Ns(n,As(n,s),r,function(e,t){return gt(e)?e.nextSibling(t):t.nextSibling}(n,s),!1)}t[e.index]=n=Ar(s,t,r,e),Or(t,n)}return new Xo(n,e,t)}const Jo={};class ei extends ro{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=Qe(e);return new si(t,this.ngModule)}}function ti(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}const ni=new Ln("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>fs});class si extends no{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(Ys).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return ti(this.componentDef.inputs)}get outputs(){return ti(this.componentDef.outputs)}create(e,t,n,s){const r=(s=s||this.ngModule)?function(e,t){return{get:(n,s,r)=>{const a=e.get(n,Jo,r);return a!==Jo||s===Jo?a:t.get(n,s,r)}}}(e,s.injector):e,a=r.get(co,bt),o=r.get(fo,null),i=a.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",l=n?function(e,t,n){if(gt(e))return e.selectRootElement(t,n===$e.ShadowDom);let s="string"==typeof t?e.querySelector(t):t;return s.textContent="",s}(i,n,this.componentDef.encapsulation):Cs(a.createRenderer(null,this.componentDef),u,function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(u)),c=this.componentDef.onPush?576:528,d={components:[],scheduler:fs,clean:Pr,playerHandler:null,flags:0},p=yr(0,null,null,1,0,null,null,null,null,null),h=ur(null,p,d,c,null,null,a,i,o,r);let f,m;Ut(h);try{const e=function(e,t,n,s,r,a){const o=n[1];n[20]=e;const i=lr(o,20,2,"#host",null),u=i.mergedAttrs=t.hostAttrs;null!==u&&(Ur(i,u,!0),null!==e&&(un(r,e,u),null!==i.classes&&Ps(r,e,i.classes),null!==i.styles&&Ls(r,e,i.styles)));const l=s.createRenderer(e,t),c=ur(n,br(t),null,t.onPush?64:16,n[20],i,s,l,null,null);return o.firstCreatePass&&(Cn(vn(i,n),o,t.type),Ir(o,i),Sr(i,n.length,1)),Or(n,c),n[20]=c}(l,this.componentDef,h,a,i);if(l)if(n)un(i,l,["ng-version",go.full]);else{const{attrs:e,classes:t}=function(e){const t=[],n=[];let s=1,r=2;for(;s<e.length;){let a=e[s];if("string"==typeof a)2===r?""!==a&&t.push(a,e[++s]):8===r&&n.push(a);else{if(!Hs(r))break;r=a}s++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);e&&un(i,l,e),t&&t.length>0&&Ps(i,l,t.join(" "))}if(m=wt(p,et),void 0!==t){const e=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const s=t[n];e.push(null!=s?Array.from(s):null)}}f=function(e,t,n,s,r){const a=n[1],o=function(e,t,n){const s=Rt();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Er(e,s,t,cr(e,t,1,null),n));const r=An(t,e,s.directiveStart,s);us(r,t);const a=xt(s,t);return a&&us(a,t),r}(a,n,t);if(s.components.push(o),e[8]=o,r&&r.forEach(e=>e(o,t)),t.contentQueries){const e=Rt();t.contentQueries(1,o,e.directiveStart)}const i=Rt();return!a.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(Qt(i.index),kr(n[1],i,0,i.directiveStart,i.directiveEnd,t),Cr(t,o)),o}(e,this.componentDef,h,d,[ua]),dr(p,h,null)}finally{Zt()}return new ri(this.componentType,f,oo(m,h),h,m)}}class ri extends class{}{constructor(e,t,n,s,r){super(),this.location=n,this._rootLView=s,this._tNode=r,this.instance=t,this.hostView=this.changeDetectorRef=new Fo(s),this.componentType=e}get injector(){return new Dn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}}const ai=new Map;class oi extends Wo{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new ei(this);const n=Je(e),s=e[Ve]||null;s&&Ha(s),this._bootstrapComponents=ms(n.bootstrap),this._r3Injector=Jr(e,t,[{provide:Wo,useValue:this},{provide:ro,useValue:this.componentFactoryResolver}],re(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=ia.THROW_IF_NOT_FOUND,n=Ce.Default){return e===ia||e===Wo||e===Gr?this:this._r3Injector.get(e,t,n)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class ii extends Uo{constructor(e){super(),this.moduleType=e,null!==Je(e)&&function(e){const t=new Set;!function e(n){const s=Je(n,!0),r=s.id;null!==r&&(function(e,t,n){if(t&&t!==n)throw new Error(`Duplicate module registered for ${e} - ${re(t)} vs ${re(t.name)}`)}(r,ai.get(r),n),ai.set(r,n));const a=ms(s.imports);for(const o of a)t.has(o)||(t.add(o),e(o))}(e)}(e)}create(e){return new oi(this.moduleType,e)}}function ui(e,t,n,s,r){return function(e,t,n,s,r,a,o){const i=t+n;return function(e,t,n,s){const r=ya(e,t,n);return ya(e,t+1,s)||r}(e,i,r,a)?function(e,t,n){return e[t]=n}(e,i+2,o?s.call(o,r,a):s(r,a)):function(e,t){const n=e[t];return n===Qs?void 0:n}(e,i+2)}(Tt(),function(){const e=Nt.lFrame;let t=e.bindingRootIndex;return-1===t&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}(),e,t,n,s,r)}function li(e){return t=>{setTimeout(e,void 0,t)}}const ci=class extends E{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,n){var s,r,a;let o=e,i=t||(()=>null),u=n;if(e&&"object"==typeof e){const t=e;o=null===(s=t.next)||void 0===s?void 0:s.bind(t),i=null===(r=t.error)||void 0===r?void 0:r.bind(t),u=null===(a=t.complete)||void 0===a?void 0:a.bind(t)}this.__isAsync&&(i=li(i),o&&(o=li(o)),u&&(u=li(u)));const l=super.subscribe({next:o,error:i,complete:u});return e instanceof m&&e.add(l),l}};function di(){return this._results[ma()]()}class pi{constructor(e=!1){this._emitDistinctChangesOnly=e,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const t=ma(),n=pi.prototype;n[t]||(n[t]=di)}get changes(){return this._changes||(this._changes=new ci)}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){const n=this;n.dirty=!1;const s=jn(e);(this._changesDetected=!function(e,t,n){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++){let r=e[s],a=t[s];if(n&&(r=n(r),a=n(a)),a!==r)return!1}return!0}(n._results,s,t))&&(n._results=s,n.length=s.length,n.last=s[this.length-1],n.first=s[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class hi{constructor(e){this.queryList=e,this.matches=null}clone(){return new hi(this.queryList)}setDirty(){this.queryList.setDirty()}}class fi{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const n=null!==e.contentQueries?e.contentQueries[0]:t.length,s=[];for(let e=0;e<n;e++){const n=t.getByIndex(e);s.push(this.queries[n.indexInDeclarationView].clone())}return new fi(s)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==Ci(e,t).matches&&this.queries[t].setDirty()}}class mi{constructor(e,t,n=null){this.predicate=e,this.flags=t,this.read=n}}class gi{constructor(e=[]){this.queries=e}elementStart(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let n=0;n<this.length;n++){const s=null!==t?t.length:0,r=this.getByIndex(n).embeddedTView(e,s);r&&(r.indexInDeclarationView=n,null!==t?t.push(r):t=[r])}return null!==t?new gi(t):null}template(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class bi{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new bi(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const t=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&8&n.type&&n.index!==t;)n=n.parent;return t===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,t){const n=this.metadata.predicate;if(Array.isArray(n))for(let s=0;s<n.length;s++){const r=n[s];this.matchTNodeWithReadOption(e,t,yi(t,r)),this.matchTNodeWithReadOption(e,t,Tn(t,e,r,!1,!1))}else n===Po?4&t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Tn(t,e,n,!1,!1))}matchTNodeWithReadOption(e,t,n){if(null!==n){const s=this.metadata.read;if(null!==s)if(s===uo||s===Ho||s===Po&&4&t.type)this.addMatch(t.index,-2);else{const n=Tn(t,e,s,!1,!1);null!==n&&this.addMatch(t.index,n)}else this.addMatch(t.index,n)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function yi(e,t){const n=e.localNames;if(null!==n)for(let s=0;s<n.length;s+=2)if(n[s]===t)return n[s+1];return null}function vi(e,t,n,s){return-1===n?function(e,t){return 11&e.type?oo(e,t):4&e.type?Bo(e,t):null}(t,e):-2===n?function(e,t,n){return n===uo?oo(t,e):n===Po?Bo(t,e):n===Ho?Qo(t,e):void 0}(e,t,s):An(e,e[1],n,t)}function xi(e,t,n,s){const r=t[19].queries[s];if(null===r.matches){const s=e.data,a=n.matches,o=[];for(let e=0;e<a.length;e+=2){const r=a[e];o.push(r<0?null:vi(t,s[r],a[e+1],n.metadata.read))}r.matches=o}return r.matches}function wi(e,t,n,s){const r=e.queries.getByIndex(n),a=r.matches;if(null!==a){const o=xi(e,t,r,n);for(let e=0;e<a.length;e+=2){const n=a[e];if(n>0)s.push(o[e/2]);else{const r=a[e+1],o=t[-n];for(let e=tt;e<o.length;e++){const t=o[e];t[17]===t[3]&&wi(t[1],t,r,s)}if(null!==o[9]){const e=o[9];for(let t=0;t<e.length;t++){const n=e[t];wi(n[1],n,r,s)}}}}}return s}function ki(e){const t=Tt(),n=At(),s=Vt();jt(s+1);const r=Ci(n,s);if(e.dirty&&Ct(t)===(2==(2&r.metadata.flags))){if(null===r.matches)e.reset([]);else{const a=r.crossesNgTemplate?wi(n,t,s,[]):xi(n,t,r,s);e.reset(a,lo),e.notifyOnChanges()}return!0}return!1}function Ci(e,t){return e.queries.getByIndex(t)}const Ii=new Ln("Application Initializer");let _i=(()=>{class e{constructor(e){this.appInits=e,this.resolve=ao,this.reject=ao,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const t=this.appInits[n]();if(_a(t))e.push(t);else if(Sa(t)){const n=new Promise((e,n)=>{t.subscribe({complete:e,error:n})});e.push(n)}}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(ns(Ii,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const Si=new Ln("AppId"),Ei={provide:Si,useFactory:function(){return`${Ni()}${Ni()}${Ni()}`},deps:[]};function Ni(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const $i=new Ln("Platform Initializer"),Ti=new Ln("Platform ID"),Ai=new Ln("appBootstrapListener");let Ri=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const Fi=new Ln("LocaleId"),Di=new Ln("DefaultCurrencyCode");class Oi{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const qi=function(e){return new ii(e)},zi=qi,Mi=function(e){return Promise.resolve(qi(e))},Li=function(e){const t=qi(e),n=ms(Je(e).declarations).reduce((e,t)=>{const n=Qe(t);return n&&e.push(new si(n)),e},[]);return new Oi(t,n)},Pi=Li,Vi=function(e){return Promise.resolve(Li(e))};let ji=(()=>{class e{constructor(){this.compileModuleSync=zi,this.compileModuleAsync=Mi,this.compileModuleAndAllComponentsSync=Pi,this.compileModuleAndAllComponentsAsync=Vi}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const Bi=(()=>Promise.resolve(0))();function Wi(e){"undefined"==typeof Zone?Bi.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class Ui{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new ci(!1),this.onMicrotaskEmpty=new ci(!1),this.onStable=new ci(!1),this.onError=new ci(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!n&&t,s.shouldCoalesceRunChangeDetection=n,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function(){let e=De.requestAnimationFrame,t=De.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const s=t[Zone.__symbol__("OriginalDelegate")];s&&(t=s)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=()=>{!function(e){e.isCheckStableRunning||-1!==e.lastRequestAnimationFrameId||(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(De,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,Ki(e),e.isCheckStableRunning=!0,Hi(e),e.isCheckStableRunning=!1},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),Ki(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,s,r,a,o,i)=>{try{return Xi(e),n.invokeTask(r,a,o,i)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===a.type||e.shouldCoalesceRunChangeDetection)&&t(),Zi(e)}},onInvoke:(n,s,r,a,o,i,u)=>{try{return Xi(e),n.invoke(r,a,o,i,u)}finally{e.shouldCoalesceRunChangeDetection&&t(),Zi(e)}},onHasTask:(t,n,s,r)=>{t.hasTask(s,r),n===s&&("microTask"==r.change?(e._hasPendingMicrotasks=r.microTask,Ki(e),Hi(e)):"macroTask"==r.change&&(e.hasPendingMacrotasks=r.macroTask))},onHandleError:(t,n,s,r)=>(t.handleError(s,r),e.runOutsideAngular(()=>e.onError.emit(r)),!1)})}(s)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Ui.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Ui.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,n){return this._inner.run(e,t,n)}runTask(e,t,n,s){const r=this._inner,a=r.scheduleEventTask("NgZoneEvent: "+s,e,Gi,ao,ao);try{return r.runTask(a,t,n)}finally{r.cancelTask(a)}}runGuarded(e,t,n){return this._inner.runGuarded(e,t,n)}runOutsideAngular(e){return this._outer.run(e)}}const Gi={};function Hi(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function Ki(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&-1!==e.lastRequestAnimationFrameId)}function Xi(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function Zi(e){e._nesting--,Hi(e)}class Yi{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new ci,this.onMicrotaskEmpty=new ci,this.onStable=new ci,this.onError=new ci}run(e,t,n){return e.apply(t,n)}runGuarded(e,t,n){return e.apply(t,n)}runOutsideAngular(e){return e()}runTask(e,t,n,s){return e.apply(t,n)}}let Qi=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Ui.assertNotInAngularZone(),Wi(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Wi(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,n){let s=-1;t&&t>0&&(s=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==s),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:s,updateCb:n})}whenStable(e,t,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,t,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,n){return[]}}return e.\u0275fac=function(t){return new(t||e)(ns(Ui))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Ji=(()=>{class e{constructor(){this._applications=new Map,nu.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return nu.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class eu{addToWindow(e){}findTestabilityInTree(e,t,n){return null}}let tu,nu=new eu,su=!0,ru=!1;const au=new Ln("AllowMultipleToken");class ou{constructor(e,t){this.name=e,this.token=t}}function iu(e,t,n=[]){const s=`Platform: ${t}`,r=new Ln(s);return(t=[])=>{let a=uu();if(!a||a.injector.get(au,!1))if(e)e(n.concat(t).concat({provide:r,useValue:!0}));else{const e=n.concat(t).concat({provide:r,useValue:!0},{provide:Kr,useValue:"platform"});!function(e){if(tu&&!tu.destroyed&&!tu.injector.get(au,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");tu=e.get(lu);const t=e.get($i,null);t&&t.forEach(e=>e())}(ia.create({providers:e,name:s}))}return function(e){const t=uu();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(r)}}function uu(){return tu&&!tu.destroyed?tu:null}let lu=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const n=function(e,t){let n;return n="noop"===e?new Yi:("zone.js"===e?void 0:e)||new Ui({enableLongStackTrace:(ru=!0,su),shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),n}(t?t.ngZone:void 0,{ngZoneEventCoalescing:t&&t.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:t&&t.ngZoneRunCoalescing||!1}),s=[{provide:Ui,useValue:n}];return n.run(()=>{const t=ia.create({providers:s,parent:this.injector,name:e.moduleType.name}),r=e.create(t),a=r.injector.get(hs,null);if(!a)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const e=n.onError.subscribe({next:e=>{a.handleError(e)}});r.onDestroy(()=>{pu(this._modules,r),e.unsubscribe()})}),function(e,t,n){try{const s=n();return _a(s)?s.catch(n=>{throw t.runOutsideAngular(()=>e.handleError(n)),n}):s}catch(s){throw t.runOutsideAngular(()=>e.handleError(s)),s}}(a,n,()=>{const e=r.injector.get(_i);return e.runInitializers(),e.donePromise.then(()=>(Ha(r.injector.get(Fi,Ua)||Ua),this._moduleDoBootstrap(r),r))})})}bootstrapModule(e,t=[]){const n=cu({},t);return function(e,t,n){const s=new ii(n);return Promise.resolve(s)}(0,0,e).then(e=>this.bootstrapModuleFactory(e,n))}_moduleDoBootstrap(e){const t=e.injector.get(du);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${re(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(ns(ia))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function cu(e,t){return Array.isArray(t)?t.reduce(cu,e):Object.assign(Object.assign({},e),t)}let du=(()=>{class e{constructor(e,t,n,s,r){this._zone=e,this._injector=t,this._exceptionHandler=n,this._componentFactoryResolver=s,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const a=new k(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),o=new k(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{Ui.assertNotInAngularZone(),Wi(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Ui.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),n.unsubscribe()}});this.isStable=function(...e){let t=Number.POSITIVE_INFINITY,n=null,s=e[e.length-1];return $(s)?(n=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof s&&(t=e.pop()),null===n&&1===e.length&&e[0]instanceof k?e[0]:H(t)(K(e,n))}(a,o.pipe(e=>{return X()((t=te,function(e){let n;n="function"==typeof t?t:function(){return t};const s=Object.create(e,J);return s.source=e,s.subjectFactory=n,s})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=e instanceof no?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(n.componentType);const s=n.isBoundToModule?void 0:this._injector.get(Wo),r=n.create(ia.NULL,[],t||n.selector,s),a=r.location.nativeElement,o=r.injector.get(Qi,null),i=o&&r.injector.get(Ji);return o&&i&&i.registerApplication(a,o),r.onDestroy(()=>{this.detachView(r.hostView),pu(this.components,r),i&&i.unregisterApplication(a)}),this._loadComponent(r),r}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;pu(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(Ai,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(ns(Ui),ns(ia),ns(hs),ns(ro),ns(_i))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function pu(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class hu{}class fu{}const mu={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let gu=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||mu}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,s]=e.split("#");return void 0===s&&(s="default"),n(255)(t).then(e=>e[s]).then(e=>bu(e,t,s)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,s]=e.split("#"),r="NgFactory";return void 0===s&&(s="default",r=""),n(255)(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[s+r]).then(e=>bu(e,t,s))}}return e.\u0275fac=function(t){return new(t||e)(ns(ji),ns(fu,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function bu(e,t,n){if(!e)throw new Error(`Cannot find '${n}' in '${t}'`);return e}const yu=iu(null,"core",[{provide:Ti,useValue:"unknown"},{provide:lu,deps:[ia]},{provide:Ji,deps:[]},{provide:Ri,deps:[]}]),vu=[{provide:du,useClass:du,deps:[Ui,ia,hs,ro,_i]},{provide:ni,deps:[Ui],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:_i,useClass:_i,deps:[[new os,Ii]]},{provide:ji,useClass:ji,deps:[]},Ei,{provide:No,useFactory:function(){return zo},deps:[]},{provide:To,useFactory:function(){return Mo},deps:[]},{provide:Fi,useFactory:function(e){return Ha(e=e||"undefined"!=typeof $localize&&$localize.locale||Ua),e},deps:[[new as(Fi),new os,new is]]},{provide:Di,useValue:"USD"}];let xu=(()=>{class e{constructor(e){}}return e.\u0275fac=function(t){return new(t||e)(ns(du))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:vu}),e})(),wu=null;function ku(){return wu}const Cu=new Ln("DocumentToken");let Iu=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:_u,token:e,providedIn:"platform"}),e})();function _u(){return ns(Eu)}const Su=new Ln("Location Initialized");let Eu=(()=>{class e extends Iu{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return ku().getBaseHref(this._doc)}onPopState(e){const t=ku().getGlobalEventTarget(this._doc,"window");return t.addEventListener("popstate",e,!1),()=>t.removeEventListener("popstate",e)}onHashChange(e){const t=ku().getGlobalEventTarget(this._doc,"window");return t.addEventListener("hashchange",e,!1),()=>t.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,n){Nu()?this._history.pushState(e,t,n):this.location.hash=n}replaceState(e,t,n){Nu()?this._history.replaceState(e,t,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(ns(Cu))},e.\u0275prov=fe({factory:$u,token:e,providedIn:"platform"}),e})();function Nu(){return!!window.history.pushState}function $u(){return new Eu(ns(Cu))}function Tu(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function Au(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function Ru(e){return e&&"?"!==e[0]?"?"+e:e}let Fu=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:Du,token:e,providedIn:"root"}),e})();function Du(e){const t=ns(Cu).location;return new qu(ns(Iu),t&&t.origin||"")}const Ou=new Ln("appBaseHref");let qu=(()=>{class e extends Fu{constructor(e,t){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Tu(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+Ru(this._platformLocation.search),n=this._platformLocation.hash;return n&&e?`${t}${n}`:t}pushState(e,t,n,s){const r=this.prepareExternalUrl(n+Ru(s));this._platformLocation.pushState(e,t,r)}replaceState(e,t,n,s){const r=this.prepareExternalUrl(n+Ru(s));this._platformLocation.replaceState(e,t,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(ns(Iu),ns(Ou,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),zu=(()=>{class e extends Fu{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=t&&(this._baseHref=t)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=Tu(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,n,s){let r=this.prepareExternalUrl(n+Ru(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.pushState(e,t,r)}replaceState(e,t,n,s){let r=this.prepareExternalUrl(n+Ru(s));0==r.length&&(r=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,r)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(ns(Iu),ns(Ou,8))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Mu=(()=>{class e{constructor(e,t){this._subject=new ci,this._urlChangeListeners=[],this._platformStrategy=e;const n=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=Au(Pu(n)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+Ru(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,Pu(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",n=null){this._platformStrategy.pushState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}replaceState(e,t="",n=null){this._platformStrategy.replaceState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformStrategy).historyGo)||void 0===n||n.call(t,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)}))}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(n=>n(e,t))}subscribe(e,t,n){return this._subject.subscribe({next:e,error:t,complete:n})}}return e.\u0275fac=function(t){return new(t||e)(ns(Fu),ns(Iu))},e.normalizeQueryParams=Ru,e.joinWithSlash=Tu,e.stripTrailingSlash=Au,e.\u0275prov=fe({factory:Lu,token:e,providedIn:"root"}),e})();function Lu(){return new Mu(ns(Fu),ns(Iu))}function Pu(e){return e.replace(/\/index.html$/,"")}var Vu=function(e){return e[e.Zero=0]="Zero",e[e.One=1]="One",e[e.Two=2]="Two",e[e.Few=3]="Few",e[e.Many=4]="Many",e[e.Other=5]="Other",e}({});class ju{}let Bu=(()=>{class e extends ju{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return function(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let n=Ba(t);if(n)return n;const s=t.split("-")[0];if(n=Ba(s),n)return n;if("en"===s)return Va;throw new Error(`Missing locale data for the locale "${e}".`)}(e)[Wa.PluralCase]}(t||this.locale)(e)){case Vu.Zero:return"zero";case Vu.One:return"one";case Vu.Two:return"two";case Vu.Few:return"few";case Vu.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(ns(Fi))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Wu=(()=>{class e{constructor(e,t,n,s){this._iterableDiffers=e,this._keyValueDiffers=t,this._ngEl=n,this._renderer=s,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(ga(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachChangedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachRemovedItem(e=>{e.previousValue&&this._toggleClass(e.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(e=>{if("string"!=typeof e.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${re(e.item)}`);this._toggleClass(e.item,!0)}),e.forEachRemovedItem(e=>this._toggleClass(e.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!0)):Object.keys(e).forEach(t=>this._toggleClass(t,!!e[t])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!1)):Object.keys(e).forEach(e=>this._toggleClass(e,!1)))}_toggleClass(e,t){(e=e.trim())&&e.split(/\s+/g).forEach(e=>{t?this._renderer.addClass(this._ngEl.nativeElement,e):this._renderer.removeClass(this._ngEl.nativeElement,e)})}}return e.\u0275fac=function(t){return new(t||e)(va(No),va(To),va(uo),va(po))},e.\u0275dir=Ye({type:e,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),e})();class Uu{constructor(e,t,n,s){this.$implicit=e,this.ngForOf=t,this.index=n,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Gu=(()=>{class e{constructor(e,t,n){this._viewContainer=e,this._template=t,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(t){throw new Error(`Cannot find a differ supporting object '${n}' of type '${e=n,e.name||typeof e}'. NgFor only supports binding to Iterables such as Arrays.`)}}var e;if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const t=[];e.forEachOperation((e,n,s)=>{if(null==e.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new Uu(null,this._ngForOf,-1,-1),null===s?void 0:s),r=new Hu(e,n);t.push(r)}else if(null==s)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const r=this._viewContainer.get(n);this._viewContainer.move(r,s);const a=new Hu(e,r);t.push(a)}});for(let n=0;n<t.length;n++)this._perViewChange(t[n].view,t[n].record);for(let n=0,s=this._viewContainer.length;n<s;n++){const e=this._viewContainer.get(n);e.context.index=n,e.context.count=s,e.context.ngForOf=this._ngForOf}e.forEachIdentityChange(e=>{this._viewContainer.get(e.currentIndex).context.$implicit=e.item})}_perViewChange(e,t){e.context.$implicit=t.item}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(va(Ho),va(Po),va(No))},e.\u0275dir=Ye({type:e,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),e})();class Hu{constructor(e,t){this.record=e,this.view=t}}let Ku=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:[{provide:ju,useClass:Bu}]}),e})(),Xu=(()=>{class e{}return e.\u0275prov=fe({token:e,providedIn:"root",factory:()=>new Zu(ns(Cu),window)}),e})();class Zu{constructor(e,t){this.document=e,this.window=t,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(!this.supportsScrolling())return;const t=function(e,t){const n=e.getElementById(t)||e.getElementsByName(t)[0];if(n)return n;if("function"==typeof e.createTreeWalker&&e.body&&(e.body.createShadowRoot||e.body.attachShadow)){const n=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let s=n.currentNode;for(;s;){const e=s.shadowRoot;if(e){const n=e.getElementById(t)||e.querySelector(`[name="${t}"]`);if(n)return n}s=n.nextNode()}}return null}(this.document,e);t&&(this.scrollToElement(t),this.attemptFocus(t))}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),n=t.left+this.window.pageXOffset,s=t.top+this.window.pageYOffset,r=this.offset();this.window.scrollTo(n-r[0],s-r[1])}attemptFocus(e){return e.focus(),this.document.activeElement===e}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const e=Yu(this.window.history)||Yu(Object.getPrototypeOf(this.window.history));return!(!e||!e.writable&&!e.set)}catch(e){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(e){return!1}}}function Yu(e){return Object.getOwnPropertyDescriptor(e,"scrollRestoration")}class Qu extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var e;e=new Qu,wu||(wu=e)}onAndCancel(e,t,n){return e.addEventListener(t,n,!1),()=>{e.removeEventListener(t,n,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.parentNode&&e.parentNode.removeChild(e)}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getBaseHref(e){const t=(el=el||document.querySelector("base"),el?el.getAttribute("href"):null);return null==t?null:function(e){Ju=Ju||document.createElement("a"),Ju.setAttribute("href",e);const t=Ju.pathname;return"/"===t.charAt(0)?t:`/${t}`}(t)}resetBaseElement(){el=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return function(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const e=n.indexOf("="),[s,r]=-1==e?[n,""]:[n.slice(0,e),n.slice(e+1)];if(s.trim()===t)return decodeURIComponent(r)}return null}(document.cookie,e)}}let Ju,el=null;const tl=new Ln("TRANSITION_ID"),nl=[{provide:Ii,useFactory:function(e,t,n){return()=>{n.get(_i).donePromise.then(()=>{const n=ku();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>n.remove(e))})}},deps:[tl,Cu,ia],multi:!0}];class sl{static init(){var e;e=new sl,nu=e}addToWindow(e){De.getAngularTestability=(t,n=!0)=>{const s=e.findTestabilityInTree(t,n);if(null==s)throw new Error("Could not find testability for element.");return s},De.getAllAngularTestabilities=()=>e.getAllTestabilities(),De.getAllAngularRootElements=()=>e.getAllRootElements(),De.frameworkStabilizers||(De.frameworkStabilizers=[]),De.frameworkStabilizers.push(e=>{const t=De.getAllAngularTestabilities();let n=t.length,s=!1;const r=function(t){s=s||t,n--,0==n&&e(s)};t.forEach(function(e){e.whenStable(r)})})}findTestabilityInTree(e,t,n){if(null==t)return null;const s=e.getTestability(t);return null!=s?s:n?ku().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}let rl=(()=>{class e{build(){return new XMLHttpRequest}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const al=new Ln("EventManagerPlugins");let ol=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,n){return this._findPluginFor(t).addEventListener(e,t,n)}addGlobalEventListener(e,t,n){return this._findPluginFor(t).addGlobalEventListener(e,t,n)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const n=this._plugins;for(let s=0;s<n.length;s++){const t=n[s];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error(`No event manager plugin found for event ${e}`)}}return e.\u0275fac=function(t){return new(t||e)(ns(al),ns(Ui))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class il{constructor(e){this._doc=e}addGlobalEventListener(e,t,n){const s=ku().getGlobalEventTarget(this._doc,e);if(!s)throw new Error(`Unsupported event target ${s} for event ${t}`);return this.addEventListener(s,t,n)}}let ul=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),ll=(()=>{class e extends ul{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,t,n){e.forEach(e=>{const s=this._doc.createElement("style");s.textContent=e,n.push(t.appendChild(s))})}addHost(e){const t=[];this._addStylesToHost(this._stylesSet,e,t),this._hostNodes.set(e,t)}removeHost(e){const t=this._hostNodes.get(e);t&&t.forEach(cl),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((t,n)=>{this._addStylesToHost(e,n,t)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(cl))}}return e.\u0275fac=function(t){return new(t||e)(ns(Cu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function cl(e){ku().remove(e)}const dl={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},pl=/%COMP%/g;function hl(e,t,n){for(let s=0;s<t.length;s++){let r=t[s];Array.isArray(r)?hl(e,r,n):(r=r.replace(pl,e),n.push(r))}return n}function fl(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let ml=(()=>{class e{constructor(e,t,n){this.eventManager=e,this.sharedStylesHost=t,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new gl(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case $e.Emulated:{let n=this.rendererByCompId.get(t.id);return n||(n=new bl(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,n)),n.applyToHost(e),n}case 1:case $e.ShadowDom:return new yl(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=hl(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(ns(ol),ns(ll),ns(Si))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();class gl{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(dl[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,n){e&&e.insertBefore(t,n)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let n="string"==typeof e?document.querySelector(e):e;if(!n)throw new Error(`The selector "${e}" did not match any elements`);return t||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,n,s){if(s){t=s+":"+t;const r=dl[s];r?e.setAttributeNS(r,t,n):e.setAttribute(t,n)}else e.setAttribute(t,n)}removeAttribute(e,t,n){if(n){const s=dl[n];s?e.removeAttributeNS(s,t):e.removeAttribute(`${n}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,n,s){s&(gs.DashCase|gs.Important)?e.style.setProperty(t,n,s&gs.Important?"important":""):e.style[t]=n}removeStyle(e,t,n){n&gs.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,n){e[t]=n}setValue(e,t){e.nodeValue=t}listen(e,t,n){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,fl(n)):this.eventManager.addEventListener(e,t,fl(n))}}class bl extends gl{constructor(e,t,n,s){super(e),this.component=n;const r=hl(s+"-"+n.id,n.styles,[]);t.addStyles(r),this.contentAttr="_ngcontent-%COMP%".replace(pl,s+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(pl,s+"-"+n.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const n=super.createElement(e,t);return super.setAttribute(n,this.contentAttr,""),n}}class yl extends gl{constructor(e,t,n,s){super(e),this.sharedStylesHost=t,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const r=hl(s.id,s.styles,[]);for(let a=0;a<r.length;a++){const e=document.createElement("style");e.textContent=r[a],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,n){return super.insertBefore(this.nodeOrShadowRoot(e),t,n)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let vl=(()=>{class e extends il{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,n){return e.addEventListener(t,n,!1),()=>this.removeEventListener(e,t,n)}removeEventListener(e,t,n){return e.removeEventListener(t,n)}}return e.\u0275fac=function(t){return new(t||e)(ns(Cu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const xl=["alt","control","meta","shift"],wl={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},kl={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Cl={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let Il=(()=>{class e extends il{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,n,s){const r=e.parseEventName(n),a=e.eventCallback(r.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ku().onAndCancel(t,r.domEventName,a))}static parseEventName(t){const n=t.toLowerCase().split("."),s=n.shift();if(0===n.length||"keydown"!==s&&"keyup"!==s)return null;const r=e._normalizeKey(n.pop());let a="";if(xl.forEach(e=>{const t=n.indexOf(e);t>-1&&(n.splice(t,1),a+=e+".")}),a+=r,0!=n.length||0===r.length)return null;const o={};return o.domEventName=s,o.fullKey=a,o}static getEventFullKey(e){let t="",n=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&kl.hasOwnProperty(t)&&(t=kl[t]))}return wl[t]||t}(e);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),xl.forEach(s=>{s!=n&&(0,Cl[s])(e)&&(t+=s+".")}),t+=n,t}static eventCallback(t,n,s){return r=>{e.getEventFullKey(r)===t&&s.runGuarded(()=>n(r))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(ns(Cu))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const _l=iu(yu,"browser",[{provide:Ti,useValue:"browser"},{provide:$i,useValue:function(){Qu.makeCurrent(),sl.init()},multi:!0},{provide:Cu,useFactory:function(){return function(e){mt=e}(document),document},deps:[]}]),Sl=[[],{provide:Kr,useValue:"root"},{provide:hs,useFactory:function(){return new hs},deps:[]},{provide:al,useClass:vl,multi:!0,deps:[Cu,Ui,Ti]},{provide:al,useClass:Il,multi:!0,deps:[Cu]},[],{provide:ml,useClass:ml,deps:[ol,ll,Si]},{provide:co,useExisting:ml},{provide:ul,useExisting:ll},{provide:ll,useClass:ll,deps:[Cu]},{provide:Qi,useClass:Qi,deps:[Ui]},{provide:ol,useClass:ol,deps:[al,Ui]},{provide:class{},useClass:rl,deps:[]},[]];let El=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:Si,useValue:t.appId},{provide:tl,useExisting:Si},nl]}}}return e.\u0275fac=function(t){return new(t||e)(ns(e,12))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({providers:Sl,imports:[Ku,xu]}),e})();function Nl(...e){let t=e[e.length-1];return $(t)?(e.pop(),L(e,t)):K(e)}"undefined"!=typeof window&&window;class $l extends E{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new I;return this._value}next(e){super.next(this._value=e)}}class Tl extends y{notifyNext(e,t,n,s,r){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}class Al extends y{constructor(e,t,n){super(),this.parent=e,this.outerValue=t,this.outerIndex=n,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function Rl(e,t,n,s,r=new Al(e,n,s)){if(!r.closed)return t instanceof k?t.subscribe(r):M(t)(r)}const Fl={};class Dl{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new Ol(e,this.resultSelector))}}class Ol extends Tl{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(Fl),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let n=0;n<t;n++)this.add(Rl(this,e[n],void 0,n))}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,n){const s=this.values,r=this.toRespond?s[n]===Fl?--this.toRespond:this.toRespond:0;s[n]=t,0===r&&(this.resultSelector?this._tryResultSelector(s):this.destination.next(s.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const ql=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})();function zl(...e){return H(1)(Nl(...e))}const Ml=new k(e=>e.complete());function Ll(e){return e?function(e){return new k(t=>e.schedule(()=>t.complete()))}(e):Ml}function Pl(e){return new k(t=>{let n;try{n=e()}catch(s){return void t.error(s)}return(n?P(n):Ll()).subscribe(t)})}function Vl(e,t){return"function"==typeof t?n=>n.pipe(Vl((n,s)=>P(e(n,s)).pipe(T((e,r)=>t(n,e,s,r))))):t=>t.lift(new jl(e))}class jl{constructor(e){this.project=e}call(e,t){return t.subscribe(new Bl(e,this.project))}}class Bl extends j{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(s){return void this.destination.error(s)}this._innerSub(t)}_innerSub(e){const t=this.innerSubscription;t&&t.unsubscribe();const n=new V(this),s=this.destination;s.add(n),this.innerSubscription=B(e,n),this.innerSubscription!==n&&s.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(e){this.destination.next(e)}}const Wl=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function Ul(e){return t=>0===e?Ll():t.lift(new Gl(e))}class Gl{constructor(e){if(this.total=e,this.total<0)throw new Wl}call(e,t){return t.subscribe(new Hl(e,this.total))}}class Hl extends y{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,n=++this.count;n<=t&&(this.destination.next(e),n===t&&(this.destination.complete(),this.unsubscribe()))}}function Kl(e,t){let n=!1;return arguments.length>=2&&(n=!0),function(s){return s.lift(new Xl(e,t,n))}}class Xl{constructor(e,t,n=!1){this.accumulator=e,this.seed=t,this.hasSeed=n}call(e,t){return t.subscribe(new Zl(e,this.accumulator,this.seed,this.hasSeed))}}class Zl extends y{constructor(e,t,n,s){super(e),this.accumulator=t,this._seed=n,this.hasSeed=s,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let n;try{n=this.accumulator(this.seed,e,t)}catch(s){this.destination.error(s)}this.seed=n,this.destination.next(n)}}function Yl(e,t){return function(n){return n.lift(new Ql(e,t))}}class Ql{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new Jl(e,this.predicate,this.thisArg))}}class Jl extends y{constructor(e,t,n){super(e),this.predicate=t,this.thisArg=n,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}t&&this.destination.next(e)}}function ec(e){return function(t){const n=new tc(e),s=t.lift(n);return n.caught=s}}class tc{constructor(e){this.selector=e}call(e,t){return t.subscribe(new nc(e,this.selector,this.caught))}}class nc extends j{constructor(e,t,n){super(e),this.selector=t,this.caught=n}error(e){if(!this.isStopped){let n;try{n=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const s=new V(this);this.add(s);const r=B(n,s);r!==s&&this.add(r)}}}function sc(e,t){return W(e,t,1)}function rc(e){return function(t){return 0===e?Ll():t.lift(new ac(e))}}class ac{constructor(e){if(this.total=e,this.total<0)throw new Wl}call(e,t){return t.subscribe(new oc(e,this.total))}}class oc extends y{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,n=this.total,s=this.count++;t.length<n?t.push(e):t[s%n]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const n=this.count>=this.total?this.total:this.count,s=this.ring;for(let r=0;r<n;r++){const r=t++%n;e.next(s[r])}}e.complete()}}function ic(e=cc){return t=>t.lift(new uc(e))}class uc{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new lc(e,this.errorFactory))}}class lc extends y{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function cc(){return new ql}function dc(e=null){return t=>t.lift(new pc(e))}class pc{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new hc(e,this.defaultValue))}}class hc extends y{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function fc(e,t){const n=arguments.length>=2;return s=>s.pipe(e?Yl((t,n)=>e(t,n,s)):w,Ul(1),n?dc(t):ic(()=>new ql))}function mc(){}function gc(e,t,n){return function(s){return s.lift(new bc(e,t,n))}}class bc{constructor(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}call(e,t){return t.subscribe(new yc(e,this.nextOrObserver,this.error,this.complete))}}class yc extends y{constructor(e,t,n,s){super(e),this._tapNext=mc,this._tapError=mc,this._tapComplete=mc,this._tapError=n||mc,this._tapComplete=s||mc,i(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||mc,this._tapError=t.error||mc,this._tapComplete=t.complete||mc)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class vc{constructor(e){this.callback=e}call(e,t){return t.subscribe(new xc(e,this.callback))}}class xc extends y{constructor(e,t){super(e),this.add(new m(t))}}class wc{constructor(e,t){this.id=e,this.url=t}}class kc extends wc{constructor(e,t,n="imperative",s=null){super(e,t),this.navigationTrigger=n,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Cc extends wc{constructor(e,t,n){super(e,t),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Ic extends wc{constructor(e,t,n){super(e,t),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class _c extends wc{constructor(e,t,n){super(e,t),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Sc extends wc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ec extends wc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Nc extends wc{constructor(e,t,n,s,r){super(e,t),this.urlAfterRedirects=n,this.state=s,this.shouldActivate=r}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class $c extends wc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Tc extends wc{constructor(e,t,n,s){super(e,t),this.urlAfterRedirects=n,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ac{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Rc{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Fc{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Dc{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Oc{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class qc{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class zc{constructor(e,t,n){this.routerEvent=e,this.position=t,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const Mc="primary";class Lc{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function Pc(e){return new Lc(e)}function Vc(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function jc(e,t,n){const s=n.path.split("/");if(s.length>e.length)return null;if("full"===n.pathMatch&&(t.hasChildren()||s.length<e.length))return null;const r={};for(let a=0;a<s.length;a++){const t=s[a],n=e[a];if(t.startsWith(":"))r[t.substring(1)]=n;else if(t!==n.path)return null}return{consumed:e.slice(0,s.length),posParams:r}}function Bc(e,t){const n=e?Object.keys(e):void 0,s=t?Object.keys(t):void 0;if(!n||!s||n.length!=s.length)return!1;let r;for(let a=0;a<n.length;a++)if(r=n[a],!Wc(e[r],t[r]))return!1;return!0}function Wc(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const n=[...e].sort(),s=[...t].sort();return n.every((e,t)=>s[t]===e)}return e===t}function Uc(e){return Array.prototype.concat.apply([],e)}function Gc(e){return e.length>0?e[e.length-1]:null}function Hc(e,t){for(const n in e)e.hasOwnProperty(n)&&t(e[n],n)}function Kc(e){return Sa(e)?e:_a(e)?P(Promise.resolve(e)):Nl(e)}const Xc={exact:function e(t,n,s){if(!rd(t.segments,n.segments))return!1;if(!ed(t.segments,n.segments,s))return!1;if(t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children){if(!t.children[r])return!1;if(!e(t.children[r],n.children[r],s))return!1}return!0},subset:Qc},Zc={exact:function(e,t){return Bc(e,t)},subset:function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>Wc(e[n],t[n]))},ignored:()=>!0};function Yc(e,t,n){return Xc[n.paths](e.root,t.root,n.matrixParams)&&Zc[n.queryParams](e.queryParams,t.queryParams)&&!("exact"===n.fragment&&e.fragment!==t.fragment)}function Qc(e,t,n){return Jc(e,t,t.segments,n)}function Jc(e,t,n,s){if(e.segments.length>n.length){const r=e.segments.slice(0,n.length);return!!rd(r,n)&&!t.hasChildren()&&!!ed(r,n,s)}if(e.segments.length===n.length){if(!rd(e.segments,n))return!1;if(!ed(e.segments,n,s))return!1;for(const n in t.children){if(!e.children[n])return!1;if(!Qc(e.children[n],t.children[n],s))return!1}return!0}{const r=n.slice(0,e.segments.length),a=n.slice(e.segments.length);return!!rd(e.segments,r)&&!!ed(e.segments,r,s)&&!!e.children.primary&&Jc(e.children.primary,t,a,s)}}function ed(e,t,n){return t.every((t,s)=>Zc[n](e[s].parameters,t.parameters))}class td{constructor(e,t,n){this.root=e,this.queryParams=t,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Pc(this.queryParams)),this._queryParamMap}toString(){return id.serialize(this)}}class nd{constructor(e,t){this.segments=e,this.children=t,this.parent=null,Hc(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return ud(this)}}class sd{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=Pc(this.parameters)),this._parameterMap}toString(){return md(this)}}function rd(e,t){return e.length===t.length&&e.every((e,n)=>e.path===t[n].path)}class ad{}class od{parse(e){const t=new xd(e);return new td(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){var t;return`/${ld(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const n=e[t];return Array.isArray(n)?n.map(e=>`${dd(t)}=${dd(e)}`).join("&"):`${dd(t)}=${dd(n)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(e.queryParams)}${"string"==typeof e.fragment?`#${t=e.fragment,encodeURI(t)}`:""}`}}const id=new od;function ud(e){return e.segments.map(e=>md(e)).join("/")}function ld(e,t){if(!e.hasChildren())return ud(e);if(t){const t=e.children.primary?ld(e.children.primary,!1):"",n=[];return Hc(e.children,(e,t)=>{t!==Mc&&n.push(`${t}:${ld(e,!1)}`)}),n.length>0?`${t}(${n.join("//")})`:t}{const t=function(e,t){let n=[];return Hc(e.children,(e,s)=>{s===Mc&&(n=n.concat(t(e,s)))}),Hc(e.children,(e,s)=>{s!==Mc&&(n=n.concat(t(e,s)))}),n}(e,(t,n)=>n===Mc?[ld(e.children.primary,!1)]:[`${n}:${ld(t,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children.primary?`${ud(e)}/${t[0]}`:`${ud(e)}/(${t.join("//")})`}}function cd(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function dd(e){return cd(e).replace(/%3B/gi,";")}function pd(e){return cd(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function hd(e){return decodeURIComponent(e)}function fd(e){return hd(e.replace(/\+/g,"%20"))}function md(e){return`${pd(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${pd(e)}=${pd(t[e])}`).join("")}`;var t}const gd=/^[^\/()?;=#]+/;function bd(e){const t=e.match(gd);return t?t[0]:""}const yd=/^[^=?&#]+/,vd=/^[^?&#]+/;class xd{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new nd([],{}):new nd([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(n.primary=new nd(e,t)),n}parseSegment(){const e=bd(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new sd(hd(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=bd(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=bd(this.remaining);e&&(n=e,this.capture(n))}e[hd(t)]=hd(n)}parseQueryParam(e){const t=function(e){const t=e.match(yd);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(vd);return t?t[0]:""}(this.remaining);e&&(n=e,this.capture(n))}const s=fd(t),r=fd(n);if(e.hasOwnProperty(s)){let t=e[s];Array.isArray(t)||(t=[t],e[s]=t),t.push(r)}else e[s]=r}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=bd(this.remaining),s=this.remaining[n.length];if("/"!==s&&")"!==s&&";"!==s)throw new Error(`Cannot parse url '${this.url}'`);let r;n.indexOf(":")>-1?(r=n.substr(0,n.indexOf(":")),this.capture(r),this.capture(":")):e&&(r=Mc);const a=this.parseChildren();t[r]=1===Object.keys(a).length?a.primary:new nd([],a),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class wd{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=kd(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=kd(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=Cd(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return Cd(e,this._root).map(e=>e.value)}}function kd(e,t){if(e===t.value)return t;for(const n of t.children){const t=kd(e,n);if(t)return t}return null}function Cd(e,t){if(e===t.value)return[t];for(const n of t.children){const s=Cd(e,n);if(s.length)return s.unshift(t),s}return[]}class Id{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function _d(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class Sd extends wd{constructor(e,t){super(e),this.snapshot=t,Rd(this,e)}toString(){return this.snapshot.toString()}}function Ed(e,t){const n=function(e,t){const n=new Td([],{},{},"",{},Mc,t,null,e.root,-1,{});return new Ad("",new Id(n,[]))}(e,t),s=new $l([new sd("",{})]),r=new $l({}),a=new $l({}),o=new $l({}),i=new $l(""),u=new Nd(s,r,o,i,a,Mc,t,n.root);return u.snapshot=n.root,new Sd(new Id(u,[]),n)}class Nd{constructor(e,t,n,s,r,a,o,i){this.url=e,this.params=t,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=a,this.component=o,this._futureSnapshot=i}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(T(e=>Pc(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(T(e=>Pc(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function $d(e,t="emptyOnly"){const n=e.pathFromRoot;let s=0;if("always"!==t)for(s=n.length-1;s>=1;){const e=n[s],t=n[s-1];if(e.routeConfig&&""===e.routeConfig.path)s--;else{if(t.component)break;s--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(s))}class Td{constructor(e,t,n,s,r,a,o,i,u,l,c){this.url=e,this.params=t,this.queryParams=n,this.fragment=s,this.data=r,this.outlet=a,this.component=o,this.routeConfig=i,this._urlSegment=u,this._lastPathIndex=l,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Pc(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Pc(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Ad extends wd{constructor(e,t){super(t),this.url=e,Rd(this,t)}toString(){return Fd(this._root)}}function Rd(e,t){t.value._routerState=e,t.children.forEach(t=>Rd(e,t))}function Fd(e){const t=e.children.length>0?` { ${e.children.map(Fd).join(", ")} } `:"";return`${e.value}${t}`}function Dd(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,Bc(t.queryParams,n.queryParams)||e.queryParams.next(n.queryParams),t.fragment!==n.fragment&&e.fragment.next(n.fragment),Bc(t.params,n.params)||e.params.next(n.params),function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!Bc(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.url.next(n.url),Bc(t.data,n.data)||e.data.next(n.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function Od(e,t){var n,s;return Bc(e.params,t.params)&&rd(n=e.url,s=t.url)&&n.every((e,t)=>Bc(e.parameters,s[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||Od(e.parent,t.parent))}function qd(e,t,n){if(n&&e.shouldReuseRoute(t.value,n.value.snapshot)){const s=n.value;s._futureSnapshot=t.value;const r=function(e,t,n){return t.children.map(t=>{for(const s of n.children)if(e.shouldReuseRoute(t.value,s.value.snapshot))return qd(e,t,s);return qd(e,t)})}(e,t,n);return new Id(s,r)}{if(e.shouldAttach(t.value)){const n=e.retrieve(t.value);if(null!==n){const e=n.route;return zd(t,e),e}}const n=new Nd(new $l((s=t.value).url),new $l(s.params),new $l(s.queryParams),new $l(s.fragment),new $l(s.data),s.outlet,s.component,s),r=t.children.map(t=>qd(e,t));return new Id(n,r)}var s}function zd(e,t){if(e.value.routeConfig!==t.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==t.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");t.value._futureSnapshot=e.value;for(let n=0;n<e.children.length;++n)zd(e.children[n],t.children[n])}function Md(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function Ld(e){return"object"==typeof e&&null!=e&&e.outlets}function Pd(e,t,n,s,r){let a={};return s&&Hc(s,(e,t)=>{a[t]=Array.isArray(e)?e.map(e=>`${e}`):`${e}`}),new td(n.root===e?t:Vd(n.root,e,t),a,r)}function Vd(e,t,n){const s={};return Hc(e.children,(e,r)=>{s[r]=e===t?n:Vd(e,t,n)}),new nd(e.segments,s)}class jd{constructor(e,t,n){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=n,e&&n.length>0&&Md(n[0]))throw new Error("Root segment cannot have matrix parameters");const s=n.find(Ld);if(s&&s!==Gc(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Bd{constructor(e,t,n){this.segmentGroup=e,this.processChildren=t,this.index=n}}function Wd(e,t,n){if(e||(e=new nd([],{})),0===e.segments.length&&e.hasChildren())return Ud(e,t,n);const s=function(e,t,n){let s=0,r=t;const a={match:!1,pathIndex:0,commandIndex:0};for(;r<e.segments.length;){if(s>=n.length)return a;const t=e.segments[r],o=n[s];if(Ld(o))break;const i=`${o}`,u=s<n.length-1?n[s+1]:null;if(r>0&&void 0===i)break;if(i&&u&&"object"==typeof u&&void 0===u.outlets){if(!Xd(i,u,t))return a;s+=2}else{if(!Xd(i,{},t))return a;s++}r++}return{match:!0,pathIndex:r,commandIndex:s}}(e,t,n),r=n.slice(s.commandIndex);if(s.match&&s.pathIndex<e.segments.length){const t=new nd(e.segments.slice(0,s.pathIndex),{});return t.children.primary=new nd(e.segments.slice(s.pathIndex),e.children),Ud(t,0,r)}return s.match&&0===r.length?new nd(e.segments,{}):s.match&&!e.hasChildren()?Gd(e,t,n):s.match?Ud(e,0,r):Gd(e,t,n)}function Ud(e,t,n){if(0===n.length)return new nd(e.segments,{});{const s=function(e){return Ld(e[0])?e[0].outlets:{[Mc]:e}}(n),r={};return Hc(s,(n,s)=>{"string"==typeof n&&(n=[n]),null!==n&&(r[s]=Wd(e.children[s],t,n))}),Hc(e.children,(e,t)=>{void 0===s[t]&&(r[t]=e)}),new nd(e.segments,r)}}function Gd(e,t,n){const s=e.segments.slice(0,t);let r=0;for(;r<n.length;){const a=n[r];if(Ld(a)){const e=Hd(a.outlets);return new nd(s,e)}if(0===r&&Md(n[0])){s.push(new sd(e.segments[t].path,Kd(n[0]))),r++;continue}const o=Ld(a)?a.outlets.primary:`${a}`,i=r<n.length-1?n[r+1]:null;o&&i&&Md(i)?(s.push(new sd(o,Kd(i))),r+=2):(s.push(new sd(o,{})),r++)}return new nd(s,{})}function Hd(e){const t={};return Hc(e,(e,n)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[n]=Gd(new nd([],{}),0,e))}),t}function Kd(e){const t={};return Hc(e,(e,n)=>t[n]=`${e}`),t}function Xd(e,t,n){return e==n.path&&Bc(t,n.parameters)}class Zd{constructor(e,t,n,s){this.routeReuseStrategy=e,this.futureState=t,this.currState=n,this.forwardEvent=s}activate(e){const t=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,n,e),Dd(this.futureState.root),this.activateChildRoutes(t,n,e)}deactivateChildRoutes(e,t,n){const s=_d(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,s[t],n),delete s[t]}),Hc(s,(e,t)=>{this.deactivateRouteAndItsChildren(e,n)})}deactivateRoutes(e,t,n){const s=e.value,r=t?t.value:null;if(s===r)if(s.component){const r=n.getContext(s.outlet);r&&this.deactivateChildRoutes(e,t,r.children)}else this.deactivateChildRoutes(e,t,n);else r&&this.deactivateRouteAndItsChildren(t,n)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const n=t.getContext(e.value.outlet);if(n&&n.outlet){const t=n.outlet.detach(),s=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:s})}}deactivateRouteAndOutlet(e,t){const n=t.getContext(e.value.outlet),s=n&&e.value.component?n.children:t,r=_d(e);for(const a of Object.keys(r))this.deactivateRouteAndItsChildren(r[a],s);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(e,t,n){const s=_d(t);e.children.forEach(e=>{this.activateRoutes(e,s[e.value.outlet],n),this.forwardEvent(new qc(e.value.snapshot))}),e.children.length&&this.forwardEvent(new Dc(e.value.snapshot))}activateRoutes(e,t,n){const s=e.value,r=t?t.value:null;if(Dd(s),s===r)if(s.component){const r=n.getOrCreateContext(s.outlet);this.activateChildRoutes(e,t,r.children)}else this.activateChildRoutes(e,t,n);else if(s.component){const t=n.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const e=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),Yd(e.route)}else{const n=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(s.snapshot),r=n?n.module.componentFactoryResolver:null;t.attachRef=null,t.route=s,t.resolver=r,t.outlet&&t.outlet.activateWith(s,r),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,n)}}function Yd(e){Dd(e.value),e.children.forEach(Yd)}class Qd{constructor(e,t){this.routes=e,this.module=t}}function Jd(e){return"function"==typeof e}function ep(e){return e instanceof td}const tp=Symbol("INITIAL_VALUE");function np(){return Vl(e=>function(...e){let t,n;return $(e[e.length-1])&&(n=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&p(e[0])&&(e=e[0]),K(e,n).lift(new Dl(t))}(e.map(e=>e.pipe(Ul(1),function(...e){const t=e[e.length-1];return $(t)?(e.pop(),n=>zl(e,n,t)):t=>zl(e,t)}(tp)))).pipe(Kl((e,t)=>{let n=!1;return t.reduce((e,s,r)=>{if(e!==tp)return e;if(s===tp&&(n=!0),!n){if(!1===s)return s;if(r===t.length-1||ep(s))return s}return e},e)},tp),Yl(e=>e!==tp),T(e=>ep(e)?e:!0===e),Ul(1)))}let sp=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=Ue({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&Ia(0,"router-outlet")},directives:function(){return[Yp]},encapsulation:2}),e})();function rp(e,t=""){for(let n=0;n<e.length;n++){const s=e[n];ap(s,op(t,s))}}function ap(e,t){e.children&&rp(e.children,t)}function op(e,t){return t?e||t.path?e&&!t.path?`${e}/`:!e&&t.path?t.path:`${e}/${t.path}`:"":e}function ip(e){const t=e.children&&e.children.map(ip),n=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!n.component&&(t||n.loadChildren)&&n.outlet&&n.outlet!==Mc&&(n.component=sp),n}function up(e){return e.outlet||Mc}function lp(e,t){const n=e.filter(e=>up(e)===t);return n.push(...e.filter(e=>up(e)!==t)),n}const cp={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function dp(e,t,n){var s;if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?Object.assign({},cp):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const r=(t.matcher||jc)(n,e,t);if(!r)return Object.assign({},cp);const a={};Hc(r.posParams,(e,t)=>{a[t]=e.path});const o=r.consumed.length>0?Object.assign(Object.assign({},a),r.consumed[r.consumed.length-1].parameters):a;return{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:o,positionalParamSegments:null!==(s=r.posParams)&&void 0!==s?s:{}}}function pp(e,t,n,s,r="corrected"){if(n.length>0&&function(e,t,n){return n.some(n=>hp(e,t,n)&&up(n)!==Mc)}(e,n,s)){const r=new nd(t,function(e,t,n,s){const r={};r.primary=s,s._sourceSegment=e,s._segmentIndexShift=t.length;for(const a of n)if(""===a.path&&up(a)!==Mc){const n=new nd([],{});n._sourceSegment=e,n._segmentIndexShift=t.length,r[up(a)]=n}return r}(e,t,s,new nd(n,e.children)));return r._sourceSegment=e,r._segmentIndexShift=t.length,{segmentGroup:r,slicedSegments:[]}}if(0===n.length&&function(e,t,n){return n.some(n=>hp(e,t,n))}(e,n,s)){const a=new nd(e.segments,function(e,t,n,s,r,a){const o={};for(const i of s)if(hp(e,n,i)&&!r[up(i)]){const n=new nd([],{});n._sourceSegment=e,n._segmentIndexShift="legacy"===a?e.segments.length:t.length,o[up(i)]=n}return Object.assign(Object.assign({},r),o)}(e,t,n,s,e.children,r));return a._sourceSegment=e,a._segmentIndexShift=t.length,{segmentGroup:a,slicedSegments:n}}const a=new nd(e.segments,e.children);return a._sourceSegment=e,a._segmentIndexShift=t.length,{segmentGroup:a,slicedSegments:n}}function hp(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path}function fp(e,t,n,s){return!!(up(e)===s||s!==Mc&&hp(t,n,e))&&("**"===e.path||dp(t,e,n).matched)}function mp(e,t,n){return 0===t.length&&!e.children[n]}class gp{constructor(e){this.segmentGroup=e||null}}class bp{constructor(e){this.urlTree=e}}function yp(e){return new k(t=>t.error(new gp(e)))}function vp(e){return new k(t=>t.error(new bp(e)))}function xp(e){return new k(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class wp{constructor(e,t,n,s,r){this.configLoader=t,this.urlSerializer=n,this.urlTree=s,this.config=r,this.allowRedirects=!0,this.ngModule=e.get(Wo)}apply(){const e=pp(this.urlTree.root,[],[],this.config).segmentGroup,t=new nd(e.segments,e.children);return this.expandSegmentGroup(this.ngModule,this.config,t,Mc).pipe(T(e=>this.createUrlTree(kp(e),this.urlTree.queryParams,this.urlTree.fragment))).pipe(ec(e=>{if(e instanceof bp)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof gp)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,Mc).pipe(T(t=>this.createUrlTree(kp(t),e.queryParams,e.fragment))).pipe(ec(e=>{if(e instanceof gp)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,n){const s=e.segments.length>0?new nd([],{[Mc]:e}):e;return new td(s,t,n)}expandSegmentGroup(e,t,n,s){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(e,t,n).pipe(T(e=>new nd([],e))):this.expandSegment(e,n,t,n.segments,s,!0)}expandChildren(e,t,n){const s=[];for(const r of Object.keys(n.children))"primary"===r?s.unshift(r):s.push(r);return P(s).pipe(sc(s=>{const r=n.children[s],a=lp(t,s);return this.expandSegmentGroup(e,a,r,s).pipe(T(e=>({segment:e,outlet:s})))}),Kl((e,t)=>(e[t.outlet]=t.segment,e),{}),function(e,t){const n=arguments.length>=2;return s=>s.pipe(e?Yl((t,n)=>e(t,n,s)):w,rc(1),n?dc(t):ic(()=>new ql))}())}expandSegment(e,t,n,s,r,a){return P(n).pipe(sc(o=>this.expandSegmentAgainstRoute(e,t,n,o,s,r,a).pipe(ec(e=>{if(e instanceof gp)return Nl(null);throw e}))),fc(e=>!!e),ec((e,n)=>{if(e instanceof ql||"EmptyError"===e.name){if(mp(t,s,r))return Nl(new nd([],{}));throw new gp(t)}throw e}))}expandSegmentAgainstRoute(e,t,n,s,r,a,o){return fp(s,t,r,a)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(e,t,s,r,a):o&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a):yp(t):yp(t)}expandSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,s,a):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,n,s){const r=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?vp(r):this.lineralizeSegments(n,r).pipe(W(n=>{const r=new nd(n,{});return this.expandSegment(e,r,t,n,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,s,r,a){const{matched:o,consumedSegments:i,lastChild:u,positionalParamSegments:l}=dp(t,s,r);if(!o)return yp(t);const c=this.applyRedirectCommands(i,s.redirectTo,l);return s.redirectTo.startsWith("/")?vp(c):this.lineralizeSegments(s,c).pipe(W(s=>this.expandSegment(e,t,n,s.concat(r.slice(u)),a,!1)))}matchSegmentAgainstRoute(e,t,n,s,r){if("**"===n.path)return n.loadChildren?(n._loadedConfig?Nl(n._loadedConfig):this.configLoader.load(e.injector,n)).pipe(T(e=>(n._loadedConfig=e,new nd(s,{})))):Nl(new nd(s,{}));const{matched:a,consumedSegments:o,lastChild:i}=dp(t,n,s);if(!a)return yp(t);const u=s.slice(i);return this.getChildConfig(e,n,s).pipe(W(e=>{const s=e.module,a=e.routes,{segmentGroup:i,slicedSegments:l}=pp(t,o,u,a),c=new nd(i.segments,i.children);if(0===l.length&&c.hasChildren())return this.expandChildren(s,a,c).pipe(T(e=>new nd(o,e)));if(0===a.length&&0===l.length)return Nl(new nd(o,{}));const d=up(n)===r;return this.expandSegment(s,c,a,l,d?Mc:r,!0).pipe(T(e=>new nd(o.concat(e.segments),e.children)))}))}getChildConfig(e,t,n){return t.children?Nl(new Qd(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?Nl(t._loadedConfig):this.runCanLoadGuards(e.injector,t,n).pipe(W(n=>n?this.configLoader.load(e.injector,t).pipe(T(e=>(t._loadedConfig=e,e))):function(e){return new k(t=>t.error(Vc(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):Nl(new Qd([],e))}runCanLoadGuards(e,t,n){const s=t.canLoad;return s&&0!==s.length?Nl(s.map(s=>{const r=e.get(s);let a;if(function(e){return e&&Jd(e.canLoad)}(r))a=r.canLoad(t,n);else{if(!Jd(r))throw new Error("Invalid CanLoad guard");a=r(t,n)}return Kc(a)})).pipe(np(),gc(e=>{if(!ep(e))return;const t=Vc(`Redirecting to "${this.urlSerializer.serialize(e)}"`);throw t.url=e,t}),T(e=>!0===e)):Nl(!0)}lineralizeSegments(e,t){let n=[],s=t.root;for(;;){if(n=n.concat(s.segments),0===s.numberOfChildren)return Nl(n);if(s.numberOfChildren>1||!s.children.primary)return xp(e.redirectTo);s=s.children.primary}}applyRedirectCommands(e,t,n){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,n)}applyRedirectCreatreUrlTree(e,t,n,s){const r=this.createSegmentGroup(e,t.root,n,s);return new td(r,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const n={};return Hc(e,(e,s)=>{if("string"==typeof e&&e.startsWith(":")){const r=e.substring(1);n[s]=t[r]}else n[s]=e}),n}createSegmentGroup(e,t,n,s){const r=this.createSegments(e,t.segments,n,s);let a={};return Hc(t.children,(t,r)=>{a[r]=this.createSegmentGroup(e,t,n,s)}),new nd(r,a)}createSegments(e,t,n,s){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,s):this.findOrReturn(t,n))}findPosParam(e,t,n){const s=n[t.path.substring(1)];if(!s)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return s}findOrReturn(e,t){let n=0;for(const s of t){if(s.path===e.path)return t.splice(n),s;n++}return e}}function kp(e){const t={};for(const n of Object.keys(e.children)){const s=kp(e.children[n]);(s.segments.length>0||s.hasChildren())&&(t[n]=s)}return function(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new nd(e.segments.concat(t.segments),t.children)}return e}(new nd(e.segments,t))}class Cp{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class Ip{constructor(e,t){this.component=e,this.route=t}}function _p(e,t,n){const s=e._root;return Ep(s,t?t._root:null,n,[s.value])}function Sp(e,t,n){const s=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(s?s.module.injector:n).get(e)}function Ep(e,t,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const a=_d(t);return e.children.forEach(e=>{!function(e,t,n,s,r={canDeactivateChecks:[],canActivateChecks:[]}){const a=e.value,o=t?t.value:null,i=n?n.getContext(e.value.outlet):null;if(o&&a.routeConfig===o.routeConfig){const u=function(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!rd(e.url,t.url);case"pathParamsOrQueryParamsChange":return!rd(e.url,t.url)||!Bc(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Od(e,t)||!Bc(e.queryParams,t.queryParams);case"paramsChange":default:return!Od(e,t)}}(o,a,a.routeConfig.runGuardsAndResolvers);u?r.canActivateChecks.push(new Cp(s)):(a.data=o.data,a._resolvedData=o._resolvedData),Ep(e,t,a.component?i?i.children:null:n,s,r),u&&i&&i.outlet&&i.outlet.isActivated&&r.canDeactivateChecks.push(new Ip(i.outlet.component,o))}else o&&Np(t,i,r),r.canActivateChecks.push(new Cp(s)),Ep(e,null,a.component?i?i.children:null:n,s,r)}(e,a[e.value.outlet],n,s.concat([e.value]),r),delete a[e.value.outlet]}),Hc(a,(e,t)=>Np(e,n.getContext(t),r)),r}function Np(e,t,n){const s=_d(e),r=e.value;Hc(s,(e,s)=>{Np(e,r.component?t?t.children.getContext(s):null:t,n)}),n.canDeactivateChecks.push(new Ip(r.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,r))}class $p{}function Tp(e){return new k(t=>t.error(e))}class Ap{constructor(e,t,n,s,r,a){this.rootComponentType=e,this.config=t,this.urlTree=n,this.url=s,this.paramsInheritanceStrategy=r,this.relativeLinkResolution=a}recognize(){const e=pp(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,Mc);if(null===t)return null;const n=new Td([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Mc,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new Id(n,t),r=new Ad(this.url,s);return this.inheritParamsAndData(r._root),r}inheritParamsAndData(e){const t=e.value,n=$d(t,this.paramsInheritanceStrategy);t.params=Object.freeze(n.params),t.data=Object.freeze(n.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,n){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,n)}processChildren(e,t){const n=[];for(const r of Object.keys(t.children)){const s=t.children[r],a=lp(e,r),o=this.processSegmentGroup(a,s,r);if(null===o)return null;n.push(...o)}const s=Fp(n);return s.sort((e,t)=>e.value.outlet===Mc?-1:t.value.outlet===Mc?1:e.value.outlet.localeCompare(t.value.outlet)),s}processSegment(e,t,n,s){for(const r of e){const e=this.processSegmentAgainstRoute(r,t,n,s);if(null!==e)return e}return mp(t,n,s)?[]:null}processSegmentAgainstRoute(e,t,n,s){if(e.redirectTo||!fp(e,t,n,s))return null;let r,a=[],o=[];if("**"===e.path){const s=n.length>0?Gc(n).parameters:{};r=new Td(n,s,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,qp(e),up(e),e.component,e,Dp(t),Op(t)+n.length,zp(e))}else{const s=dp(t,e,n);if(!s.matched)return null;a=s.consumedSegments,o=n.slice(s.lastChild),r=new Td(a,s.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,qp(e),up(e),e.component,e,Dp(t),Op(t)+a.length,zp(e))}const i=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:u,slicedSegments:l}=pp(t,a,o,i.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution);if(0===l.length&&u.hasChildren()){const e=this.processChildren(i,u);return null===e?null:[new Id(r,e)]}if(0===i.length&&0===l.length)return[new Id(r,[])];const c=up(e)===s,d=this.processSegment(i,u,l,c?Mc:s);return null===d?null:[new Id(r,d)]}}function Rp(e){const t=e.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function Fp(e){const t=[],n=new Set;for(const s of e){if(!Rp(s)){t.push(s);continue}const e=t.find(e=>s.value.routeConfig===e.value.routeConfig);void 0!==e?(e.children.push(...s.children),n.add(e)):t.push(s)}for(const s of n){const e=Fp(s.children);t.push(new Id(s.value,e))}return t.filter(e=>!n.has(e))}function Dp(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function Op(e){let t=e,n=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,n+=t._segmentIndexShift?t._segmentIndexShift:0;return n-1}function qp(e){return e.data||{}}function zp(e){return e.resolve||{}}function Mp(e){return Vl(t=>{const n=e(t);return n?P(n).pipe(T(()=>t)):Nl(t)})}class Lp extends class{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}{}const Pp=new Ln("ROUTES");class Vp{constructor(e,t,n,s){this.loader=e,this.compiler=t,this.onLoadStartListener=n,this.onLoadEndListener=s}load(e,t){if(t._loader$)return t._loader$;this.onLoadStartListener&&this.onLoadStartListener(t);const n=this.loadModuleFactory(t.loadChildren).pipe(T(n=>{this.onLoadEndListener&&this.onLoadEndListener(t);const s=n.create(e);return new Qd(Uc(s.injector.get(Pp,void 0,Ce.Self|Ce.Optional)).map(ip),s)}),ec(e=>{throw t._loader$=void 0,e}));return t._loader$=new Q(n,()=>new E).pipe(X()),t._loader$}loadModuleFactory(e){return"string"==typeof e?P(this.loader.load(e)):Kc(e()).pipe(W(e=>e instanceof Uo?Nl(e):P(this.compiler.compileModuleAsync(e))))}}class jp{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new Bp,this.attachRef=null}}class Bp{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const n=this.getOrCreateContext(e);n.outlet=t,this.contexts.set(e,n)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new jp,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}class Wp{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function Up(e){throw e}function Gp(e,t,n){return t.parse("/")}function Hp(e,t){return Nl(null)}const Kp={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Xp={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Zp=(()=>{class e{constructor(e,t,n,s,r,a,o,i){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=n,this.location=s,this.config=i,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new E,this.errorHandler=Up,this.malformedUriErrorHandler=Gp,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Hp,afterPreactivation:Hp},this.urlHandlingStrategy=new Wp,this.routeReuseStrategy=new Lp,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=r.get(Wo),this.console=r.get(Ri);const u=r.get(Ui);this.isNgZoneEnabled=u instanceof Ui&&Ui.isInAngularZone(),this.resetConfig(i),this.currentUrlTree=new td(new nd([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new Vp(a,o,e=>this.triggerEvent(new Ac(e)),e=>this.triggerEvent(new Rc(e))),this.routerState=Ed(this.currentUrlTree,this.rootComponentType),this.transitions=new $l({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(Yl(e=>0!==e.id),T(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),Vl(e=>{let n=!1,s=!1;return Nl(e).pipe(gc(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Vl(e=>{const n=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return Nl(e).pipe(Vl(e=>{const n=this.transitions.getValue();return t.next(new kc(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),n!==this.transitions.getValue()?Ml:Promise.resolve(e)}),function(e,t,n,s){return Vl(r=>function(e,t,n,s,r){return new wp(e,t,n,s,r).apply()}(e,t,n,r.extractedUrl,s).pipe(T(e=>Object.assign(Object.assign({},r),{urlAfterRedirects:e}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),gc(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,n,s,r){return W(a=>function(e,t,n,s,r="emptyOnly",a="legacy"){try{const o=new Ap(e,t,n,s,r,a).recognize();return null===o?Tp(new $p):Nl(o)}catch(o){return Tp(o)}}(e,t,a.urlAfterRedirects,n(a.urlAfterRedirects),s,r).pipe(T(e=>Object.assign(Object.assign({},a),{targetSnapshot:e}))))}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),gc(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,e),this.browserUrlTree=e.urlAfterRedirects);const n=new Sc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:s,source:r,restoredState:a,extras:o}=e,i=new kc(n,this.serializeUrl(s),r,a);t.next(i);const u=Ed(s,this.rootComponentType).snapshot;return Nl(Object.assign(Object.assign({},e),{targetSnapshot:u,urlAfterRedirects:s,extras:Object.assign(Object.assign({},o),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),Ml}),Mp(e=>{const{targetSnapshot:t,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:a,replaceUrl:o}}=e;return this.hooks.beforePreactivation(t,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!a,replaceUrl:!!o})}),gc(e=>{const t=new Ec(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),T(e=>Object.assign(Object.assign({},e),{guards:_p(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return W(n=>{const{targetSnapshot:s,currentSnapshot:r,guards:{canActivateChecks:a,canDeactivateChecks:o}}=n;return 0===o.length&&0===a.length?Nl(Object.assign(Object.assign({},n),{guardsResult:!0})):function(e,t,n,s){return P(e).pipe(W(e=>function(e,t,n,s,r){const a=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return a&&0!==a.length?Nl(a.map(a=>{const o=Sp(a,t,r);let i;if(function(e){return e&&Jd(e.canDeactivate)}(o))i=Kc(o.canDeactivate(e,t,n,s));else{if(!Jd(o))throw new Error("Invalid CanDeactivate guard");i=Kc(o(e,t,n,s))}return i.pipe(fc())})).pipe(np()):Nl(!0)}(e.component,e.route,n,t,s)),fc(e=>!0!==e,!0))}(o,s,r,e).pipe(W(n=>n&&"boolean"==typeof n?function(e,t,n,s){return P(t).pipe(sc(t=>zl(function(e,t){return null!==e&&t&&t(new Fc(e)),Nl(!0)}(t.route.parent,s),function(e,t){return null!==e&&t&&t(new Oc(e)),Nl(!0)}(t.route,s),function(e,t,n){const s=t[t.length-1],r=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>Pl(()=>Nl(t.guards.map(r=>{const a=Sp(r,t.node,n);let o;if(function(e){return e&&Jd(e.canActivateChild)}(a))o=Kc(a.canActivateChild(s,e));else{if(!Jd(a))throw new Error("Invalid CanActivateChild guard");o=Kc(a(s,e))}return o.pipe(fc())})).pipe(np())));return Nl(r).pipe(np())}(e,t.path,n),function(e,t,n){const s=t.routeConfig?t.routeConfig.canActivate:null;return s&&0!==s.length?Nl(s.map(s=>Pl(()=>{const r=Sp(s,t,n);let a;if(function(e){return e&&Jd(e.canActivate)}(r))a=Kc(r.canActivate(t,e));else{if(!Jd(r))throw new Error("Invalid CanActivate guard");a=Kc(r(t,e))}return a.pipe(fc())}))).pipe(np()):Nl(!0)}(e,t.route,n))),fc(e=>!0!==e,!0))}(s,a,e,t):Nl(n)),T(e=>Object.assign(Object.assign({},n),{guardsResult:e})))})}(this.ngModule.injector,e=>this.triggerEvent(e)),gc(e=>{if(ep(e.guardsResult)){const t=Vc(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}const t=new Nc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),Yl(e=>!!e.guardsResult||(this.cancelNavigationTransition(e,""),!1)),Mp(e=>{if(e.guards.canActivateChecks.length)return Nl(e).pipe(gc(e=>{const t=new $c(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),Vl(e=>{let t=!1;return Nl(e).pipe((n=this.paramsInheritanceStrategy,s=this.ngModule.injector,W(e=>{const{targetSnapshot:t,guards:{canActivateChecks:r}}=e;if(!r.length)return Nl(e);let a=0;return P(r).pipe(sc(e=>function(e,t,n,s){return function(e,t,n,s){const r=Object.keys(e);if(0===r.length)return Nl({});const a={};return P(r).pipe(W(r=>function(e,t,n,s){const r=Sp(e,t,s);return Kc(r.resolve?r.resolve(t,n):r(t,n))}(e[r],t,n,s).pipe(gc(e=>{a[r]=e}))),rc(1),W(()=>Object.keys(a).length===r.length?Nl(a):Ml))}(e._resolve,e,t,s).pipe(T(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),$d(e,n).resolve),null)))}(e.route,t,n,s)),gc(()=>a++),rc(1),W(t=>a===r.length?Nl(e):Ml))})),gc({next:()=>t=!0,complete:()=>{t||this.cancelNavigationTransition(e,"At least one route resolver didn't emit any value.")}}));var n,s}),gc(e=>{const t=new Tc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}))}),Mp(e=>{const{targetSnapshot:t,id:n,extractedUrl:s,rawUrl:r,extras:{skipLocationChange:a,replaceUrl:o}}=e;return this.hooks.afterPreactivation(t,{navigationId:n,appliedUrlTree:s,rawUrlTree:r,skipLocationChange:!!a,replaceUrl:!!o})}),T(e=>{const t=function(e,t,n){const s=qd(e,t._root,n?n._root:void 0);return new Sd(s,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),gc(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,e),this.browserUrlTree=e.urlAfterRedirects)}),(a=this.rootContexts,o=this.routeReuseStrategy,i=e=>this.triggerEvent(e),T(e=>(new Zd(o,e.targetRouterState,e.currentRouterState,i).activate(a),e))),gc({next(){n=!0},complete(){n=!0}}),(r=()=>{n||s||this.cancelNavigationTransition(e,`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`),this.currentNavigation=null},e=>e.lift(new vc(r))),ec(n=>{if(s=!0,(r=n)&&r.ngNavigationCancelingError){const s=ep(n.url);s||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const r=new Ic(e.id,this.serializeUrl(e.extractedUrl),n.message);t.next(r),s?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const s=new _c(e.id,this.serializeUrl(e.extractedUrl),n);t.next(s);try{e.resolve(this.errorHandler(n))}catch(a){e.reject(a)}}var r;return Ml}));var r,a,o,i}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const t=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,t)&&setTimeout(()=>{const{source:e,state:n,urlTree:s}=t,r={replaceUrl:!0};if(n){const e=Object.assign({},n);delete e.navigationId,delete e.\u0275routerPageId,0!==Object.keys(e).length&&(r.state=e)}this.scheduleNavigation(s,e,n,r)},0),this.lastLocationChangeInfo=t}))}extractLocationChangeInfoFromEvent(e){var t;return{source:"popstate"===e.type?"popstate":"hashchange",urlTree:this.parseUrl(e.url),state:(null===(t=e.state)||void 0===t?void 0:t.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,t){if(!e)return!0;const n=t.urlTree.toString()===e.urlTree.toString();return!(t.transitionId===e.transitionId&&n&&("hashchange"===t.source&&"popstate"===e.source||"popstate"===t.source&&"hashchange"===e.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){rp(e),this.config=e.map(ip),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,t={}){const{relativeTo:n,queryParams:s,fragment:r,queryParamsHandling:a,preserveFragment:o}=t,i=n||this.routerState.root,u=o?this.currentUrlTree.fragment:r;let l=null;switch(a){case"merge":l=Object.assign(Object.assign({},this.currentUrlTree.queryParams),s);break;case"preserve":l=this.currentUrlTree.queryParams;break;default:l=s||null}return null!==l&&(l=this.removeEmptyProps(l)),function(e,t,n,s,r){if(0===n.length)return Pd(t.root,t.root,t,s,r);const a=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new jd(!0,0,e);let t=0,n=!1;const s=e.reduce((e,s,r)=>{if("object"==typeof s&&null!=s){if(s.outlets){const t={};return Hc(s.outlets,(e,n)=>{t[n]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(s.segmentPath)return[...e,s.segmentPath]}return"string"!=typeof s?[...e,s]:0===r?(s.split("/").forEach((s,r)=>{0==r&&"."===s||(0==r&&""===s?n=!0:".."===s?t++:""!=s&&e.push(s))}),e):[...e,s]},[]);return new jd(n,t,s)}(n);if(a.toRoot())return Pd(t.root,new nd([],{}),t,s,r);const o=function(e,t,n){if(e.isAbsolute)return new Bd(t.root,!0,0);if(-1===n.snapshot._lastPathIndex){const e=n.snapshot._urlSegment;return new Bd(e,e===t.root,0)}const s=Md(e.commands[0])?0:1;return function(e,t,n){let s=e,r=t,a=n;for(;a>r;){if(a-=r,s=s.parent,!s)throw new Error("Invalid number of '../'");r=s.segments.length}return new Bd(s,!1,r-a)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+s,e.numberOfDoubleDots)}(a,t,e),i=o.processChildren?Ud(o.segmentGroup,o.index,a.commands):Wd(o.segmentGroup,o.index,a.commands);return Pd(o.segmentGroup,i,t,s,r)}(i,this.currentUrlTree,e,l,null!=u?u:null)}navigateByUrl(e,t={skipLocationChange:!1}){const n=ep(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(n,this.rawUrlTree);let r=null;return"computed"===this.canceledNavigationResolution&&(0===this.currentPageId||t.skipLocationChange||t.replaceUrl)&&(r=this.location.getState()),this.scheduleNavigation(s,"imperative",r,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const n=e[t];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(n){t=this.malformedUriErrorHandler(n,this.urlSerializer,e)}return t}isActive(e,t){let n;if(n=!0===t?Object.assign({},Kp):!1===t?Object.assign({},Xp):t,ep(e))return Yc(this.currentUrlTree,e,n);const s=this.parseUrl(e);return Yc(this.currentUrlTree,s,n)}removeEmptyProps(e){return Object.keys(e).reduce((t,n)=>{const s=e[n];return null!=s&&(t[n]=s),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new Cc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,n,s,r){if(this.disposed)return Promise.resolve(!1);const a=this.getTransition(),o="imperative"!==t&&"imperative"===(null==a?void 0:a.source),i=(this.lastSuccessfulId===a.id||this.currentNavigation?a.rawUrl:a.urlAfterRedirects).toString()===e.toString();if(o&&i)return Promise.resolve(!0);let u,l,c;r?(u=r.resolve,l=r.reject,c=r.promise):c=new Promise((e,t)=>{u=e,l=t});const d=++this.navigationId;let p;return p="computed"===this.canceledNavigationResolution?n&&n.\u0275routerPageId?n.\u0275routerPageId:this.currentPageId+1:0,this.setTransition({id:d,targetPageId:p,source:t,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:s,resolve:u,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(e=>Promise.reject(e))}setBrowserUrl(e,t){const n=this.urlSerializer.serialize(e),s=Object.assign(Object.assign({},t.extras.state),this.generateNgRouterState(t.id,t.targetPageId));this.location.isCurrentPathEqualTo(n)||t.extras.replaceUrl?this.location.replaceState(n,"",s):this.location.go(n,"",s)}resetStateAndUrl(e,t,n){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,t){"computed"===this.canceledNavigationResolution?"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy||this.location.historyGo(this.currentPageId-e.targetPageId):this.resetUrlToCurrentUrlTree();const n=new Ic(e.id,this.serializeUrl(e.extractedUrl),t);this.triggerEvent(n),e.resolve(!1)}generateNgRouterState(e,t){return"computed"===this.canceledNavigationResolution?{navigationId:e,"\u0275routerPageId":t}:{navigationId:e}}}return e.\u0275fac=function(t){return new(t||e)(ns(Vn),ns(ad),ns(Bp),ns(Mu),ns(ia),ns(hu),ns(ji),ns(void 0))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),Yp=(()=>{class e{constructor(e,t,n,s,r){this.parentContexts=e,this.location=t,this.resolver=n,this.changeDetector=r,this.activated=null,this._activatedRoute=null,this.activateEvents=new ci,this.deactivateEvents=new ci,this.name=s||Mc,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const n=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),s=this.parentContexts.getOrCreateContext(this.name).children,r=new Qp(e,s,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,r),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(va(Bp),va(Ho),va(ro),("name",function(e,t){const n=e.attrs;if(n){const e=n.length;let s=0;for(;s<e;){const r=n[s];if(ln(r))break;if(0===r)s+=2;else if("number"==typeof r)for(s++;s<e&&"string"==typeof n[s];)s++;else{if(r===t)return n[s+1];s+=2}}}return null}(Rt(),"name")),va(Oo))},e.\u0275dir=Ye({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class Qp{constructor(e,t,n){this.route=e,this.childContexts=t,this.parent=n}get(e,t){return e===Nd?this.route:e===Bp?this.childContexts:this.parent.get(e,t)}}class Jp{}class eh{preload(e,t){return Nl(null)}}let th=(()=>{class e{constructor(e,t,n,s,r){this.router=e,this.injector=s,this.preloadingStrategy=r,this.loader=new Vp(t,n,t=>e.triggerEvent(new Ac(t)),t=>e.triggerEvent(new Rc(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(Yl(e=>e instanceof Cc),sc(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(Wo);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,t){const n=[];for(const s of t)if(s.loadChildren&&!s.canLoad&&s._loadedConfig){const e=s._loadedConfig;n.push(this.processRoutes(e.module,e.routes))}else s.loadChildren&&!s.canLoad?n.push(this.preloadConfig(e,s)):s.children&&n.push(this.processRoutes(e,s.children));return P(n).pipe(H(),T(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>(t._loadedConfig?Nl(t._loadedConfig):this.loader.load(e.injector,t)).pipe(W(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(ns(Zp),ns(hu),ns(ji),ns(ia),ns(Jp))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})(),nh=(()=>{class e{constructor(e,t,n={}){this.router=e,this.viewportScroller=t,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof kc?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Cc&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof zc&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new zc(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(t){return new(t||e)(ns(Zp),ns(Xu),ns(void 0))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();const sh=new Ln("ROUTER_CONFIGURATION"),rh=new Ln("ROUTER_FORROOT_GUARD"),ah=[Mu,{provide:ad,useClass:od},{provide:Zp,useFactory:function(e,t,n,s,r,a,o,i={},u,l){const c=new Zp(null,e,t,n,s,r,a,Uc(o));return u&&(c.urlHandlingStrategy=u),l&&(c.routeReuseStrategy=l),function(e,t){e.errorHandler&&(t.errorHandler=e.errorHandler),e.malformedUriErrorHandler&&(t.malformedUriErrorHandler=e.malformedUriErrorHandler),e.onSameUrlNavigation&&(t.onSameUrlNavigation=e.onSameUrlNavigation),e.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=e.paramsInheritanceStrategy),e.relativeLinkResolution&&(t.relativeLinkResolution=e.relativeLinkResolution),e.urlUpdateStrategy&&(t.urlUpdateStrategy=e.urlUpdateStrategy)}(i,c),i.enableTracing&&c.events.subscribe(e=>{var t,n;null===(t=console.group)||void 0===t||t.call(console,`Router Event: ${e.constructor.name}`),console.log(e.toString()),console.log(e),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[ad,Bp,Mu,ia,hu,ji,Pp,sh,[class{},new os],[class{},new os]]},Bp,{provide:Nd,useFactory:function(e){return e.routerState.root},deps:[Zp]},{provide:hu,useClass:gu},th,eh,class{preload(e,t){return t().pipe(ec(()=>Nl(null)))}},{provide:sh,useValue:{enableTracing:!1}}];function oh(){return new ou("Router",Zp)}let ih=(()=>{class e{constructor(e,t){}static forRoot(t,n){return{ngModule:e,providers:[ah,dh(t),{provide:rh,useFactory:ch,deps:[[Zp,new os,new is]]},{provide:sh,useValue:n||{}},{provide:Fu,useFactory:lh,deps:[Iu,[new as(Ou),new os],sh]},{provide:nh,useFactory:uh,deps:[Zp,Xu,sh]},{provide:Jp,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:eh},{provide:ou,multi:!0,useFactory:oh},[ph,{provide:Ii,multi:!0,useFactory:hh,deps:[ph]},{provide:mh,useFactory:fh,deps:[ph]},{provide:Ai,multi:!0,useExisting:mh}]]}}static forChild(t){return{ngModule:e,providers:[dh(t)]}}}return e.\u0275fac=function(t){return new(t||e)(ns(rh,8),ns(Zp,8))},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({}),e})();function uh(e,t,n){return n.scrollOffset&&t.setOffset(n.scrollOffset),new nh(e,t,n)}function lh(e,t,n={}){return n.useHash?new zu(e,t):new qu(e,t)}function ch(e){return"guarded"}function dh(e){return[{provide:Pn,multi:!0,useValue:e},{provide:Pp,multi:!0,useValue:e}]}let ph=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.resultOfPreactivationDone=new E}appInitializer(){return this.injector.get(Su,Promise.resolve(null)).then(()=>{let e=null;const t=new Promise(t=>e=t),n=this.injector.get(Zp),s=this.injector.get(sh);return"disabled"===s.initialNavigation?(n.setUpLocationChangeListener(),e(!0)):"enabled"===s.initialNavigation||"enabledBlocking"===s.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?Nl(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),n.initialNavigation()):e(!0),t})}bootstrapListener(e){const t=this.injector.get(sh),n=this.injector.get(th),s=this.injector.get(nh),r=this.injector.get(Zp),a=this.injector.get(du);e===a.components[0]&&("enabledNonBlocking"!==t.initialNavigation&&void 0!==t.initialNavigation||r.initialNavigation(),n.setUpPreloading(),s.init(),r.resetRootComponentType(a.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return e.\u0275fac=function(t){return new(t||e)(ns(ia))},e.\u0275prov=fe({token:e,factory:e.\u0275fac}),e})();function hh(e){return e.appInitializer.bind(e)}function fh(e){return e.bootstrapListener.bind(e)}const mh=new Ln("Router Initializer");function gh(e,t,n,s,r,a,o){try{var i=e[a](o),u=i.value}catch(l){return void n(l)}i.done?t(u):Promise.resolve(u).then(s,r)}function bh(e){return function(){var t=this,n=arguments;return new Promise(function(s,r){var a=e.apply(t,n);function o(e){gh(a,s,r,o,i,"next",e)}function i(e){gh(a,s,r,o,i,"throw",e)}o(void 0)})}}class yh{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class vh{refCount(e){return xh("refCount")}incRef(e){return xh("incRef")}timerAvailable(){return!0}time(e){return xh("time")}read(e){return xh("read")}readSync(e){return xh("readSync")}numDataIds(){return xh("numDataIds")}disposeData(e,t){return xh("disposeData")}write(e,t,n){return xh("write")}move(e,t,n,s,r){return xh("move")}memory(){return xh("memory")}floatPrecision(){return xh("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return xh("dispose")}}function xh(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function wh(e){let t=e.length,n=0,s=0;for(;t>0;)s=Math.random()*t|0,t--,n=e[t],e[t]=e[s],e[s]=n}function kh(e,t,n){return Math.max(e,Math.min(t,n))}function Ch(e){return e%2==0?e:e+1}function Ih(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function _h(e,t,n=""){Ih($h(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Sh(e){Ih(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function Eh(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Ph(e)&&!n)for(let s=0;s<e.length;++s)Eh(e[s],t,n);else t.push(e);return t}function Nh(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function $h(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Th(e){return e%1==0}function Ah(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Rh(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Fh(e,t=(e=>0),n){return new Promise((s,r)=>{let a=0;const o=()=>{if(e())return void s();a++;const i=t(a);null!=n&&a>=n?r():setTimeout(o,i)};o()})}function Dh(e,t){let n=1,s=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===s){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[s]=t/n,r}function Oh(e,t){const n=t.length;return Ih((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Ih(e.every(e=>Th(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function qh(e,t){const n=[],s=[],r=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||r?null:Oh(t,e).sort();let o=0;for(let i=0;i<e.length;++i){if(null!=a){if(a[o]===i&&1!==e[i])throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(null==a[o]||a[o]>i)&&1===e[i]&&(n.push(e[i]),s.push(i)),a[o]<=i&&o++}1!==e[i]&&(n.push(e[i]),s.push(i))}return{newShape:n,keptDims:s}}function zh(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function Mh(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Lh(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Ph(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function Vh(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function jh(e){return"string"==typeof e||e instanceof String}function Bh(e){return"number"==typeof e}function Wh(e){return Array.isArray(e)?Wh(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":Bh(e)?"float32":jh(e)?"string":"boolean"==typeof e?"bool":"float32"}function Uh(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Gh(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Hh(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function Kh(e,t,n,s=!1){const r=new Array;if(1===t.length){const a=t[0]*(s?2:1);for(let t=0;t<a;t++)r[t]=n[e+t]}else{const a=t[0],o=t.slice(1),i=o.reduce((e,t)=>e*t)*(s?2:1);for(let t=0;t<a;t++)r[t]=Kh(e+t*i,o,n,s)}return r}function Xh(e,t,n=!1){if(0===e.length)return t[0];const s=e.reduce((e,t)=>e*t)*(n?2:1);if(0===s)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Kh(0,e,t,n)}function Zh(e,t){const n=Yh(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function Yh(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Qh(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return Xh(e,new Float32Array(n));if("int32"===t)return Xh(e,new Int32Array(n));if("bool"===t)return Xh(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Jh(e){e.forEach(t=>{Ih(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function ef(e,t,n){if(0===t)return 0;if(1===t)return e[0];let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=n[r]*e[r];return s}function tf(e,t,n){if(0===t)return[];if(1===t)return[e];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(e/n[r]),e-=s[r]*n[r];return s[s.length-1]=e,s}function nf(e){return e&&e.then&&"function"==typeof e.then}class sf{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=rf,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}getAsync(e){var t=this;return bh(function*(){return e in t.flags||(t.flags[e]=yield t.evaluateFlag(e)),t.flags[e]})()}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(nf(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)})}}function rf(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function af(){return uf}let of,uf=null;function lf(){if(null==of){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}of=e}return of}function cf(e,t){const n=function(){const e=lf();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const df="Abs",pf="Acos",hf="Acosh",ff="Add",mf="AddN",gf="All",bf="Any",yf="ArgMax",vf="ArgMin",xf="Asin",wf="Asinh",kf="Atan",Cf="Atanh",If="Atan2",_f="AvgPool",Sf="AvgPoolGrad",Ef="AvgPool3D",Nf="AvgPool3DGrad",$f="BatchMatMul",Tf="BatchToSpaceND",Af="Bincount",Rf="Cast",Ff="Ceil",Df="ClipByValue",Of="Complex",qf="ComplexAbs",zf="Concat",Mf="Conv2D",Lf="Conv2DBackpropFilter",Pf="Conv2DBackpropInput",Vf="Conv3D",jf="Conv3DBackpropFilterV2",Bf="Conv3DBackpropInputV2",Wf="Cos",Uf="Cosh",Gf="Cumsum",Hf="CropAndResize",Kf="DenseBincount",Xf="DepthToSpace",Zf="DepthwiseConv2dNative",Yf="DepthwiseConv2dNativeBackpropFilter",Qf="DepthwiseConv2dNativeBackpropInput",Jf="Diag",em="Dilation2D",tm="Dilation2DBackpropInput",nm="Dilation2DBackpropFilter",sm="RealDiv",rm="Einsum",am="Elu",om="EluGrad",im="Erf",um="Equal",lm="Exp",cm="ExpandDims",dm="Expm1",pm="FFT",hm="Fill",fm="FlipLeftRight",mm="Floor",gm="FloorDiv",bm="FusedBatchNorm",ym="GatherV2",vm="GatherNd",xm="Greater",wm="GreaterEqual",km="Identity",Cm="IFFT",Im="Imag",_m="IsFinite",Sm="IsInf",Em="IsNan",Nm="LeakyRelu",$m="Less",Tm="LessEqual",Am="LinSpace",Rm="Log",Fm="Log1p",Dm="LogicalAnd",Om="LogicalNot",qm="LogicalOr",zm="LRN",Mm="LRNGrad",Lm="Max",Pm="Maximum",Vm="MaxPool",jm="MaxPoolGrad",Bm="MaxPool3D",Wm="MaxPool3DGrad",Um="MaxPoolWithArgmax",Gm="Mean",Hm="Min",Km="Minimum",Xm="MirrorPad",Zm="Mod",Ym="Multinomial",Qm="Multiply",Jm="Neg",eg="NotEqual",tg="NonMaxSuppressionV3",ng="NonMaxSuppressionV4",sg="NonMaxSuppressionV5",rg="OnesLike",ag="OneHot",og="Pack",ig="PadV2",ug="Pow",lg="Prelu",cg="Prod",dg="Range",pg="Real",hg="Reciprocal",fg="Relu",mg="Reshape",gg="ResizeNearestNeighbor",bg="ResizeNearestNeighborGrad",yg="ResizeBilinear",vg="ResizeBilinearGrad",xg="Relu6",wg="Reverse",kg="Round",Cg="Rsqrt",Ig="ScatterNd",_g="Select",Sg="Selu",Eg="Slice",Ng="Sin",$g="Sinh",Tg="Sign",Ag="Sigmoid",Rg="Softplus",Fg="Sqrt",Dg="Sum",Og="SpaceToBatchND",qg="SplitV",zg="Softmax",Mg="SparseFillEmptyRows",Lg="SparseReshape",Pg="SparseToDense",Vg="SquaredDifference",jg="Square",Bg="StridedSlice",Wg="Sub",Ug="Tan",Gg="Tanh",Hg="Tile",Kg="TopK",Xg="Transform",Zg="Transpose",Yg="Unique",Qg="Unpack",Jg="UnsortedSegmentSum",eb="ZerosLike",tb="Step",nb="RotateWithOffset",sb="_FusedMatMul",rb="FusedConv2D",ab="FusedDepthwiseConv2D",ob=cf("kernelRegistry",()=>new Map),ib=cf("gradRegistry",()=>new Map);function ub(e,t){const n=hb(e,t);return ob.get(n)}function lb(e){return ib.get(e)}function cb(e){const t=ob.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[a,o]=r,[i]=a.split("_");i===e&&n.push(o)}return n}function db(e){const{kernelName:t,backendName:n}=e,s=hb(t,n);ob.has(s)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),ob.set(s,e)}function pb(e){const{kernelName:t}=e;ib.has(t)&&af().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),ib.set(t,e)}function hb(e,t){return`${t}_${e}`}function fb(e,t){return"string"===t?bb(e):mb([e],t)}function mb(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Eh(e)),af().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function gb(){return af().platform.now()}function bb(e,t="utf-8"){return t=t||"utf-8",af().platform.encode(e,t)}function yb(e,t="utf-8"){return t=t||"utf-8",af().platform.decode(e,t)}class vb{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new wb)}profileKernel(e,t,n){let s;const r=()=>{s=n()};let a;const o=gb();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(r);else{r();for(const e of s)e.dataSync();a=Promise.resolve({kernelMs:gb()-o})}if(af().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<s.length;i++){const t=s[i];t.data().then(n=>{xb(n,t.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:s,inputs:r,extraInfo:a}=e;n.forEach(e=>{Promise.all([e.data(),s,a]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])})})}}function xb(e,t,n){if("float32"!==t)return!1;for(let s=0;s<e.length;s++){const t=e[s];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class wb{logKernelProfile(e,t,n,s,r,a){const o="number"==typeof s?Rh(`${s}ms`,9):s.error,i=Rh(e,25),u=t.rank,l=t.size,c=Rh(t.shape.toString(),14);let d="";for(const p in r){const e=r[p];if(null!=e){const n=e.shape||t.shape,s=n.length;d+=`${p}: ${s}D ${s>0?n:""} `}}console.log(`%c${i}\t%c${o}\t%c${u}D ${c}\t%c${l}\t%c${d}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function kb(e,t,n,s){const r=Hh(t),a=function(e,t,n,s){const r=Nh(t),a=s[s.length-1],o=new Array(a).fill(0),i=t.length,u="complex64"===n?Sb(e):e;if(i>1)for(let l=0;l<r/a;l++){const e=l*a;for(let t=0;t<a;t++)o[t]=Math.max(o[t],Cb(u[e+t],0,n).length)}return o}(e,t,n,r),o=t.length,i=_b(e,t,n,r,a),u=["Tensor"];return s&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(e=>"    "+e).join("\n")),u.join("\n")}function Cb(e,t,n){let s;return s=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:jh(e)?`'${e}'`:"bool"===n?Ib(e):parseFloat(e.toFixed(7)).toString(),Rh(s,t)}function Ib(e){return 0===e?"false":"true"}function _b(e,t,n,s,r,a=!0){const o="complex64"===n?2:1,i=t[0],u=t.length;if(0===u)return"complex64"===n?[Cb(Sb(e)[0],0,n)]:"bool"===n?[Ib(e[0])]:[e[0].toString()];if(1===u){if(i>20){let t=Array.from(e.slice(0,3*o)),s=Array.from(e.slice((i-3)*o,i*o));return"complex64"===n&&(t=Sb(t),s=Sb(s)),["["+t.map((e,t)=>Cb(e,r[t],n)).join(", ")+", ..., "+s.map((e,t)=>Cb(e,r[i-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?Sb(e):Array.from(e)).map((e,t)=>Cb(e,r[t],n)).join(", ")+"]"]}const l=t.slice(1),c=s.slice(1),d=s[0]*o,p=[];if(i>20){for(let t=0;t<3;t++){const s=t*d;p.push(..._b(e.slice(s,s+d),l,n,c,r,!1))}p.push("...");for(let t=i-3;t<i;t++){const s=t*d;p.push(..._b(e.slice(s,s+d),l,n,c,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*d;p.push(..._b(e.slice(t,t+d),l,n,c,r,m===i-1))}const h=2===u?",":"";p[0]="["+p[0]+h;for(let m=1;m<p.length-1;m++)p[m]=" "+p[m]+h;let f=",\n";for(let m=2;m<u;m++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":f),p}function Sb(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Eb{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Nh(e),null!=n){const e=n.length;Ih(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Mh(t,this.size),this.strides=Hh(e)}set(e,...t){0===t.length&&(t=[0]),Ih(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t])throw new Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Nb().makeTensor(this.values,this.shape,this.dtype)}}let Nb=null,$b=null,Tb=null;class Ab{constructor(e,t,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Nh(e),this.strides=Hh(e),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var e=this;return bh(function*(){const t=yield e.data();return $b.buffer(e.shape,e.dtype,t)})()}bufferSync(){return $b.buffer(this.shape,this.dtype,this.dataSync())}array(){var e=this;return bh(function*(){const t=yield e.data();return Xh(e.shape,t,"complex64"===e.dtype)})()}arraySync(){return Xh(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var e=this;return bh(function*(){e.throwIfDisposed();const t=Nb().read(e.dataId);if("string"===e.dtype){const e=yield t;try{return e.map(e=>yb(e))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataSync(){this.throwIfDisposed();const e=Nb().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>yb(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){var e=this;return bh(function*(){e.throwIfDisposed();const t=yield Nb().read(e.dataId);return"string"===e.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(Nb().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return $b.print(this,e)}clone(){return this.throwIfDisposed(),$b.clone(this)}toString(e=!1){return kb(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),$b.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Nb().makeVariable(this,e,t,n)}}function Rb(){return cf("Tensor",()=>Ab)}Object.defineProperty(Ab,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Rb();class Fb extends Ab{constructor(e,t,n,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!$h(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Nb().disposeTensor(this),this.dataId=e.dataId,Nb().incRef(this,null)}dispose(){Nb().disposeVariable(this),this.isDisposedInternal=!0}}var Db,Ob,qb,zb,Mb;Object.defineProperty(Fb,Symbol.hasInstance,{value:e=>e instanceof Ab&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Db||(Db={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Ob||(Ob={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(qb||(qb={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(zb||(zb={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Mb||(Mb={}));const Lb={float32:zb,int32:Ob,bool:qb,complex64:Mb};function Pb(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Lb[e][t]}function Vb(e){return Pb(e,"int32")}function jb(e,t){if(e.dtype===t.dtype)return[e,t];const n=Pb(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Bb(e,t){return t.some(t=>t.id===e.id)}function Wb(e){const t=[];return Ub(e,t,new Set),t}function Ub(e,t,n){if(null==e)return;if(e instanceof Ab)return void t.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const r=e;for(const a in r){const e=r[a];n.has(e)||(n.add(e),Ub(e,t,n))}}function Gb(e){return null!=e.kernelName}class Hb{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Kb{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Hb}ready(){var e=this;return bh(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const t=e.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(yield e.initializeBackend(s).success)return void(yield e.setBackend(s))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}setBackend(e){var t=this;return bh(function*(){if(null==t.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(t.backendName=e,null==t.registry[e]){t.backendInstance=null;const{success:n,asyncInit:s}=t.initializeBackend(e);if(!(s?yield n:n))return!1}return t.backendInstance=t.registry[e],t.setupRegisteredKernels(),t.profiler=new vb(t.backendInstance),!0})()}setupRegisteredKernels(){cb(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){cb(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof vh||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,s=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:s,asyncInit:r}=this.initializeBackend(n);if(r||s)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),s=n.backend,r=this.readSync(t),a=s.refCount(t);s.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,s=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(s){throw t(),s}}nextTensorId(){return Kb.nextTensorId++}nextVariableId(){return Kb.nextVariableId++}clone(e){const t=Zb.runKernel(km,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>Zb.runKernel(Rf,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==ub(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const s=this.backend.numDataIds();let r=0;n.forEach(e=>{r+="complex64"===e.dtype?3:1});const a=s-t-r-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const s=this.isTapeOn(),r=this.state.numBytes,a=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=Gb(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Gb(e)){const{kernelName:t,inputs:r,attrs:a}=e,u=ub(t,this.backendName);Ih(null!=u,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),o=()=>{const e=this.backend.numDataIds();i=u.kernelFunc({inputs:r,attrs:a,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const l=o.map(e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:s}=e;return this.makeTensorFromDataId(t,n,s)});if(s){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{s&&(n=e.map(e=>this.keep(this.clone(e))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy(()=>t(this.backend,r));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,d=Gb(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,l,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs):t=o()}),s&&this.addTapeNode(u,l,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const s=lb(e);if(null!=s){const e=s.inputsToSave||[],r=s.outputsToSave||[];let a;s.saveAllInputs?(Ih(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);const o=n.filter((e,t)=>r[t]);return a.concat(o)}return[]}makeTensor(e,t,n,s){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");s=s||this.backend;let r=e;"string"===(n=n||"float32")&&jh(e[0])&&(r=e.map(e=>bb(e)));const a=s.write(r,t,n),o=new Ab(t,n,a,this.nextTensorId());if(this.trackTensor(o,s),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,s){const r=new Ab(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(r,s),r}makeVariable(e,t=!0,n,s){n=n||this.nextVariableId().toString(),null!=s&&s!==e.dtype&&(e=e.cast(s));const r=new Fb(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Vh(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Fb||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Vh(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var t=this;return bh(function*(){t.state.profiling=!0;const n=t.state.numBytes,s=t.state.numTensors;t.state.activeProfile.kernels=[],t.state.activeProfile.result=yield e(),t.state.profiling=!1,t.state.activeProfile.peakBytes=Math.max(...t.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),t.state.activeProfile.newBytes=t.state.numBytes-n,t.state.activeProfile.newTensors=t.state.numTensors-s;for(const e of t.state.activeProfile.kernels)e.kernelTimeMs=yield e.kernelTimeMs,e.extraInfo=yield e.extraInfo;return t.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,s,r,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=lb(e);null!=i&&(s=i.gradFunc),null!=s&&(o.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],s=Yh(e.size,e.dtype);return this.makeTensor(s,e.shape,e.dtype)}return e}),s(e.length>1?e:e[0],r,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Wb(e),n=new Set(t.map(e=>e.id));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==s.id||this.track(e)})}gradients(e,t,n,s=!1){if(Ih(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Ih(r instanceof Ab,()=>"The result y returned by f() must be a tensor.");const a=function(e,t,n){const s={},r={};for(let u=0;u<t.length;u++)s[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],a=n.inputs;for(const e in a){const o=a[e];let i=!1;for(let e=0;e<t.length;e++)if(s[o.id]){n.outputs.forEach(e=>s[e.id]=!0),i=!0,r[n.id]=!0;break}if(i)break}}const a={};a[n.id]=!0;const o={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,o[t.id]=!0;break}}const i=[];for(let u=0;u<e.length;u++){const t=e[u];if(r[t.id]&&o[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];s[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!s&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[r.id]=null==n?function(e){const t=Zh(Nh(e),"float32");return Zb.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,s){for(let r=t.length-1;r>=0;r--){const a=t[r],o=[];if(a.outputs.forEach(t=>{const n=e[t.id];o.push(null!=n?n:null)}),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const t in a.inputs){if(!(t in i))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(i)}.`);const r=n(()=>i[t]());if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${r.dtype}'`);const o=a.inputs[t];if(!$h(r.shape,o.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${r.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=r;else{const t=e[o.id];e[o.id]=s(t,r),t.dispose()}}}}(e,a,e=>this.tidy(e),Yb);const s=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:r,grads:s}})}customGrad(e){return Ih(Uh(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;Ih(t.every(e=>e instanceof Ab),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return t.forEach((e,t)=>{s[t]=e}),this.runKernelFunc({forwardFunc:(s,r)=>(n=e(...t,r),Ih(n.value instanceof Ab,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Ih(Uh(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,s)=>{const r=n.gradFunc(e,s),a=Array.isArray(r)?r:[r];Ih(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Ih(a.every(e=>e instanceof Ab),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return a.forEach((e,t)=>{o[t]=()=>e}),o},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var t=this;return bh(function*(){const n=gb(),s=yield t.backend.time(e);return s.wallMs=gb()-n,s})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Hb;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Xb(){const e=lf();if(null==e._tfengine){const t=new sf(e);e._tfengine=new Kb(t)}return uf=e._tfengine.ENV,Nb=()=>e._tfengine,e._tfengine}Kb.nextTensorId=0,Kb.nextVariableId=0;const Zb=Xb();function Yb(e,t){return Zb.runKernel(ff,{a:e,b:t})}function Qb(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Jb(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ey=af();function ty(e,t){let n=e;if(Ph(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const s=[];for(;Array.isArray(n)||Ph(n)&&"string"!==t;)s.push(n.length),n=n[0];return Array.isArray(e)&&af().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ny(e,s,[]),s}function ny(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ph(e))return void Ih(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Ih(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Ih(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r)ny(e[r],s,n.concat(r))}function sy(e,t,n,s){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function ry(e,t,n,s="numeric"){if(e instanceof Ab)return sy(s,e.dtype,t,n),e;let r=Wh(e);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),sy(s,r,t,n),null==e||!Ph(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);const a=ty(e,r);Ph(e)||Array.isArray(e)||(e=[e]);const o="string"!==r?mb(e,r):Eh(e,[],!0);return Zb.makeTensor(o,a,r)}function ay(e,t,n,s="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,r)=>ry(e,`${t}[${r}]`,n,s))}function oy(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=(...e)=>{Zb.startScope(n);try{const t=s(...e);return nf(t)&&console.error("Cannot return a Promise inside of tidy."),Zb.endScope(t),t}catch(t){throw Zb.endScope(null),t}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}ey.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ey.registerFlag("IS_BROWSER",()=>Jb()),ey.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),ey.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ey.registerFlag("PROD",()=>!1),ey.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ey.getBool("DEBUG")),ey.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ey.registerFlag("IS_TEST",()=>!1),ey.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ey.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const iy=oy({complex_:function(e,t){const n=ry(e,"real","complex"),s=ry(t,"imag","complex");return _h(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`),Zb.runKernel(Of,{real:n,imag:s})}});function uy(e,t,n,s){if(null==s&&(s=Wh(e)),"complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Ph(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Jh(t);const e=Nh(t),s=Nh(n);Ih(e===s,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${s}`);for(let r=0;r<n.length;++r){const e=n[r],s=r!==n.length-1||e!==Nh(t.slice(r));Ih(n[r]===t[r]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return Ph(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==s?mb(e,s):Eh(e,[],!0),Zb.makeTensor(e,t,s)}function ly(e,t,n){return uy(e,t,ty(e,n),n)}const cy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function dy(e,t){return py.apply(this,arguments)}function py(){return(py=bh(function*(e,t){const n=[],s=[],r=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let a=0;a<r.length;++a){const o=r[a],i=Array.isArray(e)?e[a].tensor:e[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${i.dtype}`);const u={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise(function(){var e=bh(function*(e){const t=yield i.bytes(),n=t.reduce((e,t)=>e+t.length,0)+4*t.length,s=new Uint8Array(n);let r=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);s.set(n,r),r+=4,s.set(e,r),r+=e.length}e(s)});return function(t){return e.apply(this,arguments)}}());s.push(e)}else s.push(i.data());null!=t&&(u.group=t),n.push(u)}return{data:hy(yield Promise.all(s)),specs:n}})).apply(this,arguments)}function hy(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const s=new Uint8Array(t);let r=0;return n.forEach(e=>{s.set(new Uint8Array(e.buffer),r),r+=e.byteLength}),s.buffer}const fy="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function my(e){return fy?Buffer.byteLength(e):new Blob([e]).size}function gy(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let s=0;return e.forEach(e=>{n.set(new Uint8Array(e),s),s+=e.byteLength}),n.buffer}function by(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:my(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:my(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function yy(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let o=0;o<s.length;o++){const r=s[o];a[o]=e[n[r>>10]+(1023&r)]+t[r>>10]}return new Float32Array(r)}}class vy{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==vy.instance&&(vy.instance=new vy),vy.instance}static registerSaveRouter(e){vy.getInstance().saveRouters.push(e)}static registerLoadRouter(e){vy.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return vy.getHandlers(e,"save")}static getLoadHandlers(e,t){return vy.getHandlers(e,"load",t)}static getHandlers(e,t,n){const s=[];return("load"===t?vy.getInstance().loadRouters:vy.getInstance().saveRouters).forEach(t=>{const r=t(e,n);null!==r&&s.push(r)}),s}}const xy=(e,t)=>vy.getLoadHandlers(e,t),wy="tensorflowjs",ky="models_store",Cy="model_info_store";function Iy(){if(!af().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function _y(e){const t=e.result;t.createObjectStore(ky,{keyPath:"modelPath"}),t.createObjectStore(Cy,{keyPath:"modelPath"})}class Sy{constructor(e){if(this.indexedDB=Iy(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var t=this;return bh(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return t.databaseAction(t.modelPath,e)})()}load(){var e=this;return bh(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,t){return new Promise((e,n)=>{const s=this.indexedDB.open(wy,1);s.onupgradeneeded=()=>_y(s),s.onsuccess=()=>{const r=s.result;if(null==t){const t=r.transaction(ky,"readonly"),s=t.objectStore(ky).get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(s.result.modelArtifacts)},s.onerror=e=>(r.close(),n(s.error)),t.oncomplete=()=>r.close()}else{const s=by(t),a=r.transaction(Cy,"readwrite");let o=a.objectStore(Cy);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:s});let u;i.onsuccess=()=>{u=r.transaction(ky,"readwrite");const i=u.objectStore(ky).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:s});i.onsuccess=()=>e({modelArtifactsInfo:s}),i.onerror=e=>{o=a.objectStore(Cy);const t=o.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(i.error)),t.onerror=e=>(r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),a.oncomplete=()=>{null==u?r.close():u.oncomplete=()=>r.close()}}},s.onerror=e=>n(s.error)})}}Sy.URL_SCHEME="indexeddb://";const Ey=e=>{return af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Sy.URL_SCHEME)?(t=e.slice(Sy.URL_SCHEME.length),new Sy(t)):null;var t};vy.registerSaveRouter(Ey),vy.registerLoadRouter(Ey);class Ny{constructor(){this.indexedDB=Iy()}listModels(){var e=this;return bh(function*(){return new Promise((t,n)=>{const s=e.indexedDB.open(wy,1);s.onupgradeneeded=()=>_y(s),s.onsuccess=()=>{const e=s.result,r=e.transaction(Cy,"readonly"),a=r.objectStore(Cy).getAll();a.onsuccess=()=>{const e={};for(const t of a.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},a.onerror=t=>(e.close(),n(a.error)),r.oncomplete=()=>e.close()},s.onerror=e=>n(s.error)})})()}removeModel(e){var t=this;return bh(function*(){var n;return e=(n=e).startsWith(Sy.URL_SCHEME)?n.slice(Sy.URL_SCHEME.length):n,new Promise((n,s)=>{const r=t.indexedDB.open(wy,1);r.onupgradeneeded=()=>_y(r),r.onsuccess=()=>{const t=r.result,a=t.transaction(Cy,"readwrite"),o=a.objectStore(Cy),i=o.get(e);let u;i.onsuccess=()=>{if(null==i.result)return t.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=o.delete(e),a=()=>{u=t.transaction(ky,"readwrite");const r=u.objectStore(ky).delete(e);r.onsuccess=()=>n(i.result.modelArtifactsInfo),r.onerror=e=>s(i.error)};r.onsuccess=a,r.onerror=e=>(a(),t.close(),s(i.error))}},i.onerror=e=>(t.close(),s(i.error)),a.oncomplete=()=>{null==u?t.close():u.oncomplete=()=>t.close()}},r.onerror=e=>s(r.error)})})()}}const $y="/",Ty="tensorflowjs_models",Ay="info",Ry="model_topology",Fy="weight_specs",Dy="weight_data",Oy="model_metadata";function qy(e){return{info:[Ty,e,Ay].join($y),topology:[Ty,e,Ry].join($y),weightSpecs:[Ty,e,Fy].join($y),weightData:[Ty,e,Dy].join($y),modelMetadata:[Ty,e,Oy].join($y)}}function zy(e){const t=e.split($y);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($y)}class My{constructor(e){if(!af().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=qy(this.modelPath)}save(e){var t=this;return bh(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=by(e);try{t.LS.setItem(t.keys.info,JSON.stringify(a)),t.LS.setItem(t.keys.topology,s),t.LS.setItem(t.keys.weightSpecs,r),t.LS.setItem(t.keys.weightData,function(e){if(fy)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}(e.weightData));const n={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),t.LS.setItem(t.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:a}}catch(n){throw t.LS.removeItem(t.keys.info),t.LS.removeItem(t.keys.topology),t.LS.removeItem(t.keys.weightSpecs),t.LS.removeItem(t.keys.weightData),t.LS.removeItem(t.keys.modelMetadata),new Error(`Failed to save model '${t.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}})()}load(){var e=this;return bh(function*(){const t=JSON.parse(e.LS.getItem(e.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(e.LS.getItem(e.keys.topology));if(null==s)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);n.weightSpecs=r;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);n.format=e.format,n.generatedBy=e.generatedBy,n.convertedBy=e.convertedBy,null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer)}const o=e.LS.getItem(e.keys.weightData);if(null==o)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return n.weightData=function(e){if(fy){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}(o),n})()}}My.URL_SCHEME="localstorage://";const Ly=e=>{return af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(My.URL_SCHEME)?(t=e.slice(My.URL_SCHEME.length),new My(t)):null;var t};vy.registerSaveRouter(Ly),vy.registerLoadRouter(Ly);class Py{constructor(){Ih(af().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Ih("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var e=this;return bh(function*(){const t={},n=Ty+$y,s=$y+Ay;for(let r=0;r<e.LS.length;++r){const a=e.LS.key(r);a.startsWith(n)&&a.endsWith(s)&&(t[zy(a)]=JSON.parse(e.LS.getItem(a)))}return t})()}removeModel(e){var t=this;return bh(function*(){var n;const s=qy(e=(n=e).startsWith(My.URL_SCHEME)?n.slice(My.URL_SCHEME.length):n);if(null==t.LS.getItem(s.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(t.LS.getItem(s.info));return t.LS.removeItem(s.info),t.LS.removeItem(s.topology),t.LS.removeItem(s.weightSpecs),t.LS.removeItem(s.weightData),r})()}}class Vy{constructor(){this.managers={}}static getInstance(){return null==Vy.instance&&(Vy.instance=new Vy),Vy.instance}static registerManager(e,t){Ih(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Ih(e.length>0,()=>"scheme must not be an empty string.");const n=Vy.getInstance();Ih(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class jy{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(af().get("IS_BROWSER")){af().setPlatform("browser",new jy);try{Vy.registerManager(My.URL_SCHEME,new Py)}catch(oK){}try{Vy.registerManager(Sy.URL_SCHEME,new Ny)}catch(oK){}}let By;function Wy(e,t="float32",n){return t=t||"float32",Jh(e),new Eb(e,t,n)}af().get("IS_NODE")&&af().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=af().global.fetch?af().global.fetch(e,t):(null==By&&(By=n(410)),By(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const Uy=oy({cast_:function(e,t){const n=ry(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return Zb.runKernel(Rf,{x:n},{dtype:t})}}),Gy=oy({clone_:function(e){const t=ry(e,"x","clone","string_or_numeric");return Zb.runKernel(km,{x:t})}});function Hy(e){return new Promise(e=>setTimeout(e)).then(e)}Xb(),$b={buffer:Wy,cast:Uy,clone:Gy,print:function(e,t=!1){console.log(e.toString(t))}};class Ky{constructor(e){if(!af().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ky.URL_SCHEME)&&(e=e.slice(Ky.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var t=this;return bh(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+t.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(s.signature=e.signature),null!=e.userDefinedMetadata&&(s.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(s.modelInitializer=e.modelInitializer);const r=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),a=null==t.jsonAnchor?document.createElement("a"):t.jsonAnchor;if(a.download=t.modelTopologyFileName,a.href=r,yield Hy(()=>a.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==t.weightDataAnchor?document.createElement("a"):t.weightDataAnchor;e.download=t.weightDataFileName,e.href=n,yield Hy(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:by(e)}}})()}}function Xy(e,t,n,s){!function(e){Ih(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Ih(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),Ih(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),Ih(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,s=null==s?1:s);let r=0;return Promise.all(e.map(a=>(a.then(a=>{const o=n+ ++r/e.length*(s-n);return t(o),a}),a)))}function Zy(e,t){return Yy.apply(this,arguments)}function Yy(){return(Yy=bh(function*(e,t){null==t&&(t={});const n=null==t.fetchFunc?af().platform.fetch:t.fetchFunc,s=e.map(e=>n(e,t.requestInit,{isBinary:!0})),r=(null==t.onProgress?yield Promise.all(s):yield Xy(s,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?yield Promise.all(r):yield Xy(r,t.onProgress,.5,1)})).apply(this,arguments)}Ky.URL_SCHEME="downloads://",vy.registerSaveRouter(e=>af().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ky.URL_SCHEME)?function(e="model"){return new Ky(e)}(e.slice(Ky.URL_SCHEME.length)):null);class Qy{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Ih("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=af().platform.fetch,Ih(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Ih(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}save(e){var t=this;return bh(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:t.DEFAULT_METHOD},t.requestInit);n.body=new FormData;const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(s.signature=e.signature),null!=e.userDefinedMetadata&&(s.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(s.modelInitializer=e.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(s)],{type:"application/json"}),"model.json"),null!=e.weightData&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=yield t.fetch(t.path,n);if(r.ok)return{modelArtifactsInfo:by(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)})()}load(){var e=this;return bh(function*(){const t=yield e.fetch(e.path,e.requestInit);if(!t.ok)throw new Error(`Request to ${e.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield t.json()}catch(f){let t=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const s=n.modelTopology,r=n.weightsManifest,a=n.generatedBy,o=n.convertedBy,i=n.format,u=n.signature,l=n.userDefinedMetadata;if(null==s&&null==r)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let c,d;if(null!=r){const t=yield e.loadWeights(r);[c,d]=t}const p={modelTopology:s,weightSpecs:c,weightData:d,generatedBy:a,convertedBy:o,format:i};null!=u&&(p.signature=u),null!=l&&(p.userDefinedMetadata=l);const h=n.modelInitializer;return h&&(p.modelInitializer=h),p})()}loadWeights(e){var t=this;return bh(function*(){const n=Array.isArray(t.path)?t.path[1]:t.path,[s,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(n),a=t.weightPathPrefix||s,o=[];for(const t of e)o.push(...t.weights);const i=[],u=[];for(const l of e)for(const e of l.paths)null!=t.weightUrlConverter?u.push(t.weightUrlConverter(e)):i.push(a+e+r);return t.weightUrlConverter&&i.push(...yield Promise.all(u)),[o,gy(yield Zy(i,{requestInit:t.requestInit,fetchFunc:t.fetch,onProgress:t.onProgress}))]})()}}function Jy(e){return null!=e.match(Qy.URL_SCHEME_REGEX)}Qy.URL_SCHEME_REGEX=/^https?:\/\//;const ev=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>Jy(e)):Jy(e),n)return tv(e,t)}return null};function tv(e,t){return new Qy(e,t)}function nv(e,t){return tv(e,t)}function sv(e,t,n){const s=e.shape.length;Ih(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),Ih(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)Ih(t[r]+n[r]<=e.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function rv(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function av(e,t,n){const s=[];for(let r=0;r<e.length;r++)s[r]=Math.ceil((t[r]-e[r])/n[r]);return s}function ov(e,t,n,s){const r=[...e];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<n;a++)0===a?r[t]=1:(r.splice(t,0,1),r.pop());return r}function iv(e,t,n){return n<=e?n:n-(t-1)}function uv(e,t){const n=[];for(let s=0;s<e;s++)n.push(t+s);return n}function lv(e,t,n,s,r,a,o,i,u){const l=e.length;let c=new Array(l),d=new Array(l),p=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=cv(o,u,l,s,e),d=dv(i,u,l,r,e),p=ov(a,u,l,e)}else for(let h=0;h<l;h++)c[h]=hv(o,s,a,e,h,u),d[h]=fv(i,r,a,e,h,u),p[h]=pv(a,h,u);return{begin:c,end:d,strides:p}}function cv(e,t,n,s,r){const a=[...r],o=uv(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const r=iv(t,n,i);let o=s[r];e&1<<r&&(o=0),a[i]=o}return a}function dv(e,t,n,s,r){const a=[...r],o=uv(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const r=iv(t,n,i);let o=s[r];e&1<<r&&(o=Number.MAX_SAFE_INTEGER),a[i]=o}for(let i=0;i<a.length;i++){const e=r[i];a[i]<0&&(a[i]+=e),a[i]=kh(0,a[i],r[i])}return a}function pv(e,t,n){let s=e[t];return(n&1<<t||null==s)&&(s=1),s}function hv(e,t,n,s,r,a){let o=t[r];(e&1<<r||a&1<<r||null==o)&&(o=(n[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const i=s[r];return o<0&&(o+=i),o=kh(0,o,i-1),o}function fv(e,t,n,s,r,a){let o=t[r];const i=n[r]||1;(e&1<<r||a&1<<r||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=s[r];return o<0&&(o+=u),o=i>0?kh(0,o,u):kh(-1,o,u-1),o}function mv(e,t,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function gv(e,t){let n=e.length>0?e[e.length-1]:1;for(let s=0;s<e.length-1;s++)n+=e[s]*t[s];return n}function bv(e,t,n){let s;const r=e.shape.length;let a;return s="number"==typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),s.forEach(e=>{Ih(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=null==n?new Array(r).fill(-1):"number"==typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,a=a.map((t,n)=>t>=0?t:(Ih(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-s[n])),[s,a]}function yv(e,t,n,s,r,a,o,i,u){let l=t.slice(),c=n.slice(),d=s;null==s&&(d=new Array(l.length));const p=rv(o);if(p.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==i)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const h=e.length-l.length,f=rv(i),m=e.slice();f.forEach(e=>{l[e]=0,c[e]=1,m.splice(e,0,1)});const{begin:g,end:b,strides:y}=lv(m,p,h,l,c,d,r,a,o);l=g,c=b,d=y;const v=rv(u);v.forEach(e=>{c[e]=l[e]+1,d[e]=1});const x=av(l,c,d),w=x.filter((e,t)=>-1===v.indexOf(t));return{nonStrided:d.every(e=>1===e),$begin:l,$end:c,$strides:d,size:x,newShape:m,outShape:w}}vy.registerSaveRouter(ev),vy.registerLoadRouter(ev);class vv{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class xv{constructor(){this.classNameMap={}}static getMap(){return null==xv.instance&&(xv.instance=new xv),xv.instance}static register(e){xv.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function wv(e){Ih(null!=e.className,()=>"Class being registered does not have the static className property defined."),Ih("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Ih(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),xv.register(e)}function kv(){return Zb}function Cv(){return Zb.memory()}function Iv(e,t){return Zb.tidy(e,t)}function _v(e){Wb(e).forEach(e=>e.dispose())}function Sv(e){return Zb.keep(e)}function Ev(e,t,n=1){return Zb.registerBackend(e,t,n)}function Nv(e){return Zb.customGrad(e)}function $v(e,t){if((Ph(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ph(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return uy(e,[],[],t)}Tb=function(e){af().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class Tv extends vv{minimize(e,t=!1,n){const{value:s,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:r[e.name]}));this.applyGradients(e)}else this.applyGradients(r);return _v(r),t?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Ih(Uh(e),()=>"The f passed in variableGrads(f) must be a function"),Ih(null==t||Array.isArray(t)&&t.every(e=>e instanceof Fb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in Zb.registeredVariables)t.push(Zb.registeredVariables[e])}const s=n?t.filter(e=>!e.trainable):null,r=t.length;Ih((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:a,grads:o}=Zb.gradients(e,t,null,!0);Ih(o.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Ih(0===a.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const i={};return t.forEach((e,t)=>{null!=o[t]&&(i[e.name]=o[t])}),null!=s&&s.forEach(e=>i[e.name]=null),{value:a,grads:i}}(e,t)}dispose(){null!=this.iterations_&&_v(this.iterations_)}saveIterations(){var e=this;return bh(function*(){return null==e.iterations_&&(e.iterations_=0),{name:"iter",tensor:$v(e.iterations_,"int32")}})()}getWeights(){return bh(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(e){var t=this;return bh(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${t.getClassName()}`)})()}extractIterations(e){var t=this;return bh(function*(){return t.iterations_=(yield e[0].tensor.data())[0],e.slice(1)})()}}Object.defineProperty(Tv,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});const Av=oy({abs_:function(e){const t=ry(e,"x","abs");return Zb.runKernel("complex64"===t.dtype?qf:df,{x:t})}}),Rv=oy({add_:function(e,t){let n=ry(e,"a","add"),s=ry(t,"b","add");return[n,s]=jb(n,s),Zb.runKernel(ff,{a:n,b:s})}}),Fv=oy({all_:function(e,t=null,n=!1){const s=ry(e,"x","all","bool");return Zb.runKernel(gf,{x:s},{axis:t,keepDims:n})}}),Dv=oy({any_:function(e,t=null,n=!1){const s=ry(e,"x","any","bool");return Zb.runKernel(bf,{x:s},{axis:t,keepDims:n})}}),Ov=oy({argMax_:function(e,t=0){const n=ry(e,"x","argMax");return Zb.runKernel(yf,{x:n},{axis:t})}});function qv(e,t,n,s,r="NHWC",a){return Lv(e,[...t,e[3]],n,a,s,null,null,Kv(r))}function zv(e,t,n,s,r,a,o="channelsLast"){const[i,u]=jv(t);let l;if("channelsLast"===o)l=[i,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);l=[i,u,e[1],e[1]]}return Lv(e,l,n,s,r,a,!1,o)}function Mv(e,t,n,s,r,a,o="NDHWC"){const[i,u,l]=Bv(t);let c,d;if("NDHWC"===o)d="channelsLast",c=[i,u,l,e[4],e[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[i,u,l,e[1],e[1]]}return Pv(e,c,n,s,r,!1,d,a)}function Lv(e,t,n,s,r,a,o=!1,i="channelsLast"){let[u,l,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c]=e}const[p,h,,f]=t,[m,g]=jv(n),[b,y]=jv(s),v=Wv(p,b),x=Wv(h,y),{padInfo:w,outHeight:k,outWidth:C}=function(e,t,n,s,r,a,o,i,u){let l,c,d;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,s,r){null==s&&(s=Vv(e,t,n));const a=e[1];return[Uv((e[0]-t+2*s)/n+1,r),Uv((a-t+2*s)/n+1,r)]}([t,n],a,s,e,i);c=r[0],d=r[1]}else if("same"===e){c=Math.ceil(t/s),d=Math.ceil(n/r);const e=Math.max(0,(c-1)*s+a-t),i=Math.max(0,(d-1)*r+o-n),u=Math.floor(e/2),p=e-u,h=Math.floor(i/2);l={top:u,bottom:p,left:h,right:i-h,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/s),d=Math.ceil((n-o+1)/r);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const p="channelsLast"===u?e[1][0]:e[2][0],h="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:p,bottom:h,left:f,right:m,type:0===p&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},c=Uv((t-a+p+h)/s+1,i),d=Uv((n-o+f+m)/r+1,i)}}return{padInfo:l,outHeight:c,outWidth:d}}(r,l,c,m,g,v,x,a,i),I=o?f*d:f;let _;return"channelsFirst"===i?_=[u,I,k,C]:"channelsLast"===i&&(_=[u,k,C,I]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:d,outHeight:k,outWidth:C,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:h,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:b,dilationWidth:y,inShape:e,outShape:_,filterShape:t}}function Pv(e,t,n,s,r,a=!1,o="channelsLast",i){let[u,l,c,d,p]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,d,p]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,p,l,c,d]=e}const[h,f,m,,g]=t,[b,y,v]=Bv(n),[x,w,k]=Bv(s),C=Wv(h,x),I=Wv(f,w),_=Wv(m,k),{padInfo:S,outDepth:E,outHeight:N,outWidth:$}=function(e,t,n,s,r,a,o,i,u,l,c){let d,p,h,f;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,s,r,a){null==r&&(r=Vv(e,t,s));const o=e[1],i=e[2];return[Uv((e[0]-t+2*r)/s+1,a),Uv((o-t+2*r)/s+1,a),Uv((i-t+2*r)/s+1,a),1]}([t,n,s,1],i,0,r,e,c);p=a[0],h=a[1],f=a[2]}else if("same"===e){p=Math.ceil(t/r),h=Math.ceil(n/a),f=Math.ceil(s/o);const e=(p-1)*r+i-t,c=(h-1)*a+u-n,m=(f-1)*o+l-s,g=Math.floor(e/2),b=e-g,y=Math.floor(c/2),v=c-y,x=Math.floor(m/2);d={top:y,bottom:v,left:x,right:m-x,front:g,back:b,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((t-i+1)/r),h=Math.ceil((n-u+1)/a),f=Math.ceil((s-l+1)/o)}return{padInfo:d,outDepth:p,outHeight:h,outWidth:f}}(r,l,c,d,b,y,v,C,I,_,i),T=a?g*p:g;let A;return"channelsFirst"===o?A=[u,T,E,N,$]:"channelsLast"===o&&(A=[u,E,N,$,T]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:d,inChannels:p,outDepth:E,outHeight:N,outWidth:$,outChannels:T,padInfo:S,strideDepth:b,strideHeight:y,strideWidth:v,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:I,effectiveFilterWidth:_,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function Vv(e,t,n,s=1){const r=Wv(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function jv(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Bv(e){return"number"==typeof e?[e,e,e]:e}function Wv(e,t){return t<=1?e:e+(e-1)*(t-1)}function Uv(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Gv(e){const[t,n,s]=jv(e);return 1===t&&1===n&&1===s}function Hv(e,t){return Gv(e)||Gv(t)}function Kv(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const Xv=oy({reshape_:function(e,t){const n=ry(e,"x","reshape","string_or_numeric");return Zb.runKernel(mg,{x:n},{shape:t})}}),Zv=oy({avgPool_:function(e,t,n,s,r){const a=ry(e,"x","avgPool","float32");Ih(Hv(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=a,i=!1;3===a.rank&&(i=!0,o=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ih(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),null!=r&&Ih(Th(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let u=Zb.runKernel(_f,{x:o},{filterSize:t,strides:n,pad:s,dimRoundingMode:r});return u=Uy(u,a.dtype),i?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Yv=oy({avgPool3d_:function(e,t,n,s,r,a="NDHWC"){const o=ry(e,"x","avgPool3d","float32");let i=o,u=!1;4===o.rank&&(u=!0,i=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Ih(5===i.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),Ih("NDHWC"===a,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),null!=r&&Ih(Th(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);let l=Zb.runKernel(Ef,{x:i},{filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a});return l=Uy(l,i.dtype),u?Xv(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),Qv=oy({batchNorm_:function(e,t,n,s,r,a){null==a&&(a=.001);const o=ry(e,"x","batchNorm"),i=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Ih(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ih(null==c||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ih(null==l||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d=function(e){let t;return t=0===e.rank||1===e.rank?Xv(e,[1,1,1,e.size]):2===e.rank?Xv(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(o),p=Zb.runKernel(bm,{x:d,scale:l,offset:c,mean:i,variance:u},{varianceEpsilon:a});return Xv(p,o.shape)}}),Jv=oy({batchNorm2d_:function(e,t,n,s,r,a){const o=ry(e,"x","batchNorm"),i=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;return null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Ih(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),Ih(2===i.rank||1===i.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),Ih(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=l&&Ih(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&Ih(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Qv(o,i,u,c,l,a)}}),ex=oy({batchNorm3d_:function(e,t,n,s,r,a){const o=ry(e,"x","batchNorm"),i=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;return null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Ih(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),Ih(3===i.rank||1===i.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),Ih(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=l&&Ih(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&Ih(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Qv(o,i,u,c,l,a)}}),tx=oy({batchNorm4d_:function(e,t,n,s,r,a){const o=ry(e,"x","batchNorm"),i=ry(t,"mean","batchNorm"),u=ry(n,"variance","batchNorm");let l,c;return null!=r&&(l=ry(r,"scale","batchNorm")),null!=s&&(c=ry(s,"offset","batchNorm")),Ih(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),Ih(4===i.rank||1===i.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),Ih(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=l&&Ih(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&Ih(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Qv(o,i,u,c,l,a)}}),nx=oy({clipByValue_:function(e,t,n){const s=ry(e,"x","clipByValue");return Ih(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),Zb.runKernel(Df,{x:s},{clipValueMin:t,clipValueMax:n})}}),sx=oy({concat_:function(e,t=0){Ih(e.length>=1,()=>"Pass at least one tensor to concat");const n=ay(e,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length?Gy(n[0]):Zb.runKernel(zf,n,{axis:t})}}),rx=oy({concat1d_:function(e){return sx(e,0)}}),ax=oy({concat2d_:function(e,t){return sx(e,t)}}),ox=oy({concat3d_:function(e,t){return sx(e,t)}}),ix=oy({concat4d_:function(e,t){return sx(e,t)}}),ux=oy({conv2d_:function(e,t,n,s,r="NHWC",a=[1,1],o){const i=ry(e,"x","conv2d"),u=ry(t,"filter","conv2d");let l=i,c=!1;3===i.rank&&(c=!0,l=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ih(4===l.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),Ih(4===u.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),null!=o&&Ih(Th(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d="NHWC"===r?l.shape[3]:l.shape[1];Ih(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),Ih(Hv(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const p=Zb.runKernel(Mf,{x:l,filter:u},{strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o});return c?Xv(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),lx=oy({conv1d_:function(e,t,n,s,r="NWC",a=1,o){const i=ry(e,"x","conv1d"),u=ry(t,"filter","conv1d");let l=i,c=!1;2===i.rank&&(c=!0,l=Xv(i,[1,i.shape[0],i.shape[1]])),Ih(3===l.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),Ih(3===u.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),null!=o&&Ih(Th(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),Ih(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),Ih(Hv(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Ih("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=Xv(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=Xv(l,[l.shape[0],1,l.shape[1],l.shape[2]]),h=ux(p,d,[1,n],s,"NHWC",[1,a],o);return Xv(h,c?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}}),cx=oy({conv2DBackpropInput_:function(e,t,n,s,r,a="NHWC",o){Ih(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,u=t,l=!1;3===t.rank&&(l=!0,u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),Ih(4===i.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),Ih(4===u.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),Ih(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===a?i[3]:i[1],d="NHWC"===a?u.shape[3]:u.shape[1];Ih(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Ih(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),null!=o&&Ih(Th(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const p=Zb.runKernel(Pf,{dy:u,filter:n},{strides:s,pad:r,dataFormat:a,dimRoundingMode:o,inputShape:i});return l?Xv(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),dx=oy({conv2dTranspose_:function(e,t,n,s,r,a){const o=ry(e,"x","conv2dTranspose"),i=ry(t,"filter","conv2dTranspose");return cx(n,o,i,s,r,"NHWC",a)}}),px=oy({conv3d_:function(e,t,n,s,r="NDHWC",a=[1,1,1]){const o=ry(e,"x","conv3d"),i=ry(t,"filter","conv3d");let u=o,l=!1;4===o.rank&&(l=!0,u=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Ih(5===u.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),Ih(5===i.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),Ih(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),Ih(Hv(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Ih("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const c=Zb.runKernel(Vf,{x:u,filter:i},{strides:n,pad:s,dataFormat:r,dilations:a});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),hx=oy({conv3DBackpropInput_:function(e,t,n,s,r){Ih(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,o=t,i=!1;4===t.rank&&(i=!0,o=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],l=o.shape[4];Ih(5===a.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Ih(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),Ih(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Ih(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),Ih(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c=Zb.runKernel(Bf,{dy:o,filter:n},{pad:r,strides:s,inputShape:a});return i?Xv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),fx=oy({conv3dTranspose_:function(e,t,n,s,r){const a=ry(e,"x","conv3dTranspose"),o=ry(t,"filter","conv3dTranspose");return hx(n,a,o,s,r)}}),mx=oy({depthwiseConv2d_:function(e,t,n,s,r="NHWC",a=[1,1],o){const i=ry(e,"x","depthwiseConv2d"),u=ry(t,"filter","depthwiseConv2d");let l=i,c=!1;3===i.rank&&(c=!0,l=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Ih(4===l.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),Ih(4===u.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),Ih(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),null!=o&&Ih(Th(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d=Zb.runKernel(Zf,{x:l,filter:u},{strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o});return c?Xv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),gx=oy({floorDiv_:function(e,t){let n=ry(e,"a","floorDiv"),s=ry(t,"b","floorDiv");return[n,s]=jb(n,s),Zb.runKernel(gm,{a:n,b:s})}}),bx=oy({div_:function(e,t){let n=ry(e,"a","div"),s=ry(t,"b","div");return[n,s]=jb(n,s),"int32"===n.dtype&&"int32"===s.dtype?gx(n,s):Zb.runKernel(sm,{a:n,b:s},{})}}),yx=oy({elu_:function(e){const t=ry(e,"x","elu");return Zb.runKernel(am,{x:t})}});function vx(e,t){const n=e.length,s=[];for(let r=0;r<n;r++){const a=n-1-r,o=e[a]||1;(t[t.length-1-r]||1)>1&&1===o&&s.unshift(a)}return s}function xx(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],a=t.length-s-1,o=t[a];(null==r||1===r&&o>1)&&n.unshift(a)}return n}function wx(e,t){const n=[],s=Math.max(e.length,t.length);for(let r=0;r<s;r++){let s=e[e.length-r-1];null==s&&(s=1);let a=t[t.length-r-1];if(null==a&&(a=1),1===s)n.unshift(a);else if(1===a)n.unshift(s);else{if(s!==a)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(s)}}return n}const kx=oy({equal_:function(e,t){let n=ry(e,"a","equal"),s=ry(t,"b","equal");return[n,s]=jb(n,s),wx(n.shape,s.shape),Zb.runKernel(um,{a:n,b:s})}}),Cx=oy({expandDims_:function(e,t=0){const n=ry(e,"x","expandDims","string_or_numeric");return Ih(t<=n.rank,()=>"Axis must be <= rank of the tensor"),Zb.runKernel(cm,{input:n},{dim:t})}}),Ix=oy({tile_:function(e,t){const n=ry(e,"x","tile","string_or_numeric");return Ih(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),Zb.runKernel(Hg,{x:n},{reps:t})}}),_x=oy({eye_:function(e,t,n,s="float32"){null==t&&(t=e);const r=Wy([e,t],s),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const o=Xv(r.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return Ix(Cx(o,0),[n[0],1,1]);if(2===n.length)return Ix(Cx(Cx(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Ix(Cx(Cx(Cx(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function Sx(e,t,n){return Zb.runKernel(hm,{},{shape:e,value:t,dtype:n})}const Ex=oy({floor_:function(e){const t=ry(e,"x","floor");return Zb.runKernel(mm,{x:t})}}),Nx=oy({gather_:function(e,t,n=0,s=0){const r=ry(e,"x","gather"),a=ry(t,"indices","gather","int32");return Zb.runKernel(ym,{x:r,indices:a},{axis:n,batchDims:s})}}),$x=oy({greater_:function(e,t){let n=ry(e,"a","greater"),s=ry(t,"b","greater");return[n,s]=jb(n,s),wx(n.shape,s.shape),Zb.runKernel(xm,{a:n,b:s})}}),Tx=oy({greaterEqual_:function(e,t){let n=ry(e,"a","greaterEqual"),s=ry(t,"b","greaterEqual");return[n,s]=jb(n,s),wx(n.shape,s.shape),Zb.runKernel(wm,{a:n,b:s})}}),Ax=oy({leakyRelu_:function(e,t=.2){const n=ry(e,"x","leakyRelu");return Zb.runKernel(Nm,{x:n},{alpha:t})}}),Rx=oy({log_:function(e){const t=ry(e,"x","log");return Zb.runKernel(Rm,{x:t})}}),Fx=oy({exp_:function(e){const t=ry(e,"x","exp");return Zb.runKernel(lm,{x:t})}}),Dx=oy({max_:function(e,t=null,n=!1){const s=ry(e,"x","max");return Zb.runKernel(Lm,{x:s},{reductionIndices:t,keepDims:n})}}),Ox=oy({mul_:function(e,t){let n=ry(e,"a","mul"),s=ry(t,"b","mul");return[n,s]=jb(n,s),Zb.runKernel(Qm,{a:n,b:s})}}),qx=oy({sub_:function(e,t){let n=ry(e,"a","sub"),s=ry(t,"b","sub");return[n,s]=jb(n,s),Zb.runKernel(Wg,{a:n,b:s})}}),zx=oy({sum_:function(e,t=null,n=!1){let s=ry(e,"x","sum");return"bool"===s.dtype&&(s=Uy(s,"int32")),Zb.runKernel(Dg,{x:s},{axis:t,keepDims:n})}}),Mx=oy({logSoftmax_:function(e,t=-1){const n=ry(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Nv((e,n)=>{const s=Dx(e,t,!0),r=qx(e,s),a=qx(Uy(r,"float32"),Rx(zx(Fx(r),t,!0)));return n([a]),{value:a,gradFunc:(e,n)=>{const[s]=n,r=Fx(s);return qx(e,Ox(zx(e,t,!0),r))}}})(n)}}),Lx=oy({logicalAnd_:function(e,t){const n=ry(e,"a","logicalAnd","bool"),s=ry(t,"b","logicalAnd","bool");return wx(n.shape,s.shape),Zb.runKernel(Dm,{a:n,b:s})}}),Px=oy({maxPool_:function(e,t,n,s,r){const a=ry(e,"x","maxPool");let o=a,i=!1;3===a.rank&&(i=!0,o=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ih(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),Ih(Hv(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=r&&Ih(Th(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const u=Zb.runKernel(Vm,{x:o},{filterSize:t,strides:n,pad:s,dimRoundingMode:r});return i?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Vx=oy({maxPool3d_:function(e,t=[1,1,1],n,s,r,a="NDHWC"){const o=ry(e,"x","maxPool3d");let i=o,u=!1;4===o.rank&&(u=!0,i=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Ih(5===i.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),Ih("NDHWC"===a,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),null!=r&&Ih(Th(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l=Zb.runKernel(Bm,{x:i},{filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a});return u?Xv(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),jx=oy({maximum_:function(e,t){let n=ry(e,"a","maximum"),s=ry(t,"b","maximum");return[n,s]=jb(n,s),"bool"===n.dtype&&(n=Uy(n,"int32"),s=Uy(s,"int32")),wx(n.shape,s.shape),Zb.runKernel(Pm,{a:n,b:s})}}),Bx=oy({mean_:function(e,t=null,n=!1){const s=ry(e,"x","mean");return Zb.runKernel(Gm,{x:s},{axis:t,keepDims:n})}}),Wx=oy({min_:function(e,t=null,n=!1){const s=ry(e,"x","min");return Zb.runKernel(Hm,{x:s},{axis:t,keepDims:n})}}),Ux=oy({minimum_:function(e,t){let n=ry(e,"a","minimum"),s=ry(t,"b","minimum");return[n,s]=jb(n,s),"bool"===n.dtype&&(n=Uy(n,"int32"),s=Uy(s,"int32")),wx(n.shape,s.shape),Zb.runKernel(Km,{a:n,b:s})}});function Gx(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Hx(e,t,n){const s=e.length+t.length,r=[];let a=0,o=0;for(let i=0;i<s;i++)-1===n.indexOf(i)?r.push(e[a++]):r.push(t[o++]);return r}function Kx(e,t){const n=[],s=e.length;for(let r=0;r<s;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map(t=>e[t])]}function Xx(e,t){return Hx(e,t.map(e=>1),t)}function Zx(e,t,n){Ih(Gx(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Yx(e,t){if(Gx(e,t))return null;const n=[];for(let s=0;s<t;++s)-1===e.indexOf(s)&&n.push(s);return e.forEach(e=>n.push(e)),n}function Qx(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Jx(e,t){const n=[];for(let s=t-e;s<t;++s)n.push(s);return n}const ew=oy({square_:function(e){const t=ry(e,"x","square");return Zb.runKernel("Square",{x:t},{})}}),tw=oy({moments_:function(e,t=null,n=!1){const s=Oh(t,(e=ry(e,"x","moments")).shape),r=Bx(e,s,n);let a=r.shape;n||(a=Xx(r.shape,s));const o=ew(qx(Uy(e,"float32"),Xv(r,a)));return{mean:r,variance:Bx(o,s,n)}}}),nw=oy({neg_:function(e){const t=ry(e,"x","neg");return Zb.runKernel(Jm,{x:t})}}),sw=oy({notEqual_:function(e,t){let n=ry(e,"a","notEqual"),s=ry(t,"b","notEqual");return[n,s]=jb(n,s),wx(n.shape,s.shape),Zb.runKernel(eg,{a:n,b:s})}}),rw=oy({oneHot_:function(e,t,n=1,s=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const r=ry(e,"indices","oneHot","int32");return Zb.runKernel(ag,{indices:r},{depth:t,onValue:n,offValue:s})}});function aw(e,t="float32"){if("complex64"===t){const t=aw(e,"float32"),n=aw(e,"float32");return iy(t,n)}const n=Yh(Nh(e),t);return Zb.makeTensor(n,e,t)}function ow(e,t="float32"){if("complex64"===t){const t=ow(e,"float32"),n=aw(e,"float32");return iy(t,n)}const n=Zh(Nh(e),t);return Zb.makeTensor(n,e,t)}const iw=oy({onesLike_:function(e){const t=ry(e,"x","onesLike");return Zb.runKernel(rg,{x:t})}}),uw=oy({pad_:function(e,t,n=0){const s=ry(e,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return Zb.runKernel(ig,{x:s},{paddings:t,constantValue:n})}}),lw=oy({prelu_:function(e,t){const n=ry(e,"x","prelu"),s=ry(t,"alpha","prelu");return Zb.runKernel(lg,{x:n,alpha:s})}});var cw=n(566);class dw{constructor(e,t,n,s,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=r||Math.random();this.random=cw.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let s,r,a;do{s=2*this.random()-1,r=2*this.random()-1,a=s*s+r*r}while(a>=1||0===a);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*s*o,t=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class pw{constructor(e=0,t=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=cw.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const hw=oy({randomNormal_:function(e,t=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const a=new dw(t,n,s,!1,r),o=Wy(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}}),fw=oy({randomUniform_:function(e,t=0,n=1,s="float32",r){const a=Wy(e,s),o=new pw(t,n,null,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}}),mw=oy({relu_:function(e){const t=ry(e,"x","relu");return Zb.runKernel(fg,{x:t})}}),gw=oy({reverse_:function(e,t){const n=ry(e,"x","reverse");return Zb.runKernel(wg,{x:n},{dims:t})}}),bw=oy({selu_:function(e){const t=ry(e,"x","selu");return Zb.runKernel(Sg,{x:t})}}),yw=oy({separableConv2d_:function(e,t,n,s,r,a=[1,1],o="NHWC"){const i=ry(e,"x","separableConv2d"),u=ry(t,"depthwiseFilter","separableConv2d"),l=ry(n,"pointwiseFilter","separableConv2d");let c=i,d=!1;if(3===i.rank&&(d=!0,c=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Ih(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Ih(4===u.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),Ih(4===l.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),Ih(1===l.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),Ih(1===l.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const p=u.shape[2],h=u.shape[3];Ih(l.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${l.shape[2]}.`);const f=mx(c,u,s,r,o,a),m=ux(f,l,1,"valid",o);return d?Xv(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),vw=oy({sigmoid_:function(e){const t=ry(e,"x","sigmoid");return Zb.runKernel(Ag,{x:t})}}),xw=oy({slice_:function(e,t,n){const s=ry(e,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return Zb.runKernel(Eg,{x:s},{begin:t,size:n})}}),ww=oy({slice1d_:function(e,t,n){const s=ry(e,"x","slice1d");return Ih(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),xw(s,[t],[n])}}),kw=oy({slice2d_:function(e,t,n){const s=ry(e,"x","slice2d");return Ih(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),xw(s,t,n)}}),Cw=oy({slice3d_:function(e,t,n){const s=ry(e,"x","slice3d");return Ih(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),xw(s,t,n)}}),Iw=oy({slice4d_:function(e,t,n){const s=ry(e,"x","slice4d");return Ih(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),xw(s,t,n)}}),_w=oy({softmax_:function(e,t=-1){const n=ry(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return Zb.runKernel(zg,{logits:n},{dim:t})}}),Sw=oy({softplus_:function(e){const t=ry(e,"x","softplus");return Zb.runKernel(Rg,{x:t})}}),Ew=oy({split_:function(e,t,n=0){const s=ry(e,"x","split");return Zb.runKernel(qg,{x:s},{numOrSizeSplits:t,axis:n})}}),Nw=oy({sqrt_:function(e){const t=ry(e,"x","sqrt");return Zb.runKernel(Fg,{x:t})}}),$w=oy({squeeze_:function(e,t){const n=ry(e,"x","squeeze");return Xv(n,qh(n.shape,t).newShape)}}),Tw=oy({stack_:function(e,t=0){const n=ay(e,"tensors","stack","string_or_numeric");return Ih(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Ih(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),Zb.runKernel(og,n,{axis:t})}}),Aw=oy({tanh_:function(e){const t=ry(e,"x","tanh");return Zb.runKernel(Gg,{x:t})}});function Rw(e,t){Sh(e);const n=ty(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return uy(e,null,n,t)}function Fw(e,t,n){if(Sh(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const s=ty(e,n);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return uy(e,t,s,n)}const Dw=oy({truncatedNormal_:function(e,t=0,n=1,s,r){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const a=new dw(t,n,s,!0,r),o=Wy(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}}),Ow=oy({unstack_:function(e,t=0){const n=ry(e,"x","unstack","string_or_numeric");return Ih(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),Zb.runKernel(Qg,{value:n},{axis:t})}}),qw=oy({broadcastTo_:function(e,t){let n=ry(e,"broadcastTo","x");const s=n.shape;if(t.some(e=>!(e>0)||e%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Xv(n,e)}const r=n.shape,a=Array.from(t);for(let o=t.length-1;o>=0;o--)if(r[o]===t[o])a[o]=1;else if(1!==n.shape[o])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);return 0===a.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length?Gy(n):Zb.runKernel(Hg,{x:n},{reps:a})}}),zw=oy({where_:function(e,t,n){const s=ry(t,"a","where"),r=ry(n,"b","where"),a=ry(e,"condition","where","bool"),o=wx(wx(a.shape,s.shape),r.shape),i=qw(a,o),u=qw(s,o),l=qw(r,o);return Zb.runKernel(_g,{condition:i,t:u,e:l})}}),Mw=oy({zerosLike_:function(e){const t=ry(e,"x","zerosLike");return Zb.runKernel(eb,{x:t})}}),Lw=oy({transpose_:function(e,t){const n=ry(e,"x","transpose");return null==t&&(t=n.shape.map((e,t)=>t).reverse()),Ih(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{Ih(e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`)}),n.rank<=1?n.clone():Zb.runKernel(Zg,{x:n},{perm:t})}}),Pw=oy({dropout_:function(e,t,n,s){const r=ry(e,"x","dropout");if(Ih("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),Ih(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof Ab?r.clone():r;const a=function(e,t){if(null==t)return e.shape.slice();if($h(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++)n.push(null==t[s]&&null!=e.shape[s]?e.shape[s]:t[s]);return n}return t}(r,n),o=1-t,i=bx(Ex(Rv(fw(a,0,1,"float32",s),o)),o);return Ox(r,i)}}),Vw=oy({imag_:function(e){const t=ry(e,"input","imag");return Zb.runKernel(Im,{input:t})}}),jw=oy({real_:function(e){const t=ry(e,"input","real");return Zb.runKernel(pg,{input:t})}}),Bw=oy({fft_:function(e){return Ih("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),Zb.runKernel(pm,{input:e})}}),Ww=oy({rfft_:function(e,t){Ih("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(null!=t&&t<n){const s=e.shape.map(e=>0),a=e.shape.map(e=>e);a[e.shape.length-1]=t,r=xw(e,s,a),n=t}else if(null!=t&&t>n){const s=e.shape.map(e=>e);s[e.shape.length-1]=t-n,r=sx([e,aw(s)],e.shape.length-1),n=t}else r=e;const a=Mw(r),o=Xv(iy(r,a),[s,n]),i=Bw(o),u=Math.floor(n/2)+1,l=jw(i),c=Vw(i),d=Ew(l,[u,n-u],l.shape.length-1),p=Ew(c,[u,n-u],c.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=u,Xv(iy(d[0],p[0]),h)}}),Uw=oy({ifft_:function(e){return Ih("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),Zb.runKernel(Cm,{input:e})}}),Gw=oy({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const r=Xv(e,[n,t]);s=Uw(r)}else{const r=[n,2*(t-1)],a=Xv(jw(e),[n,t]),o=Xv(Vw(e),[n,t]),i=gw(xw(a,[0,1],[n,t-2]),1),u=Ox(gw(xw(o,[0,1],[n,t-2]),1),$v(-1)),l=sx([a,i],1),c=sx([o,u],1),d=Xv(iy(l,c),[r[0],r[1]]);s=Uw(d)}if(s=jw(s),3===e.rank&&0!==e.shape[0]){const t=s,n=e.shape[0];s=Xv(s,[n,s.shape[0]/n,s.shape[1]]),t.dispose()}return s}}),Hw=oy({conv2DBackpropFilter_:function(e,t,n,s,r,a="NHWC",o){let i=e;3===e.rank&&(i=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Ih(4===i.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),Ih(4===u.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),Ih(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l="NHWC"===a?i.shape[3]:i.shape[1],c="NHWC"===a?u.shape[3]:u.shape[1];return Ih(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),Ih(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=o&&Ih(Th(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),Zb.runKernel(Lf,{x:i,dy:u},{strides:s,pad:r,dataFormat:a,dimRoundingMode:o,filterShape:n})}}),Kw=oy({relu6_:function(e){const t=ry(e,"x","relu6");return Zb.runKernel(xg,{x:t})}}),Xw=oy({step_:function(e,t=0){const n=ry(e,"x","step");return Zb.runKernel(tb,{x:n},{alpha:t})}});function Zw(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Ox(e,Xw(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Yw(e,t){let n=t;const s=xx(e.shape,t.shape);return s.length>0&&(n=zx(n,s)),Xv(n,e.shape)}function Qw(e,t,n,s){if("linear"===t)return e;if("relu"===t)return mw(e);if("elu"===t)return yx(e);if("relu6"===t)return Kw(e);if("prelu"===t)return lw(e,n);if("leakyrelu"===t)return Ax(e,s);if("sigmoid"===t)return vw(e);throw new Error(`Unknown fused activation ${t}.`)}const Jw=(e,t)=>!(e>0)||"linear"===t,ek=oy({fusedConv2d_:function({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Jw(Zb.state.gradientDepth,u=u||"linear")){let d=ux(e,t,n,s,r,a,o);return null!=i&&(d=Rv(d,i)),Qw(d,u,l,c)}const d=ry(e,"x","conv2d"),p=ry(t,"filter","conv2d");let h=d,f=!1;3===d.rank&&(f=!0,h=Xv(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Ih(4===h.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),Ih(4===p.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),null!=o&&Ih(Th(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),Ih(h.shape[3]===p.shape[2],()=>`Error in conv2d: depth of input (${h.shape[3]}) must match input depth for filter ${p.shape[2]}.`),Ih(Hv(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Ih("NHWC"===r,()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=Lv(h.shape,p.shape,n,a,s,o);let g,b;null!=i&&(g=ry(i,"bias","fused conv2d"),[g]=jb(g,d),wx(m.outShape,g.shape)),null!=l&&(b=ry(l,"prelu weights","fused conv2d"));const y=(e,t)=>{const[r,o,i,l]=t,c=Zw(e,i,u);Ih(Gv(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const d=[cx(o.shape,c,r,n,s),Hw(o,c,r.shape,n,s)];if(null!=l){const e=Yw(l,c);d.push(e)}return d},v={x:h,filter:p,bias:g,preluActivationWeights:b},x={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return null==i?Nv((e,t,n)=>{let s=Zb.runKernel(rb,v,x);return n([t,e,s]),f&&(s=Xv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(h,p):Nv((e,t,n,s)=>{let r=Zb.runKernel(rb,v,x);return s([t,e,r,n]),f&&(r=Xv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(h,p,g)}}),tk=oy({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,s,r,a=[1,1],o){let i=e;3===e.rank&&(i=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;return 3===u.rank&&(u=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Zb.runKernel(Yf,{x:i,dy:u},{strides:s,pad:r,dimRoundingMode:o,dilations:a,filterShape:n})}}),nk=oy({depthwiseConv2dNativeBackpropInput_:function(e,t,n,s,r,a=[1,1],o){let i=t,u=!1;3===t.rank&&(u=!0,i=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l=Zb.runKernel(Qf,{dy:i,filter:n},{strides:s,pad:r,dimRoundingMode:o,dilations:a,inputShape:e});return u?Xv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});oy({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Jw(Zb.state.gradientDepth,u)){let d=mx(e,t,n,s,r,a,o);return null!=i&&(d=Rv(d,i)),Qw(d,u,l,c)}const d=ry(e,"x","depthwiseConv2d"),p=ry(t,"filter","depthwiseConv2d");let h=d,f=!1;3===d.rank&&(f=!0,h=Xv(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Ih(4===h.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),Ih(4===p.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),Ih(h.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),null==a&&(a=[1,1]),Ih(Hv(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),null!=o&&Ih(Th(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${s}.`);const m=Lv(h.shape,p.shape,n,a,s,o,!0);let g,b;null!=i&&(g=ry(i,"bias","fused conv2d"),[g]=jb(g,d),wx(m.outShape,g.shape)),null!=l&&(b=ry(l,"prelu weights","fused depthwiseConv2d"));const y=(e,t)=>{Ih(Gv(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[r,i,l,c]=t,d=Zw(e,l,u),p=nk(i.shape,d,r,n,s,a,o),h=tk(i,d,r.shape,n,s,a,o);return null!=c?[p,h,Yw(g,d)]:[p,h]},v={x:h,filter:p,bias:g,preluActivationWeights:b},x={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return null==i?Nv((e,t,n)=>{let s=Zb.runKernel(ab,v,x);return n([t,e,s]),f&&(s=Xv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(h,p):Nv((e,t,n,s)=>{let r=Zb.runKernel(ab,v,x);return s([t,e,r,n]),f&&(r=Xv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(h,p,g)}});const sk=oy({matMul_:function(e,t,n=!1,s=!1){let r=ry(e,"a","matMul"),a=ry(t,"b","matMul");return[r,a]=jb(r,a),Zb.runKernel($f,{a:r,b:a},{transposeA:n,transposeB:s})}}),rk=oy({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i}){if(!1===Jw(Zb.state.gradientDepth,a)){let u=sk(e,t,n,s);return null!=r&&(u=Rv(u,r)),Qw(u,a,o,i)}let u=ry(e,"a","fused matMul"),l=ry(t,"b","fused matMul");[u,l]=jb(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],d=s?l.shape[l.rank-1]:l.shape[l.rank-2],p=n?u.shape[u.rank-1]:u.shape[u.rank-2],h=s?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=Nh(f),b=Nh(m);Ih(u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),Ih($h(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`),Ih(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${s} must match.`);const y=u.shape.slice(0,-2).concat([p,h]),v=Xv(u,n?[g,c,p]:[g,p,c]),x=Xv(l,s?[b,h,d]:[b,d,h]);let w,k;null!=r&&(w=ry(r,"bias","fused matMul"),[w]=jb(w,u),wx(y,w.shape)),null!=o&&(k=ry(o,"prelu weights","fused matMul"));const C=(e,t)=>{const[o,i,u,l]=t,c=Zw(Xv(e,u.shape),u,a);let d,p;return n||s?!n&&s?(d=sk(c,i,!1,!1),p=sk(c,o,!0,!1)):n&&!s?(d=sk(i,c,!1,!0),p=sk(o,c,!1,!1)):(d=sk(i,c,!0,!0),p=sk(c,o,!0,!0)):(d=sk(c,i,!1,!0),p=sk(o,c,!0,!1)),null!=r?[d,p,Yw(l,c)]:[d,p]},I={a:v,b:x,bias:w,preluActivationWeights:k},_={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:i};return null==r?Nv((e,t,n)=>{const s=Zb.runKernel(sb,I,_);return n([e,t,s]),{value:Xv(s,y),gradFunc:C}})(v,x):Nv((e,t,n,s)=>{const r=Zb.runKernel(sb,I,_);return s([e,t,r,n]),{value:Xv(r,y),gradFunc:C}})(v,x,w)}});function ak(e,t,n){const s=1-e%2,r=new Float32Array(e);for(let a=0;a<e;++a){const o=2*Math.PI*a/(e+s-1);r[a]=t-n*Math.cos(o)}return Rw(r,"float32")}oy({hammingWindow_:function(e){return ak(e,.54,.46)}});const ok=oy({hannWindow_:function(e){return ak(e,.5,.5)}}),ik=oy({frame_:function(e,t,n,s=!1,r=0){let a=0;const o=[];for(;a+t<=e.size;)o.push(xw(e,a,t)),a+=n;if(s)for(;a<e.size;){const s=a+t-e.size,i=sx([xw(e,a,t-s),Sx([s],r)]);o.push(i),a+=n}return 0===o.length?Fw([],[0,t]):Xv(sx(o),[o.length,t])}});function uk(e,t,n,s,r,a){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==a&&(a=0);const o=e.shape[0];return n=Math.min(n,o),Ih(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),Ih(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Ih(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Ih(1===t.rank,()=>"scores must be a 1D tensor"),Ih(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),Ih(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}function lk(e,t,n){const s=function(e,t,n){return function(e,t,n){let s=0,r=e.length,a=0,o=!1;for(;s<r;){a=s+(r-s>>>1);const i=n(t,e[a]);i>0?s=a+1:(r=a,o=!i)}return o?s:-s-1}(e,t,n||ck)}(e,t,n);e.splice(s<0?-(s+1):s,0,t)}function ck(e,t){return e>t?1:e<t?-1:0}function dk(e,t,n,s,r){return fk(e,t,n,s,r,0)}function pk(e,t,n,s,r,a){return fk(e,t,n,s,r,0,!1,a,!0)}function hk(e,t,n,s,r,a){return fk(e,t,n,s,r,a,!0)}function fk(e,t,n,s,r,a,o=!1,i=!1,u=!1){const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(bk);const c=a>0?-.5/a:0,d=[],p=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:o}=t;if(n<r)break;let i=!1;for(let u=d.length-1;u>=o;--u){const n=mk(e,a,d[u]);if(n>=s){i=!0;break}if(t.score=t.score*gk(s,c,n),t.score<=r)break}t.suppressBeginIndex=d.length,i||(t.score===n?(d.push(a),p.push(t.score)):t.score>r&&lk(l,t,bk))}const h=d.length,f=n-h;i&&f>0&&(d.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=p),u&&(m.validOutputs=h),m}function mk(e,t,n){const s=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),a=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),h=(i-a)*(u-o),f=(d-l)*(p-c);if(h<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(o,c),b=Math.min(i,d),y=Math.min(u,p),v=Math.max(b-m,0)*Math.max(y-g,0);return v/(h+f-v)}function gk(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function bk(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}oy({stft_:function(e,t,n,s,r=ok){null==s&&(s=Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2)))));const a=ik(e,t,n),o=Ox(a,r(t));return Ww(o,s)}}),oy({cropAndResize_:function(e,t,n,s,r="bilinear",a=0){const o=ry(e,"image","cropAndResize"),i=ry(t,"boxes","cropAndResize","float32"),u=ry(n,"boxInd","cropAndResize","int32"),l=i.shape[0];return Ih(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),Ih(2===i.rank&&4===i.shape[1],()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),Ih(1===u.rank&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),Ih(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),Ih(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),Ih("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),Zb.runKernel(Hf,{image:o,boxes:i,boxInd:u},{method:r,extrapolationValue:a,cropSize:s})}}),oy({flipLeftRight_:function(e){const t=ry(e,"image","flipLeftRight","float32");return Ih(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),Zb.runKernel(fm,{image:t},{})}}),oy({rotateWithOffset_:function(e,t,n=0,s=.5){const r=ry(e,"image","rotateWithOffset","float32");return Ih(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),Zb.runKernel(nb,{image:r},{radians:t,fillValue:n,center:s})}}),oy({nonMaxSuppression_:function(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=ry(e,"boxes","nonMaxSuppression"),o=ry(t,"scores","nonMaxSuppression"),i=uk(a,o,n,s,r);return Zb.runKernel(tg,{boxes:a,scores:o},{maxOutputSize:n=i.maxOutputSize,iouThreshold:s=i.iouThreshold,scoreThreshold:r=i.scoreThreshold})}}),oy({nonMaxSuppressionWithScore_:function(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=ry(e,"boxes","nonMaxSuppression"),i=ry(t,"scores","nonMaxSuppression"),u=uk(o,i,n,s,r,a),l=Zb.runKernel(sg,{boxes:o,scores:i},{maxOutputSize:n=u.maxOutputSize,iouThreshold:s=u.iouThreshold,scoreThreshold:r=u.scoreThreshold,softNmsSigma:a=u.softNmsSigma});return{selectedIndices:l[0],selectedScores:l[1]}}}),oy({nonMaxSuppressionPadded_:function(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=ry(e,"boxes","nonMaxSuppression"),i=ry(t,"scores","nonMaxSuppression"),u=uk(o,i,n,s,r,null),l=Zb.runKernel(ng,{boxes:o,scores:i},{maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:a});return{selectedIndices:l[0],validOutputs:l[1]}}});const yk=oy({resizeBilinear_:function(e,t,n=!1,s=!1){const r=ry(e,"images","resizeBilinear");Ih(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),Ih(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Ih(!1===s||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;3===r.rank&&(o=!0,a=Xv(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i=Zb.runKernel(yg,{images:a},{alignCorners:n,halfPixelCenters:s,size:t});return o?Xv(i,[i.shape[1],i.shape[2],i.shape[3]]):i}}),vk=oy({resizeNearestNeighbor_:function(e,t,n=!1,s=!1){const r=ry(e,"images","resizeNearestNeighbor");Ih(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),Ih(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Ih("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Ih(!1===s||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;3===r.rank&&(o=!0,a=Xv(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i=Zb.runKernel(gg,{images:a},{alignCorners:n,halfPixelCenters:s,size:t});return o?Xv(i,[i.shape[1],i.shape[2],i.shape[3]]):i}}),xk=oy({bincount_:function(e,t,n){const s=ry(e,"x","bincount"),r=ry(t,"weights","bincount");return Ih("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),Ih(n>=0,()=>`size must be non-negative, but got ${n}.`),Ih(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),Zb.runKernel(Af,{x:s,weights:r},{size:n})}}),wk=oy({lessEqual_:function(e,t){let n=ry(e,"a","lessEqual"),s=ry(t,"b","lessEqual");return[n,s]=jb(n,s),wx(n.shape,s.shape),Zb.runKernel(Tm,{a:n,b:s})}}),kk=oy({round_:function(e){const t=ry(e,"x","round");return Zb.runKernel(kg,{x:t})}});function Ck(e,t,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");return Zb.runKernel(dg,{},{start:e,stop:t,step:n,dtype:s})}oy({threshold_:function(e,t="binary",n=!1,s=.5){const r=ry(e,"image","threshold"),a=r.shape[0]*r.shape[1];let o,i,u,l,c=Ox(Rw([s]),255);if(Ih(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),Ih(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),Ih("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),Ih("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===r.shape[2]){[o,i,u]=Ew(r,[1,1,1],-1);const e=Ox(o,.2989),t=Ox(i,.587),n=Ox(u,.114);l=Rv(Rv(e,t),n)}else l=e;"otsu"===t&&(c=function(e,t){let n,s,r,a,o,i,u=Rw([-1]),l=Rw([0]),c=Rw([0]);for(let d=0;d<e.size-1;d++){n=xw(e,0,d+1),s=xw(e,d+1),o=bx(zx(n),t),i=bx(zx(s),t);const p=zx(Ox(n,Ck(0,n.size)));r=bx(p,zx(n));const h=Sx(s.shape,n.size),f=Rv(Ck(0,s.size),h),m=Ox(s,f);a=bx(zx(m),zx(s));const g=qx(r,a),b=qx(r,a),y=Ox(o,i);c=Ox(Ox(y,g),b);const v=$x(c,l);l=zw(v,c,l),u=zw(v,Rw([d]),u)}return u}(xk(Uy(kk(l),"int32"),ly([]),256),a));const d=n?wk(l,c):$x(l,c);return Uy(Ox(d,255),"int32")}}),oy({transform_:function(e,t,n="nearest",s="constant",r=0,a){const o=ry(e,"image","transform","float32"),i=ry(t,"transforms","transform","float32");return Ih(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),Ih(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Ih(null==a||2===a.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`),Zb.runKernel(Xg,{image:o,transforms:i},{interpolation:n,fillMode:s,fillValue:r,outputShape:a})}});const Ik=oy({bandPart_:function(e,t,n){Ih(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Ih(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=ry(e,"a","bandPart");Ih(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,o]=s.shape.slice(-2);if(!(t<=a))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);t<0&&(t=a),n<0&&(n=o);const i=Xv(Ck(0,a,1,"int32"),[-1,1]),u=Ck(0,o,1,"int32"),l=qx(i,u),c=Lx(wk(l,$v(+t,"int32")),Tx(l,$v(-n,"int32"))),d=aw([a,o],s.dtype);return Xv(Tw(Ow(Xv(s,[-1,a,o])).map(e=>zw(c,e,d))),r)}}),_k=oy({pow_:function(e,t){let n=ry(e,"base","pow"),s=ry(t,"exp","pow");return[n,s]=jb(n,s),Zb.runKernel(ug,{a:n,b:s})}});function Sk(e,t,n=null){if(0===e.rank)return Av(e);if(1!==e.rank&&null===n)return Sk(Xv(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return zx(Av(e),n);if(t===1/0)return Dx(Av(e),n);if(t===-1/0)return Wx(Av(e),n);if("euclidean"===t||2===t)return Nw(zx(_k(Av(e),$v(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Dx(zx(Av(e),n[0]),n[1]-1);if(t===1/0)return Dx(zx(Av(e),n[1]),n[0]);if(t===-1/0)return Wx(zx(Av(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Nw(zx(ew(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ek=oy({norm_:function(e,t="euclidean",n=null,s=!1){const r=Sk(e=ry(e,"x","norm"),t,n);let a=r.shape;if(s){const t=Oh(n,e.shape);a=Xx(r.shape,t)}return Xv(r,a)}}),Nk=oy({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Ih(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Ih(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=Ew(e,e.shape[0],0).map(e=>$w(e,[0]));Ih(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],s=e;for(let r=0;r<e.length;++r)n.push(Zb.tidy(()=>{let e=s[r];if(r>0)for(let t=0;t<r;++t){const s=Ox(zx(Ox(n[t],e)),n[t]);e=qx(e,s)}return bx(e,Ek(e,"euclidean"))}));return t?Tw(n,0):n}});function $k(e,t=!1){return Zb.tidy(()=>{Ih(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],s=e.shape[1];let r=_x(n),a=Gy(e);const o=Fw([[1]],[1,1]);let i=Gy(o);const u=n>=s?s:n;for(let e=0;e<u;++e){const t=a,u=i,l=r;[i,a,r]=Zb.tidy(()=>{const t=xw(a,[e,e],[n-e,1]),u=Ek(t),l=xw(a,[e,e],[1,1]),c=zw($x(l,0),Fw([[-1]]),Fw([[1]])),d=qx(l,Ox(c,u)),p=bx(t,d);i=1===p.shape[0]?Gy(o):sx([o,xw(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);const h=nw(bx(sk(c,d),u)),f=xw(a,[e,0],[n-e,s]),m=Ox(h,i),g=Lw(i);if(0===e)a=qx(f,sk(m,sk(g,f)));else{const t=qx(f,sk(m,sk(g,f)));a=sx([xw(a,[0,0],[e,s]),t],0)}const b=Lw(m),y=xw(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=qx(y,sk(sk(y,i),b));else{const t=qx(y,sk(sk(y,i),b));r=sx([xw(r,[0,0],[n,e]),t],1)}return[i,a,r]}),_v([t,u,l])}return!t&&n>s&&(r=xw(r,[0,0],[n,s]),a=xw(a,[0,0],[s,s])),[r,a]})}const Tk=oy({qr_:function(e,t=!1){if(Ih(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return $k(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),s=Ow(Xv(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],a=[];return s.forEach(e=>{const[n,s]=$k(e,t);r.push(n),a.push(s)}),[Xv(Tw(r,0),e.shape),Xv(Tw(a,0),e.shape)]}}});var Ak;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Ak||(Ak={}));const Rk=oy({computeWeightedLoss_:function(e,t,n=Ak.SUM_BY_NONZERO_WEIGHTS){const s=ry(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=ry(t,"weights","computeWeightedLoss"));const a=null==r?s:Ox(s,r);if(n===Ak.NONE)return a;if(n===Ak.SUM)return zx(a);if(n===Ak.MEAN){if(null==r)return Bx(a);{const e=s.size/r.size,t=bx(zx(a),zx(r));return e>1?bx(t,$v(e)):t}}if(n===Ak.SUM_BY_NONZERO_WEIGHTS){if(null==r)return bx(zx(a),$v(s.size));{const e=Ox(r,ow(s.shape)),t=Uy(zx(sw(e,$v(0))),"float32");return bx(zx(a),t)}}throw Error(`Unknown reduction: ${n}`)}});oy({absoluteDifference_:function(e,t,n,s=Ak.SUM_BY_NONZERO_WEIGHTS){const r=ry(e,"labels","absoluteDifference"),a=ry(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=ry(n,"weights","absoluteDifference")),_h(r.shape,a.shape,"Error in absoluteDifference: ");const i=Av(qx(r,a));return Rk(i,o,s)}}),oy({cosineDistance_:function(e,t,n,s,r=Ak.SUM_BY_NONZERO_WEIGHTS){const a=ry(e,"labels","cosineDistance"),o=ry(t,"predictions","cosineDistance");let i=null;null!=s&&(i=ry(s,"weights","cosineDistance")),_h(a.shape,o.shape,"Error in cosineDistance: ");const u=$v(1),l=qx(u,zx(Ox(a,o),n,!0));return Rk(l,i,r)}}),oy({hingeLoss_:function(e,t,n,s=Ak.SUM_BY_NONZERO_WEIGHTS){let r=ry(e,"labels","hingeLoss");const a=ry(t,"predictions","hingeLoss");let o=null;null!=n&&(o=ry(n,"weights","hingeLoss")),_h(r.shape,a.shape,"Error in hingeLoss: ");const i=$v(1);r=qx(Ox($v(2),r),i);const u=mw(qx(i,Ox(r,a)));return Rk(u,o,s)}}),oy({huberLoss_:function(e,t,n,s=1,r=Ak.SUM_BY_NONZERO_WEIGHTS){const a=ry(e,"labels","huberLoss"),o=ry(t,"predictions","huberLoss");let i=null;null!=n&&(i=ry(n,"weights","huberLoss")),_h(a.shape,o.shape,"Error in huberLoss: ");const u=$v(s),l=Av(qx(o,a)),c=Ux(l,u),d=qx(l,c),p=Rv(Ox($v(.5),ew(c)),Ox(u,d));return Rk(p,i,r)}}),oy({logLoss_:function(e,t,n,s=1e-7,r=Ak.SUM_BY_NONZERO_WEIGHTS){const a=ry(e,"labels","logLoss"),o=ry(t,"predictions","logLoss");let i=null;null!=n&&(i=ry(n,"weights","logLoss")),_h(a.shape,o.shape,"Error in logLoss: ");const u=$v(1),l=$v(s),c=nw(Ox(a,Rx(Rv(o,l)))),d=Ox(qx(u,a),Rx(Rv(qx(u,o),l))),p=qx(c,d);return Rk(p,i,r)}});const Fk=oy({squaredDifference_:function(e,t){let n=ry(e,"a","squaredDifference"),s=ry(t,"b","squaredDifference");return[n,s]=jb(n,s),wx(n.shape,s.shape),Zb.runKernel(Vg,{a:n,b:s},{})}});oy({meanSquaredError_:function(e,t,n,s=Ak.SUM_BY_NONZERO_WEIGHTS){const r=ry(e,"labels","meanSquaredError"),a=ry(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=ry(n,"weights","meanSquaredError")),_h(r.shape,a.shape,"Error in meanSquaredError: ");const i=Fk(r,a);return Rk(i,o,s)}});const Dk=oy({log1p_:function(e){const t=ry(e,"x","log1p");return Zb.runKernel(Fm,{x:t})}});oy({sigmoidCrossEntropy_:function(e,t,n,s=0,r=Ak.SUM_BY_NONZERO_WEIGHTS){let a=ry(e,"multiClassLabels","sigmoidCrossEntropy");const o=ry(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=ry(n,"weights","sigmoidCrossEntropy")),_h(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const e=$v(s),t=$v(1),n=$v(.5);a=Rv(Ox(a,qx(t,e)),Ox(n,e))}const u=function(e,t){const n=ry(e,"labels","sigmoidCrossEntropyWithLogits"),s=ry(t,"logits","sigmoidCrossEntropyWithLogits");_h(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=mw(s),a=Ox(s,n),o=Dk(Fx(nw(Av(s))));return Rv(qx(r,a),o)}(a,o);return Rk(u,i,r)}});const Ok=oy({logSumExp_:function(e,t=null,n=!1){const s=ry(e,"x","logSumExp"),r=Oh(t,s.shape),a=Dx(s,r,!0),o=qx(s,a),i=Fx(o),u=zx(i,r),l=Rx(u),c=Rv(Xv(a,l.shape),l);if(n){const e=Xx(c.shape,r);return Xv(c,e)}return c}});oy({softmaxCrossEntropy_:function(e,t,n,s=0,r=Ak.SUM_BY_NONZERO_WEIGHTS){let a=ry(e,"onehotLabels","softmaxCrossEntropy");const o=ry(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=ry(n,"weights","softmaxCrossEntropy")),_h(a.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const e=$v(s),t=$v(1),n=$v(a.shape[1]);a=Rv(Ox(a,qx(t,e)),bx(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Nv((e,t,s)=>{const r=Ok(t,[n],!0),a=qx(Uy(t,"float32"),r);s([e,a]);const o=nw(Ox(a,e));return{value:zx(o,[n]),gradFunc:(e,t)=>{const[s,r]=t,a=Xx(e.shape,[n]);return[Ox(Xv(e,a),qx(Uy(s,"float32"),Fx(r))),Ox(Xv(e,a),qx(Fx(r),Uy(s,"float32")))]}}})(e,t)}(a,o);return Rk(u,i,r)}}),oy({sparseFillEmptyRows_:function(e,t,n,s){const r=ry(e,"indices","sparseFillEmptyRows"),a=ry(t,"values","sparseFillEmptyRows"),o=ry(n,"denseShape","sparseFillEmptyRows"),i=ry(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==r.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==i.rank)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u=Zb.runKernel(Mg,{indices:r,values:a,denseShape:o,defaultValue:i});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),oy({sparseReshape_:function(e,t,n){const s=ry(e,"inputIndices","sparseReshape"),r=ry(t,"inputShape","sparseReshape"),a=ry(n,"newShape","sparseReshape");if(2!==s.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==r.rank)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o=Zb.runKernel(Lg,{inputIndices:s,inputShape:r,newShape:a});return{outputIndices:o[0],outputShape:o[1]}}});const qk={bandPart:Ik,gramSchmidt:Nk,qr:Tk};class zk extends Tv{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Zb.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Zb.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Iv(()=>Mw(s).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Iv(()=>Mw(s).variable(!1))});const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Iv(()=>{const e=Rv(Ox(a,this.rho),Ox(ew(r),1-this.rho)),t=Ox(bx(Nw(Rv(o,this.epsilon)),Nw(Rv(a,this.epsilon))),r),n=Rv(Ox(o,this.rho),Ox(ew(t),1-this.rho));a.assign(e),o.assign(n);const i=Rv(Ox(t,-this.learningRate),s);s.assign(i)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(_v(this.accumulatedGrads.map(e=>e.variable)),_v(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return bh(function*(){const t=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bh(function*(){const n=(e=yield t.extractIterations(e)).length/2;t.accumulatedGrads=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedUpdates=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}zk.className="Adadelta",wv(zk);class Mk extends Tv{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Zb.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Iv(()=>Sx(s.shape,this.initialAccumulatorValue).variable(e))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=this.accumulatedGrads[n].variable;Iv(()=>{const e=Rv(a,ew(r));a.assign(e);const t=Rv(Ox(bx(r,Nw(Rv(e,Zb.backend.epsilon()))),-this.learningRate),s);s.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&_v(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return bh(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bh(function*(){e=yield t.extractIterations(e),t.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Mk.className="Adagrad",wv(Mk);class Lk extends Tv{constructor(e,t,n,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Iv(()=>{this.accBeta1=$v(t).variable(),this.accBeta2=$v(n).variable()}),null==s&&(this.epsilon=Zb.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Iv(()=>{const n=qx(1,this.accBeta1),s=qx(1,this.accBeta2);t.forEach((t,r)=>{const a=Zb.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:Iv(()=>Mw(a).variable(!1))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${t}/v`,variable:Iv(()=>Mw(a).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[r].variable,u=this.accumulatedSecondMoment[r].variable,l=Rv(Ox(i,this.beta1),Ox(o,1-this.beta1)),c=Rv(Ox(u,this.beta2),Ox(ew(o),1-this.beta2)),d=bx(l,n),p=bx(c,s);i.assign(l),u.assign(c);const h=Rv(Ox(bx(d,Rv(Nw(p),this.epsilon)),-this.learningRate),a);a.assign(h)}),this.accBeta1.assign(Ox(this.accBeta1,this.beta1)),this.accBeta2.assign(Ox(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&_v(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&_v(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return bh(function*(){const t=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bh(function*(){e=yield t.extractIterations(e),Iv(()=>{t.accBeta1.assign(_k(t.beta1,t.iterations_+1)),t.accBeta2.assign(_k(t.beta2,t.iterations_+1))});const n=e.length/2;t.accumulatedFirstMoment=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),t.accumulatedSecondMoment=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}Lk.className="Adam",wv(Lk);class Pk extends Tv{constructor(e,t,n,s=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=s,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Iv(()=>{this.iteration=$v(0).variable(),this.accBeta1=$v(t).variable()}),null==s&&(this.epsilon=Zb.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Iv(()=>{const n=qx(1,this.accBeta1),s=bx(-this.learningRate,Rv(Ox(this.iteration,this.decay),1));t.forEach((t,r)=>{const a=Zb.registeredVariables[t];null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:Mw(a).variable(!1)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${t}/v`,variable:Mw(a).variable(!1)});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const i=this.accumulatedFirstMoment[r].variable,u=this.accumulatedWeightedInfNorm[r].variable,l=Rv(Ox(i,this.beta1),Ox(o,1-this.beta1)),c=Ox(u,this.beta2),d=Av(o),p=jx(c,d);i.assign(l),u.assign(p);const h=Rv(Ox(bx(s,n),bx(l,Rv(p,this.epsilon))),a);a.assign(h)}),this.iteration.assign(Rv(this.iteration,1)),this.accBeta1.assign(Ox(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&_v(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&_v(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return bh(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return bh(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Pk.className="Adamax",wv(Pk);class Vk extends Tv{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const r=Zb.registeredVariables[t];Iv(()=>{const e=Rv(Ox(this.c,s),r);r.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Sv($v(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return bh(function*(){return[yield e.saveIterations()]})()}setWeights(e){var t=this;return bh(function*(){if(0!==(e=yield t.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Vk.className="SGD",wv(Vk);class jk extends Vk{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=$v(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Zb.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Iv(()=>Mw(s).variable(e))}}const r=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Iv(()=>{let e;const t=Rv(Ox(this.m,r),a);e=Rv(Ox(this.c,this.useNesterov?Rv(a,Ox(t,this.m)):t),s),r.assign(t),s.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&_v(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return bh(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bh(function*(){e=yield t.extractIterations(e),t.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}jk.className="Momentum",wv(jk);class Bk extends Tv{constructor(e,t=.9,n=0,s=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==s&&(this.epsilon=Zb.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const s=Zb.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Iv(()=>Mw(s).variable(r))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Iv(()=>Mw(s).variable(r))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Iv(()=>Mw(s).variable(r))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Iv(()=>{const e=Rv(Ox(o,this.decay),Ox(ew(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=Rv(Ox(t,this.decay),Ox(a,1-this.decay)),u=bx(Ox(a,this.learningRate),Nw(qx(e,Rv(ew(r),this.epsilon)))),l=Rv(Ox(i,this.momentum),u);o.assign(e),t.assign(r),i.assign(l);const c=qx(s,l);s.assign(c)}else{const e=Rv(Ox(o,this.decay),Ox(ew(a),1-this.decay)),t=Rv(Ox(i,this.momentum),bx(Ox(a,this.learningRate),Nw(Rv(e,this.epsilon))));o.assign(e),i.assign(t);const n=qx(s,t);s.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&_v(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&_v(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&_v(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return bh(function*(){const t=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&t.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(e){var t=this;return bh(function*(){e=yield t.extractIterations(e);const n=t.centered?e.length/3:e.length/2,s=!1;t.accumulatedMeanSquares=e.slice(0,n).map(e=>({originalName:e.name,variable:e.tensor.variable(s)})),t.accumulatedMoments=e.slice(n,2*n).map(e=>({originalName:e.name,variable:e.tensor.variable(s)})),t.centered&&(t.accumulatedMeanGrads=e.slice(2*n,3*n).map(e=>({originalName:e.name,variable:e.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Bk.className="RMSProp",wv(Bk);class Wk{static sgd(e){return new Vk(e)}static momentum(e,t,n=!1){return new jk(e,t,n)}static rmsprop(e,t=.9,n=0,s=null,r=!1){return new Bk(e,t,n,s,r)}static adam(e=.001,t=.9,n=.999,s=null){return new Lk(e,t,n,s)}static adadelta(e=.001,t=.95,n=null){return new zk(e,t,n)}static adamax(e=.002,t=.9,n=.999,s=null,r=0){return new Pk(e,t,n,s,r)}static adagrad(e,t=.1){return new Mk(e,t)}}const Uk={sgd:Wk.sgd,momentum:Wk.momentum,adadelta:Wk.adadelta,adagrad:Wk.adagrad,rmsprop:Wk.rmsprop,adamax:Wk.adamax,adam:Wk.adam},Gk="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Hk(){return new Promise(e=>Gk(()=>e()))}function Kk(e,t){const n=e[0].length;e.forEach((e,t)=>{Ih(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),Ih(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=e[0];e.forEach((e,r)=>{for(let a=0;a<n;a++)Ih(a===t||e[a]===s[a],()=>`Error in concat${n}D: Shape of tensors[${r}] (${e}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function Xk(e,t){const n=e[0].slice();for(let s=1;s<e.length;s++)n[t]+=e[s][t];return n}const Zk=30;function Yk(e){return e<=Zk?e:Gh(e,Math.floor(Math.sqrt(e)))}function Qk(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Jk(e,t,n,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)r=r.concat([e[s+1]/t[s],t[s]]);r=r.concat(e.slice(n+1))}return r}function eC(e,t,n=!0){const s=[];if(n){s.push(t);for(let n=t+1;n<e;++n)n<=2*t?(s.push(n),s.push(n-(t+1))):s.push(n)}else{const n=[],r=[];for(let s=1;s<e;++s)s>=2*t+1||s%2==1?r.push(s):n.push(s);s.push(...n),s.push(0),s.push(...r)}return s}function tC(e,t,n,s=!0){const r=[];r.push(s?e[0]/n:e[0]*n);for(let a=1;a<e.length;++a)r.push(a<=t.length?s?t[a-1]*e[a]:e[a]/t[a-1]:e[a]);return r}function nC(e,t){const n=[0];for(let s=0;s<t;++s)n.push(e[s][0]);return n}function sC(e,t,n){const s=e.slice(0,1);for(let r=0;r<n;++r)s.push(e[r+1]-t[r][0]-t[r][1]);return s}function rC(e,t){const n=e.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(0===Nh(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,a=r[r.length-1];let o=1;for(let d=0;d<r.length-1;++d)o*=r[d];const i=e.shape,u=r.slice();u.pop();let l=1;for(let d=a;d<n;++d)l*=i[d],u.push(i[d]);const c=[...Hh(e.shape).map(e=>e/l),1].slice(0,a);return[u,o,l,c]}function aC(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(a+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(a+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(a+" update.rank != "+(r+e.length-s));for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+s])throw new Error(a+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${e[o+r]})`)}function oC(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}aC(n,t,e)}function iC(e,t,n){const s=t.shape.length,r=s>1?t.shape[s-1]:1,a=n.length;let o=1;for(let u=r;u<a;++u)o*=n[u];const i=r<1?1:r;return{sliceRank:r,numUpdates:Nh(t.shape)/i,sliceSize:o,strides:[...Hh(n.slice(0,r)),1],outputSize:Nh(n)}}const uC=1.7580993408473768,lC=1.0507009873554805,cC=.3275911,dC=.254829592,pC=-.284496736,hC=1.421413741,fC=-1.453152027,mC=1.061405429;function gC(...e){af().getBool("IS_TEST")||console.warn(...e)}function bC(...e){af().getBool("IS_TEST")||console.log(...e)}function yC(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let s=0;s<n.length;s+=2)n[s]=e[s/2],n[s+1]=t[s/2];return n}function vC(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=e[s],n[s/2]=e[s+1];return{real:t,imag:n}}function xC(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function wC(e){const t=Math.floor(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function kC(e,t){return{real:e[2*t],imag:e[2*t+1]}}function CC(e,t,n,s){e[2*s]=t,e[2*s+1]=n}function IC(e,t){const n=new Float32Array(e/2),s=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const a=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:n,imag:s}}function _C(e,t,n){const s=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(s),imag:Math.sin(s)}}const SC=/->/g;function EC(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(SC,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[s,r]=e.split("->");Ih(-1===s.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const a=s.split(","),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<r.length;++d){const e=r[d];if(!a.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===i.indexOf(e)&&i.push(e)}for(let d=0;d<s.length;++d){const e=s[d];-1===i.indexOf(e)&&","!==e&&i.push(e)}const u=new Array(a.length);for(let d=0;d<o;++d){if(new Set(a[d].split("")).size!==a[d].length)throw new Error(`Found duplicate axes in input component ${a[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let e=0;e<a[d].length;++e)u[d].push(i.indexOf(a[d][e]))}const l=i.length,c=[];for(let d=r.length;d<l;++d)c.push(d);return{allDims:i,summedDims:c,idDims:u}}function NC(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const s=[];for(let r=0;r<e;++r)-1===n[r]&&s.push(r);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:s}}function $C(e,t,n){const s=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===s[t[r][n]]?s[t[r][n]]=e[n]:Ih(s[t[r][n]]===e[n],()=>`Expected dimension ${s[t[r][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`)}}function TC(e,t){const n=e,s=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let o=0;o<r;++o)s.push([]);const a=[];for(let o=0;o<n.length;++o){const e=RC(t,n[o]);for(const t of e)-1===a.indexOf(t)&&(s[o].push(t),a.push(t))}return{path:n,steps:s}}function AC(e){return e.every((e,t)=>e===t)}function RC(e,t){const n=[];for(let s=0;s<e.length;++s)0!==e[s].length&&-1===e[s].indexOf(t)&&-1!==t||n.push(s);return n}function FC(e,t,n=0){let s=[];if("number"==typeof t)Ih(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(e.shape[n]/t);else{Ih(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");const r=t.indexOf(-1);if(-1!==r){const s=t.reduce((e,t)=>t>0?e+t:e);t[r]=e.shape[n]-s}Ih(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function DC(e,t){let n,s=!1;for(e<=Zk?(n=e,s=!0):n=Gh(e,Math.floor(Math.sqrt(e)));!s;)n>t||n===e?s=!0:n=Gh(e,n+1);return n}function OC(e,t,n){const s=[],r=e.length;for(let a=0;a<r;a++)s.push(a!==t?e[a]:n);return s}function qC(e,t,n,s){const r=t.shape.length,a=e.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let d=0;d<s;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=e.shape[n],i=[];let u=1,l=1,c=1;for(let d=0;d<s;++d)i.push(e.shape[d]),u*=e.shape[d];for(let d=s;d<n;d++)i.push(e.shape[d]),l*=e.shape[d];for(let d=s;d<r;d++)i.push(t.shape[d]);for(let d=n+1;d<a;d++)i.push(e.shape[d]),c*=e.shape[d];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}function zC(e){try{return e.map(e=>yb(e))}catch(oK){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${oK}`)}}function MC(e){return e.map(e=>bb(e))}function LC(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const s=Wy(e,"int32"),r=Wy([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=s.indexToLoc(n[a]);r.values.set(t,a*e.length)}return r.toTensor()}const PC={kernelName:df,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Xw(Uy(n,"float32"),-1))}}},VC={kernelName:pf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ew(Uy(n,"float32")),s=Nw(qx($v(1),t));return nw(bx(e,s))}}}},jC={kernelName:hf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Nw(qx(ew(Uy(n,"float32")),1));return bx(e,t)}}}},BC={kernelName:ff,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=wx(n.shape,s.shape);return{a:()=>{let t=e;const s=xx(n.shape,r);return s.length>0&&(t=zx(t,s)),Xv(t,n.shape)},b:()=>{let t=e;const n=xx(s.shape,r);return n.length>0&&(t=zx(t,n)),Xv(t,s.shape)}}}},WC={kernelName:mf,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,s)=>{n[s]=()=>e.clone()}),n}},UC={kernelName:yf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Mw(n)}}},GC={kernelName:vf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Mw(n)}}},HC={kernelName:xf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Nw(qx($v(1),ew(Uy(n,"float32")))))}}},KC={kernelName:wf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Nw(Rv($v(1),ew(Uy(n,"float32"))));return bx(e,t)}}}},XC={kernelName:If,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=wx(n.shape,s.shape);return{a:()=>{const t=Rv(ew(n),ew(s));let a=Ox(e,bx(s,t));const o=xx(n.shape,r);return o.length>0&&(a=zx(a,o)),Xv(a,n.shape)},b:()=>{const t=Rv(ew(n),ew(s));let a=nw(Ox(e,bx(n,t)));const o=xx(s.shape,r);return o.length>0&&(a=zx(a,o)),Xv(a,s.shape)}}}},ZC={kernelName:kf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Rv(ew(Uy(n,"float32")),1))}}},YC={kernelName:Cf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,qx($v(1),ew(Uy(n,"float32"))))}}},QC=oy({avgPool3dGrad_:function(e,t,n,s,r,a){const o=ry(e,"dy","avgPool3dGrad"),i=ry(t,"input","avgPool3dGrad");let u=o,l=i,c=!1;4===i.rank&&(c=!0,u=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),l=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ih(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),Ih(5===l.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),null!=a&&Ih(Th(r),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${r}.`);const d=Zb.runKernel(Nf,{dy:u,input:l},{filterSize:n,strides:s,pad:r,dimRoundingMode:a});return c?Xv(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),JC={kernelName:Ef,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:a,pad:o,dimRoundingMode:i}=n;return{x:()=>QC(e,s,r,a,o,i)}}},eI=oy({avgPoolGrad_:function(e,t,n,s,r){const a=ry(e,"dy","avgPoolGrad"),o=ry(t,"input","avgPoolGrad");Ih(o.rank===a.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`);let i=o,u=a,l=!1;3===o.rank&&(l=!0,i=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ih(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),Ih(4===i.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);const c=Zb.runKernel(Sf,{dy:u,input:i},{filterSize:n,strides:s,pad:r});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),tI={kernelName:_f,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:a,pad:o}=n;return{x:()=>eI(e,s,r,a,o)}}},nI={kernelName:$f,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[s,r]=t,{transposeA:a,transposeB:o}=n;return a||o?!a&&o?{a:()=>sk(e,r,!1,!1),b:()=>sk(e,s,!0,!1)}:a&&!o?{a:()=>sk(r,e,!1,!0),b:()=>sk(s,e,!1,!1)}:{a:()=>sk(r,e,!0,!0),b:()=>sk(e,s,!0,!0)}:{a:()=>sk(e,r,!1,!0),b:()=>sk(s,e,!0,!1)}}},sI=oy({spaceToBatchND_:function(e,t,n){const s=ry(e,"x","spaceToBatchND");return Ih(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),Ih(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Ih(s.shape.reduce((e,s,r)=>r>0&&r<=t.length?e&&(s+n[r-1][0]+n[r-1][1])%t[r-1]==0:e,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),Zb.runKernel(Og,{x:s},{blockShape:t,paddings:n})}}),rI={kernelName:Tf,gradFunc:(e,t,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>sI(e,s,r)}}},aI={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const s=n.inputShape,r=n.shape,a=Array.from(r);for(let i=s.length-1;i>=0;i--)if(s[i]===r[i])a[i]=1;else if(1!==s[i])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${r}].`);const o=[];for(let i=0;i<a.length;i++)a[i]>1&&o.push(i);return{x:()=>zx(e,o,!0)}}},oI={kernelName:Rf,gradFunc:e=>({x:()=>e.clone()})},iI={kernelName:Ff,gradFunc:e=>({x:()=>Mw(e)})},uI={kernelName:Df,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{clipValueMin:r,clipValueMax:a}=n;return{x:()=>zw(Lx(Tx(s,r),wk(s,a)),e,Mw(e))}}},lI={kernelName:qf,inputsToSave:["x"],gradFunc:PC.gradFunc},cI={kernelName:zf,saveAllInputs:!0,gradFunc:(e,t,n)=>{const s=t.map(e=>e.shape),{axis:r}=n,a=Oh(r,t[0].shape)[0],o=s.map(e=>e[a]);return Ew(e,o,a).map(e=>()=>e)}},dI={kernelName:Mf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{dilations:a,strides:o,pad:i,dataFormat:u}=n;return Ih(Gv(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>cx(s.shape,e,r,o,i,u),filter:()=>Hw(s,e,r.shape,o,i,u)}}},pI={kernelName:Pf,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{strides:a,pad:o,dataFormat:i,dimRoundingMode:u}=n;return{dy:()=>ux(e,r,a,o,i,1,u),filter:()=>Hw(e,s,r.shape,a,o,i,u)}}},hI=oy({conv3DBackpropFilter_:function(e,t,n,s,r){let a=e;4===e.rank&&(a=Xv(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;return 4===o.rank&&(o=Xv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Ih(5===a.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Ih(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),Ih(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Ih(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Ih(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`),Zb.runKernel(jf,{x:a,dy:o},{strides:s,pad:r,filterShape:n})}}),fI={kernelName:Vf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:a}=n;Ih(Gv(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,i]=t;return{x:()=>hx(o.shape,e,i,r,a),filter:()=>hI(o,e,i.shape,r,a)}}},mI=oy({sin_:function(e){const t=ry(e,"x","sin");return Zb.runKernel(Ng,{x:t})}}),gI={kernelName:Wf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(nw(mI(Uy(n,"float32"))),e)}}},bI=oy({sinh_:function(e){const t=ry(e,"x","sinh");return Zb.runKernel($g,{x:t})}}),yI={kernelName:Uf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(bI(Uy(n,"float32")),e)}}},vI=oy({cumsum_:function(e,t=0,n=!1,s=!1){const r=ry(e,"x","cumsum");return Zb.runKernel(Gf,{x:r},{axis:t,exclusive:n,reverse:s})}}),xI={kernelName:Gf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r,exclusive:a,reverse:o}=n;return{x:()=>{const t=Yx([r],s.rank);let n=vI(e,r,a,!o);return null!=t&&(n=Lw(n,t)),n}}}},wI={kernelName:Zf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:a,dimRoundingMode:o}=n,i=null==s?[1,1]:s;Ih(Gv(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[u,l]=t;return Ih(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),Ih(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),Ih(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),Ih(Hv(r,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${i}'.`),null!=o&&Ih(Th(a),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`),{x:()=>nk(u.shape,e,l,r,a,s,o),filter:()=>tk(u,e,l.shape,r,a,s,o)}}},kI={kernelName:em,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,a={x:s,filter:r,dy:e},o={x:s,filter:r,dy:e};return{x:()=>Zb.runKernel(tm,a,n),filter:()=>Zb.runKernel(nm,o,n)}}},CI={kernelName:am,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,s={dy:e,y:n};return{x:()=>Zb.runKernel(om,s)}}},II={kernelName:im,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=Ox(Fx(nw(ew(n))),2/Math.sqrt(Math.PI));return{x:()=>Ox(e,s)}}},_I={kernelName:lm,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,n)}}},SI={kernelName:cm,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Xv(e,n.shape)}}},EI={kernelName:dm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Fx(n))}}},NI={kernelName:mm,gradFunc:e=>({x:()=>Mw(e)})},$I={kernelName:gm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=wx(n.shape,s.shape);return{a:()=>{const t=bx(e,Uy(s,"float32")),a=xx(n.shape,r);return a.length>0?Xv(zx(t,a),n.shape):t},b:()=>{let t=Ox(e,Uy(n,"float32"));const a=xx(s.shape,r);a.length>0&&(t=Xv(zx(t,a),s.shape));const o=ew(s);return nw(bx(t,Uy(o,"float32")))}}}},TI=oy({rsqrt_:function(e){const t=ry(e,"x","rsqrt");return Zb.runKernel(Cg,{x:t})}}),AI={kernelName:bm,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:s}=n,[r,a,o,i]=t,u=null==i?$v(1):i,l=xx(a.shape,r.shape),c=[];if(1===a.rank){for(let e=0;e<r.shape.length-1;++e)c.push(r.shape[e]);c.push(1)}const d=qx(r,a),p=Ox(e,u),h=TI(Rv(o,$v(s))),f=Ox(Ox(Ox(h,h),h),$v(-.5));return{x:()=>Xv(Ox(Ox(e,1===a.rank?Ix(Xv(h,[1,1,1,a.shape[0]]),c):h),u),r.shape),mean:()=>{let e=Ox(Ox(h,$v(-1)),p);return 1===a.rank&&(e=zx(e,l)),Xv(e,a.shape)},variance:()=>{let e=Ox(Ox(f,d),p);return 1===a.rank&&(e=zx(e,l)),Xv(e,a.shape)},scale:()=>{const t=Ox(d,h);let n=Ox(e,t);return 1===a.rank&&(n=zx(n,l)),Xv(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=zx(t,l)),Xv(t,a.shape)}}}},RI=oy({unsortedSegmentSum_:function(e,t,n){const s=ry(e,"x","unsortedSegmentSum"),r=ry(t,"segmentIds","unsortedSegmentSum","int32");return Ih(Th(n),()=>"numSegments must be of dtype int"),Zb.runKernel(Jg,{x:s,segmentIds:r},{numSegments:n})}}),FI={kernelName:ym,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[s,r]=t,{axis:a}=n,o=Oh(a,s.shape)[0];return{x:()=>{const t=s.shape,n=r.size,i=t.slice(0,o),u=i.length,l=t.slice(a,t.length).slice(1),c=l.length,d=DI(0,u),p=DI(u+1,u+1+c),h=OI([i,[n],l]),f=Xv(e,h),m=Xv(r,[n]),g=OI([[u],d,p]),b=Lw(f,g);let y=RI(b,m,s.shape[o]);const v=Qx(g);return y=Lw(y,v),y},indices:()=>r}}};function DI(e,t){const n=[];for(let s=e;s<t;++s)n.push(s);return n}function OI(e){const t=[];for(let n=0;n<e.length;++n)for(let s=0;s<e[n].length;++s)t.push(e[n][s]);return t}const qI={kernelName:wm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Mw(n),b:()=>Mw(s)}}},zI={kernelName:km,gradFunc:e=>({x:()=>Uy(e,"float32")})},MI={kernelName:_m,gradFunc:e=>({x:()=>Mw(e)})},LI={kernelName:Sm,gradFunc:e=>({x:()=>Mw(e)})},PI={kernelName:Em,gradFunc:e=>({x:()=>Mw(e)})},VI={kernelName:Nm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{alpha:r}=n,a=$x(s,0);return{x:()=>zw(a,e,Ox(e,r))}}},jI={kernelName:Fm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Rv(n,1))}}},BI={kernelName:Rm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Uy(n,"float32"))}}},WI={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n;return{logits:()=>{const t=Fx(s);return qx(e,Ox(zx(e,r,!0),t))}}}},UI=oy({localResponseNormalizationBackprop_:function(e,t,n,s=5,r=1,a=1,o=.5){return Zb.runKernel(Mm,{x:e,y:t,dy:n},{depthRadius:s,bias:r,alpha:a,beta:o})}}),GI={kernelName:zm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{depthRadius:a,bias:o,alpha:i,beta:u}=n;return{x:()=>UI(s,r,e,a,o,i,u)}}};function HI(e,t,n,s){return t.rank<n.rank&&(t=Xv(t,Xx(t.shape,s))),e.rank<n.rank&&(e=Xv(e,Xx(e.shape,s))),{x:()=>Ox(e,Uy(kx(n,t),e.dtype))}}const KI={kernelName:Lm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{reductionIndices:r}=s,a=t[0],o=HI(e,t[1],a,Oh(r,a.shape));return{x:()=>o.x()}}},XI=oy({less_:function(e,t){let n=ry(e,"a","less"),s=ry(t,"b","less");return[n,s]=jb(n,s),wx(n.shape,s.shape),Zb.runKernel($m,{a:n,b:s})}}),ZI={kernelName:Pm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Ox(e,Uy(Tx(n,s),"float32")),b:()=>Ox(e,Uy(XI(n,s),"float32"))}}},YI=oy({maxPool3dGrad_:function(e,t,n,s,r,a,o){const i=ry(e,"dy","maxPool3dGrad"),u=ry(t,"input","maxPool3dGrad"),l=ry(n,"output","maxPool3dGrad");let c=i,d=u,p=l,h=!1;4===u.rank&&(h=!0,c=Xv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=Xv(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=Xv(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Ih(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Ih(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Ih(5===p.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),null!=o&&Ih(Th(a),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`);const f=Zb.runKernel(Wm,{dy:c,input:d,output:p},{filterSize:s,strides:r,pad:a,dimRoundingMode:o});return h?Xv(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),QI={kernelName:Bm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=n;return{x:()=>YI(e,s,r,a,o,i,u)}}},JI=oy({maxPoolGrad_:function(e,t,n,s,r,a,o){const i=ry(e,"dy","maxPoolGrad"),u=ry(t,"input","maxPoolGrad"),l=ry(n,"output","maxPoolGrad");return Ih(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),Ih(4===i.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),Ih(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),null!=o&&Ih(Th(a),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${a}.`),Zb.runKernel(jm,{dy:i,input:u,output:l},{filterSize:s,strides:r,pad:a,dimRoundingMode:o})}}),e_={kernelName:Vm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:a,strides:o,pad:i}=n;return{x:()=>JI(e,s,r,a,o,i)}}},t_={kernelName:Gm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n,a=Oh(r,s.shape),o=Nh(Kx(s.shape,a)[1]);return{x:()=>{const t=s.shape.slice();a.forEach(e=>{t[e]=1});const n=Xv(e,t);return bx(Ox(n,ow(s.shape,"float32")),o)}}}},n_={kernelName:Hm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{axis:r}=s,[a,o]=t,i=HI(e,o,a,Oh(r,a.shape));return{x:()=>i.x()}}},s_={kernelName:Km,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Ox(e,Uy(wk(n,s),"float32")),b:()=>Ox(e,Uy($x(n,s),"float32"))}}},r_={kernelName:Xm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,a=r.map(e=>e[0]);return{x:()=>xw(e,a,s.shape)}}},a_={kernelName:Zm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=wx(n.shape,s.shape);return{a:()=>{const t=xx(n.shape,r);return t.length>0?Xv(zx(e,t),n.shape):e},b:()=>{const t=Ox(e,nw(Ex(bx(n,s)))),a=xx(s.shape,r);return a.length>0?Xv(zx(t,a),s.shape):t}}}},o_={kernelName:Qm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=wx(n.shape,s.shape);return{a:()=>{const t=Ox(e,Uy(s,"float32")),a=xx(n.shape,r);return a.length>0?Xv(zx(t,a),n.shape):t},b:()=>{const t=Ox(e,Uy(n,"float32")),a=xx(s.shape,r);return a.length>0?Xv(zx(t,a),s.shape):t}}}},i_={kernelName:Jm,gradFunc:e=>({x:()=>nw(e)})},u_={kernelName:ag,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>aw(n.shape,"float32")}}},l_={kernelName:rg,gradFunc:e=>({x:()=>Mw(e)})},c_={kernelName:og,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:s}=n;return Ow(e,s).map(e=>()=>e)}},d_={kernelName:ig,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,a=r.map(e=>e[0]);return{x:()=>xw(e,a,s.shape)}}},p_={kernelName:ug,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,s,r]=t,a=n,o=s,i=wx(a.shape,o.shape);return{a:()=>{const t=Uy(o,"float32");let n=Ox(e,Ox(t,_k(a,qx(t,$v(1)))));const s=xx(a.shape,i);return s.length>0&&(n=zx(n,s)),Xv(n,a.shape)},b:()=>{const t=$x(a,0),n=zw(t,Rx(a),Mw(a));let s=Ox(e,Ox(r,n));const u=xx(o.shape,i);return u.length>0&&(s=zx(s,u)),Xv(s,o.shape)}}}},h_={kernelName:lg,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,s]=t,r=$x(n,0);return{x:()=>zw(r,e,Ox(e,s)),alpha:()=>{let t=zw(r,Mw(e),Ox(e,n));const a=xx(s.shape,e.shape);return a.length>0&&(t=zx(t,a)),Xv(t,s.shape)}}}},f_={kernelName:sm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=wx(n.shape,s.shape);return{a:()=>{const t=bx(e,Uy(s,"float32")),a=xx(n.shape,r);return a.length>0?Xv(zx(t,a),n.shape):t},b:()=>{let t=Ox(e,Uy(n,"float32"));const a=xx(s.shape,r);a.length>0&&(t=Xv(zx(t,a),s.shape));const o=ew(s);return nw(bx(t,Uy(o,"float32")))}}}},m_={kernelName:hg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,nw(ew(n)))}}},g_={kernelName:xg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=Ox(wk(n,6),Xw(n));return{x:()=>Ox(e,Uy(s,"float32"))}}},b_={kernelName:fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Uy(Xw(n),"float32"))}}},y_={kernelName:mg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xv(e,n.shape)}}},v_={kernelName:yg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>Zb.runKernel(vg,r,n)}}},x_={kernelName:gg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>Zb.runKernel(bg,r,n)}}},w_={kernelName:wg,gradFunc:(e,t,n)=>{const{dims:s}=n,r=Oh(s,e.shape);return{x:()=>gw(e,r)}}},k_={kernelName:kg,gradFunc:e=>({x:()=>Mw(e)})},C_={kernelName:Cg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nw(bx(e,Ox(_k(n,1.5),2)))}}},I_=oy({logicalNot_:function(e){const t=ry(e,"x","logicalNot","bool");return Zb.runKernel(Om,{x:t})}}),__={kernelName:_g,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Uy(Mw(n),"float32"),t:()=>Ox(e,Uy(n,e.dtype)),e:()=>Ox(e,Uy(I_(n),e.dtype))}}},S_={kernelName:Sg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=$x(n,$v(0)),s=$v(uC),r=$v(lC),a=Ox(e,r),o=Ox(Ox(e,s),Fx(Uy(n,"float32")));return zw(t,a,o)}}}},E_={kernelName:Ag,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Ox(n,qx($v(1),n)))}}},N_={kernelName:Tg,gradFunc:e=>({x:()=>Mw(e)})},$_=oy({cos_:function(e){const t=ry(e,"x","cos");return Zb.runKernel(Wf,{x:t})}}),T_={kernelName:Ng,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox($_(Uy(n,"float32")),e)}}},A_=oy({cosh_:function(e){const t=ry(e,"x","cosh");return Zb.runKernel(Uf,{x:t})}}),R_={kernelName:$g,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(A_(Uy(n,"float32")),e)}}},F_={kernelName:Eg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{begin:r,size:a}=n,o=s.shape,[i,u]=bv(s,r,a),l=[];for(let c=0;c<e.rank;c++)l.push([i[c],o[c]-i[c]-u[c]]);return{x:()=>uw(e,l)}}},D_={kernelName:zg,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{dim:r}=n,a=Ox(e,s);return{logits:()=>qx(a,Ox(zx(a,[r],!0),s))}}},O_={kernelName:Rg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,vw(n))}}},q_=oy({batchToSpaceND_:function(e,t,n){const s=ry(e,"x","batchToSpaceND"),r=t.reduce((e,t)=>e*t);return Ih(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),Ih(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Ih(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`),Zb.runKernel(Tf,{x:s},{blockShape:t,crops:n})}}),z_={kernelName:Og,gradFunc:(e,t,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>q_(e,s,r)}}},M_={kernelName:qg,gradFunc:(e,t,n)=>{const{axis:s}=n;return{x:()=>sx(e,s)}}},L_=[PC,VC,jC,BC,WC,UC,GC,HC,KC,XC,ZC,YC,JC,tI,nI,rI,aI,oI,iI,uI,lI,cI,pI,dI,fI,gI,yI,xI,wI,kI,f_,CI,II,_I,SI,EI,$I,NI,AI,FI,qI,zI,MI,LI,PI,VI,jI,BI,WI,GI,KI,KI,ZI,QI,e_,t_,n_,s_,r_,a_,o_,i_,u_,l_,c_,d_,d_,p_,h_,m_,g_,b_,y_,v_,x_,w_,k_,C_,__,S_,E_,N_,T_,R_,F_,D_,O_,z_,z_,M_,M_,{kernelName:Fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,Ox(Nw(Uy(n,"float32")),2))}}},{kernelName:Vg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=$v(2);return{a:()=>Ox(e,Ox(r,qx(n,s))),b:()=>Ox(e,Ox(r,qx(s,n)))}}},{kernelName:jg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(e,Ox(Uy(n,"float32"),2))}}},{kernelName:tb,gradFunc:e=>({x:()=>Mw(e)})},{kernelName:Wg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=wx(n.shape,s.shape);return{a:()=>{let t=e;const s=xx(n.shape,r);return s.length>0&&(t=zx(t,s)),Xv(t,n.shape)},b:()=>{let t=e;const n=xx(s.shape,r);return n.length>0&&(t=zx(t,n)),Xv(nw(t),s.shape)}}}},{kernelName:Dg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,r=s.shape.slice(),{axis:a}=n;Oh(a,s.shape).forEach(e=>{r[e]=1});const o=Xv(e,r),i=Ox(o,ow(s.shape,"float32"));return{x:()=>i}}},{kernelName:Ug,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bx(e,ew($_(n)))}}},{kernelName:Gg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ox(qx($v(1),ew(n)),e)}}},{kernelName:Hg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{reps:r}=n;return{x:()=>{let t=Mw(s);if(1===s.rank)for(let n=0;n<r[0];++n)t=Rv(t,xw(e,[n*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let n=0;n<r[0];++n)for(let a=0;a<r[1];++a)t=Rv(t,xw(e,[n*s.shape[0],a*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let n=0;n<r[0];++n)for(let a=0;a<r[1];++a)for(let o=0;o<r[2];++o)t=Rv(t,xw(e,[n*s.shape[0],a*s.shape[1],o*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let a=0;a<r[1];++a)for(let o=0;o<r[2];++o)for(let i=0;i<r[3];++i)t=Rv(t,xw(e,[n*s.shape[0],a*s.shape[1],o*s.shape[2],i*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return t}}}},{kernelName:Zg,gradFunc:(e,t,n)=>{const s=n,{perm:r}=s,a=Qx(r);return{x:()=>Lw(e,a)}}},{kernelName:Qg,gradFunc:(e,t,n)=>{const s=n,{axis:r}=s;return{value:()=>Tw(e,r)}}},{kernelName:Jg,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=jx(t,Mw(t)),s=Nx(e,n);let r=Tx(t,$v(0,"int32"));const a=s.rank-r.rank;for(let i=0;i<a;++i)r=Cx(r,i+1);r=Lx(r,ow(s.shape,"bool"));const o=Mw(s);return zw(r,s,o)}(e,n)}}},{kernelName:eb,gradFunc:e=>({x:()=>Mw(e)})}];for(const iK of L_)pb(iK);Rb().prototype.abs=function(){return this.throwIfDisposed(),Av(this)};const P_=oy({acos_:function(e){const t=ry(e,"x","acos");return Zb.runKernel(pf,{x:t})}});Rb().prototype.acos=function(){return this.throwIfDisposed(),P_(this)};const V_=oy({acosh_:function(e){const t=ry(e,"x","acosh");return Zb.runKernel(hf,{x:t})}});Rb().prototype.acosh=function(){return this.throwIfDisposed(),V_(this)},Rb().prototype.add=function(e){return this.throwIfDisposed(),Rv(this,e)},Rb().prototype.all=function(e,t){return this.throwIfDisposed(),Fv(this,e,t)},Rb().prototype.any=function(e,t){return this.throwIfDisposed(),Dv(this,e,t)},Rb().prototype.argMax=function(e){return this.throwIfDisposed(),Ov(this,e)};const j_=oy({argMin_:function(e,t=0){const n=ry(e,"x","argMin");return Zb.runKernel(vf,{x:n},{axis:t})}});Rb().prototype.argMin=function(e){return this.throwIfDisposed(),j_(this,e)},Rb().prototype.asScalar=function(){return this.throwIfDisposed(),Ih(1===this.size,()=>"The array must have only 1 element."),Xv(this,[])},Rb().prototype.asType=function(e){return this.throwIfDisposed(),Uy(this,e)},Rb().prototype.as1D=function(){return this.throwIfDisposed(),Xv(this,[this.size])},Rb().prototype.as2D=function(e,t){return this.throwIfDisposed(),Xv(this,[e,t])},Rb().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Xv(this,[e,t,n])},Rb().prototype.as4D=function(e,t,n,s){return this.throwIfDisposed(),Xv(this,[e,t,n,s])},Rb().prototype.as5D=function(e,t,n,s,r){return this.throwIfDisposed(),Xv(this,[e,t,n,s,r])};const B_=oy({asin_:function(e){const t=ry(e,"x","asin");return Zb.runKernel(xf,{x:t})}});Rb().prototype.asin=function(){return this.throwIfDisposed(),B_(this)};const W_=oy({asinh_:function(e){const t=ry(e,"x","asinh");return Zb.runKernel(wf,{x:t})}});Rb().prototype.asinh=function(){return this.throwIfDisposed(),W_(this)};const U_=oy({atan_:function(e){const t=ry(e,"x","atan");return Zb.runKernel(kf,{x:t})}});Rb().prototype.atan=function(){return this.throwIfDisposed(),U_(this)};const G_=oy({atan2_:function(e,t){let n=ry(e,"a","atan2"),s=ry(t,"b","atan2");return[n,s]=jb(n,s),Zb.runKernel(If,{a:n,b:s})}});Rb().prototype.atan2=function(e){return this.throwIfDisposed(),G_(this,e)};const H_=oy({atanh_:function(e){const t=ry(e,"x","atanh");return Zb.runKernel(Cf,{x:t})}});Rb().prototype.atanh=function(){return this.throwIfDisposed(),H_(this)},Rb().prototype.avgPool=function(e,t,n,s){return this.throwIfDisposed(),Zv(this,e,t,n,s)},Rb().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),q_(this,e,t)},Rb().prototype.batchNorm=function(e,t,n,s,r){return this.throwIfDisposed(),Qv(this,e,t,n,s,r)},Rb().prototype.broadcastTo=function(e){return this.throwIfDisposed(),qw(this,e)},Rb().prototype.cast=function(e){return this.throwIfDisposed(),Uy(this,e)};const K_=oy({ceil_:function(e){const t=ry(e,"x","ceil");return Zb.runKernel(Ff,{x:t})}});Rb().prototype.ceil=function(){return this.throwIfDisposed(),K_(this)},Rb().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),nx(this,e,t)},Rb().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ab&&(e=[e]),sx([this,...e],t)},Rb().prototype.conv1d=function(e,t,n,s,r,a){return this.throwIfDisposed(),lx(this,e,t,n,s,r,a)},Rb().prototype.conv2dTranspose=function(e,t,n,s,r){return this.throwIfDisposed(),dx(this,e,t,n,s,r)},Rb().prototype.conv2d=function(e,t,n,s,r,a){return this.throwIfDisposed(),ux(this,e,t,n,s,r,a)},Rb().prototype.cos=function(){return this.throwIfDisposed(),$_(this)},Rb().prototype.cosh=function(){return this.throwIfDisposed(),A_(this)},Rb().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),vI(this,e,t,n)};const X_=oy({depthToSpace_:function(e,t,n="NHWC"){const s=ry(e,"x","depthToSpace"),r="NHWC"===n?s.shape[1]:s.shape[2],a="NHWC"===n?s.shape[2]:s.shape[3],o="NHWC"===n?s.shape[3]:s.shape[1];return Ih(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${s.shape}`),Ih(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${s.shape}`),Ih(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`),Zb.runKernel(Xf,{x:s},{blockSize:t,dataFormat:n})}});Rb().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),X_(this,e,t)},Rb().prototype.depthwiseConv2d=function(e,t,n,s,r,a){return this.throwIfDisposed(),mx(this,e,t,n,s,r,a)};const Z_=oy({dilation2d_:function(e,t,n,s,r=[1,1],a="NHWC"){const o=ry(e,"x","dilation2d"),i=ry(t,"filter","dilation2d");Ih(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),Ih(3===i.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),Ih("NHWC"===a,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,l=!1;3===o.rank&&(u=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const c=Zb.runKernel(em,{x:u,filter:i},{strides:n,pad:s,dilations:r});return l?Xv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});Rb().prototype.dilation2d=function(e,t,n,s,r){return this.throwIfDisposed(),Z_(this,e,t,n,s,r)};const Y_=oy({divNoNan_:function(e,t){let n=ry(e,"a","div"),s=ry(t,"b","div");[n,s]=jb(n,s);const r=bx(n,s),a=Mw(r),o=kx(s,a);return zw(o,a,r)}});Rb().prototype.divNoNan=function(e){return this.throwIfDisposed(),Y_(this,e)},Rb().prototype.div=function(e){return this.throwIfDisposed(),bx(this,e)};const Q_=oy({dot_:function(e,t){const n=ry(e,"t1","dot"),s=ry(t,"t2","dot");Ih(!(1!==n.rank&&2!==n.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=1===n.rank?n.size:n.shape[1],a=1===s.rank?s.size:s.shape[0];if(Ih(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),1===n.rank&&1===s.rank){const e=Xv(n,[1,-1]),t=Xv(s,[-1,1]),r=sk(e,t);return Xv(r,[])}if(1===n.rank&&2===s.rank){const e=Xv(n,[1,-1]),t=Xv(s,[s.shape[0],s.shape[1]]),r=sk(e,t);return Xv(r,[r.size])}if(2===n.rank&&1===s.rank){const e=Xv(s,[-1,1]),t=sk(n,e);return Xv(t,[t.size])}{const e=Xv(s,[s.shape[0],s.shape[1]]);return sk(n,e)}}});Rb().prototype.dot=function(e){return this.throwIfDisposed(),Q_(this,e)},Rb().prototype.elu=function(){return this.throwIfDisposed(),yx(this)},Rb().prototype.equal=function(e){return this.throwIfDisposed(),kx(this,e)};const J_=oy({erf_:function(e){let t=ry(e,"x","erf");return Ih("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Uy(t,"float32")),Zb.runKernel(im,{x:t})}});Rb().prototype.erf=function(){return this.throwIfDisposed(),J_(this)},Rb().prototype.exp=function(){return this.throwIfDisposed(),Fx(this)},Rb().prototype.expandDims=function(e){return this.throwIfDisposed(),Cx(this,e)};const eS=oy({expm1_:function(e){const t=ry(e,"x","expm1");return Zb.runKernel(dm,{x:t})}});Rb().prototype.expm1=function(){return this.throwIfDisposed(),eS(this)},Rb().prototype.fft=function(){return this.throwIfDisposed(),Bw(this)},Rb().prototype.flatten=function(){return this.throwIfDisposed(),Xv(this,[this.size])},Rb().prototype.floor=function(){return this.throwIfDisposed(),Ex(this)},Rb().prototype.floorDiv=function(e){return this.throwIfDisposed(),gx(this,e)},Rb().prototype.gather=function(e,t){return this.throwIfDisposed(),Nx(this,e,t)},Rb().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Tx(this,e)},Rb().prototype.greater=function(e){return this.throwIfDisposed(),$x(this,e)},Rb().prototype.ifft=function(){return this.throwIfDisposed(),Uw(this)},Rb().prototype.irfft=function(){return this.throwIfDisposed(),Gw(this)};const tS=oy({isFinite_:function(e){const t=ry(e,"x","isFinite");return Zb.runKernel(_m,{x:t})}});Rb().prototype.isFinite=function(){return this.throwIfDisposed(),tS(this)};const nS=oy({isInf_:function(e){const t=ry(e,"x","isInf");return Zb.runKernel(Sm,{x:t})}});Rb().prototype.isInf=function(){return this.throwIfDisposed(),nS(this)};const sS=oy({isNaN_:function(e){const t=ry(e,"x","isNaN");return Zb.runKernel(Em,{x:t})}});Rb().prototype.isNaN=function(){return this.throwIfDisposed(),sS(this)},Rb().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Ax(this,e)},Rb().prototype.lessEqual=function(e){return this.throwIfDisposed(),wk(this,e)},Rb().prototype.less=function(e){return this.throwIfDisposed(),XI(this,e)};const rS=oy({localResponseNormalization_:function(e,t=5,n=1,s=1,r=.5){const a=ry(e,"x","localResponseNormalization");Ih(4===a.rank||3===a.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`),Ih(Th(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,i=!1;3===a.rank&&(i=!0,o=Xv(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u=Zb.runKernel(zm,{x:o},{depthRadius:t,bias:n,alpha:s,beta:r});return i?Xv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Rb().prototype.localResponseNormalization=function(e,t,n,s){return this.throwIfDisposed(),rS(this,e,t,n,s)};const aS=oy({logSigmoid_:function(e){const t=ry(e,"x","logSigmoid");return Nv(e=>({value:nw(Sw(nw(e))),gradFunc:t=>Ox(t,vw(nw(e)))}))(t)}});Rb().prototype.logSigmoid=function(){return this.throwIfDisposed(),aS(this)},Rb().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Mx(this,e)},Rb().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Ok(this,e,t)},Rb().prototype.log=function(){return this.throwIfDisposed(),Rx(this)},Rb().prototype.log1p=function(){return this.throwIfDisposed(),Dk(this)},Rb().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Lx(this,e)},Rb().prototype.logicalNot=function(){return this.throwIfDisposed(),I_(this)};const oS=oy({logicalOr_:function(e,t){const n=ry(e,"a","logicalOr","bool"),s=ry(t,"b","logicalOr","bool");return wx(n.shape,s.shape),Zb.runKernel(qm,{a:n,b:s})}});Rb().prototype.logicalOr=function(e){return this.throwIfDisposed(),oS(this,e)};const iS=oy({logicalXor_:function(e,t){const n=ry(e,"a","logicalXor","bool"),s=ry(t,"b","logicalXor","bool");return wx(n.shape,s.shape),Lx(oS(e,t),I_(Lx(e,t)))}});Rb().prototype.logicalXor=function(e){return this.throwIfDisposed(),iS(this,e)},Rb().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),sk(this,e,t,n)},Rb().prototype.maxPool=function(e,t,n,s){return this.throwIfDisposed(),Px(this,e,t,n,s)},Rb().prototype.max=function(e,t){return this.throwIfDisposed(),Dx(this,e,t)},Rb().prototype.maximum=function(e){return this.throwIfDisposed(),jx(this,e)},Rb().prototype.mean=function(e,t){return this.throwIfDisposed(),Bx(this,e,t)},Rb().prototype.min=function(e,t){return this.throwIfDisposed(),Wx(this,e,t)},Rb().prototype.minimum=function(e){return this.throwIfDisposed(),Ux(this,e)};const uS=oy({mirrorPad_:function(e,t,n){Ih("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=ry(e,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Ih(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r="reflect"===n?1:0;for(let a=0;a<s.rank;a++)Ih(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),Ih(t[a][0]>=0&&t[a][0]<=s.shape[a]-r&&t[a][1]>=0&&t[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);return Zb.runKernel(Xm,{x:s},{paddings:t,mode:n})}});Rb().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),uS(this,e,t)};const lS=oy({mod_:function(e,t){let n=ry(e,"a","mod"),s=ry(t,"b","mod");return[n,s]=jb(n,s),Zb.runKernel(Zm,{a:n,b:s})}});Rb().prototype.mod=function(e){return this.throwIfDisposed(),lS(this,e)},Rb().prototype.mul=function(e){return this.throwIfDisposed(),Ox(this,e)},Rb().prototype.neg=function(){return this.throwIfDisposed(),nw(this)},Rb().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Ek(this,e,t,n)},Rb().prototype.notEqual=function(e){return this.throwIfDisposed(),sw(this,e)},Rb().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),rw(this,e,t,n)},Rb().prototype.onesLike=function(){return this.throwIfDisposed(),iw(this)},Rb().prototype.pad=function(e,t){return this.throwIfDisposed(),uw(this,e,t)};const cS=oy({pool_:function(e,t,n,s,r,a){null==r&&(r=[1,1]),null==a&&(a=1),0===s&&(s="valid");const o=ry(e,"x","maxPool");let i=o,u=!1;3===o.rank&&(u=!0,i=Xv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ih(Hv(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const l=zv(i.shape,t,a,r,s),c=[l.dilationHeight,l.dilationWidth];let d;d="same"===s?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),s=n.map(e=>Math.floor(e/2)),r=n.map((e,t)=>e-s[t]);return n.map((e,t)=>[s[t],r[t]])}([l.filterHeight,l.filterWidth],c):[[0,0],[0,0]];const p=1===c[0]&&1===c[1],[h,f]=function(e,t,n){const s=n.map(e=>e[0]),r=n.map(e=>e[1]),a=e.concat(s,r),o=t.map((e,t)=>(e-a[t]%e)%e),i=r.map((e,t)=>e+o[t]);return[t.map((e,t)=>[s[t],i[t]]),t.map((e,t)=>[0,o[t]])]}([l.inHeight,l.inWidth],c,d),m=p?s:"valid",g=p?i:sI(i,c,h),b=("avg"===n?()=>Zv(g,t,a,m):()=>Px(g,t,a,m))(),y=p?b:q_(b,c,f);return u?Xv(y,[y.shape[1],y.shape[2],y.shape[3]]):y}});Rb().prototype.pool=function(e,t,n,s,r){return this.throwIfDisposed(),cS(this,e,t,n,s,r)},Rb().prototype.pow=function(e){return this.throwIfDisposed(),_k(this,e)},Rb().prototype.prelu=function(e){return this.throwIfDisposed(),lw(this,e)};const dS=oy({prod_:function(e,t=null,n=!1){let s=ry(e,"x","prod");return"bool"===s.dtype&&(s=Uy(s,"int32")),Zb.runKernel(cg,{x:s},{axis:t,keepDims:n})}});Rb().prototype.prod=function(e,t){return this.throwIfDisposed(),dS(this,e,t)};const pS=oy({reciprocal_:function(e){const t=ry(e,"x","reciprocal");return Zb.runKernel(hg,{x:t})}});Rb().prototype.reciprocal=function(){return this.throwIfDisposed(),pS(this)},Rb().prototype.relu=function(){return this.throwIfDisposed(),mw(this)},Rb().prototype.relu6=function(){return this.throwIfDisposed(),Kw(this)},Rb().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Xv(this,e.shape)},Rb().prototype.reshape=function(e){return this.throwIfDisposed(),Xv(this,e)},Rb().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),yk(this,e,t,n)},Rb().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),vk(this,e,t,n)},Rb().prototype.reverse=function(e){return this.throwIfDisposed(),gw(this,e)},Rb().prototype.rfft=function(){return this.throwIfDisposed(),Ww(this)},Rb().prototype.round=function(){return this.throwIfDisposed(),kk(this)},Rb().prototype.rsqrt=function(){return this.throwIfDisposed(),TI(this)},Rb().prototype.selu=function(){return this.throwIfDisposed(),bw(this)},Rb().prototype.separableConv2d=function(e,t,n,s,r,a){return this.throwIfDisposed(),yw(this,e,t,n,s,r,a)},Rb().prototype.sigmoid=function(){return this.throwIfDisposed(),vw(this)};const hS=oy({sign_:function(e){const t=ry(e,"x","sign");return Zb.runKernel(Tg,{x:t})}});Rb().prototype.sign=function(){return this.throwIfDisposed(),hS(this)},Rb().prototype.sin=function(){return this.throwIfDisposed(),mI(this)},Rb().prototype.sinh=function(){return this.throwIfDisposed(),bI(this)},Rb().prototype.slice=function(e,t){return this.throwIfDisposed(),xw(this,e,t)},Rb().prototype.softmax=function(e){return this.throwIfDisposed(),_w(this,e)},Rb().prototype.softplus=function(){return this.throwIfDisposed(),Sw(this)},Rb().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),sI(this,e,t)},Rb().prototype.split=function(e,t){return this.throwIfDisposed(),Ew(this,e,t)},Rb().prototype.sqrt=function(){return this.throwIfDisposed(),Nw(this)},Rb().prototype.square=function(){return this.throwIfDisposed(),ew(this)},Rb().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Fk(this,e)},Rb().prototype.squeeze=function(e){return this.throwIfDisposed(),$w(this,e)},Rb().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Ab?[this,e]:[this,...e];return Tw(n,t)},Rb().prototype.step=function(e){return this.throwIfDisposed(),Xw(this,e)};const fS=oy({stridedSlice_:function(e,t,n,s,r=0,a=0,o=0,i=0,u=0){const l=ry(e,"x","stridedSlice");return Zb.runKernel(Bg,{x:l},{begin:t,end:n,strides:s,beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u})}});Rb().prototype.stridedSlice=function(e,t,n,s,r,a,o,i){return this.throwIfDisposed(),fS(this,e,t,n,s,r,a,o,i)},Rb().prototype.sub=function(e){return this.throwIfDisposed(),qx(this,e)},Rb().prototype.sum=function(e,t){return this.throwIfDisposed(),zx(this,e,t)};const mS=oy({tan_:function(e){const t=ry(e,"x","tan");return Zb.runKernel(Ug,{x:t})}});Rb().prototype.tan=function(){return this.throwIfDisposed(),mS(this)},Rb().prototype.tanh=function(){return this.throwIfDisposed(),Aw(this)},Rb().prototype.tile=function(e){return this.throwIfDisposed(),Ix(this,e)},Rb().prototype.toBool=function(){return this.throwIfDisposed(),Uy(this,"bool")},Rb().prototype.toFloat=function(){return this.throwIfDisposed(),Uy(this,"float32")},Rb().prototype.toInt=function(){return this.throwIfDisposed(),Uy(this,"int32")};const gS=oy({topk_:function(e,t=1,n=!0){const s=ry(e,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const a={x:s},o={k:t,sorted:n},[i,u]=Zb.runKernel(Kg,a,o);return{values:i,indices:u}}});Rb().prototype.topk=function(e,t){return this.throwIfDisposed(),gS(this,e,t)},Rb().prototype.transpose=function(e){return this.throwIfDisposed(),Lw(this,e)};const bS=oy({unique_:function(e,t=0){const n=ry(e,"x","unique","string_or_numeric");Ih(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:t},[a,o]=Zb.runKernel(Yg,s,r);return{values:a,indices:o}}});let yS;function vS(){return null==yS&&(yS=Zb.backend.epsilon()),yS}Rb().prototype.unique=function(e){return this.throwIfDisposed(),bS(this,e)},Rb().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),RI(this,e,t)},Rb().prototype.unstack=function(e){return this.throwIfDisposed(),Ow(this,e)},Rb().prototype.where=function(e,t){return this.throwIfDisposed(),zw(e,this,t)},Rb().prototype.zerosLike=function(){return this.throwIfDisposed(),Mw(this)};class xS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xS.prototype)}}class wS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wS.prototype)}}class kS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kS.prototype)}}class CS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,CS.prototype)}}class IS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,IS.prototype)}}function _S(e,t){if(Array.isArray(e)){let n=[];for(let s=0;s<t;s++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function SS(e,t){if(!e)throw new IS(t)}function ES(e,t){let n=0;for(const s of e)s===t&&n++;return n}function NS(e){return 1===e.length?e[0]:e}function $S(e){return Array.isArray(e)?e:[e]}function TS(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function AS(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}Error;let RS={};function FS(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function DS(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>DS(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?DS(t):e[n]=t.value)}}}function OS(e,t={},n={},s="object",r=!1){if("string"==typeof e){const r=e;let a;if(r in n)a=n[r];else if(r in RS)a=RS[r];else if(a=t[r],null==a)throw new kS(`Unknown ${s}: ${e}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new kS(`${s}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const o=a.className;let i,u;if(o in n?[i,u]=n[o]:o in RS?[i,u]=RS.className:o in t&&([i,u]=t[o]),null==i)throw new kS(`Unknown ${s}: ${o}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const e={};for(const n of Object.keys(RS))e[n]=RS[n];for(const r of Object.keys(n))e[r]=n[r];a.config.customObjects=e;const t=Object.assign({},RS);for(const r of Object.keys(n))RS[r]=n[r];DS(a.config);const s=u(i,a.config,n,r);return RS=Object.assign({},t),s}{const e=Object.assign({},RS);for(const s of Object.keys(n))RS[s]=n[s];const t=new i(a.config);return RS=Object.assign({},e),t}}}function qS(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function zS(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function MS(e){if(null==e)throw new kS(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function LS(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new kS(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function PS(e,t,n=0,s=1/0){return SS(n>=0),SS(s>=n),Array.isArray(e)&&e.length>=n&&e.length<=s&&e.every(e=>typeof e===t)}function VS(e,t){Array.isArray(e)?(Ih(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>VS(e,`element ${n+1} of ${t}`))):Ih(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${jS(e)}.`)}function jS(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>jS(e)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function BS(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function WS(e,t){return Iv(()=>Nw(zx(Ox(e,e),t,!0)))}class US extends vv{getConfig(){return{}}}class GS extends US{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Iv(()=>{const t=WS(e,this.axis),n=nx(t,0,this.maxValue);return Ox(e,bx(n,Rv(vS(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}GS.className="MaxNorm",wv(GS);class HS extends US{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Iv(()=>bx(e,Rv(vS(),WS(e,this.axis))))}getConfig(){return{axis:this.axis}}}HS.className="UnitNorm",wv(HS);class KS extends US{apply(e){return mw(e)}}KS.className="NonNeg",wv(KS);class XS extends US{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Iv(()=>{const t=WS(e,this.axis),n=Rv(Ox(this.rate,nx(t,this.minValue,this.maxValue)),Ox(1-this.rate,t));return Ox(e,bx(n,Rv(vS(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}XS.className="MinMaxNorm",wv(XS);const ZS={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function YS(e){return FS(e)}function QS(e,t={}){return OS(e,xv.getMap().classNameMap,t,"constraint")}function JS(e){return null==e?null:"string"==typeof e?QS({className:e in ZS?ZS[e]:e,config:{}}):e instanceof US?e:QS(e)}const eE=["channelsFirst","channelsLast"],tE=["nearest","bilinear"],nE=["valid","same","causal"],sE=["max","avg"],rE=["sum","mul","concat","ave"],aE=new Map;function oE(e){LS(eE,"DataFormat",e)}function iE(e){LS(nE,"PaddingMode",e)}function uE(e){LS(sE,"PoolMode",e)}const lE=[];function cE(e,t){lE.push(e);try{const e=t();return lE.pop(),e}catch(n){throw lE.pop(),n}}function dE(e){if(!fE(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===lE.length?"":lE.join("/")+"/")+e}function pE(e){if(!fE(e))throw new Error("Not a valid tensor name: '"+e+"'");aE.has(e)||aE.set(e,0);const t=aE.get(e);if(aE.set(e,aE.get(e)+1),t>0){const n=`${e}_${t}`;return aE.set(n,1),n}return e}const hE=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fE(e){return!!e.match(hE)}function mE(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let s=1;for(let r=t;r<n;++r)s*=e[r];return s}function gE(e){return Rw(e=Array.isArray(e)?new Float32Array(e):e)}function bE(e){return Wx(gE(e)).dataSync()[0]}function yE(e){return Dx(gE(e)).dataSync()[0]}function vE(e,t){if(t<e)throw new kS(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let s=e;s<t;++s)n.push(s);return n}function xE(e,t){return e.asType(t)}function wE(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function kE(e,t,n){return Iv(()=>{switch(e.rank){case 1:return ww(e,t,n);case 2:return kw(e,[t,0],[n,e.shape[1]]);case 3:return Cw(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Iw(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return xw(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return xw(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new kS(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function CE(e,t,n){return Iv(()=>{switch(e.rank){case 1:return ww(e,t,n);case 2:return kw(e,[0,t],[e.shape[0],n]);case 3:return Cw(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Iw(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new kS(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function IE(e,t,n,s){return Iv(()=>{switch(e.rank){case 1:return ww(e,t,n);case 2:switch(s){case 1:return kE(e,t,n);case 2:return CE(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return kE(e,t,n);case 2:return Cw(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return CE(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return kE(e,t,n);case 2:return Iw(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Iw(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return CE(e,t,n);default:throw new kS(`The axis is not within the rank of the tensor ${s}`)}default:throw new kS(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function _E(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),sx(e,t)}function SE(e,t){switch(e.rank){case 1:return rx([e,t]);case 2:return ax([e,t],0);case 3:return ox([e,t],0);case 4:return ix([e,t],0);default:throw new kS(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function EE(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new kS(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ix(e,t)}function NE(e,t=0,n=1,s,r){return hw(e,t,n,s,r)}function $E(e,t,n,s){if(e.rank<2||t.rank<2)throw new CS(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new CS(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return rk({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?RE(e.rank,s,"channelsLast"):null,activation:n});{const r=e.shape.slice(),a=r.pop();e=e.reshape([-1,a]);const o=t.shape.slice(),i=o.pop(),u=o.pop(),l=[...o,i],c=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=t.transpose(c).reshape([u,-1]);const d=[...r,...l];return rk({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?RE(e.rank,s,"channelsLast"):null,activation:n}).reshape(d)}}function TE(e,t,n){return Iv(()=>(t=Array.isArray(t)?Rw(t,"int32"):t.toInt(),Nx(e,t,n)))}function AE(e){return Ox(e,e)}function RE(e,t,n){const s=t.shape;if(1!==t.rank&&t.rank!==e)throw new kS(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return t.reshape(1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===n)return t.reshape(1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===e){if("channelsFirst"===n)return t.reshape(1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===n)return t.reshape(1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===e){if("channelsFirst"===n)return t.reshape(1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===n)return t.reshape(1===s.length?[1,1,s[0]]:[1].concat(s))}else if(e<3)return t;throw new kS(`Unsupported input rank by biasAdd: ${t.rank}`)}function FE(e,t,n){return Iv(()=>(null==n&&(n="channelsLast"),oE(n),e.add(RE(e.rank,t,n))))}function DE(e,t,n,s){return Iv(()=>Pw(e,t,n,s))}function OE(e,t,n=!1){return n?e():t()}const qE=["fanIn","fanOut","fanAvg"],zE=["normal","uniform","truncatedNormal"];class ME extends vv{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class LE extends ME{apply(e,t){return aw(e,t)}}LE.className="Zeros",wv(LE);class PE extends ME{apply(e,t){return ow(e,t)}}PE.className="Ones",wv(PE);class VE extends ME{constructor(e){if(super(),"object"!=typeof e)throw new kS(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new kS(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Iv(()=>Ox($v(this.value),ow(e,t)))}getConfig(){return{value:this.value}}}VE.className="Constant",wv(VE);class jE extends ME{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return fw(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}jE.className="RandomUniform",wv(jE);class BE extends ME{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new CS(`randomNormal does not support dType ${t}.`);return NE(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}BE.className="RandomNormal",wv(BE);class WE extends ME{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new CS(`truncatedNormal does not support dType ${t}.`);return Dw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}WE.className="TruncatedNormal",wv(WE);class UE extends ME{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Iv(()=>{if(2!==e.length||e[0]!==e[1])throw new kS("Identity matrix initializer can only be used for 2D square matrices.");return Ox(this.gain,_x(e[0]))})}getConfig(){return{gain:this.gain}}}UE.className="Identity",wv(UE);class GE extends ME{constructor(e){if(super(),e.scale<0)throw new kS(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,LS(qE,"FanMode",this.mode),this.distribution=null==e.distribution?"normal":e.distribution,LS(zE,"Distribution",this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,s;if(oE(t),2===e.length)n=e[0],s=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=mE(e,2);n=e[1]*t,s=e[0]*t}else if("channelsLast"===t){const t=mE(e,0,e.length-2);n=e[e.length-2]*t,s=e[e.length-1]*t}}else{const t=mE(e);n=Math.sqrt(t),s=Math.sqrt(t)}return[n,s]}(e),s=n[0],r=n[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,s):"fanOut"===this.mode?Math.max(1,r):Math.max(1,(s+r)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new CS(`${this.getClassName()} does not support dType ${t}.`);return Dw(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return fw(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}GE.className="VarianceScaling",wv(GE);class HE extends GE{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GE.className}}HE.className="GlorotUniform",wv(HE);class KE extends GE{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GE.className}}KE.className="GlorotNormal",wv(KE);class XE extends GE{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GE.className}}XE.className="HeNormal",wv(XE);class ZE extends GE{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GE.className}}ZE.className="HeUniform",wv(ZE);class YE extends GE{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return GE.className}}YE.className="LeCunNormal",wv(YE);class QE extends GE{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return GE.className}}QE.className="LeCunNormal",wv(QE);class JE extends ME{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new CS("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return Iv(()=>{if(e.length<2)throw new CS("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=NE(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=qk.gramSchmidt(t);return e[0]>e[1]&&(n=n.transpose()),Ox(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}JE.className="Orthogonal",wv(JE);const eN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function tN(e,t={}){return OS(e,xv.getMap().classNameMap,t,"initializer")}function nN(e){return FS(e)}function sN(e){if("string"==typeof e){const t=e in eN?eN[e]:e;if("GlorotNormal"===t)return new KE;if("GlorotUniform"===t)return new HE;if("HeNormal"===t)return new XE;if("HeUniform"===t)return new ZE;if("LeCunNormal"===t)return new YE;if("LeCunUniform"===t)return new QE;{const e={};return e.className=t,e.config={},tN(e)}}return e instanceof ME?e:tN(e)}let rN=0;function aN(){return rN++}const oN={};function iN(e=""){return e in oN||(oN[e]=0),oN[e]+=1,e+oN[e].toString()}function uN(e){return Array.isArray(e)&&Array.isArray(e[0])}function lN(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function cN(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new kS(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function dN(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new kS(`Expected exactly 1 Shape; got ${e.length}`)}return e}function pN(e){let t=0;for(const n of e)t+=0===n.shape.length?1:n.shape.reduce((e,t)=>e*t);return t}class hN{constructor(e,t="float32",n="Variable",s=!0,r=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=aN(),this.originalName=dE(n=null==n?"Variable":n),this.name=pE(this.originalName),this.trainable_=s,this.constraint=r,this.val=function(e,t=!0,n,s){return Zb.makeVariable(e,t,n,s)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function fN(e){return e.map(e=>e.read())}function mN(e){e.forEach(e=>{e[0].write(e[1])})}class gN{constructor(e){this.dtype=e.dtype,this.shape=e.shape,this.ndim=null!=e.shape?e.shape.length:e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class bN{constructor(e,t,n,s,r,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=s,this.callArgs=r,this.outputTensorIndex=o,this.id=aN(),null!=a&&(this.originalName=dE(a),this.name=pE(this.originalName)),this.rank=t.length}}let yN=0;class vN{constructor(e,t){this.callArgs=t,this.id=yN++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)e.push(null!=t?t.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let xN=0;class wN extends vv{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xN++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=TS(e)+"_"+iN(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=e.weights?e.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new wS(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new kS(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return NS(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return NS(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new xS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new xS(`Layer ${this.name} is not connected, no input to return.`);return NS(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new xS(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new xS(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return NS(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=$S(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=$S(this.inputSpec);if(e.length!==t.length)throw new kS(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const s=e[n],r=t[n];if(null==r)continue;const a=s.rank;if(null!=r.ndim&&a!==r.ndim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${a}`);if(null!=r.maxNDim&&a>r.maxNDim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${a}`);if(null!=r.minNDim&&a<r.minNDim)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${a}.`);if(null!=r.dtype&&s.dtype!==r.dtype)throw new kS(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${s.dtype}.`);if(r.axes){const e=s.shape;for(const t in r.axes){const s=Number(t),a=r.axes[t],o=s>=0?e[s]:e[e.length+s];if(null!=a&&-1===[a,null].indexOf(o))throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected axis ${s} of input shape to have value ${a} but got shape ${e}.`)}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){const t=r.shape[e],a=s.shape[e];if(null!=t&&null!=a&&t!==a)throw new kS(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=$S(e);let s=!0;for(const a of n)if(!(a instanceof bN)){s=!1;break}let r=!0;for(const a of n)if(a instanceof bN){r=!1;break}if(s===r)throw new kS("Arguments to apply() must be all SymbolicTensors or all Tensors");return cE(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of $S(e))t.push(n.shape);this.build(NS(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);const r=$S(s),a=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(s=NS(a),null!=this.activityRegularizer)throw new CS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const n=function(e){e=$S(e);const t=[];for(const n of e)t.push(n.shape);return NS(t)}(e),s=this.computeOutputShape(n);let r;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((n,s)=>new bN(a,n,this,$S(e),t,this.name,s)):new bN(a,s,this,$S(e),t,this.name),this.addInboundNode(e,r,null,null,n,s,t),this._refCount++,null!=this.activityRegularizer)throw new CS("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,s)=>{null!=n&&null!=e[s]&&e[s]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new xS(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new xS(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new wS(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return pN(this.weights)}build(e){this.built=!0}getWeights(e=!1){return fN(e?this.trainableWeights:this.weights)}setWeights(e){Iv(()=>{const t=this.weights;if(t.length!==e.length)throw new kS(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],s=fN(t);for(let r=0;r<s.length;++r){const a=s[r],o=t[r],i=e[r];if(!$h(a.shape,i.shape))throw new kS(`Layer weight shape ${a.shape} not compatible with provided weight shape ${i.shape}`);n.push([o,i])}mN(n)})}addWeight(e,t,n,s,r,a,o){if(-1!==this._addedWeightNames.indexOf(e))throw new kS(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(s=sN("zeros"));const i=s.apply(t,n),u=new hN(i,n,e,a,o);return i.dispose(),null!=r&&this.addLoss(()=>r.apply(u.read())),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=$S(e),null!=this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}addInboundNode(e,t,n,s,r,a,o=null){const i=$S(e);t=$S(t),n=$S(n),s=$S(s),r=lN(r),a=lN(a);const u=[],l=[],c=[];for(const d of i)u.push(d.sourceLayer),l.push(d.nodeIndex),c.push(d.tensorIndex);new vN({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:s,inputShapes:r,outputShapes:a},o);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function kN(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const s=kN(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of s)-1===t.indexOf(e)&&t.push(e)}return t}}}class CN extends wN{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:iN("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new kS("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new kS("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new kS("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const s=new bN(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new vN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new kS(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function IN(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new kS("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new CN({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function _N(e){return SN.apply(this,arguments)}function SN(){return(SN=bh(function*(e){if(null==e)return;const t=[],n=[],s=[];for(const r in e){const a=e[r];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(r),s.push(e)}}if(t.length>0){const r=yield Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];_v(s)}})).apply(this,arguments)}function EN(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var NN;CN.className="InputLayer",wv(CN),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(NN||(NN={}));class $N{constructor(){this.validationData=null}setParams(e){this.params=e}onEpochBegin(e,t){return bh(function*(){})()}onEpochEnd(e,t){return bh(function*(){})()}onBatchBegin(e,t){return bh(function*(){})()}onBatchEnd(e,t){return bh(function*(){})()}onTrainBegin(e){return bh(function*(){})()}onTrainEnd(e){return bh(function*(){})()}setModel(e){}}class TN{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}onEpochBegin(e,t){var n=this;return bh(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onEpochBegin(e,t)})()}onEpochEnd(e,t){var n=this;return bh(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onEpochEnd(e,t)})()}onBatchBegin(e,t){var n=this;return bh(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onBatchBegin(e,t)})()}onBatchEnd(e,t){var n=this;return bh(function*(){null==t&&(t={});for(const s of n.callbacks)yield s.onBatchEnd(e,t)})()}onTrainBegin(e){var t=this;return bh(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainBegin(e)})()}onTrainEnd(e){var t=this;return bh(function*(){null==e&&(e={});for(const n of t.callbacks)yield n.onTrainEnd(e)})()}}class AN extends $N{constructor(){super()}onEpochBegin(e){var t=this;return bh(function*(){t.seen=0,t.totals={}})()}onBatchEnd(e,t){var n=this;return bh(function*(){null==t&&(t={});const e=null==t.size?0:t.size;n.seen+=e;for(const s in t){const r=t[s];if("number"==typeof r)n.totals.hasOwnProperty(s)||(n.totals[s]=0),n.totals[s]=n.totals[s]+r*e;else{let t;s in n.totals?t=n.totals[s]:n.totals[s]=0;const a=Iv(()=>Rv(n.totals[s],Ox(r,e)));n.totals[s]=a,null!=t&&t.dispose()}}})()}onEpochEnd(e,t){var n=this;return bh(function*(){if(null!=t)for(const e of n.params.metrics)null!=n.totals[e]&&("number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:Iv(()=>{const s=Ox(bx(1,n.seen),n.totals[e]);t[e]=s,n.totals[e].dispose(),Sv(t[e])}))})()}}class RN extends $N{onTrainBegin(e){var t=this;return bh(function*(){t.epoch=[],t.history={}})()}onEpochEnd(e,t){var n=this;return bh(function*(){null==t&&(t={}),n.epoch.push(e);for(const e in t)null==n.history[e]&&(n.history[e]=[]),n.history[e].push(t[e])})()}syncData(){var e=this;return bh(function*(){const t=[],n=[],s=[];for(const a in e.history){const r=e.history[a];for(let e=0;e<r.length;++e)"number"!=typeof r[e]&&(t.push(r[e].data()),n.push(a),s.push(e))}const r=yield Promise.all(t);for(let a=0;a<r.length;++a)e.history[n[a]][s[a]].dispose(),e.history[n[a]][s[a]]=r[a][0]})()}}class FN extends $N{constructor(e,t){if(super(),this.currentEpoch=0,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Bh(this.yieldEvery)&&(this.maybeWait=function(e,t){let n,s=gb();return(...r)=>{const a=gb();return a-s<t||(s=a,n=e(...r)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}maybeWait(e,t,n){var s=this;return bh(function*(){const r=[];null!=s.yield&&(yield _N(n),r.push(s.yield(e,t,n))),r.push(Hk()),yield Promise.all(r)})()}onEpochBegin(e,t){var n=this;return bh(function*(){n.currentEpoch=e,null!=n.epochBegin&&(yield _N(t),yield n.epochBegin(e,t))})()}onEpochEnd(e,t){var n=this;return bh(function*(){const s=[];null!=n.epochEnd&&(yield _N(t),s.push(n.epochEnd(e,t))),"epoch"===n.yieldEvery&&s.push(Hk()),yield Promise.all(s)})()}onBatchBegin(e,t){var n=this;return bh(function*(){null!=n.batchBegin&&(yield _N(t),yield n.batchBegin(e,t))})()}onBatchEnd(e,t){var n=this;return bh(function*(){const s=[];null!=n.batchEnd&&(yield _N(t),s.push(n.batchEnd(e,t))),"batch"===n.yieldEvery?s.push(Hk()):Bh(n.yieldEvery)&&s.push(n.maybeWait(n.currentEpoch,e,t)),yield Promise.all(s)})()}onTrainBegin(e){var t=this;return bh(function*(){null!=t.trainBegin&&(yield _N(e),yield t.trainBegin(e))})()}onTrainEnd(e){var t=this;return bh(function*(){null!=t.trainEnd&&(yield _N(e),yield t.trainEnd(e))})()}}function DN(e,t){return null==e&&(e={}),e instanceof $N?[e]:Array.isArray(e)&&e[0]instanceof $N?e:$S(e).map(e=>new FN(e,t))}class ON{constructor(){}static registerCallbackConstructor(e,t){Ih(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ON.checkForDuplicate(t),null==ON.constructors[e]&&(ON.constructors[e]=[]),ON.constructors[e].push(t)}static checkForDuplicate(e){for(const t in ON.constructors)ON.constructors[+t].forEach(t=>{if(t===e)throw new kS("Duplicate callback constructor.")})}static clear(){ON.constructors={}}static createCallbacks(e){const t=[];for(const n in ON.constructors){const s=+n;e>=s&&t.push(...ON.constructors[s])}return t.map(e=>new e)}}function qN(e,t,n,s,r,a,o,i,u){const l=new RN,c=[new AN,...ON.createCallbacks(t)];null!=e&&c.push(...e),c.push(l);const d=new TN(c);return d.setParams({epochs:n,initialEpoch:s,samples:r,steps:a,batchSize:o,verbose:t,doValidation:i,metrics:u}),{callbackList:d,history:l}}function zN(e,t={},n=!1){return OS(e,xv.getMap().classNameMap,t,"layer",n)}function MN(e,t){return Iv(()=>{"float32"!==e.dtype&&(e=e.asType("float32"));const n=zx(AE(e),t,!0),s=Sx(n.shape,vS()),r=Nw(jx(n,s));return bx(e,r)})}function LN(e,t){return Iv(()=>Bx(AE(qx(t,e)),-1))}function PN(e,t){return Iv(()=>Bx(Av(qx(t,e)),-1))}function VN(e,t){return Iv(()=>{const n=qx(e,t),s=nx(Av(e),vS(),Number.MAX_VALUE),r=Av(bx(n,s));return Ox(100,Bx(r,-1))})}function jN(e,t,n=!1){return Iv(()=>{if(n)t=_w(t);else{const e=zx(t,t.shape.length-1,!0);t=bx(t,e)}return t=nx(t,vS(),1-vS()),nw(zx(Ox(e.toFloat(),Rx(t)),t.shape.length-1))})}function BN(e,t,n=!1){return Iv(()=>{const s=Ex(function(e){const t=[mE(e.shape)];return e.reshape(t)}(e)).toInt(),r=(t=nx(t,vS(),1-vS())).shape;return jN(rw(s,r[r.length-1]).reshape(r),t,n)})}function WN(e,t){return Iv(()=>{let n;return n=nx(t,vS(),1-vS()),n=Rx(bx(n,qx(1,n))),Bx(function(e,t){if(!$h(e.shape,t.shape))throw new kS(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Iv(()=>{const n=t.relu(),s=t.abs().neg();return n.sub(t.mul(e)).add(s.exp().log1p())})}(e,n),-1)})}function UN(e,t){return Iv(()=>{const n=MN(e,-1),s=MN(t,-1),r=Ox(n,s);return nw(zx(r,-1))})}ON.constructors={};const GN={meanSquaredError:LN,meanAbsoluteError:PN,meanAbsolutePercentageError:VN,meanSquaredLogarithmicError:function(e,t){return Iv(()=>{const n=nx(t,vS(),Number.MAX_VALUE),s=Rx(Rv(1,n)),r=nx(e,vS(),Number.MAX_VALUE),a=Rx(Rv(1,r));return Bx(AE(qx(s,a)),-1)})},squaredHinge:function(e,t){return Iv(()=>{const n=jx(0,qx(1,Ox(e,t)));return Bx(AE(n),-1)})},hinge:function(e,t){return Iv(()=>{const n=jx(0,qx(1,Ox(e,t)));return Bx(n,-1)})},categoricalHinge:function(e,t){return Iv(()=>{const n=zx(Ox(e,t),-1),s=Dx(Ox(qx(1,e),t),-1);return jx(0,Rv(1,qx(s,n)))})},logcosh:function(e,t){return Iv(()=>{const n=Math.log(2),s=qx(t,e),r=qx(Rv(s,Sw(Ox(-2,s))),n);return Bx(r,-1)})},categoricalCrossentropy:jN,sparseCategoricalCrossentropy:BN,binaryCrossentropy:WN,kullbackLeiblerDivergence:function(e,t){return Iv(()=>{const n=nx(e,vS(),1),s=nx(t,vS(),1);return zx(Ox(e,Rx(bx(n,s))),-1)})},poisson:function(e,t){return Iv(()=>{const n=Rx(Rv(vS(),t));return Bx(qx(t,Ox(e,n)),-1)})},cosineProximity:UN};function HN(e){if("string"==typeof e){if(e in GN)return GN[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new kS(t)}return e}function KN(e,t){return Iv(()=>{const n=Ox(.5,iw(t)),s=xE($x(t,n),e.dtype);return Bx(kx(e,s),-1)})}function XN(e,t){return Iv(()=>xE(kx(Ov(e,-1),Ov(t,-1)),"float32"))}function ZN(e,t){return WN(e,t)}function YN(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),kx(e,t).asType("float32")}const QN=jN,JN=BN,e$={binaryAccuracy:KN,categoricalAccuracy:XN,precision:function(e,t){return Iv(()=>{const n=function(e,t){return Iv(()=>Lx(e.equal(1),t.equal(1)).sum().cast("float32"))}(e,t),s=function(e,t){return Iv(()=>Lx(e.equal(0),t.equal(1)).sum().cast("float32"))}(e,t),r=n.add(s);return zw($x(r,0),n.div(r),0).cast("float32")})},categoricalCrossentropy:QN,sparseCategoricalCrossentropy:JN,mse:LN,MSE:LN,mae:PN,MAE:PN,mape:VN,MAPE:VN,cosine:UN};function t$(e){if("string"==typeof e&&e in e$)return e$[e];if("string"!=typeof e&&null!=e)return e;throw new kS(`Unknown metric ${e}`)}function n$(e){if(SS(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(GN))if(GN[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(e$))if(e$[n]===e){t=n;break}return void 0!==t?t:e.name}}function s$(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!r$(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function r$(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!r$(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!r$(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function a$(e,t,n=console.log){let s="";for(let r=0;r<e.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=e[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);n(s)}function o$(e,t,n){let s;try{s=JSON.stringify(e.outputShape)}catch(oK){s="multiple"}a$([`${e.name} (${e.getClassName()})`,s,e.countParams().toString()],t,n)}function i$(e,t,n,s){let r;try{r=JSON.stringify(e.outputShape)}catch(oK){r="multiple"}const a=[];for(const l of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(let e=0;e<l.inboundLayers.length;++e)a.push(`${l.inboundLayers[e].name}[${l.nodeIndices[e]}][${l.tensorIndices[e]}]`);const o=e.name,i=e.getClassName(),u=0===a.length?"":a[0];a$([`${o} (${i})`,r,e.countParams().toString(),u],t,s);for(let l=1;l<a.length;++l)a$(["","","",a[l]],t,s)}function u$(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function l$(e,t){if(null===e)return null;if("string"==typeof e)return AS(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const s=e[r];u$(t,r,s)?n.push(s):n.push(l$(s,t))}return n}{const t={};for(const n of Object.keys(e)){const s=e[n];if("name"===n&&"string"==typeof s)t[n]=s;else{const e=AS(n);t[e]=l$(s,e)}}return t}}function c$(e,t){if(null==e)return null;if("string"==typeof e)return TS(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const s=e[r];u$(t,r,s)?n.push(s):n.push(c$(s,t))}return n}{const t={};for(const n of Object.keys(e)){const s=e[n];t[TS(n)]="name"!==n&&"className"!==n||"string"!=typeof s?c$(s,n):s}return t}}class d${constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof d$)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new kS(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Uy(t,e.dtype)}catch(oK){throw new kS(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof bN){if(null==this.id2Value[e.id])throw new kS(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new kS(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof bN){if(null==this.id2Value[e.id])throw new kS(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new kS(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&_v(this.id2Mask)}}const p$={},h$={};function f$(e,t,n,s){const r=null!=n&&n.training,a=Array.isArray(e),o=a?e:[e],i=o.map(e=>e.name),u=[],l=t.names();for(const f of i)-1!==l.indexOf(f)?u.push(t.getValue(f)):u.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=i.join(",")+"|"+t.names().join(",");let d,p;if(null==p$[c]){const e=function(e,t){Ih(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(1===e.length){const r=g$(e[0],t);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const a of e){const{sorted:e,recipientMap:o}=g$(a,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in o)null==s[t]&&(s[t]=new Set),o[t].forEach(e=>s[t].add(e))}}return{sorted:n,recipientCounts:m$(s)}}(o,t);d=e.sorted,p=e.recipientCounts,p$[c]=d,h$[c]=p}d=p$[c],p={},r||Object.assign(p,h$[c]);const h=new d$(t);for(let f=0;f<d.length;++f){if(null!=s){const e=Cv().numTensors;e>s.maxNumTensors&&(s.maxNumTensors=e),e<s.minNumTensors&&(s.minNumTensors=e)}const e=d[f],a=e.sourceLayer;if(a instanceof CN)continue;const o=[],l=[],c=[];let m=!1;for(const n of e.inputs){const e=h.getValue(n),s=h.getMask(n);o.push(e),l.push(s),null!=s&&(m=!0),r||(p[n.name]--,0!==p[n.name]||t.hasKey(n)||-1!==i.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=l[0]);const g=$S(a.apply(o,n));let b=null;a.supportsMasking&&(b=a.computeMask(o,l));const y=b$(e),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){h.hasKey(v[t])||h.add(v[t],g[t],Array.isArray(b)?b[0]:b);const e=i.indexOf(v[t].name);-1!==e&&(u[e]=g[t])}r||_v(c)}return h.disposeMasks(),a?u:u[0]}function m$(e){const t={};for(const n in e)t[n]=e[n].size;return t}function g$(e,t){const n=new Set,s=[],r={};for(const i of t.names())n.add(i);const a=[],o=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=o[o.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),s.push(e),n.add(e.name),t&&o.pop();else{o.push(a.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:s,recipientMap:r}}function b$(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const s of e.sourceLayer.inboundNodes[t].outputTensors)if(s.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}class y$ extends wN{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=iN(e)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(e.inputs)?e.inputs.slice():[e.inputs],this.outputs=Array.isArray(e.outputs)?e.outputs.slice():[e.outputs],zS(this.inputs).length!==this.inputs.length)throw new kS(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);zS(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.nodeIndex,t=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(e),this.outputLayersTensorIndices.push(t)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;SS(0===t,"input layer has >1 nodes"),SS(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof CN))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},s={},r={},a={},o=[],i=(e,t,n,s,r,u)=>{null!=s&&null!=r&&null!=u||(s=e.sourceLayer,r=e.nodeIndex,u=e.tensorIndex);const l=s.inboundNodes[r];if(-1!==n.indexOf(l))throw new wS(`The tensor ${e.name} at layer "${s.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(y$.nodeKey(s,r)),s.id in a||(a[s.id]=Object.keys(a).length),-1===n.indexOf(l)&&n.push(l);const c=l.inboundLayers.length;for(let a=0;a<c;a++)i(l.inputTensors[a],t,n,l.inboundLayers[a],l.nodeIndices[a],l.tensorIndices[a]);for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);o.push(l)},u=[],l=[];for(const b of this.outputs)i(b,u,l);const c=o.slice().reverse();for(const b of c){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];e=Math.max(e,null==s[b.outboundLayer.id]?0:s[b.outboundLayer.id]),s[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let s=0;s<b.inboundLayers.length;s++){const r=b.inboundLayers[s].inboundNodes[b.nodeIndices[s]];t[r.id]=Math.max(e+1,null==t[r.id]?0:t[r.id]),n[r.id]=r}}const d={};for(const b in t){const e=t[b];e in d||(d[e]=[]),d[e].push(n[b])}const p={};for(const b in s){const e=s[b];e in p||(p[e]=[]),p[e].push(r[b])}let h=Object.keys(p).map(e=>parseInt(e,10)).sort(qS);this.layers=[];for(const b of h){const e=p[b];e.sort((e,t)=>{const n=a[e.id],s=a[t.id];return n<s?-1:n>s?1:0});for(const t of e)t instanceof y$&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=p,h=Object.keys(d).map(e=>parseInt(e,10)).sort(qS);const f=this.inputs.slice(),m=[];for(const b of h)for(const e of d[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new wS(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map(e=>e.name);for(const b of g){const e=g.filter(e=>e===b).length;if(1!==e)throw new wS(`The name "${b}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new vN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new kS("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let s=0;for(const a of this.layers)for(const e of a.weights){if(null!=n[e.originalName])throw new kS(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,s++}const r=[];for(const a in e){let s=a;if(null==n[a]){const e=a.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])r.push([n[s],e[a]]);else if(t)throw new kS(`Provided weight data has no target variable: ${a}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new kS(`${e.length} of ${s} weights are not set: ${e}`)}mN(r)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers 3.6.0",t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=c$(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Iv(()=>{e=$S(e);const n=new d$;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return f$(this.outputs,n,t)})}computeMask(e,t){return Iv(()=>{let n;return e=$S(e),n=null==t?_S(null,e.length):$S(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=lN(e);if(t.length!==this.inputLayers.length)throw new kS(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let o=0;o<t.length;o++)n[this.inputLayers[o].name+"_0_0"]=t[o];const s=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(qS);if(s.length>1)for(const o of s){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(e.id))continue;const s=[];for(let o=0;o<t.inboundLayers.length;o++)s.push(n[`${t.inboundLayers[o].name}_${t.nodeIndices[o]}_${t.tensorIndices[o]}`]);const r=lN(e.computeOutputShape(NS(s))),a=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++)n[`${e.name}_${a}_${t}`]=r[t]}}const r=[],a=[];for(let o=0;o<this.outputLayers.length;o++)a.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<a.length;o++){const e=a[o];SS(e in n),r.push(n[e])}return NS(r)}runInternalGraph(e,t){null==t&&(t=_S(null,e.length));const n={};for(let i=0;i<this.inputs.length;++i)n[this.inputs[i].id]=[e[i],t[i]];const s=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(qS);for(const i of s){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer,s=t.inputTensors,r=t.outputTensors,a=new Array;for(const t of s)t.id in n&&a.push(n[t.id]);if(a.length===s.length){let s,o,i,u,l={};if(null!=t.callArgs&&(l=t.callArgs),1===a.length){const[t,n]=a[0];null==l.mask&&(l.mask=n),i=$S(e.call(t,l)),u=$S(e.computeMask(t,n)),s=[t],o=[n]}else s=a.map(e=>e[0]),o=a.map(e=>e[1]),null==l.mask&&(l.mask=o),i=$S(e.call(s,l)),u=$S(e.computeMask(s,o));if(e.activityRegularizer)throw new CS("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e)n[r[e].id]=[i[e],u[e]]}}}const r=[],a=[],o=[];for(const i of this.outputs){SS(i.id in n,`Could not compute output ${i.name} : ${i.id}`);const[e,t]=n[i.id];o.push(e.shape),r.push(e),a.push(t)}return[r,a,o]}buildNodeConversionMap(e){const t={};let n;for(const s of this.layers){n=s instanceof y$?1:0;for(let e=0;e<s.inboundNodes.length;e++){const r=y$.nodeKey(s,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new kS(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new kS("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===e)return n;throw new kS(`No such layer: ${e}`)}calculateLosses(){return Iv(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const s=y$.nodeKey(t,n);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),s=a.getConfig(),r=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],s=y$.nodeKey(a,n);let o={};if(this.containerNodes.has(s)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(oK){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(e.inboundLayers.length>0){const n=[];for(let s=0;s<e.inboundLayers.length;s++){const r=e.inboundLayers[s],a=e.tensorIndices[s];let i=t[y$.nodeKey(r,e.nodeIndices[s])];null==i&&(i=0),n.push([r.name,i,a,o])}r.push(n)}}}const o={};o.name=a.name,o.className=e,o.config=s,o.inboundNodes=r,n.push(o)}e.layers=n;const s=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=y$.nodeKey(e,this.inputLayersNodeIndices[a]);if(!this.containerNodes.has(n))continue;let r=t[n];null==r&&(r=0),s.push([e.name,r,this.inputLayersTensorIndices[a]])}e.inputLayers=s;const r=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=y$.nodeKey(e,this.outputLayersNodeIndices[a]);if(!this.containerNodes.has(n))continue;let s=t[n];null==s&&(s=0),r.push([e.name,s,this.outputLayersTensorIndices[a]])}return e.outputLayers=r,e}static fromConfig(e,t,n={},s=!1){const r={},a={};function o(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){const n=[];let s;for(const a of t){const i=a[0],u=a[1],l=a[2];if(s=null==a[3]?{}:a[3],!(i in r))return void o(e,t);const c=r[i];if(c.inboundNodes.length<=u)return void o(e,t);n.push(c.inboundNodes[u].outputTensors[l])}n.length>0&&e.apply(NS(n),s)}function u(e){const n=e.name,a=zN(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(s),r[n]=a,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new kS(`Corrupted configuration, expected array for nodeData: ${e}`);o(a,e)})}const l=t.name,c=t.layers;for(const m of c)u(m);for(;!MS(a);)for(const e of c){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)i(t,n)}}const d=[],p=[],h=t.inputLayers;for(const m of h){const e=m[0],t=m[1],n=m[2];SS(e in r),d.push(r[e].inboundNodes[t].outputTensors[n])}const f=t.outputLayers;for(const m of f){const e=m[0],t=m[1],n=m[2];SS(e in r),p.push(r[e].inboundNodes[t].outputTensors[n])}return new e({inputs:d,outputs:p,name:l})}get stateful(){if(this._stateful)throw new kS("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Iv(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function v$(e,t){return function(e,t,n){const s=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===s)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==s)throw new Error(`Provided classWeight is an array of ${e.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{n.push(t in e?e[t]:null)}),n}throw new Error(`The model has multiple (${s}) outputs, so classWeight must be either an array with ${s} elements or an object with ${t} keys. Provided classWeight not understood: ${JSON.stringify(e)}`)}(e,t)}function x$(e,t,n,s){return w$.apply(this,arguments)}function w$(){return(w$=bh(function*(e,t,n,s){if(null!=t||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Iv(()=>{if(1===e.shape.length)return e.clone();if(2===e.shape.length){if(e.shape[1]>1)return e.argMax(1);if(1===e.shape[1])return e.reshape([e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield t.data());_v(t);const r=[];return s.forEach(e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);r.push(n[e])}),Rw(r,"float32")}return null})).apply(this,arguments)}function k$(e,t){return Ox(e,t)}function C$(e,t){let n,s;n=t.xs,s=t.ys,Ih(null!=n&&null!=s,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const r=I$("input",e.inputNames,n),a=I$("output",e.outputNames,s),o=r[0].shape[0];Ih(r.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),Ih(a.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let i=0;i<r.length;i++)Ih(r[i].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[i]} has ${r[i].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let i=0;i<a.length;i++)Ih(a[i].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[i]} has ${a[i].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:r,ys:a}}function I$(e,t,n){if(n instanceof Ab)return[n];if(Array.isArray(n))return Ih(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const s=[];for(const r of t){if(null==n[r])throw new kS(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);s.push(n[r])}return s}}function _$(e){if(3===e.length)throw new CS("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function S$(){return(S$=bh(function*(e,t,n){const s=null!=n.batchesPerEpoch;if(Ih(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Ih(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Ih(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),Ih(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),Ih(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let a,o;if(r)if(N$(n.validationData))Ih(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const e=_$(n.validationData);a=e.xs,o=e.ys}const i=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let l;l=r?u.slice().concat(u.map(e=>"val_"+e)):u.slice();const c=DN(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:h}=qN(c,d,n.epochs,null,null,E$(t,n),null,r,l);p.setModel(e),e.history=h,yield p.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=yield t.iterator();for(;f<n.epochs;){const l={};yield p.onEpochBegin(f);let c=0,d=0;for(s||(m=yield t.iterator());!s||c<n.batchesPerEpoch;){const t=yield m.next();if(s&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:s,ys:r}=C$(e,t.value),a={};a.batch=d,a.size=s[0].shape[0],yield p.onBatchBegin(d,a);const o=[];if(null!=n.classWeight){const t=v$(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(yield x$(r[e],null,t[e]))}const l=s.concat(r).concat(o),h=i(l);_v(l);for(let e=0;e<u.length;++e){const t=h[e];a[u[e]]=t,Sv(t)}yield p.onBatchEnd(d,a),EN(a),d++,c++}if(s?c>=n.batchesPerEpoch:t.done){if(r){let t;t=N$(n.validationData)?$S(yield e.evaluateDataset(n.validationData,{batches:n.validationBatches})):$S(e.evaluate(a,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(yield p.onEpochEnd(f,l),f++,e.stopTraining_)break}return yield p.onTrainEnd(),yield e.history.syncData(),e.history}finally{e.isTraining=!1}})).apply(this,arguments)}function E$(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function N$(e){return"function"==typeof e.iterator}function $$(e){return"function"==typeof e.next}function T$(){return(T$=bh(function*(e,t,n){const s=null!=(n=n||{}).batches,r=e.testFunction;let a=[];if(n.verbose>0)throw new CS("Verbose mode is not implemented yet.");Ih(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const o=$$(t)?t:yield t.iterator();let i=0,u=0;for(;!s||u<n.batches;){const t=yield o.next();if(a=Iv(()=>{if(t.value){const{xs:n,ys:s}=C$(e,t.value),o=n.concat(s),l=Iv(()=>r(o));if(_v(o),0===u)for(let e=0;e<l.length;++e)a.push($v(0));const c=o[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=a[e];a[e]=Iv(()=>Rv(a[e],Ox(c,t))),u>0&&_v(n)}_v(l),i+=c,++u}return a}),t.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<a.length;++l){const e=a[l];a[l]=bx(a[l],i),_v(e)}return NS(a)})).apply(this,arguments)}function A$(e){Ih(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function R$(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>kE(e,t,n-t)):kE(e,t,n-t)}function F$(e,t){return Iv(()=>null==e?null:Array.isArray(e)?e.map(e=>F$(e,t)):TE(e,"int32"===t.dtype?t:t.toInt()))}function D$(e,t){const n=[];let s=0,r=null;for(;s<e;)r=s+t,r>=e&&(r=e),n.push([s,r]),s=r;return n}function O$(e,t,n,s,r,a,o,i,u,l,c,d,p,h,f){return q$.apply(this,arguments)}function q$(){return(q$=bh(function*(e,t,n,s,r,a,o,i,u,l,c,d,p,h,f){null==r&&(r=32),null==a&&(a=1),null==c&&(c=!0),null==p&&(p=0);let m=!1;if(null!=u&&null!=l&&(m=!0),null!=f&&(m=!0,null==h))throw new kS("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=e.checkNumSamples(n,r,h,"steps_per_epoch");let b;null!=g&&(b=vE(0,g)),null==o&&(o=1);const{callbackList:y,history:v}=qN(i,o,a,p,g,h,r,m,d);y.setModel(e),e.history=v,yield y.onTrainBegin(),e.stopTraining_=!1;for(let x=p;x<a;++x){yield y.onEpochBegin(x);const a={};if(null!=h)throw new CS("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new CS("batch shuffling is not implemneted yet");c&&wh(b);const o=Rw(b),i=D$(g,r);for(let c=0;c<i.length;++c){const d={};if(yield y.onBatchBegin(c,d),Iv(()=>{const p=i[c][0],h=i[c][1],f=kE(o,p,h-p);d.batch=c,d.size=h-p;const g=F$(n,f),b=t(g);for(let e=0;e<s.length;++e){const t=b[e];d[s[e]]=t,Sv(t)}if(c===i.length-1&&m){const t=e.testLoop(u,l,r);for(let e=0;e<s.length;++e){const n=s[e],r=t[e];Sv(r),a["val_"+n]=r}}}),yield y.onBatchEnd(c,d),EN(d),e.stopTraining_)break}o.dispose()}if(yield y.onEpochEnd(x,a),e.stopTraining_)break}return yield y.onTrainEnd(),yield e.history.syncData(),e.history})).apply(this,arguments)}function z$(){return(z$=bh(function*(e,t,n,s={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,a,o,i,u,l,c;e.isTraining=!0;try{const d=null==s.batchSize?32:s.batchSize;A$(d);const p=!1,h=yield e.standardizeUserData(t,n,s.sampleWeight,s.classWeight,p,d);r=h[0],a=h[1],c=h[2];let f,m=!1;if(null!=s.validationData&&s.validationData.length>0){if(m=!0,2!==s.validationData.length)throw 3===s.validationData.length?new CS("validationData including sample weights is not supported yet."):new kS(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);o=s.validationData[0],i=s.validationData[1];const t=!0,n=yield e.standardizeUserData(o,i,null,null,t,d);u=n[0],l=n[1],f=u.concat(l)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){m=!0;const e=Math.floor(r[0].shape[0]*(1-s.validationSplit)),t=r[0].shape[0];u=R$(r,e,t),r=R$(r,0,e),l=R$(a,e,t),a=R$(a,0,e),f=u.concat(l)}else null!=s.validationSteps&&(m=!0);const g=r.concat(a).concat(c);e.checkTrainableWeightsConsistency();const b=e.makeTrainFunction(),y=e.getDedupedMetricsNames();let v,x;m?(e.makeTestFunction(),v=e.testFunction,x=y.slice().concat(y.map(e=>"val_"+e))):(v=null,f=[],x=y.slice());const w=DN(s.callbacks,s.yieldEvery);return yield O$(e,b,g,y,d,s.epochs,s.verbose,w,v,f,s.shuffle,x,s.initialEpoch,null,null)}finally{e.isTraining=!1,L$(r,t),L$(a,n),L$(u,o),L$(l,i),null!=c&&_v(c)}})).apply(this,arguments)}function M$(e){const t=[];e instanceof Ab&&(e=[e]);for(let n=0;n<e.length;++n){const s=e[n];if(1===s.rank)t.push(wE(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function L$(e,t){if(null==e)return;const n=[];if(t instanceof Ab)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const r in t)n.push(t[r].id);const s=[];if(e instanceof Ab)-1===n.indexOf(e.id)&&s.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&s.push(e)});else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&s.push(t)}s.forEach(e=>{e.isDisposed||e.dispose()})}function P$(e){return Array.isArray(e)}function V$(e){return!function(e){return e instanceof Ab}(e)&&!P$(e)}function j$(e,t,n,s=!0,r=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(P$(e)&&e.length>0)t=!0;else if(V$(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new kS(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);let a;if(V$(e)){e=e,a=[];for(const n of t){if(null==e[n])throw new kS(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(P$(e)){if((e=e).length!==t.length)throw new kS(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new kS(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=M$(a),null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;const e=a[o];if(e.shape.length!==n[o].length)throw new kS(`Error when checking ${r}: expected ${t[o]} to have ${n[o].length} dimension(s). but got array with shape ${e.shape}`);for(let a=0;a<n[o].length;++a){if(0===a&&!s)continue;const i=e.shape[a],u=n[o][a];if(null!=u&&u>=0&&i!==u)throw new kS(`Error when checking ${r}: expected ${t[o]} to have shape [${n[o]}], but got array with shape [${e.shape}].`)}}return a}function B$(e,t,n,s=!0,r=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new kS(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new kS(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;const e=a[o];if(e.shape.length!==n[o].length)throw new kS(`Error when checking ${r}: expected ${t[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let a=0;a<n[o].length;++a){if(0===a&&!s)continue;const i=e.shape[a],u=n[o][a];if(null!=u&&u!==i)throw new kS(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class W$ extends y${constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new kS("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,s=console.log){const r=function(e){let t=!0;const n=[],s=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==s.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Output shape","Param #"];let o;if(r?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!r){a.push("Receives inputs"),o=[];for(const t in e.nodesByDepth)o.push(...e.nodesByDepth[t])}s("_".repeat(t)),a$(a,n,s),s("=".repeat(t));const i=e.layers;for(let c=0;c<i.length;++c)r?o$(i[c],n,s):i$(i[c],n,o,s),s((c===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=function(e){let t;return t=pN(null!=e.collectedTrainableWeights?e.collectedTrainableWeights:e.trainableWeights),t}(e),l=pN(e.nonTrainableWeights);s(`Total params: ${u+l}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${l}`),s("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Uk.adagrad(.01),Adadelta:()=>Uk.adadelta(1,.95,vS()),Adam:()=>Uk.adam(.001,.9,.999,vS()),Adamax:()=>Uk.adamax(.002,.9,.999,vS(),0),RMSProp:()=>Uk.rmsprop(.001,.9,0,vS()),SGD:()=>Uk.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new kS(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Tv))throw new kS("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new kS(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(e=>HN(e))}else{const n=HN(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new kS(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(HN(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],cE("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const s=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const s of t){let t=n.hasOwnProperty(s)?n[s]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};cE("metric",()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,s,a;for(const o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===WN?-1!==["accuracy","acc"].indexOf(o)?s=KN:-1!==["crossentropy","ce"].indexOf(o)&&(s=ZN):this.lossFunctions[e]===BN?-1!==["accuracy","acc"].indexOf(o)?s=YN:-1!==["crossentropy","ce"].indexOf(o)&&(s=JN):-1!==["accuracy","acc"].indexOf(o)?s=XN:-1!==["crossentropy","ce"].indexOf(o)&&(s=QN),-1!==["accuracy","acc"].indexOf(o)?r="acc":-1!==["crossentropy","ce"].indexOf(o)&&(r="ce"),a=s,n=""+r}else{const e=t$(o);a=e,n=""+n$(o)}let t;cE(n,()=>{t=a}),r(e,n,t)}})(s[e])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const s=null==n.batchSize?32:n.batchSize;A$(s);const r=this.standardizeUserDataXY(e,t,!0,s);try{const a=r[0].concat(r[1]);return this.makeTestFunction(),NS(this.testLoop(this.testFunction,a,s,n.verbose,n.steps))}finally{L$(r[0],e),L$(r[1],t)}}evaluateDataset(e,t){var n=this;return bh(function*(){return n.makeTestFunction(),function(e,t,n){return T$.apply(this,arguments)}(n,e,t)})()}checkNumSamples(e,t,n,s="steps"){let r;if(null!=n){if(r=null,null!=t)throw new kS(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new kS(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new kS("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),s=this.retrieveSymbolicTensors(n?t:[t]),r=new d$;if(e instanceof Ab&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new kS(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)r.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new kS(`No value is provided for the model's input ${o.name}`);r.add(o,t)}const a=f$(s,r);return n?a:a[0]}retrieveSymbolicTensors(e){const t=_S(null,e.length);let n=e.length;for(const s of this.layers){const r=Array.isArray(s.output)?s.output:[s.output],a=r.map(e=>e.name);for(let s=0;s<e.length;++s){const o=a.indexOf(e[s]);if(-1!==o&&(t[s]=r[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,s)=>{null==t&&n.push(e[s])}),new kS(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return Iv(()=>{const s=this.checkNumSamples(e);if(n)throw new CS("Verbose predictLoop() is not implemented yet.");const r=D$(s,t),a=this.outputs.map(e=>[]);for(let t=0;t<r.length;++t)Iv(()=>{const n=R$(e,r[t][0],r[t][1]),s=[];if(Array.isArray(n))for(let e=0;e<n.length;++e)s.push({key:this.inputs[e],value:n[e]});else s.push({key:this.inputs[0],value:n});const a=new d$(s);return f$(this.outputs,a)}).forEach((e,t)=>a[t].push(e));return NS(a.map(e=>sx(e,0)))})}predict(e,t={}){const n=M$(e);B$(n,this.inputNames,this.feedInputShapes,!1);try{const s=null==t.batchSize?32:t.batchSize;return A$(s),this.predictLoop(n,s)}finally{L$(n,e)}}predictOnBatch(e){B$(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,s){if(null==this.optimizer_)throw new wS("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];r.push(this.feedLossFns[a]===BN?e.slice(0,e.length-1).concat([1]):e)}if(function(e,t,n){const s=zS(e.map(e=>e.shape[0]));s.sort();const r=zS(t.map(e=>e.shape[0]));if(r.sort(),s.length>1)throw new kS(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(e=>e.shape))}`);if(r.length>1)throw new kS(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(e=>e.shape))}`);if(s.length>0&&r.length>0&&!$h(s,r))throw new kS(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=j$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=j$(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const s=[LN,WN,jN];for(let r=0;r<e.length;++r){const a=e[r],o=t[r],i=n[r];if(null!=o){if(o===jN&&1===a.shape[a.shape.length-1])throw new kS(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(o)){const e=a.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const s=e[n],r=t[n];if(null!=r&&s!==r)throw new kS(`A target Tensor with shape ${a.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&e[0].shape[0]%s!=0)throw new kS(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}standardizeUserData(e,t,n,s,r=!0,a){var o=this;return bh(function*(){const[i,u]=o.standardizeUserDataXY(e,t,r,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=s){const e=v$(s,o.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(yield x$(u[t],null,e[t]))}return[i,u,l]})()}testLoop(e,t,n,s=0,r){return Iv(()=>{const a=this.checkNumSamples(t,n,r,"steps"),o=[];if(s>0)throw new CS("Verbose mode is not implemented yet.");if(null!=r)throw new CS("steps mode in testLoop() is not implemented yet");{const s=D$(a,n),r=Rw(vE(0,a));for(let n=0;n<s.length;++n){const a=s[n][0],i=s[n][1],u=kE(r,a,i-a),l=F$(t,u),c=e(l);if(0===n)for(let e=0;e<c.length;++e)o.push($v(0));for(let e=0;e<c.length;++e)o[e]=Rv(o[e],Ox(i-a,c[e]))}for(let e=0;e<o.length;++e)o[e]=bx(o[e],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const s=e[n];let r=s;ES(e,s)>1&&(r+=`_${ES(e.slice(0,n),s)}`),t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],o=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const o=new d$(e),i=f$(this.outputs,o,{training:!0});let u;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(s[n],i[n]);null!=r[n]&&(e=k$(e,r[n]));const a=Bx(e);t.push(a),u=0===n?e:Rv(u,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][1];e=Bx((0,this.metricsTensors[n][0])(s[t],i[t]))}Sv(e),a.push(e)}return u=Bx(u),this.calculateLosses().forEach(e=>{u=Rv(u,e)}),u},!0,o)].concat(a)}}makeTestFunction(){this.testFunction=e=>Iv(()=>{const t=[];let n;const s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:s[e]});const o=new d$(a),i=f$(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){const s=Bx((0,this.lossFunctions[e])(r[e],i[e]));n=0===e?s:Rv(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][1],s=Bx((0,this.metricsTensors[e][0])(r[n],i[n]));t.push(s)}return t})}fit(e,t,n={}){var s=this;return bh(function*(){return function(e,t,n){return z$.apply(this,arguments)}(s,e,t,n)})()}fitDataset(e,t){var n=this;return bh(function*(){return function(e,t,n){return S$.apply(this,arguments)}(n,e,t)})()}trainOnBatch(e,t){var n=this;return bh(function*(){const s=yield n.standardizeUserData(e,t),r=s[0],a=s[1],o=n.makeTrainFunction()(r.concat(a)),i=[];for(const e of o){const t=yield e.data();i.push(t[0])}return _v(o),NS(i)})()}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,s=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let a=0;a<s.length;++a)n&&!s[a].trainable||t.push({name:s[a].originalName,tensor:r[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Cv().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Cv().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=TS(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>TS(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const s of t){if("string"!=typeof n[s])throw new Error("Serialization of non-string loss is not supported.");e[s]=TS(n[s])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[TS(n$(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>TS(n$(e)));{const e={};for(const t in this.metrics)e[t]=TS(n$(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=zN(l$(e.optimizer_config));let n,s;if("string"==typeof e.loss)n=AS(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>AS(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=AS(e.loss[t])}if(Array.isArray(e.metrics))s=e.metrics.map(e=>AS(e));else if(null!=e.metrics){s={};for(const t in e.metrics)s[t]=AS(e.metrics[t])}this.compile({loss:n,metrics:s,optimizer:t})}save(e,t){var n=this;return bh(function*(){if("string"==typeof e){const t=vy.getSaveHandlers(e);if(0===t.length)throw new kS(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new kS(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new kS("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=yield dy(n.getNamedWeights(t)),r={modelTopology:n.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.6.0",convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=n.optimizer){r.trainingConfig=n.getTrainingConfig();const e="optimizer",{data:t,specs:a}=yield dy(yield n.optimizer.getWeights(),e);s.specs.push(...a),s.data=gy([s.data,t])}return null!=n.userDefinedMetadata&&(s$(n.userDefinedMetadata,n.name,!0),r.userDefinedMetadata=n.userDefinedMetadata),r.weightData=s.data,r.weightSpecs=s.specs,e.save(r)})()}setUserDefinedMetadata(e){s$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}W$.className="Model",wv(W$);class U$ extends W${}function G$(){return(G$=bh(function*(e,t){if(null==t&&(t={}),"string"==typeof e){const n=xy(e,t);if(0===n.length)n.push(nv(e,t));else if(n.length>1)throw new kS(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return H$(e,void 0,t)})).apply(this,arguments)}function H$(e,t,n){return K$.apply(this,arguments)}function K$(){return(K$=bh(function*(e,t,n){if(null==n&&(n={}),null==e.load)throw new kS("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=yield e.load();let r=s.modelTopology;null!=r.model_config&&(r=r.model_config);const a=null==n.strict||n.strict,o=null!=s.weightData&&null!=s.weightSpecs&&a,i=zN(l$(r),t,o),u=s.trainingConfig;if(null!=u&&i.loadTrainingConfig(u),null!=s.userDefinedMetadata&&i.setUserDefinedMetadata(s.userDefinedMetadata),null!=s.weightData){if(null==s.weightSpecs)throw new kS("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=X$(s.weightData,s.weightSpecs);i.loadWeights(e,a),null!=i.optimizer&&t.length>0&&(yield i.optimizer.setWeights(t)),_v(e),_v(t.map(e=>e.tensor))}return i})).apply(this,arguments)}function X$(e,t){const n=function(e,t){const n={};let s,r=0;for(const a of t){const t=a.name,o=a.dtype,i=a.shape,u=Nh(i);let l;if("quantization"in a){const n=a.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${a.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${a.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${a.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const i=cy[n.dtype],c=e.slice(r,r+u*i),d="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(d.length);for(let e=0;e<d.length;e++)l[e]=d[e]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===s&&(s=yy()),l=s(d)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(d.length);for(let e=0;e<d.length;e++)l[e]=Math.round(d[e]*n.scale+n.min)}r+=u*i}else if("string"===o){const t=Nh(a.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(r,r+4))[0];r+=4;const n=new Uint8Array(e.slice(r,r+t));l.push(n),r+=t}}else{const s=cy[o],a=e.slice(r,r+u*s);if("float32"===o)l=new Float32Array(a);else if("int32"===o)l=new Int32Array(a);else if("bool"===o)l=new Uint8Array(a);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${t}': ${o}`);{l=new Float32Array(a);const e=new Float32Array(l.length/2),s=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],s[t]=l[2*t+1];const r=ly(e,i,"float32"),o=ly(s,i,"float32");n[t]=iy(r,o),r.dispose(),o.dispose()}}r+=u*s}"complex64"!==o&&(n[t]=ly(l,i,o))}return n}(e,t),s={},r=[];return t.forEach(e=>{"optimizer"===e.group?r.push({name:e.name,tensor:n[e.name]}):s[e.name]=n[e.name]}),{modelWeights:s,optimizerWeights:r}}U$.className="Functional",wv(U$);class Z$ extends W${constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:iN("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new kS(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Z$||e instanceof W$;let n;if(t){if(n=e,1!==n.outputs.length)throw new kS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new kS("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new kS("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=IN({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new kS(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new kS("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=kN(this.outputs[0])}this.inboundNodes=[],new vN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:_S(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(dN(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new W$({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new wS("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}evaluateDataset(e,t){var n=this;return bh(function*(){if(!n.built)throw new wS("The model needs to be compiled before being used.");return n.model.evaluateDataset(e,t)})()}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,t,n={}){var s=this;return bh(function*(){if(!s.built)throw new wS("The model needs to be compiled before being used.");return s.model.fit(e,t,n)})()}fitDataset(e,t){var n=this;return bh(function*(){if(!n.built)throw new wS("The model needs to be compiled before being used.");return n.model.fitDataset(e,t)})()}trainOnBatch(e,t){var n=this;return bh(function*(){return n.model.trainOnBatch(e,t)})()}static fromConfig(e,t,n={},s=!1){let r,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new kS("Legacy serialization format not supported yet.");r=t}else Ih(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof Z$))throw new CS(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const i of r){const e=zN(i,void 0,s);s&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(e){if(null==this.model)throw new kS("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new kS("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function Y$(e){return new W$(e)}function Q$(e,t){return null==t&&(t={}),function(e,t){return G$.apply(this,arguments)}(e,t)}function J$(e){return IN(e)}Z$.className="Sequential",wv(Z$);class eT extends vv{getConfig(){return{}}}class tT extends eT{apply(e,t=1){return function(e,t=1){if(1!==t)throw new CS(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return yx(e)}(e,t)}}tT.className="elu",wv(tT);class nT extends eT{apply(e){return bw(e)}}nT.className="selu",wv(nT);class sT extends eT{apply(e){return mw(e)}}sT.className="relu",wv(sT);class rT extends eT{apply(e){return Iv(()=>Ux(6,mw(e)))}}rT.className="relu6",wv(rT);class aT extends eT{apply(e){return e}}aT.className="linear",wv(aT);class oT extends eT{apply(e){return vw(e)}}oT.className="sigmoid",wv(oT);class iT extends eT{apply(e){return function(e){return Iv(()=>{const t=Rv(.5,Ox(.2,e));return nx(t,0,1)})}(e)}}iT.className="hardSigmoid",wv(iT);class uT extends eT{apply(e){return Sw(e)}}uT.className="softplus",wv(uT);class lT extends eT{apply(e){return function(e){return Iv(()=>bx(e,Av(e).add(1)))}(e)}}lT.className="softsign",wv(lT);class cT extends eT{apply(e){return Aw(e)}}cT.className="tanh",wv(cT);class dT extends eT{apply(e,t=-1){return _w(e,t)}}dT.className="softmax",wv(dT);class pT extends eT{apply(e,t=-1){return Mx(e,t)}}pT.className="logSoftmax",wv(pT);class hT extends eT{apply(e,t=1){return Iv(()=>vw(e.mul(t)).mul(e))}}hT.className="swish",wv(hT);class fT extends eT{apply(e){return Iv(()=>Ox(e,Aw(Sw(e))))}}function mT(e){return e.getClassName()}function gT(e,t={}){return OS(e,xv.getMap().classNameMap,t,"activation")}function bT(e){if(null==e)return gT({className:"linear",config:{}});if("string"==typeof e){const t={};return t.className=e,t.config={},gT(t)}return e instanceof eT?e:gT(e)}fT.className="mish",wv(fT);class yT extends vv{}class vT extends yT{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Iv(()=>{let t=aw([1]);return this.hasL1&&(t=Rv(t,zx(Ox(this.l1,Av(e))))),this.hasL2&&(t=Rv(t,zx(Ox(this.l2,AE(e))))),t.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}vT.className="L1L2",wv(vT);const xT={l1l2:"L1L2"};function wT(e){return FS(e)}function kT(e,t={}){return OS(e,xv.getMap().classNameMap,t,"regularizer")}function CT(e){return null==e?null:"string"==typeof e?kT({className:e in xT?xT[e]:e,config:{}}):e instanceof yT?e:kT(e)}class IT extends wN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=cN(e);let n=mw(e);return null!=this.maxValue&&(n=nx(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}IT.className="ReLU",wv(IT);class _T extends wN{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=cN(e);return Ax(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}_T.className="LeakyReLU",wv(_T);class ST extends wN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=sN(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=CT(e.alphaRegularizer),this.alphaConstraint=JS(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new kS(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=dN(e)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let s=1;s<e.length;++s)n[s]=e[s];this.inputSpec=[new gN({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=cN(e),lw(e,this.alpha.read())}getConfig(){const e={alphaInitializer:nN(this.alphaInitializer),alphaRegularizer:wT(this.alphaRegularizer),alphaConstraint:YS(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}ST.className="PReLU",wv(ST);class ET extends wN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new CS(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=cN(e);return yx(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}ET.className="ELU",wv(ET);class NT extends wN{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=cN(e);return n.mul(xE(n.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}NT.className="ThresholdedReLU",wv(NT);class $T extends wN{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new dT).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=cN(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function TT(e,t,n){if("number"==typeof e)return _S(e,t);if(e.length!==t)throw new kS(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const a=e[r];if((s=a)!==parseInt(s.toString(),10))throw new kS(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var s}function AT(e,t,n,s,r=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(r-1))+1,Math.floor((a+s-1)/s)}function RT(e,t,n,s){if(null==e)return null;if("valid"===s)e=e*t+yE([n-t,0]);else{if("same"!==s)throw new kS(`Unsupport padding mode: ${s}.`);e*=t}return e}function FT(e,t){return Iv(()=>(oE(t),"channelsFirst"===t?Lw(e,[0,2,3,1]):e))}function DT(e,t){return Iv(()=>(oE(t),"channelsFirst"===t?Lw(e,[0,2,3,4,1]):e))}function OT(e,t,n,s=[1,1],r="valid",a,o,i=null){return Iv(()=>{if(null==a&&(a="channelsLast"),oE(a),3!==e.rank&&4!==e.rank)throw new kS(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new kS(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=FT(e,a);if("causal"===r)throw new CS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=ek({x:u,filter:t,strides:s,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===a&&(u=Lw(u,[0,3,1,2])),u})}$T.className="Softmax",wv($T);class qT extends wN{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",qT.verifyArgs(t),this.rank=e,VS(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new CS(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=TT(t.kernelSize,e,"kernelSize"),this.strides=TT(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,iE(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,oE(this.dataFormat),this.activation=bT(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=sN(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=JS(t.biasConstraint),this.biasRegularizer=CT(t.biasRegularizer),this.activityRegularizer=CT(t.activityRegularizer),this.dilationRate=TT(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new kS(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new kS(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new kS(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(SS("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!PS(e.kernelSize,"number",1,3))throw new kS(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:mT(this.activation),useBias:this.useBias,biasInitializer:nN(this.biasInitializer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),biasConstraint:YS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class zT extends qT{constructor(e,t){super(e,t),this.kernel=null,zT.verifyArgs(t),this.filters=t.filters,VS(this.filters,"filters"),this.kernelInitializer=sN(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=JS(t.kernelConstraint),this.kernelRegularizer=CT(t.kernelRegularizer)}build(e){e=dN(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Iv(()=>{let t;e=cN(e);const n=null==this.bias?null:this.bias.read(),s=BS(this.activation.getClassName());if(null!=s&&2===this.rank)t=OT(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)t=function(e,t,n,s=1,r="valid",a,o=1){return Iv(()=>{if(null==a&&(a="channelsLast"),oE(a),3!==e.shape.length)throw new kS(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new kS(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new kS(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===a&&(e=Lw(e,[0,2,1])),"causal"===r)throw new CS("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=lx(e,t,s,"same"===r?"same":"valid","NWC",o);return null!=n&&(i=FE(i,n)),i})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=OT(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new CS("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,s=[1,1,1],r="valid",a,o){return Iv(()=>{if(null==a&&(a="channelsLast"),oE(a),4!==e.rank&&5!==e.rank)throw new kS(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new kS(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let i=DT(e,a);if("causal"===r)throw new CS("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=px(i,t,s,"same"===r?"same":"valid","NDHWC",o),null!=n&&(i=FE(i,n)),"channelsFirst"===a&&(i=Lw(i,[0,4,1,2,3])),i})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=dN(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=AT(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let s=[e[0]];return"channelsLast"===this.dataFormat?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:nN(this.kernelInitializer),kernelRegularizer:wT(this.kernelRegularizer),kernelConstraint:YS(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new kS(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class MT extends zT{constructor(e){super(2,e),MT.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!PS(e.kernelSize,"number",1,2))throw new kS(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}MT.className="Conv2D",wv(MT);class LT extends zT{constructor(e){super(3,e),LT.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new kS(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}LT.className="Conv3D",wv(LT);class PT extends MT{constructor(e){if(super(e),this.inputSpec=[new gN({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new kS(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=dN(e)).length)throw new kS("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gN({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Iv(()=>{let t=cN(e);if(4!==t.shape.length)throw new kS(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let s,r;"channelsFirst"===this.dataFormat?(s=2,r=3):(s=1,r=2);const a=n[r],o=this.kernelSize[1],i=this.strides[1],u=[n[0],RT(n[s],this.strides[0],this.kernelSize[0],this.padding),RT(a,i,o,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Lw(t,[0,2,3,1]));let l=dx(t,this.kernel.read(),u,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(l=Lw(l,[0,3,1,2])),null!=this.bias&&(l=FE(l,this.bias.read(),this.dataFormat)),null!=this.activation&&(l=this.activation.apply(l)),l})}computeOutputShape(e){const t=(e=dN(e)).slice();let n,s,r;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3):(n=3,s=1,r=2);const a=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[s]=RT(t[s],i,a,this.padding),t[r]=RT(t[r],u,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}PT.className="Conv2DTranspose",wv(PT);class VT extends LT{constructor(e){if(super(e),this.inputSpec=[new gN({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new kS(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=dN(e)).length)throw new kS("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new kS("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gN({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Iv(()=>{let t=cN(e);if(5!==t.shape.length)throw new kS(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape;let s,r,a;"channelsFirst"===this.dataFormat?(a=2,s=3,r=4):(a=1,s=2,r=3);const o=n[s],i=n[r],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[1],d=this.strides[2],p=[n[0],RT(n[a],this.strides[0],this.kernelSize[0],this.padding),RT(o,c,u,this.padding),RT(i,d,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Lw(t,[0,2,3,4,1]));let h=fx(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(h=Lw(h,[0,4,1,2,3])),null!==this.bias&&(h=FE(h,this.bias.read(),this.dataFormat)),null!==this.activation&&(h=this.activation.apply(h)),h})}computeOutputShape(e){const t=(e=dN(e)).slice();let n,s,r,a;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3,a=4):(n=4,s=1,r=2,a=3);const o=this.kernelSize[0],i=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[s]=RT(t[s],l,o,this.padding),t[r]=RT(t[r],c,i,this.padding),t[a]=RT(t[a],d,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}VT.className="Conv3DTranspose",wv(VT);class jT extends zT{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new kS("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new kS("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new kS(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=sN(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=CT(t.depthwiseRegularizer),this.depthwiseConstraint=JS(t.depthwiseConstraint),this.pointwiseInitializer=sN(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=CT(t.pointwiseRegularizer),this.pointwiseConstraint=JS(t.pointwiseConstraint)}build(e){if((e=dN(e)).length<this.rank+2)throw new kS(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new kS(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],s=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new gN({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Iv(()=>{let t;if(e=cN(e),1===this.rank)throw new CS("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Lw(e,[0,2,3,1])),t=yw(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=FE(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Lw(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=nN(this.depthwiseInitializer),e.pointwiseInitializer=nN(this.pointwiseInitializer),e.depthwiseRegularizer=wT(this.depthwiseRegularizer),e.pointwiseRegularizer=wT(this.pointwiseRegularizer),e.depthwiseConstraint=YS(this.depthwiseConstraint),e.pointwiseConstraint=YS(this.pointwiseConstraint),e}}jT.className="SeparableConv";class BT extends jT{constructor(e){super(2,e)}}BT.className="SeparableConv2D",wv(BT);class WT extends zT{constructor(e){super(1,e),WT.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!PS(e.kernelSize,"number",1,1))throw new kS(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}WT.className="Conv1D",wv(WT);class UT extends wN{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Iv(()=>{if(e=cN(e),"channelsLast"===this.dataFormat){const t=IE(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return IE(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=IE(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return IE(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}UT.className="Cropping2D",wv(UT);class GT extends wN{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oE(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,LS(tE,"InterpolationFormat",this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,t){return Iv(()=>{let t=cN(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Lw(t,[0,2,3,1]);const e=this.size[0]*n[2],s=this.size[1]*n[3],r="nearest"===this.interpolation?t.resizeNearestNeighbor([e,s]):t.resizeBilinear([e,s]);return Lw(r,[0,3,1,2])}{const e=this.size[0]*n[1],s=this.size[1]*n[2];return"nearest"===this.interpolation?t.resizeNearestNeighbor([e,s]):t.resizeBilinear([e,s])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}GT.className="UpSampling2D",wv(GT);class HT extends qT{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=sN(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=JS(e.depthwiseConstraint),this.depthwiseRegularizer=CT(e.depthwiseRegularizer)}build(e){if((e=dN(e)).length<4)throw new kS(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new kS(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Iv(()=>{let t=function(e,t,n=[1,1],s="valid",r,a){return Iv(()=>{null==r&&(r="channelsLast"),oE(r);let o=FT(e,r);if(4!==e.rank)throw new kS(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new kS(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=mx(o,t,n,"same"===s?"same":"valid","NHWC",a),"channelsFirst"===r&&(o=Lw(o,[0,3,1,2])),o})}(e=cN(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=FE(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=dN(e);const t="channelsFirst"===this.dataFormat?e[3]:e[2],n="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=AT("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),r=AT(t,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],n,s,r]:[e[0],s,r,n]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=nN(this.depthwiseInitializer),e.depthwiseRegularizer=wT(this.depthwiseRegularizer),e.depthwiseConstraint=YS(this.depthwiseRegularizer),e}}function KT(e,t,n,s){if(Array.isArray(e)){if(null!=t||null!=n)throw new kS("When inputs is an array, neither initialState or constants should be provided");null!=s&&(n=e.slice(e.length-s,e.length),e=e.slice(0,e.length-s)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function XT(e,t,n,s=!1,r,a,o=!1,i=!1){return Iv(()=>{const u=t.shape.length;if(u<3)throw new kS(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(vE(2,u));if(t=Lw(t,l),null!=a)throw new CS("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=r.asType("bool").asType("float32")).rank===u-1&&(r=Cx(r,-1)),r=Lw(r,l)),s&&(t=gw(t,0),null!=r&&(r=gw(r,0)));const c=[];let d,p=n;const h=t.shape[0],f=Ow(t);let m,g;null!=r&&(m=Ow(r));for(let t=0;t<h;++t){const n=f[t],s=Iv(()=>e(n,p));if(null==r)d=s[0],p=s[1];else{const e=Iv(()=>{const e=m[t],n=iw(e).sub(e);return{output:s[0].mul(e).add(p[0].mul(n)),newStates:p.map((t,r)=>s[1][r].mul(e).add(t.mul(n)))}});d=e.output,p=e.newStates}i&&c.push(d)}return i&&(g=Tw(c,1)),[d,g,p]})}HT.className="DepthwiseConv2D",wv(HT);class ZT extends wN{constructor(e){let t;if(super(e),null==e.cell)throw new kS("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new rA({cells:e.cell}):e.cell,null==t.stateSize)throw new kS("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new gN({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?vE(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){uN(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let s;if(s=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const s of t)n.push([e[0],s]);return[s].concat(n)}return s}computeMask(e,t){return Iv(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new CS("Constants support is not implemented in RNN yet.");uN(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new gN({shape:[t,null,...n]});const s=[e[0]].concat(e.slice(2));let r;if(this.cell.build(s),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!$h(this.stateSpec.map(e=>e.shape[e.shape.length-1]),r))throw new kS(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(e=>new gN({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Iv(()=>{if(!this.stateful)throw new xS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new kS("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>aw([n,e])):[aw([n,this.cell.stateSize])];else if(null==e)_v(this.states_),null!=this.keptStates&&(_v(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>aw([n,e])):this.states_[0]=aw([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new kS(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):_v(this.states_);for(let t=0;t<this.states_.length;++t){const s=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,r];if(!$h(s.shape,a))throw new kS(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[t]=s}}this.states_=this.states_.map(e=>Sv(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,s=null==t?null:t.constants;null==t&&(t={});const r=KT(e,n,s,this.numConstants);e=r.inputs,n=r.initialState,s=r.constants;let a=[],o=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new gN({shape:e.shape}));o=o.concat(this.stateSpec)}if(null!=s&&(t.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof bN){const n=[e].concat(a),s=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=s;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Iv(()=>{const n=null==t?null:t.mask,s=null==t?null:t.training;let r=null==t?null:t.initialState;e=cN(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==a)throw new kS(`RNN Layer has ${a} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:s},i=XT((e,t)=>{const n=this.cell.call([e].concat(t),o);return[n[0],n.slice(1)]},e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),u=i[0],l=i[1],c=i[2];this.stateful&&this.resetStates(c,s);const d=this.returnSequences?l:u;return this.returnState?[d].concat(c):d})}getInitialState(e){return Iv(()=>{let t=aw(e.shape);return t=zx(t,[1,2]),t=wE(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?EE(t,[1,e]):t):this.cell.stateSize>1?[EE(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===ZT.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){const s=zN(t.cell,n);return new e(Object.assign(t,{cell:s}))}}ZT.className="RNN",wv(ZT);class YT extends wN{}class QT extends YT{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,VS(this.units,"units"),this.activation=bT(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=CT(e.kernelRegularizer),this.recurrentRegularizer=CT(e.recurrentRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.kernelConstraint=JS(e.kernelConstraint),this.recurrentConstraint=JS(e.recurrentConstraint),this.biasConstraint=JS(e.biasConstraint),this.dropout=bE([1,yE([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bE([1,yE([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=dN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Iv(()=>{if(2!==(e=e).length)throw new kS(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const s=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=aA({ones:()=>iw(e),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=aA({ones:()=>iw(n),rate:this.recurrentDropout,training:s}));const a=this.dropoutMask,o=this.recurrentDropoutMask;r=$E(null!=a?Ox(e,a):e,this.kernel.read()),null!=this.bias&&(r=FE(r,this.bias.read())),null!=o&&(n=Ox(n,o));let i=Rv(r,$E(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mT(this.activation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),recurrentInitializer:nN(this.recurrentInitializer),biasInitializer:nN(this.biasInitializer),kernelRegularizer:wT(this.kernelRegularizer),recurrentRegularizer:wT(this.recurrentRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),recurrentConstraint:YS(this.recurrentConstraint),biasConstraint:YS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}QT.className="SimpleRNNCell",wv(QT);class JT extends ZT{constructor(e){e.cell=new QT(e),super(e)}call(e,t){return Iv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return new e(t)}}JT.className="SimpleRNN",wv(JT);class eA extends YT{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new kS("GRUCell does not support reset_after parameter set to true.");this.units=e.units,VS(this.units,"units"),this.activation=bT(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=bT(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=CT(e.kernelRegularizer),this.recurrentRegularizer=CT(e.recurrentRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.kernelConstraint=JS(e.kernelConstraint),this.recurrentConstraint=JS(e.recurrentConstraint),this.biasConstraint=JS(e.biasConstraint),this.dropout=bE([1,yE([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bE([1,yE([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=dN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,t){return Iv(()=>{if(2!==(e=e).length)throw new kS(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=aA({ones:()=>iw(e),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=aA({ones:()=>iw(s),rate:this.recurrentDropout,training:n,count:3}));const r=this.recurrentDropoutMask;let a,o,i;0<this.dropout&&this.dropout<1&&(e=Ox(e,this.dropoutMask[0]));let u=$E(e,this.kernel.read());this.useBias&&(u=FE(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Ox(s,r[0]));const l=this.recurrentKernel.read(),[c,d]=Ew(l,[2*this.units,this.units],l.rank-1),p=$E(s,c),[h,f,m]=Ew(u,3,u.rank-1),[g,b]=Ew(p,2,p.rank-1);a=this.recurrentActivation.apply(Rv(h,g)),o=this.recurrentActivation.apply(Rv(f,b));const y=$E(Ox(o,s),d);i=this.activation.apply(Rv(m,y));const v=Rv(Ox(a,s),Ox(Rv(1,nw(a)),i));return[v,v]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mT(this.activation),recurrentActivation:mT(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),recurrentInitializer:nN(this.recurrentInitializer),biasInitializer:nN(this.biasInitializer),kernelRegularizer:wT(this.kernelRegularizer),recurrentRegularizer:wT(this.recurrentRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),recurrentConstraint:YS(this.recurrentConstraint),biasConstraint:YS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}eA.className="GRUCell",wv(eA);class tA extends ZT{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new eA(e),super(e)}call(e,t){return Iv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}tA.className="GRU",wv(tA);class nA extends YT{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,VS(this.units,"units"),this.activation=bT(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=bT(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=CT(e.kernelRegularizer),this.recurrentRegularizer=CT(e.recurrentRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.kernelConstraint=JS(e.kernelConstraint),this.recurrentConstraint=JS(e.recurrentConstraint),this.biasConstraint=JS(e.biasConstraint),this.dropout=bE([1,yE([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bE([1,yE([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n;if(e=dN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,s=this.units;n=new((t=class extends ME{apply(t,n){const r=e.apply([s]),a=(new PE).apply([s]),o=e.apply([2*s]);return SE(SE(r,a),o)}}).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Iv(()=>{const n=null!=t.training&&t.training;if(3!==(e=e).length)throw new kS(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=aA({ones:()=>iw(e),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=aA({ones:()=>iw(s),rate:this.recurrentDropout,training:n,count:4}));const a=this.recurrentDropoutMask;let o,i,u,l;0<this.dropout&&this.dropout<1&&(e=Ox(e,this.dropoutMask[0]));let c=$E(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Ox(s,a[0])),c=Rv(c,$E(s,this.recurrentKernel.read())),this.useBias&&(c=FE(c,this.bias.read()));const[d,p,h,f]=Ew(c,4,c.rank-1);o=this.recurrentActivation.apply(d),i=this.recurrentActivation.apply(p),u=Rv(Ox(i,r),Ox(o,this.activation.apply(h))),l=this.recurrentActivation.apply(f);const m=Ox(l,this.activation.apply(u));return[m,m,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mT(this.activation),recurrentActivation:mT(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),recurrentInitializer:nN(this.recurrentInitializer),biasInitializer:nN(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:wT(this.kernelRegularizer),recurrentRegularizer:wT(this.recurrentRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),recurrentConstraint:YS(this.recurrentConstraint),biasConstraint:YS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}nA.className="LSTMCell",wv(nA);class sA extends ZT{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new nA(e),super(e)}call(e,t){return Iv(()=>(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}sA.className="LSTM",wv(sA);class rA extends YT{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Iv(()=>{let n=(e=e).slice(1);const s=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?s.push(n.splice(0,e.stateSize.length)):s.push(n.splice(0,1));s.reverse();const r=[];let a;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=s[o],a=0===o?[e[0]].concat(n):[a[0]].concat(n),a=i.call(a,t),r.push(a.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[a[0]].concat(n)})}build(e){let t;uN(e)&&(e=e[0]),e=e,this.cells.forEach((n,s)=>{cE(`RNNCell_${s}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}));return Object.assign({},e,{cells:t})}static fromConfig(e,t,n={}){const s=[];for(const r of t.cells)s.push(zN(r,n));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return fN(e)}setWeights(e){const t=[];for(const n of this.cells){const s=e.splice(n.weights.length);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}mN(t)}}function aA(e){const{ones:t,rate:n,training:s=!1,count:r=1}=e,a=()=>DE(t(),n),o=()=>OE(a,t,s);return!r||r<=1?Sv(o().clone()):Array(r).fill(void 0).map(o).map(e=>Sv(e.clone()))}var oA,iA,uA,lA;rA.className="StackedRNNCells",wv(rA);class cA extends ZT{constructor(e){if(e.unroll)throw new CS("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new CS("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new gN({ndim:5})]}call(e,t){return Iv(()=>{if(null!=this.cell.dropoutMask&&(_v(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(_v(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new kS("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==t?null:t.mask,training:null==t?null:t.training,initialState:null==t?null:t.initialState})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Iv(()=>{const{stateSize:t}=this.cell,n=this.computeSingleOutputShape(e.shape),s=aw([n[0],...n.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){Iv(()=>{if(!this.stateful)throw new xS("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,s=this.computeSingleOutputShape(n),r=[s[0],...s.slice(2)];if(null==n[0])throw new kS("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>aw(r)):[aw(r)];else if(null==e)_v(this.states_),null!=this.keptStates&&(_v(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>aw(r)):this.states_[0]=aw(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new kS(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_v(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],s=r;if(!$h(n.shape,s))throw new kS(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>Sv(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:s,padding:r,strides:a,dilationRate:o}=this.cell,i="channelsFirst"===t,u=e[i?4:3],l=AT(e[i?3:2],s[0],r,a[0],o[0]),c=AT(u,s[1],r,a[1],o[1]);return[...e.slice(0,2),...i?[n,l,c]:[l,c,n]]}}cA.className="ConvRNN2D";class dA extends nA{constructor(e){const{filters:t,kernelSize:n,strides:s,padding:r,dataFormat:a,dilationRate:o}=e;super(Object.assign({},e,{units:t})),this.filters=t,VS(this.filters,"filters"),this.kernelSize=TT(n,2,"kernelSize"),this.kernelSize.forEach(e=>VS(e,"kernelSize")),this.strides=TT(s||1,2,"strides"),this.strides.forEach(e=>VS(e,"strides")),this.padding=r||"valid",iE(this.padding),this.dataFormat=a||"channelsLast",oE(this.dataFormat),this.dilationRate=TT(o||1,2,"dilationRate"),this.dilationRate.forEach(e=>VS(e,"dilationRate"))}build(e){var t;e=dN(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new kS(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=this.kernelSize.concat([e[n],4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const r=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",r,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,s=this.filters;e=new((t=class extends ME{apply(e,t){return _E([n.apply([s]),ow([s]),n.apply([2*s])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Iv(()=>{if(3!==e.length)throw new kS(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,s=e[0],r=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=aA({ones:()=>iw(s),rate:this.dropout,training:n,count:4}));const o=this.dropoutMask,i=(e,t,n)=>t&&t[n]?Ox(t[n],e):e;let u=i(s,o,0),l=i(s,o,1),c=i(s,o,2),d=i(s,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=aA({ones:()=>iw(r),rate:this.recurrentDropout,training:n,count:4}));const p=this.recurrentDropoutMask;let h=i(r,p,0),f=i(r,p,1),m=i(r,p,2),g=i(r,p,3);const[b,y,v,x]=Ew(this.kernel.read(),4,3),[w,k,C,I]=this.useBias?Ew(this.bias.read(),4):[null,null,null,null];u=this.inputConv(u,b,w,this.padding),l=this.inputConv(l,y,k,this.padding),c=this.inputConv(c,v,C,this.padding),d=this.inputConv(d,x,I,this.padding);const[_,S,E,N]=Ew(this.recurrentKernel.read(),4,3);h=this.recurrentConv(h,_),f=this.recurrentConv(f,S),m=this.recurrentConv(m,E),g=this.recurrentConv(g,N);const $=this.recurrentActivation.apply(Rv(u,h)),T=this.recurrentActivation.apply(Rv(l,f)),A=Rv(Ox(T,a),Ox($,this.activation.apply(Rv(c,m)))),R=Ox(this.recurrentActivation.apply(Rv(d,g)),this.activation.apply(A));return[R,R,A]})}getConfig(){const e=function(e,t){var n={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.indexOf(s)<0&&(n[s]=e[s]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(e);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(e,s[r])&&(n[s[r]]=e[s[r]])}return n}(super.getConfig(),["units"]);return Object.assign({},e,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(e,t,n,s){const r=ux(e,t,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?FE(r,n,this.dataFormat):r}recurrentConv(e,t){return ux(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}dA.className="ConvLSTM2DCell",wv(dA);class pA extends cA{constructor(e){const t=new dA(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}pA.className="ConvLSTM2D",wv(pA);class hA extends wN{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(null==this.noiseShape[s]?t[s]:this.noiseShape[s]);return n}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cN(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,s=this.getNoiseShape(n);return OE(()=>DE(n,this.rate,s,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}hA.className="Dropout",wv(hA);class fA extends hA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}fA.className="SpatialDropout1D",wv(fA);class mA extends wN{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,VS(this.units,"units"),this.activation=bT(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=sN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=sN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=JS(e.kernelConstraint),this.biasConstraint=JS(e.biasConstraint),this.kernelRegularizer=CT(e.kernelRegularizer),this.biasRegularizer=CT(e.biasRegularizer),this.activityRegularizer=CT(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=dN(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=dN(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cN(e),s=BS(this.activation.getClassName());let r;return null!=s?r=$E(n,this.kernel.read(),s,this.bias?this.bias.read():null):(r=$E(n,this.kernel.read()),null!=this.bias&&(r=FE(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:mT(this.activation),useBias:this.useBias,kernelInitializer:nN(this.kernelInitializer),biasInitializer:nN(this.biasInitializer),kernelRegularizer:wT(this.kernelRegularizer),biasRegularizer:wT(this.biasRegularizer),activityRegularizer:wT(this.activityRegularizer),kernelConstraint:YS(this.kernelConstraint),biasConstraint:YS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}mA.className="Dense",wv(mA);class gA extends wN{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=dN(e);for(const t of e.slice(1))if(null==t)throw new kS(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],mE(e,1)]}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);let n=cN(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=n.transpose(e)}return function(e){if(e.rank<=1)throw new kS(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],mE(e.shape,1)];return e.reshape(t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}gA.className="Flatten",wv(gA);class bA extends wN{constructor(e){super(e),this.supportsMasking=!0,this.activation=bT(e.activation)}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cN(e);return this.activation.apply(n)})}getConfig(){const e={activation:mT(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}bA.className="Activation",wv(bA);class yA extends wN{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Iv(()=>{return e=cN(e),t=e,n=this.n,Iv(()=>{if(2!==t.shape.length)throw new kS(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return EE(wE(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}yA.className="RepeatVector",wv(yA);class vA extends wN{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",s=t.slice();let r=1,a=null;for(let i=0;i<s.length;++i){const e=s[i];if(this.isUnknown(e)){if(null!==a)throw new kS("Can only specifiy one unknown dimension.");a=i}else r*=e}const o=mE(e);if(null!==a){if(0===r||o%r!=0)throw new kS(n);s[a]=o/r}else if(o!==r)throw new kS(n);return s}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cN(e),s=n.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return n.reshape(r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}vA.className="Reshape",wv(vA);class xA extends wN{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=vE(1,e.dims.length+1);if(!$h(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new gN({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=dN(e)).slice();return this.dims.forEach((n,s)=>{t[s+1]=e[n]}),t}call(e,t){return Lw(cN(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}xA.className="Permute",wv(xA);class wA extends wN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=cN(e);return Dv(sw(n,this.maskValue),-1)}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cN(e),s=Dv(sw(n,this.maskValue),-1,!0);return n.mul(s.asType(n.dtype))})}}wA.className="Masking",wv(wA);class kA extends wN{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=null==e.inputLength?[t,null]:[t].concat($S(e.inputLength))}this.inputDim=e.inputDim,VS(this.inputDim,"inputDim"),this.outputDim=e.outputDim,VS(this.outputDim,"outputDim"),this.embeddingsInitializer=sN(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=CT(e.embeddingsRegularizer),this.activityRegularizer=CT(e.activityRegularizer),this.embeddingsConstraint=JS(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Iv(()=>this.maskZero?(e=cN(e),sw(e,Mw(e))):null)}computeOutputShape(e){if(e=dN(e),null==this.inputLength)return[...e,this.outputDim];const t=$S(this.inputLength);if(t.length!==e.length-1)throw new kS(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let s=0;s<t.length;++s){const r=t[s],a=e[s+1];if(null!=r&&null!=a&&r!==a)throw new kS(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==r&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);let n=cN(e);return"int32"!==n.dtype&&(n=xE(n,"int32")),TE(this.embeddings.read(),n.as1D()).reshape(dN(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:nN(this.embeddingsInitializer),embeddingsRegularizer:wT(this.embeddingsRegularizer),activityRegularizer:wT(this.activityRegularizer),embeddingsConstraint:YS(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}kA.className="Embedding",wv(kA);class CA extends wN{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new CS}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const r=e[e.length-t.length+s],a=t[s];if(null==r||null==a||r<0||a<0)n.push(null);else if(1===r)n.push(a);else if(1===a)n.push(r);else{if(r!==a)throw new kS("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[dN(e)]),(e=e).length<2)throw new kS(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=zS(t),t.length>1)throw new kS(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const s=e.map(e=>e.length);this.reshapeRequired=-1!==e.indexOf(null)||1!==zS(s).length}call(e,t){return Iv(()=>{if(e=e,this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const s=yE(n);for(let n of e){const e=n.rank;for(let t=0;t<s-e;++t)n=wE(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,s=e[0],r=e.slice(1).concat([s]);let o=a.reshape([s].concat(mE(e.slice(1))));o=Lw(o,[1,0]),o=o.reshape(r),t.push(o),n=!0}else if(e>1){const s=vE(1,e).concat([0]);t.push(Lw(a,s)),n=!0}else t.push(a)}let s=this.mergeFunction(t);const r=s.rank;if(n)if(null==r){const e=s.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));s=Lw(s.reshape([-1,t]),[1,0]).reshape(n)}else if(r>1){const e=[r-1].concat(vE(0,r-1));s=Lw(s,e)}return s}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const n=null==e[s]?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const s of e)null!=s&&null!==s[0]&&n.push(s[0]);return n=zS(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Iv(()=>{if(null==t)return null;if(!Array.isArray(t))throw new kS("`mask` should be an Array");if(!Array.isArray(e))throw new kS("`inputs` should be an Array");if(t.length!==e.length)throw new kS(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:Cx(e,0)))[0];for(let e=1;e<t.length-1;++e)n=Lx(n,t[e]);return n})}}class IA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Rv(t,e[n]);return t})}}IA.className="Add",wv(IA);class _A extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ox(t,e[n]);return t})}}_A.className="Multiply",wv(_A);class SA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Rv(t,e[n]);return Ox(1/e.length,t)})}}SA.className="Average",wv(SA);class EA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=jx(t,e[n]);return t})}}EA.className="Maximum",wv(EA);class NA extends CA{constructor(e){super(e)}mergeFunction(e){return Iv(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ux(t,e[n]);return t})}}NA.className="Minimum",wv(NA);class $A extends CA{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new kS("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const s of e)if(null!=s){t=!1;break}if(t)return;const n=[];for(let s=0;s<e.length;++s){const t=e[s].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if($h(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new kS("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Iv(()=>_E(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new kS("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[s]||null==r[s]){n[s]=null;break}n[s]+=r[s]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new kS("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new kS("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new kS(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Iv(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const s=[];for(let a=0;a<e.length;++a)s.push(null==t[a]?iw(e[a]).asType("bool"):t[a].rank<e[a].rank?Cx(t[a],-1):t[a]);const r=sx(s,this.axis);return Fv(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function TA(e,t){for(;e<0;)e+=t;return e}$A.className="Concatenate",wv($A);class AA extends CA{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Ih(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new CS("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,n);if(t[s[0]]!==n[s[1]])throw new kS(`Dimension incompatibility: ${t[s[0]]} !== ${n[s[1]]}`)}mergeFunction(e){if(2!==e.length)throw new kS(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],s=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>TA(t,e[n].shape.length)):[TA(this.axes,n.shape.length),TA(this.axes,s.shape.length)],this.normalize&&(n=MN(n,t[0]),s=MN(s,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new CS("batchDot is not implemented for tensors of 4D or higher rank yet");if(Ih(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),Ih(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new CS("batchDot is not implemented for complex64-type Tensors yet.");const s=e.shape.length,r=t.shape.length;null==n&&(n=[s-1,r-2]);const a=n;return Iv(()=>{let n,o;if(s>r){n=s-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else if(r>s){n=r-s;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else n=0;if(o=2===e.shape.length&&2===t.shape.length?a[0]===a[1]?e.mul(t).sum(a[0]):e.transpose([1,0]).mul(t).sum(a[1]):e.matMul(t,a[0]!==e.shape.length-1,a[1]===t.shape.length-1),n>0){let e;e=s>r?s+r-3:s-1;const t=[];for(let s=e;s<e+n;++s)t.push(s);o=o.squeeze(t)}return 1===o.shape.length&&(o=o.expandDims(1)),o})}(n,s,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[TA(this.axes,e.length),TA(this.axes,t.length)],n}computeOutputShape(e){Ih(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new CS("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,n);t.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}AA.className="Dot",wv(AA);class RA extends wN{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cN(e);return OE(()=>NE(n.shape,0,this.stddev).add(n),()=>n,t.training||!1)})}}RA.className="GaussianNoise",wv(RA);class FA extends wN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Iv(()=>{this.invokeCallHook(e,t);const n=cN(e);return this.rate>0&&this.rate<1?OE(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return n.mul(NE(n.shape,1,e))},()=>n,t.training||!1):n})}}FA.className="GaussianDropout",wv(FA);class DA extends wN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||cN(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Iv(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return OE(()=>{const t=cN(e),s=-1.7580993408473766;let r=Tx(fw(n),this.rate);r=xE(r,"float32");const a=((1-this.rate)*(1+this.rate*s**2))**-.5,o=-a*s*this.rate;return t.mul(r).add(r.add(-1).mul(s)).mul(a).add(o)},()=>cN(e),t.training||!1)}return e})}}function OA(e,t,n,s,r,a=.001){let o;if(2===e.rank)o=Jv(e,t,n,s,r,a);else if(3===e.rank)o=ex(e,t,n,s,r,a);else{if(4!==e.rank)throw new CS(`batchNormalization is not implemented for array of rank ${e.rank} yet`);o=tx(e,t,n,s,r,a)}return o}DA.className="AlphaDropout",wv(DA);class qA extends wN{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=sN(e.betaInitializer||"zeros"),this.gammaInitializer=sN(e.gammaInitializer||"ones"),this.movingMeanInitializer=sN(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=sN(e.movingVarianceInitializer||"ones"),this.betaConstraint=JS(e.betaConstraint),this.gammaConstraint=JS(e.gammaConstraint),this.betaRegularizer=CT(e.betaRegularizer),this.gammaRegularizer=CT(e.gammaRegularizer)}build(e){e=dN(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new kS(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new gN({ndim:e.length,axes:{[t]:n}})];const s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Iv(()=>{const n=null!=t.training&&t.training,s=cN(e),r=s.shape,a=r.length,o=vE(0,a),i=this.axis>=0?this.axis:this.axis+a;o.splice(i,1);const u=_S(1,a);u[i]=r[i];const l=o.slice();l.sort();const c=!$h(l,vE(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=this.movingMean.read().reshape(u),t=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,r=this.scale?this.gamma.read().reshape(u):null;return OA(s,e,t,n,r,this.epsilon)}return OA(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,h]=function(e,t,n,s,r=.001){return $h(s.slice().sort(),vE(0,e.rank-1))?function(e,t,n,s,r=.001){return Iv(()=>{const a=tw(e,s),o=a.mean,i=a.variance;return[OA(e,o,i,n,t,r),o,i]})}(e,t,n,s,r):function(e,t,n,s,r=.001){return Iv(()=>{const a=tw(e,s),o=a.mean,i=a.variance,u=[];for(const t of vE(0,e.rank))-1!==s.indexOf(t)?u.push(1):u.push(e.shape[t]);const l=o.reshape(u),c=i.reshape(u),d=null==t?null:t.reshape(u),p=null==n?null:n.reshape(u);return[OA(e,l,c,p,d,r),o,i]})}(e,t,n,s,r)}(s,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(e,t,n)=>{Iv(()=>{const s=1-n,r=e.read(),a=r.sub(t).mul(s);e.write(r.sub(a))})};return(()=>{f(this.movingMean,p,this.momentum),f(this.movingVariance,h,this.momentum)})(),d})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nN(this.betaInitializer),gammaInitializer:nN(this.gammaInitializer),movingMeanInitializer:nN(this.movingMeanInitializer),movingVarianceInitializer:nN(this.movingVarianceInitializer),betaRegularizer:wT(this.betaRegularizer),gammaRegularizer:wT(this.gammaRegularizer),betaConstraint:YS(this.betaConstraint),gammaConstraint:YS(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}qA.className="BatchNormalization",wv(qA);class zA extends wN{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=sN(e.betaInitializer||"zeros"),this.gammaInitializer=sN(e.gammaInitializer||"ones"),this.betaRegularizer=CT(e.betaRegularizer),this.gammaRegularizer=CT(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=dN(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==zS(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(t=>e[t]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,t){const n=cN(e),s=n.shape,r=s.length;return Iv(()=>{let{mean:e,variance:t}=tw(n,this.axis,!0);const a=_S(1,r);for(const n of this.axis)a[n]=s[n];const o=e=>null!=e&&e.shape.length!==r&&this.axis!==[r-1]?e.reshape(a):e;let i=o(this.gamma.read()),u=o(this.beta.read());const l=[],c=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(l.push(s[n]),c.push(1)):(l.push(1),c.push(s[n]));return e=e.tile(l),t=t.tile(l),i=i.tile(c),u=u.tile(c),OA(n,e,t,u,i,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nN(this.betaInitializer),gammaInitializer:nN(this.gammaInitializer),betaRegularizer:wT(this.betaRegularizer),gammaRegularizer:wT(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}zA.className="LayerNormalization",wv(zA);class MA extends wN{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new kS(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new kS(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new kS(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new gN({ndim:4})]}computeOutputShape(e){let t,n;return e=dN(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Iv(()=>{return t=cN(e),n=this.padding,s=this.dataFormat,Iv(()=>{if(4!==t.rank)throw new kS(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new kS("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s="channelsLast"),"channelsLast"!==s&&"channelsFirst"!==s)throw new kS(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===s?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],uw(t,e)});var t,n,s})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function LA(e,t,n,s,r,a){return Iv(()=>{let o;oE(r),uE(a),iE(s),null==n&&(n=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),e=FT(e,r);const i="same"===s?"same":"valid";return o="max"===a?Px(e,t,n,i):Zv(e,t,n,i),"channelsFirst"===r&&(o=Lw(o,[0,3,1,2])),o})}function PA(e,t,n,s,r,a){return Iv(()=>{let o;oE(r),uE(a),iE(s),null==n&&(n=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),e=DT(e,r);const i="same"===s?"same":"valid";return o="max"===a?Vx(e,t,n,i):Yv(e,t,n,i),"channelsFirst"===r&&(o=Lw(o,[0,4,1,2,3])),o})}MA.className="ZeroPadding2D",wv(MA);class VA extends wN{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new kS(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(VS(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new kS(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}VS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,iE(this.padding),this.inputSpec=[new gN({ndim:3})]}computeOutputShape(e){const t=AT((e=dN(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Iv(()=>{this.invokeCallHook(e,t),e=wE(cN(e),2);const n=this.poolingFunction(cN(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return $w(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class jA extends VA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return oE(r),iE(s),LA(e,t,n,s,r,"max")}}jA.className="MaxPooling1D",wv(jA);class BA extends VA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return oE(r),iE(s),LA(e,t,n,s,r,"avg")}}BA.className="AveragePooling1D",wv(BA);class WA extends wN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new kS(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];VS(this.poolSize,"poolSize"),VS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oE(this.dataFormat),iE(this.padding),this.inputSpec=[new gN({ndim:4})]}computeOutputShape(e){e=dN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=AT(t,this.poolSize[0],this.padding,this.strides[0]),n=AT(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Iv(()=>(this.invokeCallHook(e,t),this.poolingFunction(cN(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class UA extends WA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return oE(r),iE(s),LA(e,t,n,s,r,"max")}}UA.className="MaxPooling2D",wv(UA);class GA extends WA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return oE(r),iE(s),LA(e,t,n,s,r,"avg")}}GA.className="AveragePooling2D",wv(GA);class HA extends wN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new kS(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];VS(this.poolSize,"poolSize"),VS(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oE(this.dataFormat),iE(this.padding),this.inputSpec=[new gN({ndim:5})]}computeOutputShape(e){e=dN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[4]:e[3];return t=AT(t,this.poolSize[0],this.padding,this.strides[0]),n=AT(n,this.poolSize[1],this.padding,this.strides[1]),s=AT(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,s]:[e[0],t,n,s,e[4]]}call(e,t){return Iv(()=>(this.invokeCallHook(e,t),this.poolingFunction(cN(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class KA extends HA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return oE(r),iE(s),PA(e,t,n,s,r,"max")}}KA.className="MaxPooling3D",wv(KA);class XA extends HA{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return oE(r),iE(s),PA(e,t,n,s,r,"avg")}}XA.className="AveragePooling3D",wv(XA);class ZA extends wN{constructor(e){super(e),this.inputSpec=[new gN({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new CS}}class YA extends ZA{constructor(e){super(e||{})}call(e,t){return Iv(()=>{const t=cN(e);return Bx(t,1)})}}YA.className="GlobalAveragePooling1D",wv(YA);class QA extends ZA{constructor(e){super(e||{})}call(e,t){return Iv(()=>{const t=cN(e);return Dx(t,1)})}}QA.className="GlobalMaxPooling1D",wv(QA);class JA extends wN{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,oE(this.dataFormat),this.inputSpec=[new gN({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new CS}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class eR extends JA{call(e,t){return Iv(()=>{const t=cN(e);return Bx(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}eR.className="GlobalAveragePooling2D",wv(eR);class tR extends JA{call(e,t){return Iv(()=>{const t=cN(e);return Dx(t,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}tR.className="GlobalMaxPooling2D",wv(tR);class nR extends wN{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const s=zN(t.layer,n);delete t.layer;const r={layer:s};return Object.assign(r,t),new e(r)}}class sR extends nR{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=dN(e)).length<3)throw new kS(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=dN(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t);return[n[0],e[1]].concat(n.slice(1))}call(e,t){return Iv(()=>XT((e,n)=>[cN(this.layer.call(e,t)),[]],e=cN(e),[],!1,null,null,!1,!0)[1])}}sR.className="TimeDistributed",wv(sR);class rR extends nR{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=zN(n),t.goBackwards=!0!==t.goBackwards;const s={};if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=zN(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,LS(rE,"BidirectionalMergeMode",this.mergeMode),e.weights)throw new CS("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,t)),this.backwardLayer.setWeights(e.slice(t))}computeOutputShape(e){let t,n,s,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r,this.returnState?(s=r.slice(1),t=r[0]):t=r[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(s).concat(s.slice()):[t].concat(s).concat(s.slice()):NS(n)}apply(e,t){let n=null==t?null:t.initialState,s=null==t?null:t.constants;null==t&&(t={});const r=KT(e,n,s,this.numConstants);if(e=r.inputs,n=r.initialState,s=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==s)return super.apply(e,t);const a=[],o=[];if(null!=n){const e=n.length;if(e%2>0)throw new kS("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const s=n.map(e=>new gN({shape:e.shape}));this.forwardLayer.stateSpec=s.slice(0,e/2),this.backwardLayer.stateSpec=s.slice(e/2),o.push(...s)}if(null!=s)throw new CS("Support for constants in Bidirectional layers is not implemented yet.");const i=a[0]instanceof bN;for(const u of a)if(u instanceof bN!==i)throw new kS("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(a),s=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=s;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Iv(()=>{const n=t.initialState;let s,r,a,o;if(null==n)s=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),o=n.slice(n.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:o}))}return this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=gw(r,1)),"concat"===this.mergeMode?o=_E([s,r]):"sum"===this.mergeMode?o=Rv(s,r):"ave"===this.mergeMode?o=Ox(.5,Rv(s,r)):"mul"===this.mergeMode?o=Ox(s,r):null==this.mergeMode&&(o=[s,r]),this.returnState?null==this.mergeMode?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){cE(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),cE(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=zN(t.layer);if(delete t.layer,null!=t.numConstants)throw new CS("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=n,new e(s)}}function aR(e){return new mA(e)}function oR(e,t,n=new Map,s=new Set){if(null==e)return null;if(s.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(cR(e)){const r=Array.isArray(e)?[]:{};s.add(e);for(const a in e){const o=oR(e[a],t,n,s);r[a]=o}return s.delete(e),r}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,r.value),r.value}function iR(e,t=lR){return uR(e,t)}function uR(e,t,n=new Set){const s=e[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(cR(s)){const r=Array.isArray(s)?[]:{};n.add(s);for(const a in s){const s=uR(e.map(e=>e[a]),t,n);r[a]=s}return n.delete(s),r}throw new Error(`Can't recurse into non-iterable type: ${s}`)}return r.value}function lR(e){return null===e?null:cR(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function cR(e){return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof Ab))}function dR(e){return function(e,t){return oR(e,t)}(e,pR)}function pR(e){return e instanceof Ab?{value:e.clone(),recurse:!1}:cR(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}rR.className="Bidirectional",wv(rR),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(oA||(oA={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(iA||(iA={}));class hR{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class fR extends hR{constructor(){super(fR.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let s=0;s<n;s++)t[s]=this.get(this.wrap(this.begin+s));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}fR.INITIAL_CAPACITY=32;class mR{toArray(){var e=this;return bh(function*(){const t=[];let n=yield e.next();for(;!n.done;)t.push(n.value),n=yield e.next();return t})()}toArrayForTest(){var e=this;return bh(function*(){const t=e.prefetch(100),n=[];let s=yield t.next();for(;!s.done;)n.push(s.value),s=yield t.next();return n})()}resolveFully(){var e=this;return bh(function*(){let t=yield e.next();for(;!t.done;)t=yield e.next()})()}resolveWhile(e){var t=this;return bh(function*(){let n=yield t.next(),s=e(n.value);for(;!n.done&&s;)n=yield t.next(),s=e(n.value)})()}handleErrors(e){return new IR(this,e)}filter(e){return new kR(this,e)}map(e){return new CR(this,e)}mapAsync(e){return new _R(this,e)}serialMapAsync(e){return new _R(this,e).serial()}flatmap(e){return new ER(this,e)}forEachAsync(e){var t=this;return bh(function*(){return t.map(e).resolveFully()})()}serialForEach(e){var t=this;return bh(function*(){return t.serialMapAsync(e).resolveWhile(e=>!0===e)})()}rowMajorBatch(e,t=!0){return new wR(this,e,t)}columnMajorBatch(e,t=!0,n=lR){return this.rowMajorBatch(e,t).map(e=>iR(e,n))}concatenate(e,t){return new NR(new gR([this,e]),t)}take(e){return e<0||null==e?this:new xR(this,e)}skip(e){return e<0||null==e?this:new vR(this,e)}prefetch(e){return new $R(this,e)}shuffle(e,t){return new TR(this,e,t)}serial(){return new yR(this)}}class gR extends mR{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}next(){var e=this;return bh(function*(){if(e.trav>=e.items.length)return{value:null,done:!0};const t=e.items[e.trav];return e.trav++,{value:dR(t),done:!1}})()}}class bR extends mR{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}next(){var e=this;return bh(function*(){try{return e.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}})()}}class yR extends mR{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}next(){var e=this;return bh(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bh(function*(){return e.upstream.next()})()}}class vR extends mR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}next(){var e=this;return bh(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bh(function*(){for(;e.count++<e.maxCount;){const t=yield e.upstream.next();if(t.done)return t;_v(t.value)}return e.upstream.next()})()}}class xR extends mR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}next(){var e=this;return bh(function*(){return e.count++>=e.maxCount?{value:null,done:!0}:e.upstream.next()})()}}class wR extends mR{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}next(){var e=this;return bh(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bh(function*(){const t=[];for(;t.length<e.batchSize;){const n=yield e.upstream.next();if(n.done)return e.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}})()}}class kR extends mR{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}next(){var e=this;return bh(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bh(function*(){for(;;){const t=yield e.upstream.next();if(t.done||e.predicate(t.value))return t;_v(t.value)}})()}}class CR extends mR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}next(){var e=this;return bh(function*(){const t=yield e.upstream.next();if(t.done)return{value:null,done:!0};const n=Wb(t.value),s=e.transform(t.value),r=Wb(s);for(const e of n)Bb(e,r)||e.dispose();return{value:s,done:!1}})()}}class IR extends mR{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}next(){var e=this;return bh(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bh(function*(){for(;;)try{return yield e.upstream.next()}catch(t){if(!e.handler(t))return{value:null,done:!0}}})()}}class _R extends mR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}next(){var e=this;return bh(function*(){const t=yield e.upstream.next();if(t.done)return{value:null,done:!0};const n=Wb(t.value),s=yield e.transform(t.value),r=Wb(s);for(const e of n)Bb(e,r)||e.dispose();return{value:s,done:!1}})()}}class SR extends mR{constructor(){super(),this.outputQueue=new fR,this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return bh(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}serialNext(){var e=this;return bh(function*(){for(;0===e.outputQueue.length();)if(!(yield e.pump()))return{value:null,done:!0};return{value:e.outputQueue.shift(),done:!1}})()}}class ER extends SR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}pump(){var e=this;return bh(function*(){const t=yield e.upstream.next();if(t.done)return!1;const n=Wb(t.value),s=e.transform(t.value),r=Wb(s);e.outputQueue.pushAll(s);for(const e of n)Bb(e,r)||e.dispose();return!0})()}}class NR extends mR{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}next(){var e=this;return bh(function*(){return e.lastRead=e.readFromChain(e.lastRead),e.lastRead})()}readFromChain(e){var t=this;return bh(function*(){if(yield e,null==t.iterator){const e=yield t.moreIterators.next();if(e.done)return{value:null,done:!0};t.iterator=e.value,null!=t.baseErrorHandler&&(t.iterator=t.iterator.handleErrors(t.baseErrorHandler))}const n=yield t.iterator.next();return n.done?(t.iterator=null,t.readFromChain(e)):n})()}}(lA=uA||(uA={}))[lA.FAIL=0]="FAIL",lA[lA.SHORTEST=1]="SHORTEST",lA[lA.LONGEST=2]="LONGEST";class $R extends mR{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new hR(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class TR extends $R{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=cw.alea(n||gb().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}next(){var e=this;return bh(function*(){return e.lastRead=e.lastRead.then(()=>e.serialNext()),e.lastRead})()}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}serialNext(){var e=this;return bh(function*(){for(e.upstreamExhausted||e.refill();!e.buffer.isEmpty();){const t=e.chooseIndex(),n=yield e.buffer.shuffleExcise(t);if(!n.done)return e.refill(),n;e.upstreamExhausted=!0}return{value:null,done:!0}})()}}class AR{constructor(){this.size=null}batch(e,t=!0){const n=this;let s;return Ih(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),s=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),RR(bh(function*(){return(yield n.iterator()).columnMajorBatch(e,t,FR)}),s)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,RR(bh(function*(){return(yield t.iterator()).concatenate(yield e.iterator())}),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,RR(bh(function*(){return(yield t.iterator()).filter(t=>Iv(()=>e(t)))}),n)}forEachAsync(e){var t=this;return bh(function*(){return(yield t.iterator()).forEachAsync(e)})()}map(e){const t=this;return RR(bh(function*(){return(yield t.iterator()).map(t=>Iv(()=>e(t)))}),this.size)}mapAsync(e){const t=this;return RR(bh(function*(){return(yield t.iterator()).mapAsync(e)}),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return RR(bh(function*(){return(yield t.iterator()).prefetch(e)}),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,RR(bh(function*(){return n=(s=bh(function*(){return{value:yield t.iterator(),done:!1}}),new bR(s)).take(e),new NR(n,undefined);var n,s}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,RR(bh(function*(){return(yield t.iterator()).skip(e)}),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,r=cw.alea(t||gb().toString());return RR(bh(function*(){let t=r.int32();return n&&(t+=r.int32()),(yield s.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,RR(bh(function*(){return(yield t.iterator()).take(e)}),n)}toArray(){var e=this;return bh(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArray()})()}toArrayForTest(){var e=this;return bh(function*(){if(e.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(yield e.iterator()).toArrayForTest()})()}}function RR(e,t=null){return new class extends AR{constructor(){super(...arguments),this.size=t}iterator(){return bh(function*(){return e()})()}}}function FR(e){return null===e?null:null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof Ab||Ph(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ab?Tw(e):ly(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}function DR(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Ih("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}AR.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const OR=LC;class qR extends vh{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new yh(this,kv())}nextDataId(){return qR.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,af().get("IS_NODE")&&gC("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:n,refCount:1}),s}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&jh(n[0])){const r=n.map(e=>bb(e));s=this.write(r,e,t)}else s=this.write(n,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,s,r){this.data.set(e,{values:t,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}read(e){var t=this;return bh(function*(){return t.readSync(e)})()}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?yC(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>yb(e))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wy(e.shape,e.dtype,n)}makeOutput(e,t,n){const s=this.write(e,t,n);return kv().makeTensorFromDataId(s,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return bh(function*(){const t=gb();return e(),{kernelMs:gb()-t}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){DR([e],"where");const t=this.readSync(e.dataId);return OR(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function zR(e,t,n){return({inputs:s,attrs:r,backend:a})=>{const{x:o}=s;if(DR(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=a,u=i.data.get(o.dataId).values,l=Nh(o.shape),c=n||o.dtype,d=Mh(c,l);for(let e=0;e<l;++e)d[e]=t(u[e],r);return i.makeTensorInfo(o.shape,c,d)}}function MR(e,t,n){return({inputs:s,attrs:r,backend:a})=>{const{x:o}=s;if(DR(o,e),"string"===o.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const i=a,u=i.data.get(o.dataId).values,l=n||o.dtype,c=t(u,l,r);return i.makeTensorInfo(o.shape,l,c)}}qR.nextDataId=0,Ev("cpu",()=>new qR,1);const LR=zR(am,e=>e>=0?e:Math.exp(e)-1),PR={kernelName:am,backendName:"cpu",kernelFunc:LR};function VR(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const jR={kernelName:km,backendName:"cpu",kernelFunc:VR};function BR(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:a}=s;DR([r],"leakyRelu");const o=Nh(r.shape),i=n.data.get(r.dataId).values,u=zh("float32",o);for(let l=0;l<i.length;l++)u[l]=i[l]<0?a*i[l]:i[l];return n.makeTensorInfo(r.shape,"float32",u)}const WR={kernelName:Nm,backendName:"cpu",kernelFunc:BR};function UR(e){return(t,n,s,r,a)=>{const o=wx(t,n),i=o.length,u=Hh(o),l=zh(a,Nh(o)),c=t.length,d=n.length,p=Hh(t),h=Hh(n),f=vx(t,o),m=vx(n,o);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(s[g%s.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=tf(g,i,u),n=t.slice(-c);f.forEach(e=>n[e]=0);const a=ef(n,c,p),o=t.slice(-d);m.forEach(e=>o[e]=0);const b=ef(o,d,h);l[g]=e(s[a],r[b])}return[l,o]}}const GR=UR((e,t)=>e<0?t*e:e);function HR(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t;DR([s,r],"prelu");const a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,[i,u]=GR(s.shape,r.shape,a,o,s.dtype);return n.makeTensorInfo(u,s.dtype,i)}const KR={kernelName:lg,backendName:"cpu",kernelFunc:HR},XR=zR(fg,e=>Math.max(0,e)),ZR={kernelName:fg,backendName:"cpu",kernelFunc:XR},YR=zR(xg,e=>Math.min(Math.max(0,e),6)),QR={kernelName:xg,backendName:"cpu",kernelFunc:YR},JR=zR(Ag,e=>1/(1+Math.exp(-e))),eF={kernelName:Ag,backendName:"cpu",kernelFunc:JR};function tF(e,t,n,s,r){if("linear"===n)return VR({inputs:{x:t},backend:e});if("relu"===n)return XR({inputs:{x:t},backend:e});if("elu"===n)return LR({inputs:{x:t},backend:e});if("relu6"===n)return YR({inputs:{x:t},backend:e});if("prelu"===n)return HR({inputs:{x:t,alpha:s},backend:e});if("leakyrelu"===n)return BR({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return JR({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function nF(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,i=n.makeTensorInfo(s.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",a),imag:n.makeTensorInfo(r.shape,"float32",o)},i}const sF={kernelName:Of,backendName:"cpu",kernelFunc:nF};function rF(e,t,n="float32"){if("complex64"===n)return nF({inputs:{real:rF(e,t,"float32"),imag:rF(e,t,"float32")},backend:e});const s=Yh(Nh(t),n);return e.makeTensorInfo(t,n,s)}function aF(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.real,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const oF={kernelName:pg,backendName:"cpu",kernelFunc:aF};function iF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dtype:a}=s;if("complex64"===a){if("complex64"===r.dtype)return VR({inputs:{x:r},backend:n});const e=rF(n,r.shape,r.dtype),t=iF({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),s=nF({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),s}if("complex64"===r.dtype){const e=aF({inputs:{input:r},backend:n}),t=iF({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Lh(r.dtype,a)){const e=VR({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}if("int32"===a){const e=n.data.get(r.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(r.shape,"int32",t)}if("bool"===a){const e=n.data.get(r.dataId).values,t=mb([0],r.dtype),[s,a]=UR((e,t)=>e!==t?1:0)(r.shape,[],e,t,"bool");return n.makeTensorInfo(a,"bool",s)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const uF={kernelName:Rf,backendName:"cpu",kernelFunc:iF};function lF(e,t,n,s){return null==n?({inputs:n,backend:r})=>{const{a:a,b:o}=n,i=r;DR([a,o],e);const u=i.data.get(a.dataId).values,l=i.data.get(o.dataId).values,c=s||a.dtype,[d,p]=t(a.shape,o.shape,u,l,c);return i.makeTensorInfo(p,c,d)}:({inputs:e,backend:r})=>{const{a:a,b:o}=e,i=r;if("complex64"===a.dtype||"complex64"===o.dtype){const e=iF({inputs:{x:a},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),s=t.complexTensorInfos.imag,r=i.data.get(t.complexTensorInfos.real.dataId).values,u=i.data.get(s.dataId).values,l=iF({inputs:{x:o},backend:i,attrs:{dtype:"complex64"}}),c=i.data.get(l.dataId),d=c.complexTensorInfos.imag,p=i.data.get(c.complexTensorInfos.real.dataId).values,h=i.data.get(d.dataId).values,[f,m,g]=n(a.shape,o.shape,r,u,p,h),b=i.makeTensorInfo(g,"float32",f),y=i.makeTensorInfo(g,"float32",m),v=nF({inputs:{real:b,imag:y},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(l),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(y),v}{const e=i.data.get(a.dataId).values,n=i.data.get(o.dataId).values,r=s||a.dtype,[u,l]=t(a.shape,o.shape,e,n,r);return i.makeTensorInfo(l,r,u)}}}function cF(e){return(t,n,s,r,a,o)=>{const i=wx(t,n),u=Nh(i),l=i.length,c=Hh(i),d=zh("float32",u),p=zh("float32",u),h=vx(t,i),f=vx(n,i),m=yC(s,r),g=yC(a,o),b=t.length,y=Hh(t),v=n.length,x=Hh(n);if(h.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,s=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=s.real,p[w]=s.imag}else for(let w=0;w<d.length;w++){const t=tf(w,l,c),n=t.slice(-b);h.forEach(e=>n[e]=0);const s=ef(n,b,y),r=t.slice(-v);f.forEach(e=>r[e]=0);const a=ef(r,v,x),o=e(m[2*s],m[2*s+1],g[2*a],g[2*a+1]);d[w]=o.real,p[w]=o.imag}return[d,p,i]}}const dF=UR((e,t)=>e+t),pF=cF((e,t,n,s)=>({real:e+n,imag:t+s})),hF=lF(ff,dF,pF),fF={kernelName:ff,backendName:"cpu",kernelFunc:hF};function mF(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:a}=s,o=Nh(r.shape),i=Dh(a,o),u=Nh(i);Ih(o===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.imag;l.complexTensorInfos.real.shape=i,e.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const gF={kernelName:mg,backendName:"cpu",kernelFunc:mF};function bF(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a}=t,{transposeA:o,transposeB:i}=s;DR([r,a],"matMul");const u=r.shape.length,l=a.shape.length,c=o?r.shape[u-2]:r.shape[u-1],d=i?a.shape[l-1]:a.shape[l-2],p=o?r.shape[u-1]:r.shape[u-2],h=i?a.shape[l-2]:a.shape[l-1],f=r.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Nh(f),b=Nh(m);Ih(u>=2&&l>=2&&(g===b||1===g||1===b),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);const y=(g>b?r.shape.slice(0,-2):a.shape.slice(0,-2)).concat([p,h]);Ih(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);const v=i?[b,h,d]:[b,d,h],x=mF({inputs:{x:r},backend:n,attrs:{shape:o?[g,c,p]:[g,p,c]}}),w=mF({inputs:{x:a},backend:n,attrs:{shape:v}}),k=o?x.shape[1]:x.shape[2],C=o?x.shape[2]:x.shape[1],I=i?w.shape[1]:w.shape[2],_=Math.max(g,b),S=n.data.get(x.dataId).values,E=n.data.get(w.dataId).values,N=Hh(x.shape),$=Hh(w.shape),[T,A,R]=o?[N[0],1,N[1]]:[N[0],N[1],1],[F,D,O]=i?[1,$[1],$[0]]:[$[1],1,$[0]],q=C*I,z=Wy([_,C,I],x.dtype),M=z.values,L=n.blockSize;for(let P=0;P<_;P++)for(let e=0;e<C;e+=L)for(let t=0;t<I;t+=L)for(let n=0;n<k;n+=L){const s=Math.min(e+L,C),r=Math.min(t+L,I),a=Math.min(n+L,k);for(let o=e;o<s;o++)for(let e=t;e<r;e++){let t=0;for(let s=n;s<a;s++){const n=Math.min(P,g-1)*T,r=Math.min(P,b-1)*O;t+=S[n+o*A+s*R]*E[s*F+e*D+r]}M[P*q+(o*I+e)]+=t}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,z.dtype,z.values)}const yF={kernelName:$f,backendName:"cpu",kernelFunc:bF},vF={kernelName:sb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=s;let p,h,f;const m=[];p=bF({inputs:{a:r,b:a},attrs:{transposeA:u,transposeB:l},backend:n}),o&&(h=hF({inputs:{a:p,b:o},backend:n}),m.push(p),p=h),c&&(f=tF(n,p,c,i,d),m.push(p),p=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return p}};function xF(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const wF={kernelName:df,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;DR(t,"abs");let s=new Float32Array(Nh(t.shape));return s=xF(n.data.get(t.dataId).values),n.makeOutput(s,t.shape,"float32")}},kF=zR(pf,e=>Math.acos(e)),CF={kernelName:pf,backendName:"cpu",kernelFunc:kF},IF=zR(hf,e=>Math.acosh(e)),_F={kernelName:hf,backendName:"cpu",kernelFunc:IF},SF={kernelName:mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,s=t;DR(t,"addN");const r=s.map(e=>n.data.get(e.dataId).values),a=Wy(s[0].shape,s[0].dtype),o=a.values;for(let i=0;i<s.length;i++){const e=r[i];for(let t=0;t<o.length;t++)o[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function EF(e,t,n,s,r){const a=t.length,o=Nh(t),i=Hh(t),u=Hh(r),l=zh(n,Nh(r));for(let c=0;c<o;++c){const t=tf(c,a,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[s[e]];l[ef(n,a,u)]=e[c]}return l}function NF(e){const{inputs:t,attrs:n,backend:s}=e,{x:r}=t,{perm:a}=n;DR(r,"transpose");const o=new Array(r.shape.length);for(let u=0;u<o.length;u++)o[u]=r.shape[a[u]];const i=EF(s.data.get(r.dataId).values,r.shape,r.dtype,a,o);return{dataId:s.write(i,o,r.dtype),shape:o,dtype:r.dtype}}const $F={kernelName:Zg,backendName:"cpu",kernelFunc:NF},TF={kernelName:gf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;DR(r,"all");const i=Oh(a,r.shape);let u=i;const l=Yx(u,r.shape.length);let c=r;null!=l&&(c=NF({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Jx(u.length,r.shape.length)),Zx("all",u,c.shape.length);const[d,p]=Kx(c.shape,u),h=Nh(p),f=Yh(Nh(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*h;let t=m[e];for(let n=0;n<h;++n){const s=m[e+n];t=t&&s}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(o){const e=mF({inputs:{x:g},backend:n,attrs:{shape:Xx(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},AF={kernelName:bf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;DR(r,"any");const i=Oh(a,r.shape);let u=i;const l=Yx(u,r.shape.length);let c=r;null!=l&&(c=NF({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Jx(u.length,r.shape.length)),Zx("any",u,c.shape.length);const[d,p]=Kx(c.shape,u),h=Nh(p),f=Yh(Nh(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*h;let t=m[e];for(let n=0;n<h;++n){const s=m[e+n];t=t||s}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(o){const e=mF({inputs:{x:g},backend:n,attrs:{shape:Xx(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},RF={kernelName:yf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;DR(r,"argMax");let o=Oh(a,r.shape);const i=Yx(o,r.shape.length);let u=r;const l=[];null!=i&&(u=NF({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Jx(o.length,u.shape.length)),o=[o[0]],Zx("argMax",o,u.shape.length);const[c,d]=Kx(u.shape,o),p=Yh(Nh(c),"int32"),h=Nh(d),f=n.data.get(u.dataId).values;for(let m=0;m<p.length;++m){const e=m*h;let t=f[e],n=0;for(let s=0;s<h;++s){const r=f[e+s];r>t&&(t=r,n=s)}p[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",p)}},FF={kernelName:vf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;DR(r,"argMin");let o=Oh(a,r.shape);const i=Yx(o,r.shape.length);let u=r;const l=[];null!=i&&(u=NF({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Jx(o.length,u.shape.length)),o=[o[0]],Zx("argMin",o,u.shape.length);const[c,d]=Kx(u.shape,o),p=Yh(Nh(c),"int32"),h=Nh(d),f=n.data.get(u.dataId).values;for(let m=0;m<p.length;++m){const e=m*h;let t=f[e],n=0;for(let s=0;s<h;++s){const r=f[e+s];r<t&&(t=r,n=s)}p[m]=n}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",p)}},DF=zR(xf,e=>Math.asin(e)),OF={kernelName:xf,backendName:"cpu",kernelFunc:DF},qF=zR(wf,e=>Math.asinh(e)),zF={kernelName:wf,backendName:"cpu",kernelFunc:qF},MF=zR(kf,e=>Math.atan(e)),LF={kernelName:kf,backendName:"cpu",kernelFunc:MF},PF=UR((e,t)=>Math.atan2(e,t)),VF=lF(If,PF),jF={kernelName:If,backendName:"cpu",kernelFunc:VF},BF=zR(Cf,e=>Math.atanh(e)),WF={kernelName:Cf,backendName:"cpu",kernelFunc:BF};function UF(e,t,n,s,r,a){const o=r.strideHeight,i=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,h=r.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Wy(r.outShape,n),g=m.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let x=0;x<r.batchSize;++x){const t=x*b,n=x*s[0];for(let m=0;m<r.inChannels;++m)for(let b=0;b<r.outHeight;++b){const x=b*o-p,w=Math.max(0,x),k=Math.min(r.inHeight,c+x),C=t+b*y;for(let t=0;t<r.outWidth;++t){const o=t*i-h,c=Math.max(0,o),p=Math.min(r.inWidth,d+o);let b=f,y=0,x=0;for(let t=w;t<k;t+=u){const r=n+t*s[1];for(let t=c;t<p;t+=l){const n=e[r+t*s[2]+m];"max"===a&&n>b?b=n:"avg"===a&&(y+=n,x++)}if(isNaN(b))break}g[C+t*v+m]="avg"===a?y/x:b}}}return m}function GF(e,t,n,s,r=!1,a=!1){const o=Wy(s.outShape,"int32"),i=s.strideHeight,u=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,m=Wy(t,n,e);for(let g=0;g<s.batchSize;++g)for(let e=0;e<s.inChannels;++e)for(let t=0;t<s.outHeight;++t){const n=t*i-h;let b=n;for(;b<0;)b+=l;const y=Math.min(s.inHeight,d+n);for(let i=0;i<s.outWidth;++i){const d=i*u-f;let h=d;for(;h<0;)h+=c;const v=Math.min(s.inWidth,p+d);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=l){const o=t-n;for(let n=h;n<v;n+=c){const i=n-d,u=m.get(g,t,n,e);u>x&&(x=u,w=r?a?((g*s.inHeight+t)*s.inWidth+n)*s.inChannels+e:(t*s.inWidth+n)*s.inChannels+e:o*p+i)}}o.set(w,g,t,i,e)}}return o}function HF(e,t,n,s,r,a){const o=r.strideDepth,i=r.strideHeight,u=r.strideWidth,l=r.dilationDepth,c=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterDepth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Wy(r.outShape,n),x=v.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let _=0;_<r.batchSize;++_){const t=_*w,n=_*s[0];for(let v=0;v<r.inChannels;++v)for(let w=0;w<r.outDepth;++w){const _=w*o-m;let S=_;for(;S<0;)S+=l;const E=Math.min(r.inDepth,p+_),N=t+w*k;for(let t=0;t<r.outHeight;++t){const o=t*i-g;let p=o;for(;p<0;)p+=c;const m=Math.min(r.inHeight,h+o),w=N+t*C;for(let t=0;t<r.outWidth;++t){const o=t*u-b;let i=o;for(;i<0;)i+=d;const h=Math.min(r.inWidth,f+o),g=w+t*I;let k=y,C=0,_=0;for(let t=S;t<E;t+=l){const r=n+t*s[1];for(let t=p;t<m;t+=c){const n=r+t*s[2];for(let t=i;t<h;t+=d){const r=e[n+t*s[3]+v];if("max"===a&&r>k?k=r:"avg"===a&&(C+=r,_++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===a?C/_:k}}}}return v}const KF={kernelName:_f,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;DR(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=s;Ih(Hv(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const l=zv(r.shape,a,o,1,i,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&$h(l.inShape,l.outShape))c=VR({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Hh(r.shape),s=UF(e,0,r.dtype,t,l,"avg");c=n.makeTensorInfo(l.outShape,r.dtype,s.values)}return c}},XF={kernelName:Ef,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=s;DR(r,"avgPool3d");const c=Mv(r.shape,a,o,1,i,u,l),d=HF(n.data.get(r.dataId).values,0,r.dtype,Hh(r.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}},ZF={kernelName:Nf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=s;DR([r,a],"avgPool3DGrad");const c=Mv(a.shape,o,i,1,u,l),d=c.strideDepth,p=c.strideHeight,h=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,C=x-1-c.padInfo.front,I=k-1-c.padInfo.left,_=w-1-c.padInfo.top,S=Wy(a.shape,"float32"),E=1/(f*m*g),N=n.bufferSync(r);for(let $=0;$<c.batchSize;++$)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=t-C,a=n-_,o=s-I;let i=0;for(let t=0;t<x;t+=b){const n=(r+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const s=(a+t)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let t=0;t<k;t+=v){const r=(o+t)/h;r<0||r>=c.outWidth||Math.floor(r)!==r||(i+=N.get($,n,s,r,e))}}}S.set(i*E,$,t,n,s,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},YF={kernelName:Sf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,o=a;DR([r,a],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=s,c=zv(o.shape,i,u,1,l),d=c.strideHeight,p=c.strideWidth,h=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,y=c.effectiveFilterWidth,v=y-1-c.padInfo.left,x=b-1-c.padInfo.top,w=Wy(o.shape,"float32"),k=1/(h*f),C=n.data.get(r.dataId).values,I=Wy(r.shape,"float32",C);for(let _=0;_<c.batchSize;++_)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const s=t-x,r=n-v;let a=0;for(let t=0;t<b;t+=m){const n=(s+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){const s=(r+t)/p;s<0||s>=c.outWidth||Math.floor(s)!==s||(a+=I.get(_,n,s,e))}}w.set(a*k,_,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},QF={kernelName:bm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,scale:a,offset:o,mean:i,variance:u}=t;Ih(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ih(null==o||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ih(null==a||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),DR([r,i,u,a,o],"batchNorm");let{varianceEpsilon:l}=s;null==l&&(l=.001);const c=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values,p=n.data.get(u.dataId).values,h=a?n.data.get(a.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,b=h.length,y=p.length,v=d.length;let x=0,w=0,k=0,C=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-d[w++])*h[k++]/Math.sqrt(p[C++]+l),x>=g&&(x=0),w>=v&&(w=0),k>=b&&(k=0),C>=y&&(C=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function JF(e,t,n,s,r){const a=mv(s,t,n),o=Nh(n),i=Hh(s);if(a){const n=gv(t,i);return"string"===r?e.slice(n,n+o):e.subarray(n,n+o)}const u=Wy(s,r,"string"===r?zC(e):e),l=Wy(n,r);for(let c=0;c<l.size;++c){const e=l.indexToLoc(c),n=e.map((e,n)=>e+t[n]);l.set(u.get(...n),...e)}return"string"===r?MC(l.values):l.values}function eD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,size:o}=s;DR(r,"slice");const[i,u]=bv(r,a,o);sv(r,i,u);const l=JF(n.data.get(r.dataId).values,i,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,l)}const tD={kernelName:Eg,backendName:"cpu",kernelFunc:eD},nD={kernelName:Tf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,crops:o}=s;DR([r],"batchToSpaceND");const i=a.reduce((e,t)=>e*t),u=Jk(r.shape,a,i),l=eC(u.length,a.length),c=tC(r.shape,a,i),d=nC(o,a.length),p=sC(c,o,a.length),h=mF({inputs:{x:r},backend:n,attrs:{shape:u}}),f=NF({inputs:{x:h},backend:n,attrs:{perm:l}}),m=mF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=eD({inputs:{x:m},backend:n,attrs:{begin:d,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function sD(e,t,n,s,r){const a=Nh(s),o=Yh(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(o[n]+=a>0?t[i]:1)}return o}function rD(e,t,n,s=!1){const r=e.shape[0],a=e.shape[1],o=Wy([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<a;r++){const a=e.get(i,r);if(a<0)throw new Error("Input x must be non-negative!");a>=n||o.set(s?1:t.size>0?o.get(i,a)+t.get(i,r):o.get(i,a)+1,i,a)}return o}const aD={kernelName:Af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o}=s,i=sD(n.data.get(r.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,i)}};function oD(e){return(t,n,s)=>{const r=zh(n,t.length);for(let a=0;a<t.length;++a)r[a]=e(t[a],s);return r}}const iD=oD(e=>Math.ceil(e)),uD=MR(Ff,iD),lD={kernelName:Ff,backendName:"cpu",kernelFunc:uD},cD=zR(Df,(e,t)=>e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e),dD={kernelName:Df,backendName:"cpu",kernelFunc:cD},pD={kernelName:qf,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,s=new Float32Array(Nh(t.shape)),r=n.data.get(t.dataId),a=r.complexTensorInfos.imag,o=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(a.dataId).values;for(let u=0;u<o.length;u++)s[u]=Math.hypot(o[u],i[u]);return n.makeOutput(s,t.shape,"float32")}};function hD(e,t,n,s){const r=Mh(n,Nh(t));if(s&&"string"!==n){let t=0;e.forEach(e=>{const n=Nh(e.shape);r.set(e.vals,t),t+=n})}else{let s=0;e.forEach(e=>{const a="string"===n?zC(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+s;for(let t=0;t<e.shape[1];++t)r[i+t]=a[o++]}s+=e.shape[1]})}return r}function fD(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.imag,a=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,a)}const mD={kernelName:Im,backendName:"cpu",kernelFunc:fD};function gD(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,a=Oh(r,t[0].shape)[0];let o=Xk(t.map(e=>e.shape),a);if(0===Nh(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter(e=>Nh(e.shape)>0);if(1===i.length)return VR({inputs:{x:i[0]},backend:n});if(Kk(i.map(e=>e.shape),a),"complex64"===i[0].dtype){const e=i.map(e=>aF({inputs:{input:e},backend:n})),t=i.map(e=>fD({inputs:{input:e},backend:n})),s=gD({inputs:e,backend:n,attrs:{axis:a}}),r=gD({inputs:t,backend:n,attrs:{axis:a}}),o=nF({inputs:{real:s,imag:r},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),o}const u=i.map(e=>{const t=Nh(e.shape.slice(a));return mF({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),l=u.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));o=Xk(u.map(e=>e.shape),1);const c=hD(l,o,t[0].dtype,1===u[0].shape[0]),d=Xk(i.map(e=>e.shape),a),p=n.makeTensorInfo(d,t[0].dtype,c);return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}const bD={kernelName:zf,backendName:"cpu",kernelFunc:gD};function yD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=s;DR([r,a],"conv2d");const d=Kv(u),p=Lv(r.shape,a.shape,o,l,i,c,!1,d),h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,b=p.padInfo.left,y=p.padInfo.top,v="channelsLast"===p.dataFormat,x=new Eb(p.outShape,r.dtype),w=Hh(r.shape),k=Hh(a.shape),C=w[0],I=v?w[1]:w[2],_=v?w[2]:1,S=v?1:w[1],E=x.strides[0],N=v?x.strides[1]:x.strides[2],$=v?x.strides[2]:1,T=v?1:x.strides[1],A=n.data.get(r.dataId).values,R=n.data.get(a.dataId).values,F=x.values;for(let D=0;D<p.batchSize;++D){const e=D*C,t=D*E;for(let n=0;n<p.outHeight;++n){const s=t+n*N,r=n*p.strideHeight-y;for(let t=0;t<h;++t){const n=r+t*m;if(n<0||n>=p.inHeight)continue;const a=t*k[0],o=e+n*I;for(let e=0;e<p.outWidth;++e){const t=s+e*$,n=e*p.strideWidth-b;for(let e=0;e<f;++e){const s=n+e*g;if(s<0||s>=p.inWidth)continue;const r=o+s*_;let i=a+e*k[1];for(let e=0;e<p.inChannels;++e){const n=A[r+e*S];for(let e=0;e<p.outChannels;++e)F[t+e*T]+=n*R[i+e];i+=p.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,F)}const vD={kernelName:Mf,backendName:"cpu",kernelFunc:yD},xD={kernelName:Lf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=s;DR([r,a],"conv2dBackpropFilter");const d=Kv(u),p=Lv(r.shape,c,o,1,i,l,!1,d),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=p,b="channelsLast"===p.dataFormat,y=new Eb(p.filterShape,"float32"),v=p.padInfo.left,x=p.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(a.dataId).values,C=new Eb(r.shape,r.dtype,w),I=new Eb(a.shape,a.dtype,k);for(let _=0;_<m;++_){const e=Math.max(0,Math.ceil((x-_)/h)),t=Math.min(p.outHeight,(p.inHeight+x-_)/h);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(p.outWidth,(p.inWidth+v-n)/f);for(let a=0;a<p.inChannels;++a)for(let o=0;o<p.outChannels;++o){let i=0;for(let u=0;u<p.batchSize;++u)for(let l=e;l<t;++l){const e=_+l*h-x;for(let t=s;t<r;++t){const s=n+t*f-v;i+=b?C.get(u,e,s,a)*I.get(u,l,t,o):C.get(u,a,e,s)*I.get(u,o,l,t)}}y.set(i,_,n,a,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},wD={kernelName:Pf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=s;DR([r,a],"conv2dBackpropInput");const d=Hh(a.shape),p=Hh(r.shape);let h=Kv(l);const f=Lv(o,a.shape,i,1,u,c,!1,h),m=new Eb(f.inShape,"float32"),g=m.values,b=n.data.get(r.dataId).values,y=n.data.get(a.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:C,filterWidth:I,inChannels:_,inHeight:S,inWidth:E,outChannels:N,outHeight:$,outWidth:T,strideHeight:A,strideWidth:R}=f;h=f.dataFormat;const F=C-1-f.padInfo.top,D=I-1-f.padInfo.left,O="channelsLast"===h,q=m.strides[0],z=O?m.strides[1]:m.strides[2],M=O?m.strides[2]:1,L=O?1:m.strides[1],P=p[0],V=O?p[1]:p[2],j=O?p[2]:1,B=O?1:p[1];for(let W=0;W<k;++W)for(let e=0;e<_;++e)for(let t=0;t<S;++t){const n=t-F,s=Math.max(0,Math.ceil(n/A)),r=Math.min($,(C+n)/A);for(let a=0;a<E;++a){const o=a-D,i=Math.max(0,Math.ceil(o/R)),u=Math.min(T,(I+o)/R);let l=0;for(let t=s;t<r;++t){const s=t*A-n;for(let n=i;n<u;++n){const r=P*W+V*t+j*n,a=v*(C-1-s)+x*(I-1-(n*R-o))+w*e;for(let e=0;e<N;++e)l+=b[r+B*e]*y[a+e]}}g[q*W+z*t+M*a+L*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},kD={kernelName:Vf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dilations:u}=s;DR([r,a],"conv3d");const l=Pv(r.shape,a.shape,o,u,i),{filterDepth:c,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,v=g.top,x=new Eb(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(a.dataId).values,C=x.values,I=Hh(r.shape),_=Hh(a.shape);for(let S=0;S<l.batchSize;++S){const e=S*I[0],t=S*x.strides[0];for(let n=0;n<l.outDepth;++n){const s=t+n*x.strides[1],r=n*l.strideDepth-b;for(let t=0;t<c;++t){const n=r+t*h;if(n<0||n>=l.inDepth)continue;const a=t*_[0],o=e+n*I[1];for(let e=0;e<l.outHeight;++e){const t=s+e*x.strides[2],n=e*l.strideHeight-v;for(let e=0;e<d;++e){const s=n+e*f;if(s<0||s>=l.inHeight)continue;const r=a+e*_[1],i=o+s*I[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,s=e*l.strideWidth-y;for(let e=0;e<p;++e){const t=s+e*m;if(t<0||t>=l.inWidth)continue;const a=i+t*l.inChannels;let o=r+e*_[2];for(let e=0;e<l.inChannels;++e){const t=w[a+e];for(let e=0;e<l.outChannels;++e)C[n+e]+=t*k[o+e];o+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},CD={kernelName:jf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:i,filterShape:u}=s;DR([r,a],"conv3dBackpropFilterV2");const l=Hh(r.shape),c=Hh(a.shape),d=Pv(r.shape,u,o,1,i),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new Eb(d.filterShape,"float32"),v=y.values,[x,w,k,C]=y.strides,I=n.data.get(a.dataId).values,[_,S,E,N]=c,$=n.data.get(r.dataId).values,[T,A,R,F]=l,D=d.padInfo.front,O=d.padInfo.left,q=d.padInfo.top;for(let z=0;z<m;++z){const e=Math.max(0,Math.ceil((D-z)/p)),t=Math.min(d.outDepth,(d.inDepth+D-z)/p),n=z*x;for(let s=0;s<g;++s){const r=Math.max(0,Math.ceil((q-s)/h)),a=Math.min(d.outHeight,(d.inHeight+q-s)/h),o=s*w+n;for(let n=0;n<b;++n){const i=Math.max(0,Math.ceil((O-n)/f)),u=Math.min(d.outWidth,(d.inWidth+O-n)/f),l=n*k+o;for(let o=0;o<d.inChannels;++o){const c=o*C+l;for(let l=0;l<d.outChannels;++l){let m=0;for(let c=0;c<d.batchSize;++c){const d=c*T,g=c*_;for(let c=e;c<t;++c){const e=(z+c*p-D)*A+d,t=c*S+g;for(let c=r;c<a;++c){const r=(s+c*h-q)*R+e,a=c*E+t;for(let e=i;e<u;++e)m+=$[(n+e*f-O)*F+r+o]*I[e*N+a+l]}}}v[c+l]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},ID={kernelName:Bf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{pad:o,strides:i,inputShape:u}=s;DR([r],"conv3dBackpropInputV2");const l=Hh(r.shape),c=Hh(a.shape),d=Pv(u,a.shape,i,1,o),p=new Eb(d.inShape,"float32"),h=p.values,[f,m,g,b]=p.strides,y=n.data.get(r.dataId).values,[v,x,w,k]=l,C=n.data.get(a.dataId).values,[I,_,S,E]=c,{batchSize:N,filterDepth:$,filterHeight:T,filterWidth:A,inChannels:R,inDepth:F,inHeight:D,inWidth:O,outChannels:q,outDepth:z,outHeight:M,outWidth:L,strideDepth:P,strideHeight:V,strideWidth:j}=d,B=$-1-d.padInfo.front,W=T-1-d.padInfo.top,U=A-1-d.padInfo.left;for(let G=0;G<N;++G)for(let e=0;e<R;++e)for(let t=0;t<F;++t){const n=t-B,s=Math.max(0,Math.ceil(n/P)),r=Math.min(z,($+n)/P);for(let a=0;a<D;++a){const o=a-W,i=Math.max(0,Math.ceil(o/V)),u=Math.min(M,(T+o)/V);for(let l=0;l<O;++l){const c=l-U,d=Math.max(0,Math.ceil(c/j)),p=Math.min(L,(A+c)/j);let N=0;for(let t=s;t<r;++t){const s=t*P-n;for(let n=i;n<u;++n){const r=n*V-o;for(let a=d;a<p;++a){const o=v*G+x*t+w*n+k*a,i=I*($-1-s)+_*(T-1-r)+S*(A-1-(a*j-c))+E*e;for(let e=0;e<q;++e)N+=y[o+e]*C[i+e]}}}h[f*G+m*t+g*a+b*l+e]=N}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}},_D=zR(Wf,e=>Math.cos(e)),SD={kernelName:Wf,backendName:"cpu",kernelFunc:_D},ED=zR(Uf,e=>Math.cosh(e)),ND={kernelName:Uf,backendName:"cpu",kernelFunc:ED},$D={kernelName:Hf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=s,[c,d,p,h]=r.shape,f=a.shape[0],[m,g]=i,b=Wy([f,m,g,h],"float32"),y=n.data.get(a.dataId).values,v=n.data.get(o.dataId).values,x=n.data.get(r.dataId).values,w=Hh(r.shape),k=Hh(b.shape);for(let C=0;C<f;C++){const e=4*C,t=y[e],n=y[e+1],s=y[e+2],r=y[e+3],a=v[C];if(a>=c)continue;const o=m>1?(s-t)*(d-1)/(m-1):0,i=g>1?(r-n)*(p-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(d-1)+c*o:.5*(t+s)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<h;e++)b.values[e+t*k[2]+c*k[1]+C*k[0]]=l;else if("bilinear"===u){const t=Math.floor(e),s=Math.ceil(e),o=e-t;for(let e=0;e<g;e++){const u=g>1?n*(p-1)+e*i:.5*(n+r)*(p-1);if(u<0||u>p-1){for(let t=0;t<h;t++)b.values[t+e*k[2]+c*k[1]+C*k[0]]=l;continue}const d=Math.floor(u),f=Math.ceil(u),m=u-d;for(let n=0;n<h;n++){let r=n+d*w[2]+t*w[1]+a*w[0];const i=x[r];r=n+f*w[2]+t*w[1]+a*w[0];const u=x[r];r=n+d*w[2]+s*w[1]+a*w[0];const l=x[r];r=n+f*w[2]+s*w[1]+a*w[0];const p=x[r],h=i+(u-i)*m;r=n+e*k[2]+c*k[1]+C*k[0],b.values[r]=h+(l+(p-l)*m-h)*o}}}else for(let t=0;t<g;++t){const s=g>1?n*(p-1)+t*i:.5*(n+r)*(p-1);if(s<0||s>p-1){for(let e=0;e<h;e++)b.values[e+t*k[2]+c*k[1]+C*k[0]]=l;continue}const o=Math.round(s),u=Math.round(e);for(let e=0;e<h;e++)b.values[e+t*k[2]+c*k[1]+C*k[0]]=x[e+o*w[2]+u*w[1]+a*w[0]]}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},TD={kernelName:Gf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s;DR(r,"cumsum");const u=Yx([a],r.shape.length);let l=r;null!=u&&(l=NF({inputs:{x:r},backend:n,attrs:{perm:u}}));const c=Jx(1,r.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const d=Pb(l.dtype,"int32"),p=Yh(Nh(l.shape),d),h=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<h.length;b+=f)for(let e=0;e<f;e++){const t=m(b,e);if(0===e)p[t]=o?0:h[t];else{const n=m(b,e-1);p[t]=o?h[n]+p[n]:h[t]+p[n]}}const g=n.makeTensorInfo(l.shape,d,p);if(null!=u){const e=NF({inputs:{x:g},backend:n,attrs:{perm:Qx(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}},AD={kernelName:Kf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o,binaryOutput:i}=s;if(1===r.shape.length){const e=sD(n.data.get(r.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,e)}if(2===r.shape.length){const e=rD(n.bufferSync(r),n.bufferSync(a),o,i);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},RD={kernelName:Xf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:a,dataFormat:o}=s;Ih("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`),Ih(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const i=r.shape[0],u=r.shape[1],l=r.shape[2],c=r.shape[3],d=u*a,p=l*a,h=c/(a*a),f=n.data.get(r.dataId).values,m=new Float32Array(i*d*p*h);let g=0;for(let b=0;b<i;++b)for(let e=0;e<d;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<p;++e){const s=Math.floor(e/a),r=(n*a+e%a)*h;for(let e=0;e<h;++e)m[g++]=f[e+r+c*(s+l*(t+u*b))]}}return n.makeTensorInfo([i,d,p,h],r.dtype,m)}};function FD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=s;DR([r,a],"depthwiseConv2DNative");const c=Hh(r.shape),d=Hh(a.shape);let p=u;null==p&&(p=[1,1]),Ih(Hv(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);const h=Lv(r.shape,a.shape,o,p,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=h,v=y.left,x=y.top,w=h.outChannels/h.inChannels,k=new Eb(h.outShape,r.dtype),C=n.data.get(r.dataId).values,I=n.data.get(a.dataId).values,_=k.values;for(let S=0;S<h.batchSize;++S){const e=S*c[0],t=S*k.strides[0];for(let n=0;n<h.outHeight;++n){const s=t+n*k.strides[1],r=n*h.strideHeight-x;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=h.inHeight)continue;const a=t*d[0],o=e+n*c[1];for(let e=0;e<h.outWidth;++e){const t=s+e*k.strides[2],n=e*h.strideWidth-v;for(let e=0;e<m;++e){const s=n+e*b;if(s<0||s>=h.inWidth)continue;const r=o+s*h.inChannels;let i=t,u=a+e*d[1];for(let e=0;e<h.inChannels;++e){const t=C[r+e];for(let e=0;e<w;++e)_[i+e]+=t*I[u+e];i+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const DD={kernelName:Zf,backendName:"cpu",kernelFunc:FD},OD={kernelName:Yf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=s;DR([r,a],"depthwiseConv2dNativeBackpropFilter");const d=Lv(r.shape,c,o,i,u,l,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:m}=d,g=new Eb(d.filterShape,"float32"),b=d.padInfo.left,y=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(r.dataId).values,w=new Eb(r.shape,r.dtype,x),k=n.data.get(a.dataId).values,C=new Eb(a.shape,a.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((y-I)/p)),t=Math.min(d.outHeight,(d.inHeight+y-I)/p);for(let n=0;n<m;++n){const s=Math.max(0,Math.ceil((b-n)/h)),r=Math.min(d.outWidth,(d.inWidth+b-n)/h);for(let a=0;a<d.outChannels;++a){const o=Math.trunc(a/v),i=a%v;let u=0;for(let l=0;l<d.batchSize;++l)for(let i=e;i<t;++i){const e=I+i*p-y;for(let t=s;t<r;++t)u+=w.get(l,e,n+t*h-b,o)*C.get(l,i,t,a)}g.set(u,I,n,o,i)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},qD={kernelName:Qf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=s;DR([r,a],"depthwiseConv2DNativeBackpropInput");const d=Hh(r.shape),p=Hh(a.shape),h=Lv(c,a.shape,o,i,u,l,!0),f=new Eb(h.inShape,"float32"),m=f.values,[g,b,y]=f.strides,v=n.data.get(r.dataId).values,[x,w,k]=d,C=n.data.get(a.dataId).values,[I,_,S]=p,{batchSize:E,filterHeight:N,filterWidth:$,inChannels:T,inHeight:A,inWidth:R,outChannels:F,outHeight:D,outWidth:O,strideHeight:q,strideWidth:z}=h,M=N-1-h.padInfo.top,L=$-1-h.padInfo.left,P=F/T;for(let V=0;V<E;++V)for(let e=0;e<T;++e)for(let t=0;t<A;++t){const n=t-M,s=Math.max(0,Math.ceil(n/q)),r=Math.min(D,(N+n)/q);for(let a=0;a<R;++a){const o=a-L,i=Math.max(0,Math.ceil(o/z)),u=Math.min(O,($+o)/z);let l=0;for(let t=s;t<r;++t){const s=t*q-n;for(let n=i;n<u;++n){const r=x*V+w*t+k*n,a=I*(N-1-s)+_*($-1-(n*z-o))+S*e;for(let t=0;t<P;++t)l+=v[r+(e*P+t)]*C[a+t]}}m[g*V+b*t+y*a+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},zD={kernelName:Jf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=Nh(s.shape),a=n.data.get(s.dataId).values,o=Wy([r,r],s.dtype),i=o.values;for(let l=0;l<a.length;l++)i[l*r+l]=a[l];const u=[...s.shape,...s.shape];return n.makeTensorInfo(u,o.dtype,o.values)}},MD={kernelName:em,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r}=e,{strides:a,pad:o,dilations:i}=n,u=t,l=u.data.get(s.dataId).values,c=s.shape.length,d=u.data.get(r.dataId).values,p=r.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:C,dilationHeight:I,dilationWidth:_,outShape:S}=qv(s.shape,r.shape,a,o,"NHWC",i),E=Nh(S),N=S.length,$=Mh(s.dtype,E);for(let T=0;T<h;++T)for(let e=0;e<b;++e){const t=e*x-v.top;for(let n=0;n<y;++n){const a=n*w-v.left;for(let o=0;o<g;++o){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<C;++t){const u=a+t*_;if(u>=0&&u<m){const a=ef([T,n,u,o],c,Hh(s.shape)),h=ef([e,t,o],p,Hh(r.shape)),f=l[a]+d[h];f>i&&(i=f)}}}$[ef([T,e,n,o],N,Hh(S))]=i}}}return{dataId:u.write(mb($,s.dtype),S,s.dtype),shape:S,dtype:s.dtype}}},LD={kernelName:nm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:a}=e,{strides:o,pad:i,dilations:u}=n,l=t,c=Xh(s.shape,l.data.get(s.dataId).values),d=Xh(r.shape,l.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:C,dilationWidth:I,outShape:_}=qv(s.shape,r.shape,o,i,"NHWC",u);Ih(a.rank===_.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${_.length}, but got ${a.rank}`);const S=Xh(_,l.data.get(a.dataId).values),E=Qh(r.shape,r.dtype);for(let N=0;N<p;++N)for(let e=0;e<g;++e){const t=e*v-y.top;for(let n=0;n<b;++n){const s=n*x-y.left;for(let r=0;r<m;++r){let a=Number.MIN_SAFE_INTEGER,o=0,i=0;for(let e=0;e<w;++e){const n=t+e*C;if(n>=0&&n<h)for(let t=0;t<k;++t){const u=s+t*I;if(u>=0&&u<f){const s=c[N][n][u][r]+d[e][t][r];s>a&&(a=s,o=e,i=t)}}}E[o][i][r]+=S[N][e][n][r]}}}return{dataId:l.write(mb(E,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},PD={kernelName:tm,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:a}=e,{strides:o,pad:i,dilations:u}=n,l=t,c=Xh(s.shape,l.data.get(s.dataId).values),d=Xh(r.shape,l.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:C,dilationWidth:I,outShape:_}=qv(s.shape,r.shape,o,i,"NHWC",u);Ih(a.rank===_.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${_.length}, but got ${a.rank}`);const S=Xh(_,l.data.get(a.dataId).values),E=Qh(s.shape,s.dtype);for(let N=0;N<p;++N)for(let e=0;e<g;++e){const t=e*v-y.top;for(let n=0;n<b;++n){const s=n*x-y.left;for(let r=0;r<m;++r){let a=Number.MIN_SAFE_INTEGER,o=t<0?0:t,i=s<0?0:s;for(let e=0;e<w;++e){const n=t+e*C;if(n>=0&&n<h)for(let t=0;t<k;++t){const u=s+t*I;if(u>=0&&u<f){const s=c[N][n][u][r]+d[e][t][r];s>a&&(a=s,o=n,i=u)}}}E[N][o][i][r]+=S[N][e][n][r]}}}return{dataId:l.write(mb(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},VD=UR((e,t)=>e*t),jD=cF((e,t,n,s)=>({real:e*n-t*s,imag:e*s+t*n})),BD=lF(Qm,VD,jD),WD={kernelName:Qm,backendName:"cpu",kernelFunc:BD};function UD(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;let i;DR(r,"sum"),i="bool"===r.dtype?iF({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):VR({inputs:{x:r},backend:n});const u=i.shape.length,l=Oh(a,i.shape),c=Yx(l,u);let d=l,p=i;null!=c&&(p=NF({inputs:{x:i},backend:n,attrs:{perm:c}}),d=Jx(d.length,u)),Zx("sum",d,p.shape.length);const[h,f]=Kx(p.shape,d);let m=rF(n,h,Pb(p.dtype,"int32"));const g=Nh(f),b=n.data.get(m.dataId).values,y=n.data.get(p.dataId).values;for(let v=0;v<b.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=y[e+n];b[v]=t}if(o){const e=m;m=mF({inputs:{x:m},backend:n,attrs:{shape:Xx(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=c&&n.disposeIntermediateTensorInfo(p),m}const GD={kernelName:Dg,backendName:"cpu",kernelFunc:UD},HD={kernelName:rm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,a=t,{allDims:o,summedDims:i,idDims:u}=EC(r,a.length);$C(o.length,u,a);const{path:l,steps:c}=TC(i,u),d=c.length;let p=null,h=o.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:s}=NC(h,u[e]);let r;AC(t)?r=a[e]:(r=NF({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let e=0;e<s.length;++e)o.splice(s[e],0,1);$h(r.shape,o)||(r=mF({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===p?p=r:(p=BD({inputs:{a:r,b:p},backend:n}),f.push(p))}m<d-1&&(l[m]>=0&&(p=UD({inputs:{x:p},backend:n,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(const m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}},KD={kernelName:om,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:s,y:r}=t;DR([s,r],"eluGrad");const a=new Float32Array(Nh(r.shape)),o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values;for(let u=0;u<o.length;++u){const e=o[u];a[u]=e>=1?i[u]:i[u]*(e+1)}return n.makeTensorInfo(r.shape,"float32",a)}},XD=UR((e,t)=>e===t?1:0),ZD=lF(um,XD,null,"bool"),YD={kernelName:um,backendName:"cpu",kernelFunc:ZD},QD=cC,JD=dC,eO=pC,tO=hC,nO=fC,sO=mC,rO=zR(im,e=>{const t=Math.sign(e),n=Math.abs(e),s=1/(1+QD*n);return t*(1-((((sO*s+nO)*s+tO)*s+eO)*s+JD)*s*Math.exp(-n*n))}),aO={kernelName:im,backendName:"cpu",kernelFunc:rO},oO=oD(e=>Math.exp(e)),iO=MR(lm,oO),uO={kernelName:lm,backendName:"cpu",kernelFunc:iO};function lO(e){const{inputs:t,backend:n,attrs:s}=e,{input:r}=t,{dim:a}=s,o=r.shape.length,i=r.shape.slice();let u=a;return a<0&&(Ih(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),mF({inputs:{x:r},backend:n,attrs:{shape:i}})}const cO={kernelName:cm,backendName:"cpu",kernelFunc:lO},dO=oD(e=>Math.expm1(e)),pO=MR(dm,dO),hO={kernelName:dm,backendName:"cpu",kernelFunc:pO},fO=UR((e,t)=>e/t),mO=lF(sm,fO),gO={kernelName:sm,backendName:"cpu",kernelFunc:mO},bO=UR((e,t)=>e-t),yO=cF((e,t,n,s)=>({real:e-n,imag:t-s})),vO=lF(Wg,bO,yO),xO={kernelName:Wg,backendName:"cpu",kernelFunc:vO};function wO(e,t,n){const s=e.shape,r=s[0],a=s[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,l=[r,a],c=Nh(l),d=zh("float32",c),p=zh("float32",c);for(let g=0;g<r;g++){const e=eD({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,a]}}),s=eD({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,a]}}),r=nF({inputs:{real:e,imag:s},backend:n}),{real:o,imag:l}=kO(r,t,n),c=yC(o,l);for(let t=0;t<a;t++){const e=kC(c,t);d[g*a+t]=e.real,p[g*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r)}const h=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",p),m=nF({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function kO(e,t,n){const s=Nh(e.shape),r=n.data.get(e.dataId),a=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((i=s)&i-1)){const r=CO(a,o,s,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),a=n.makeTensorInfo([],"float32",fb(s,"float32")),o=VR({inputs:{x:a},backend:n}),u=gO.kernelFunc({inputs:{a:e,b:a},backend:n}),l=gO.kernelFunc({inputs:{a:t,b:o},backend:n}),c=n.data.get(u.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),{real:c,imag:d}}return r}return vC(function(e,t,n){const s=new Float32Array(2*t);for(let r=0;r<t;r++){let a=0,o=0;for(let s=0;s<t;s++){const i=_C(r*s,t,n),u=kC(e,s);a+=u.real*i.real-u.imag*i.imag,o+=u.real*i.imag+u.imag*i.real}n&&(a/=t,o/=t),CC(s,a,o,r)}return s}(yC(a,o),s,t));var i}function CO(e,t,n,s,r){if(1===n)return{real:e,imag:t};const a=yC(e,t),o=n/2,i=xC(a),u=i.real,l=i.imag,c=[u.length],d=r.makeTensorInfo(c,"float32",u),p=r.makeTensorInfo(c,"float32",l),h=nF({inputs:{real:d,imag:p},backend:r}),f=wC(a),m=f.real,g=f.imag,b=[m.length],y=r.makeTensorInfo(b,"float32",m),v=r.makeTensorInfo(b,"float32",g),x=nF({inputs:{real:y,imag:v},backend:r}),w=CO(u,l,o,s,r),k=w.real,C=w.imag,I=[k.length],_=r.makeTensorInfo(I,"float32",k),S=r.makeTensorInfo(I,"float32",C),E=nF({inputs:{real:_,imag:S},backend:r}),N=CO(m,g,o,s,r),$=N.real,T=N.imag,A=[$.length],R=r.makeTensorInfo(A,"float32",$),F=r.makeTensorInfo(A,"float32",T),D=nF({inputs:{real:R,imag:F},backend:r}),O=IC(n,s),q=[O.real.length],z=r.makeTensorInfo(q,"float32",O.real),M=r.makeTensorInfo(q,"float32",O.imag),L=nF({inputs:{real:z,imag:M},backend:r}),P=BD({inputs:{a:L,b:D},backend:r}),V=hF({inputs:{a:E,b:P},backend:r}),j=vO({inputs:{a:E,b:P},backend:r}),B=aF({inputs:{input:V},backend:r}),W=aF({inputs:{input:j},backend:r}),U=fD({inputs:{input:V},backend:r}),G=fD({inputs:{input:j},backend:r}),H=gD({inputs:[B,W],backend:r,attrs:{axis:0}}),K=gD({inputs:[U,G],backend:r,attrs:{axis:0}}),X=r.data.get(H.dataId).values,Z=r.data.get(K.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(K),{real:X,imag:Z}}const IO={kernelName:pm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,r=Nh(s.shape),a=s.shape[s.shape.length-1],o=mF({inputs:{x:s},backend:n,attrs:{shape:[r/a,a]}}),i=wO(o,!1,n),u=mF({inputs:{x:i},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}};function _O(e){const{backend:t,attrs:n}=e,{shape:s,value:r,dtype:a}=n,o=a||Wh(r),i=Mh(o,Nh(s));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(s,o,i)}const SO={kernelName:hm,backendName:"cpu",kernelFunc:_O},EO={kernelName:fm,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,s=t,r=zh(n.dtype,Nh(n.shape)),[a,o,i,u]=n.shape,l=s.data.get(n.dataId).values;for(let c=0;c<a;c++){const e=c*i*o*u;for(let t=0;t<o;t++){const n=t*(i*u);for(let s=0;s<i;s++){const o=s*u;for(let c=0;c<u;c++){const d=Math.round(i-[a,t,s,c][2]),p=e+n+o+c;let h=l[p];d>=0&&d<i&&(h=l[e+n+d*u+c]),r[p]=h}}}}return{dataId:s.write(r,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},NO=oD(e=>Math.floor(e)),$O=MR(mm,NO),TO={kernelName:mm,backendName:"cpu",kernelFunc:$O},AO=UR((e,t)=>Math.floor(e/t)),RO=lF(gm,AO,null,"int32"),FO={kernelName:gm,backendName:"cpu",kernelFunc:RO},DO={kernelName:rb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s;let m=yD({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){const e=m;m=hF({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){const e=m;m=tF(n,m,h,i,f),n.disposeIntermediateTensorInfo(e)}return m}},OO={kernelName:ab,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s;let m=FD({inputs:{x:r,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p}});if(o){const e=m;m=hF({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){const e=m;m=tF(n,m,h,i,f),n.disposeIntermediateTensorInfo(e)}return m}},qO={kernelName:vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,a=Nh(s.shape),o=r.shape,i=o[o.length-1],[u,l,c,d]=rC(s,r);if(0===l)return n.makeTensorInfo(u,s.dtype,[]);const p=Wy([l,c],s.dtype),h=n.data.get(r.dataId).values,f=n.data.get(s.dataId).values;for(let m=0;m<l;m++){const e=[];let t=0;for(let n=0;n<i;n++){const s=h[m*i+n];t+=s*d[n],e.push(s)}if(t<0||t>=a/c)throw new Error(`Invalid indices: ${e} does not index into ${s.shape}`);for(let n=0;n<c;n++)p.values[m*c+n]=f[t*c+n]}return n.makeTensorInfo(u,p.dtype,p.values)}};function zO(e,t,n){const s=Wy(n,e.dtype);for(let r=0;r<s.size;++r){const n=s.indexToLoc(r).slice(),a=t.locToIndex([n[0],n[2]]);n[2]=t.values[a];const o=e.locToIndex(n);s.values[r]=e.values[o]}return s}const MO={kernelName:ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:a}=t,{axis:o,batchDims:i}=s;DR([r,a],"gatherV2");let u=i;null==i&&(u=0);const l=Nh(a.shape),c=qC(r,a,Oh(o,r.shape)[0],u),d=mF({inputs:{x:r},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=mF({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}}),h=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize],f=n.bufferSync(p),m=zO(n.bufferSync(d),f,h);return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.makeTensorInfo(c.outputShape,m.dtype,m.values)}},LO=UR((e,t)=>e>t?1:0),PO=lF(xm,LO,null,"bool"),VO={kernelName:xm,backendName:"cpu",kernelFunc:PO},jO=UR((e,t)=>e>=t?1:0),BO=lF(wm,jO,null,"bool"),WO={kernelName:wm,backendName:"cpu",kernelFunc:BO},UO={kernelName:Cm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,r=Nh(s.shape),a=s.shape[s.shape.length-1],o=mF({inputs:{x:s},backend:n,attrs:{shape:[r/a,a]}}),i=wO(o,!0,n),u=mF({inputs:{x:i},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),u}},GO=zR(_m,e=>Number.isFinite(e)?1:0,"bool"),HO={kernelName:_m,backendName:"cpu",kernelFunc:GO},KO=zR(Sm,e=>Math.abs(e)===1/0?1:0,"bool"),XO={kernelName:Sm,backendName:"cpu",kernelFunc:KO},ZO=zR(Em,e=>Number.isNaN(e)?1:0,"bool"),YO={kernelName:Em,backendName:"cpu",kernelFunc:ZO},QO=UR((e,t)=>e<t?1:0),JO=lF($m,QO,null,"bool"),eq={kernelName:$m,backendName:"cpu",kernelFunc:JO},tq=UR((e,t)=>e<=t?1:0),nq=lF(Tm,tq,null,"bool"),sq={kernelName:Tm,backendName:"cpu",kernelFunc:nq};function rq(e,t,n){const s=(t-e)/(n-1),r=Yh(n,"float32");r[0]=e;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}const aq={kernelName:Am,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:a}=n,o=rq(s,r,a);return t.makeTensorInfo([o.length],"float32",o)}},oq=oD(e=>Math.log(e)),iq=MR(Rm,oq),uq={kernelName:Rm,backendName:"cpu",kernelFunc:iq},lq=zR(Fm,e=>Math.log1p(e)),cq={kernelName:Fm,backendName:"cpu",kernelFunc:lq},dq=UR((e,t)=>e&&t),pq=lF(Dm,dq,null,"bool"),hq={kernelName:Dm,backendName:"cpu",kernelFunc:pq},fq=zR(Om,e=>e?0:1,"bool"),mq={kernelName:Om,backendName:"cpu",kernelFunc:fq},gq=UR((e,t)=>e||t),bq=lF(qm,gq,null,"bool"),yq={kernelName:qm,backendName:"cpu",kernelFunc:bq},vq={kernelName:zm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=s;DR(r,"LRN");const l=r.shape[3],c=l-1,d=n.data.get(r.dataId).values,p=Nh(r.shape),h=new Float32Array(p);function f(e){const t=e%l;let n=e-t+Math.max(0,t-a);const s=e-t+Math.min(t+a,c);let r=0;for(;n<=s;n++){const e=d[n];r+=e*e}return r}for(let m=0;m<p;m++){const e=f(m),t=d[m]*Math.pow(o+i*e,-u);h[m]=t}return n.makeTensorInfo(r.shape,r.dtype,h)}},xq={kernelName:Mm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:c}=s;DR(o,"LRNGrad");const d=Nh(o.shape),p=o.shape[3],h=n.data.get(o.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){const e=y%p,t=y-e+Math.max(0,e-i),n=y-e+Math.min(p,e+i+1);let s=0;for(let r=t;r<n;r++)s+=Math.pow(f[r],2);s=l*s+u;for(let r=t;r<n;r++){let e=-2*l*c*f[r]*m[y]/s;y===r&&(e+=Math.pow(s,-c)),e*=h[y],g[r]+=e}}return n.makeTensorInfo(o.shape,r.dtype,g)}};function wq(e,t,n,s){const r=zh(s,Nh(n));for(let a=0;a<r.length;++a){const n=a*t;let s=e[n];for(let r=0;r<t;++r){const t=e[n+r];t>s&&(s=t)}r[a]=s}return r}function kq(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:a,keepDims:o}=s,i=n;let u=r.shape;const l=u.length,c=Oh(a,u);let d=c;const p=Yx(d,l);let h=i.data.get(r.dataId).values;if(null!=p){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=u[p[t]];h=EF(h,u,r.dtype,p,e),d=Jx(d.length,l),u=e}DR(r,"max"),Zx("max",d,l);const[f,m]=Kx(u,d),g=wq(h,Nh(m),f,r.dtype),b=i.write(g,f,r.dtype);let y=f;return o&&(y=Xx(f,c)),{dataId:b,shape:y,dtype:r.dtype}}const Cq={kernelName:Lm,backendName:"cpu",kernelFunc:kq},Iq=UR((e,t)=>Math.max(e,t)),_q=lF(Pm,Iq),Sq={kernelName:Pm,backendName:"cpu",kernelFunc:_q},Eq={kernelName:Vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;DR(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=s;Ih(Hv(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const l=zv(r.shape,a,o,1,i,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&$h(l.inShape,l.outShape))c=VR({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Hh(r.shape),s=UF(e,0,r.dtype,t,l,"max");c=n.makeTensorInfo(l.outShape,r.dtype,s.values)}return c}},Nq={kernelName:Bm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=s;DR(r,"maxPool3d");const c=Mv(r.shape,a,o,1,i,u,l),d=HF(n.data.get(r.dataId).values,0,r.dtype,Hh(r.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}},$q={kernelName:Wm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=s;DR([r,a],"maxPool3DGrad");const c=Mv(a.shape,o,i,1,u,l),d=function(e,t){const n=Wy(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*s-p;let v=y;for(;v<0;)v+=o;const x=Math.min(t.inDepth,l+y);for(let s=0;s<t.outHeight;++s){const l=s*r-h;let p=l;for(;p<0;)p+=i;const w=Math.min(t.inHeight,c+l);for(let r=0;r<t.outWidth;++r){const h=r*a-f;let k=h;for(;k<0;)k+=u;const C=Math.min(t.inWidth,d+h);let I=Number.NEGATIVE_INFINITY,_=-1;for(let t=v;t<x;t+=o){const n=t-y;for(let s=p;s<w;s+=i){const r=s-l;for(let a=k;a<C;a+=u){const o=a-h,i=e.get(m,t,s,a,g);i>=I&&(I=i,_=n*c*d+r*c+o)}}}n.set(_,m,b,s,r,g)}}}return n}(n.bufferSync(a),c),p=c.strideDepth,h=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,y=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=y-1-c.padInfo.front,k=x-1-c.padInfo.left,C=v-1-c.padInfo.top,I=Wy(a.shape,"float32"),_=n.bufferSync(r);for(let S=0;S<c.batchSize;++S)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=t-w,a=n-C,o=s-k;let i=0;for(let t=0;t<y;t+=m){const n=(r+t)/p;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let s=0;s<v;s+=g){const r=(a+s)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let a=0;a<x;a+=b){const u=(o+a)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const l=y*v*x-1-d.get(S,n,r,u,e)===t*v*x+s*x+a?1:0;0!==l&&(i+=_.get(S,n,r,u,e)*l)}}}I.set(i,S,t,n,s,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},Tq={kernelName:jm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a,output:o}=t,i=a;DR([a,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=s,p=zv(i.shape,u,l,1,c,d),h=n.data.get(i.dataId).values,f=Wy(p.outShape,i.dtype,GF(h,i.shape,i.dtype,p).values),m=p.strideHeight,g=p.strideWidth,b=p.dilationHeight,y=p.dilationWidth,v=p.effectiveFilterHeight,x=p.effectiveFilterWidth,w=x-1-p.padInfo.left,k=v-1-p.padInfo.top,C=Wy(i.shape,"float32"),I=n.data.get(r.dataId).values,_=Wy(r.shape,"float32",I);for(let S=0;S<p.batchSize;++S)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){const s=t-k,r=n-w;let a=0;for(let t=0;t<v;t+=b){const n=(s+t)/m;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let s=0;s<x;s+=y){const o=(r+s)/g;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;const i=v*x-1-f.get(S,n,o,e)===t*x+s?1:0;0!==i&&(a+=_.get(S,n,o,e)*i)}}C.set(a,S,t,n,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},Aq={kernelName:Um,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=t,u=n;DR(s,"MaxPoolWithArgmax");const l=u.data.get(s.dataId).values,c=zv(s.shape,r,a,[1,1],o),[d,p]=function(e,t,n,s,r){const a=UF(e,0,n,Hh(t),r,"max"),o=GF(e,t,n,r,!0,s);return[a.values,o.values]}(l,s.shape,s.dtype,i,c),h=u.write(d,c.outShape,s.dtype),f=u.write(p,c.outShape,s.dtype);return[{dataId:h,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},Rq={kernelName:Gm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s,i=Oh(a,r.shape),u=Nh(Kx(r.shape,i)[1]),l=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));l.push(c);const d=iF({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(d);const p=mO({inputs:{a:d,b:c},backend:n});l.push(p);const h=UD({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:o}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},Fq={kernelName:Hm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;DR(r,"min");const i=Oh(a,r.shape);let u=i;const l=Yx(u,r.shape.length);let c=r;null!=l&&(c=NF({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Jx(u.length,r.shape.length)),Zx("min",u,c.shape.length);const[d,p]=Kx(c.shape,u),h=Nh(p),f=Yh(Nh(d),c.dtype),m=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*h;let t=m[e];for(let n=0;n<h;++n){const s=m[e+n];s<t&&(t=s)}f[b]=t}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(o){const e=mF({inputs:{x:g},backend:n,attrs:{shape:Xx(d,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},Dq=UR((e,t)=>Math.min(e,t)),Oq=lF(Km,Dq),qq={kernelName:Km,backendName:"cpu",kernelFunc:Oq},zq={kernelName:Xm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,mode:o}=s;DR(r,"mirrorPad");const i=a.map((e,t)=>e[0]+r.shape[t]+e[1]),u=a.map(e=>e[0]),l=a.map((e,t)=>e[0]+r.shape[t]),c="reflect"===o?0:1,d=n.data.get(r.dataId).values,p=r.shape.length,h=Hh(r.shape),f=Nh(i),m=i.length,g=Hh(i),b=zh(r.dtype,f);for(let y=0;y<f;y++){let e=tf(y,m,g);for(let n=0;n<m;n++)e[n]<u[n]?e[n]=2*u[n]-e[n]-c:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+c);e=e.map((e,t)=>e-u[t]);const t=ef(e,p,h);b[y]=d[t]}return{dataId:n.write(b,i,r.dtype),shape:i,dtype:r.dtype}}},Mq=UR((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Lq=lF(Zm,Mq),Pq={kernelName:Zm,backendName:"cpu",kernelFunc:Lq};function Vq(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:a}=s,o=r.shape.length;let i=a;if(-1===i&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const u=Oh([i],r.shape),l=kq({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=Xx(l.shape,u),d=mF({inputs:{x:l},backend:n,attrs:{shape:c}}),p=vO({inputs:{a:r,b:d},backend:n}),h=iO({inputs:{x:p},backend:n}),f=UD({inputs:{x:h},backend:n,attrs:{axis:u,keepDims:!1}}),m=mF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=mO({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const jq={kernelName:zg,backendName:"cpu",kernelFunc:Vq},Bq={kernelName:Ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:a,seed:o,normalized:i}=s;DR(r,"multinomial");const u=i?r:Vq({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],d=n.data.get(u.dataId).values,p=[l,a],h=Yh(Nh(p),"int32");for(let f=0;f<l;++f){const e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+d[e+r];const n=cw.alea(o.toString()),s=f*a;for(let r=0;r<a;++r){const e=n();h[s+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){h[s+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(p,"int32",h)}};function Wq(e,t,n){const s=fb(-1,n);return VD([],t,s,e,n)}const Uq={kernelName:Jm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;DR(s,"neg");const r=n.data.get(s.dataId).values,[a,o]=Wq(r,s.shape,s.dtype);return n.makeTensorInfo(o,s.dtype,a)}},Gq=dk,Hq={kernelName:tg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=s;DR(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=Gq(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Kq=pk,Xq={kernelName:ng,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=s;DR(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:p,validOutputs:h}=Kq(c,d,o,i,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},Zq=hk,Yq={kernelName:sg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=s;DR(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,d=n.data.get(a.dataId).values,p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:b}=Zq(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},Qq=UR((e,t)=>e!==t?1:0),Jq=lF(eg,Qq,null,"bool"),ez={kernelName:eg,backendName:"cpu",kernelFunc:Jq},tz={kernelName:ag,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{depth:a,onValue:o,offValue:i}=s;DR(r,"oneHot");const u=Nh(r.shape),l=new Float32Array(u*a);l.fill(i);const c=n.data.get(r.dataId).values;for(let d=0;d<u;++d)c[d]>=0&&c[d]<a&&(l[d*a+c[d]]=o);return n.makeTensorInfo([...r.shape,a],"int32",l)}};function nz(e){const{inputs:t,backend:n}=e,{x:s}=t;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const e=aF({inputs:{input:s},backend:n}),t=nz({inputs:{x:e},backend:n}),r=fD({inputs:{input:s},backend:n}),a=nz({inputs:{x:r},backend:n}),o=nF({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}return _O({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const sz={kernelName:eb,backendName:"cpu",kernelFunc:nz},rz={kernelName:rg,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:s}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=aF({inputs:{input:r},backend:s}),n=e({inputs:{x:t},backend:s}),a=fD({inputs:{input:r},backend:s}),o=nz({inputs:{x:a},backend:s}),i=nF({inputs:{real:n,imag:o},backend:s});return s.disposeIntermediateTensorInfo(t),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(o),i}return _O({backend:s,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function az(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return lO({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const a=t[0].shape,o=t[0].dtype;t.forEach(e=>{_h(a,e.shape,"All tensors passed to stack must have matching shapes"),Ih(o===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=gD({inputs:t.map(e=>{const t=lO({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t}),backend:n,attrs:{axis:r}});return i.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}const oz={kernelName:og,backendName:"cpu",kernelFunc:az},iz={kernelName:ig,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,constantValue:o}=s;DR(r,"pad");const i=a.map((e,t)=>e[0]+r.shape[t]+e[1]),u=a.map(e=>e[0]),l=n.data.get(r.dataId).values,c=Nh(r.shape),d=r.shape.length,p=Hh(r.shape),h=Nh(i),f=i.length,m=Hh(i),g=zh(r.dtype,h);0!==o&&g.fill(o);for(let b=0;b<c;b++)g[ef(tf(b,d,p).map((e,t)=>e+u[t]),f,m)]=l[b];return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},uz=UR((e,t)=>Math.pow(e,t)),lz=lF(ug,uz),cz={kernelName:ug,backendName:"cpu",kernelFunc:lz};function dz(e,t,n,s){const[r,a]=Kx(e,s),o=Pb(t,"int32"),i=Yh(Nh(r),o),u=Nh(a);for(let l=0;l<i.length;++l){const e=l*u;let t=1;for(let s=0;s<u;++s)t*=n[e+s];i[l]=t}return{outVals:i,outShape:r,outDtype:o}}const pz={kernelName:cg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;DR(r,"prod");const i=r.shape.length,u=Oh(a,r.shape),l=Yx(u,i);let c=u,d=r;const p=[];null!=l&&(d=NF({inputs:{x:r},backend:n,attrs:{perm:l}}),p.push(d),c=Jx(c.length,i));const h=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=dz(d.shape,d.dtype,h,c);let b=m;return o&&(b=Xx(m,u)),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(b,g,f)}};function hz(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return Yh(0,s);const r=Yh(Math.abs(Math.ceil((t-e)/n)),s);t<e&&1===n&&(n=-1),r[0]=e;for(let a=1;a<r.length;a++)r[a]=r[a-1]+n;return r}const fz={kernelName:dg,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,dtype:a,step:o}=n,i=hz(s,r,o,a);return t.makeTensorInfo([i.length],a,i)}},mz=zR(hg,e=>1/e),gz={kernelName:hg,backendName:"cpu",kernelFunc:mz},bz={kernelName:yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s;DR(r,"resizeBilinear");const u=Hh(r.shape),[l,c]=i,[d,p,h,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(Nh([d,l,c,f])),b=[a&&l>1?p-1:p,a&&c>1?h-1:h],y=[a&&l>1?l-1:l,a&&c>1?c-1:c];let v=0;const x=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<d;k++)for(let e=0;e<l;e++){let t;t=o?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),s=t-n,r=Math.min(p-1,Math.ceil(t)),a=k*u[0]+n*u[1],i=k*u[0]+r*u[1];for(let e=0;e<c;e++){let t;t=o?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(h-1,Math.ceil(t)),c=a+n*u[2],d=i+n*u[2],p=a+l*u[2],b=i+l*u[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],a=t+(m[p+e]-t)*r;g[v++]=a+(n+(m[b+e]-n)*r-a)*s}}}return n.makeTensorInfo([d,l,c,f],"float32",g)}},yz={kernelName:vg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:o}=s;DR([a,r],"resizeBilinearGrad");const i=Hh(r.shape),[u,l,c,d]=r.shape,[,p,h]=a.shape,f=new Float32Array(u*l*c*d),m=[o&&p>1?l-1:l,o&&h>1?c-1:c],g=[o&&p>1?p-1:p,o&&h>1?h-1:h],b=m[0]/g[0],y=m[1]/g[1],v=n.data.get(a.dataId).values;let x=0;for(let w=0;w<u;w++){const e=w*i[0];for(let t=0;t<p;t++){const n=t*b,s=Math.floor(n),r=Math.min(Math.ceil(n),l-1),a=e+s*i[1],o=e+r*i[1],u=n-s,p=1-u;for(let e=0;e<h;e++){const t=e*y,n=Math.floor(t),s=Math.min(Math.ceil(t),c-1),r=t-n,l=1-r,h=a+n*i[2],m=a+s*i[2],g=o+n*i[2],b=o+s*i[2],w=p*l,k=p*r,C=u*l,I=u*r;for(let e=0;e<d;e++){const t=v[x++];f[h+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*C,f[b+e]+=t*I}}}}return n.makeTensorInfo([u,c,l,d],"float32",f)}},vz={kernelName:gg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s;DR(r,"resizeNearestNeighbor");const u=Hh(r.shape),[l,c]=i,[d,p,h,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(d*l*c*f),b=[a&&l>1?p-1:p,a&&c>1?h-1:h],y=[a&&l>1?l-1:l,a&&c>1?c-1:c],v=b[0]/y[0],x=b[1]/y[1];let w=0;for(let k=0;k<d;k++){const e=k*u[0];for(let t=0;t<l;t++){const n=o?v*(t+.5):v*t;let s=Math.min(p-1,a?Math.round(n):Math.floor(n));o&&(s=Math.max(0,s));const r=e+s*u[1];for(let e=0;e<c;e++){const t=o?x*(e+.5):x*e;let n=Math.min(h-1,a?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));const s=r+n*u[2];for(let e=0;e<f;e++)g[w++]=m[s+e]}}}return n.makeTensorInfo([d,l,c,f],r.dtype,g)}},xz={kernelName:bg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:o}=s;DR([a,r],"resizeNearestNeighborGrad");const i=Hh(r.shape),u=Hh(a.shape),[l,c,d,p]=r.shape,[,h,f]=a.shape,m=new Float32Array(l*c*d*p),g=n.data.get(a.dataId).values,b=[o&&h>1?c-1:c,o&&f>1?d-1:d],y=[o&&h>1?h-1:h,o&&f>1?f-1:f],v=b[0]/y[0],x=b[1]/y[1],w=1/v,k=1/x,C=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let _=0;_<l;_++){const e=_*i[0];for(let t=0;t<c;t++){const n=e+t*i[1],s=Math.floor(t*w),r=Math.floor(s-C/2);for(let a=0;a<d;a++){const s=n+a*i[2],l=Math.floor(a*k),b=Math.floor(l-I/2);for(let n=0;n<p;n++){let i=0;for(let s=0;s<C;s++){const l=s+r;if(l<0||l>=h)continue;const p=e+l*u[1],m=l*v;if(t===Math.min(c-1,o?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+b;if(t<0||t>=f)continue;const s=p+t*u[2],r=t*x;a===Math.min(d-1,o?Math.round(r):Math.floor(r))&&(i+=g[s+n])}}m[s+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}},wz={kernelName:wg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:a}=s;DR(r,"reverse");const o=r.shape.length,i=Oh(a,r.shape);if(0===o)return VR({inputs:{x:r},backend:n});const u=new Eb(r.shape,r.dtype),l=n.bufferSync(r);for(let c=0;c<u.size;c++){const e=u.indexToLoc(c),t=e.slice();i.forEach(e=>t[e]=r.shape[e]-1-t[e]),u.set(l.get(...t),...e)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},kz={kernelName:nb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:r,fillValue:a,center:o}=t,i=n,u=zh(s.dtype,Nh(s.shape)),[l,c,d,p]=s.shape,[h,f]=Qk(o,c,d),m=Math.sin(r),g=Math.cos(r),b=i.data.get(s.dataId).values;for(let y=0;y<l;y++){const e=y*d*c*p;for(let t=0;t<c;t++){const n=t*(d*p);for(let s=0;s<d;s++){const r=s*p;for(let o=0;o<p;o++){const i=[l,t,s,o],y=i[2],v=i[1];let x=(y-h)*g-(v-f)*m,w=(y-h)*m+(v-f)*g;x=Math.round(x+h),w=Math.round(w+f);let k=a;"number"!=typeof a&&(k=3===o?255:a[o]),x>=0&&x<d&&w>=0&&w<c&&(k=b[e+w*(d*p)+x*p+o]),u[e+n+r+o]=k}}}}return{dataId:i.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Cz=zR(kg,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),Iz={kernelName:kg,backendName:"cpu",kernelFunc:Cz},_z=oD(e=>1/Math.sqrt(e)),Sz=MR(Cg,_z),Ez={kernelName:Cg,backendName:"cpu",kernelFunc:Sz};function Nz(e,t,n,s,r,a,o,i,u,l){const c=[s/r,r],d=e.values,p=t.values;if(0===s)return Wy(n,t.dtype);const h=Wy(c,t.dtype);h.values.fill(u);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<o;t++){const n=d[f*o+t];e.push(n),a+=n*i[t]}if(a<0||a>=s/r)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<r;n++)l?h.values[a*r+n]+=p[f*r+n]:h.values[a*r+n]=0===t.rank?p[0]:p[f*r+n]}return h}const $z={kernelName:Ig,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:a}=t,{shape:o}=s,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=iC(0,r,o),p=Nz(n.bufferSync(r),n.bufferSync(a),o,d,l,u,i,c,0,!0);return n.makeTensorInfo(o,p.dtype,p.values)}},Tz={kernelName:_g,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:a}=t;DR([s,r,a],"select");const o=s.shape.length,i=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=Pb(r.dtype,a.dtype),d=Yh(Nh(r.shape),c);let p=0;const h=0===o||o>1||1===r.shape.length?1:Nh(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<h;e++)d[p++]=1===i[f]?u[f]:l[f];return n.makeTensorInfo(r.shape,c,d)}},Az=uC,Rz=lC,Fz=zR(Sg,e=>e>=0?Rz*e:Az*(Math.exp(e)-1)),Dz={kernelName:Sg,backendName:"cpu",kernelFunc:Fz},Oz=zR(Tg,e=>e<0?-1:e>0?1:0),qz={kernelName:Tg,backendName:"cpu",kernelFunc:Oz},zz=zR(Ng,e=>Math.sin(e)),Mz={kernelName:Ng,backendName:"cpu",kernelFunc:zz},Lz=zR($g,e=>Math.sinh(e)),Pz={kernelName:$g,backendName:"cpu",kernelFunc:Lz},Vz=Math.log(1.1920928955078125e-7)+2,jz=zR(Rg,e=>{const t=e>-Vz,n=e<Vz,s=Math.exp(e);let r;return r=n?s:t?e:Math.log(1+s),r}),Bz={kernelName:Rg,backendName:"cpu",kernelFunc:jz},Wz={kernelName:Og,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,paddings:o}=s;DR([r],"spaceToBatchND");const i=Nh(a),u=[[0,0]];u.push(...o);for(let g=1+a.length;g<r.shape.length;++g)u.push([0,0]);const l=iz.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=Jk(l.shape,a,i,!1),d=eC(c.length,a.length,!1),p=tC(l.shape,a,i,!1),h=mF({inputs:{x:l},backend:n,attrs:{shape:c}}),f=NF({inputs:{x:h},backend:n,attrs:{perm:d}}),m=mF({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}};function Uz(e,t,n,s,r,a,o){const i=t[0],u=a[0],l=new Array(u),c=new Array(i),d=t[1];if(0===u){if(0!==i)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${i}`);return[Mh(n,0),[0,d],Mh(r,0),l,c]}let p=!0,h=0;const f=new Array(u).fill(0);for(let g=0;g<i;++g){const t=e[g*d];if(t<0)throw new Error(`indices(${g}, 0) is invalid: ${t} < 0`);if(t>=u)throw new Error(`indices(${g}, 0) is invalid: ${t} >= ${u}`);++f[t],p=p&&t>=h,h=t}let m=!0;for(let g=0;g<u;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&p){const t=e,n=s;for(let e=0;e<i;++e)c[e]=e;return[t,[i,d],n,l,c]}{const t=f[u-1],a=Mh(n,t*d),p=Mh(r,t),h=new Array(u).fill(0);for(let n=0;n<i;++n){const t=e[n*d],r=(0===t?0:f[t-1])+h[t];h[t]++;for(let s=0;s<d;++s)a[r*d+s]=e[n*d+s];p[r]=s[n],c[n]=r}for(let e=0;e<u;++e)if(0===h[e]){const t=0===e?0:f[e-1];a[t*d+0]=e;for(let e=1;e<d;++e)a[t*d+e]=0;p[t]=o}return[a,[i,d],p,l,c]}}const Gz={kernelName:Mg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:a,defaultValue:o}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values[0],[d,p,h,f,m]=Uz(i,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(p,s.dtype,d),n.makeTensorInfo([p[0]],r.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}};function Hz(e,t,n,s,r){const a=Nh(s),o=t[0],i=r.length,u=[];let l=1,c=-1;for(let g=0;g<i;++g){const e=r[g];if(-1===e){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,u.push(1)}else{if(e<0)throw new Error(`size ${g} must be non-negative, not ${e}`);l*=e,u.push(e)}}if(-1!==c){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/l);if(l*e!==a)throw new Error(`Input to reshape is a SparseTensor with ${a}\n          dense values, but the requested shape requires a multiple of ${l}. inputShape=${s} outputShape= ${u}`);u[c]=e}const d=Nh(u);if(d!==a)throw new Error(`Input to reshape is a tensor with ${a} dense values, but the requested shape has ${d}. inputShape=${s} outputShape=${u}`);const p=s.length,h=[];if(p>0){h[p-1]=1;for(let e=p-2;e>=0;--e)h[e]=h[e+1]*s[e+1]}const f=[];if(i>0){f[i-1]=1;for(let e=i-2;e>=0;--e)f[e]=f[e+1]*u[e+1]}const m=Mh(n,o*i);for(let g=0;g<o;++g){let t=0;for(let n=0;n<p;++n)t+=e[g*p+n]*h[n];for(let e=0;e<i;++e)m[g*i+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[o,i],u]}const Kz={kernelName:Lg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(n.data.get(r.dataId).values),i=n.data.get(s.dataId).values,u=Array.from(n.data.get(a.dataId).values),[l,c,d]=Hz(i,s.shape,s.dtype,o,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}},Xz={kernelName:Pg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:a,defaultValue:o}=t,{outputShape:i}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=iC(0,r,i),h=Nz(n.bufferSync(r),n.bufferSync(a),i,p,c,l,u,d,n.data.get(o.dataId).values[0],!1);return n.makeTensorInfo(i,h.dtype,h.values)}},Zz={kernelName:qg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:a,axis:o}=s,i=Oh(o,r.shape)[0],u=FC(r,a,i),l=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(e=>{const t=[...c];t[i]=e;const s=eD({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,s})}},Yz=zR(Fg,e=>Math.sqrt(e)),Qz={kernelName:Fg,backendName:"cpu",kernelFunc:Yz},Jz={kernelName:jg,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,s=t;DR(n,"square");const r=s.data.get(n.dataId).values,a=new Float32Array(r.length);for(let o=0;o<r.length;++o){const e=r[o];a[o]=e*e}return{dataId:s.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},eM=UR((e,t)=>{const n=e-t;return n*n}),tM=lF(Vg,eM),nM={kernelName:Vg,backendName:"cpu",kernelFunc:tM},sM=zR(tb,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),rM={kernelName:tb,backendName:"cpu",kernelFunc:sM};function aM(e,t,n,s){const r=Wy(e,t.dtype);for(let a=0;a<r.size;a++){const e=r.indexToLoc(a),o=new Array(e.length);for(let t=0;t<o.length;t++)o[t]=e[t]*n[t]+s[t];r.set(t.get(...o),...e)}return r}const oM={kernelName:Bg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=s;DR(r,"stridedSlice");const{nonStrided:h,$begin:f,$strides:m,size:g,newShape:b,outShape:y}=yv(r.shape,a,o,i,u,l,c,d,p),v=mF({inputs:{x:r},backend:n,attrs:{shape:b}});let x;if(h){const e=eD({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});x=mF({inputs:{x:e},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(e)}else if(y.some(e=>0===e))x=n.makeTensorInfo(y,r.dtype,[]);else{const e=aM(y,n.bufferSync(v),m,f);x=n.makeTensorInfo(e.shape,e.dtype,e.values)}const w=mF({inputs:{x:x},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),w}},iM=zR(Ug,e=>Math.tan(e)),uM={kernelName:Ug,backendName:"cpu",kernelFunc:iM},lM=zR(Gg,e=>Math.tanh(e));function cM(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const s=Wy(n,e.dtype);for(let r=0;r<s.values.length;++r){const t=s.indexToLoc(r),n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=t[s]%e.shape[s];const a=e.locToIndex(n);s.values[r]=e.values[a]}return s}function dM(e,t,n,s,r){const a=t[t.length-1],[o,i]=[e.length/a,a],u=zh(n,o*s),l=zh("int32",o*s);for(let d=0;d<o;d++){const t=d*i,n=e.subarray(t,t+i),r=[];for(let e=0;e<n.length;e++)r.push({value:n[e],index:e});r.sort((e,t)=>t.value-e.value);const a=d*s,o=u.subarray(a,a+s),c=l.subarray(a,a+s);for(let e=0;e<s;e++)o[e]=r[e].value,c[e]=r[e].index}const c=t.slice();return c[c.length-1]=s,[Wy(c,n,u),Wy(c,"int32",l)]}function pM(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return kh(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;return n<0?t<=1?n=0:n+=t*(Math.trunc(-n/(t-1))+1):n>t-1&&(t<=1?n=0:n-=t*Math.trunc(n/(t-1))),kh(0,n,t-1)}(e,t);case"nearest":return function(e,t){return kh(0,e,t-1)}(e,t);case"constant":default:return function(e,t){return e}(e)}}function hM(e,t,n,s,r,a,o,i,u,l,c){return 0<=i&&i<t&&0<=u&&u<n?e[o*s+i*r+u*a+l]:c}function fM(e,t,n,s,r,a,o,i,u,l,c){return hM(e,t,n,s,r,a,o,Math.round(i),Math.round(u),l,c)}function mM(e,t,n,s,r,a,o,i,u,l,c){const d=Math.floor(i),p=Math.floor(u),h=d+1,f=p+1;return(h-i)*((f-u)*hM(e,t,n,s,r,a,o,d,p,l,c)+(u-p)*hM(e,t,n,s,r,a,o,d,f,l,c))+(i-d)*((f-u)*hM(e,t,n,s,r,a,o,h,p,l,c)+(u-p)*hM(e,t,n,s,r,a,o,h,f,l,c))}function gM(e,t,n,s){const r=Oh(t,n)[0],a=[1,n[0],1];for(let f=0;f<r;f++)a[0]*=n[f];a[1]=n[r];for(let f=r+1;f<n.length;f++)a[2]*=n[f];const o={},i=new Int32Array(n[r]),u=new Eb(a,s,e),l=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[r];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(u.get(t,f,n));t=e.join(",")}if(void 0!==o[t])i[f]=o[t];else{const e=Object.keys(o).length;o[t]=e,i[f]=e,l.push(f)}}const d=a.slice();d[1]=Object.keys(o).length;const p=new Eb(d,s);l.forEach((e,t)=>{for(let n=0;n<a[0];n++)for(let s=0;s<a[2];s++)p.set(u.get(n,e,s),n,t,s)});const h=n.slice();return h[r]=d[1],{outputValues:p.values,outputShape:h,indices:i}}const bM=[vF,wF,CF,_F,fF,SF,TF,AF,RF,FF,OF,zF,LF,jF,WF,KF,XF,ZF,YF,yF,QF,nD,aD,uF,lD,dD,sF,pD,bD,xD,wD,vD,CD,ID,kD,SD,ND,$D,TD,AD,RD,DD,OD,qD,zD,MD,PD,LD,gO,HD,PR,KD,YD,aO,uO,cO,hO,IO,SO,EO,TO,FO,DO,OO,qO,MO,VO,WO,jR,UO,mD,HO,XO,YO,WR,eq,sq,aq,uq,cq,hq,mq,yq,vq,xq,Sq,Eq,Nq,$q,Tq,Aq,Cq,Rq,Fq,qq,zq,Pq,Bq,WD,Uq,Hq,Xq,Yq,ez,tz,rz,oz,iz,cz,KR,pz,fz,oF,gz,ZR,QR,gF,bz,yz,vz,xz,wz,kz,Iz,Ez,$z,Tz,Dz,eF,qz,Mz,Pz,tD,jq,Bz,Wz,Gz,Kz,Xz,Zz,Qz,Jz,nM,rM,oM,xO,GD,uM,{kernelName:Gg,backendName:"cpu",kernelFunc:lM},{kernelName:Hg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:a}=s;DR(r,"tile");const o=cM(n.bufferSync(r),a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:Kg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:a}=s;DR(r,"topk");const o=n.data.get(r.dataId).values,[i,u]=dM(o,r.shape,r.dtype,a);return[n.makeTensorInfo(i.shape,i.dtype,i.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},$F,{kernelName:Xg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{image:r,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=n,[c,d,p,h]=r.shape,[f,m]=null!=l?l:[d,p],g=[c,f,m,h],b=Hh(r.shape),y=b[0],v=b[1],x=b[2],w=zh(r.dtype,Nh(g));w.fill(u);const k=s.data.get(r.dataId).values,C=s.data.get(a.dataId).values;for(let I=0;I<c;++I){const e=1===a.shape[0]?C:C.subarray(8*I,8*I+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let s=0;s<h;++s){let r;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const l=(e[3]*n+e[4]*t+e[5])/a,c=pM((e[0]*n+e[1]*t+e[2])/a,p,i),h=pM(l,d,i);switch(o){case"nearest":r=fM(k,d,p,y,v,x,I,h,c,s,u);break;case"bilinear":r=mM(k,d,p,y,v,x,I,h,c,s,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}w[I*y+t*v+n*x+s]=r}return s.makeTensorInfo(g,r.dtype,w)}return{dataId:s.write(w,g,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:Yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:a}=t;DR(a,"unique");const o=s.data.get(a.dataId).values,{outputValues:i,outputShape:u,indices:l}=gM(o,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,i),s.makeTensorInfo([l.length],"int32",l)]}},{kernelName:Qg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const o=r.shape.length,i=r.shape[a],u=new Array(o-1);let l=0;for(let h=0;h<o;h++)h!==a&&(u[l++]=r.shape[h]);const c=new Array(o).fill(0),d=r.shape.slice();d[a]=1;const p=new Array(i);for(let h=0;h<p.length;h++){c[a]=h;const e=eD({inputs:{x:r},backend:n,attrs:{begin:c,size:d}});p[h]=mF({inputs:{x:e},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(e)}return p}},{kernelName:Jg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:a}=t,{numSegments:o}=s;DR(r,"unsortedSegmentSum");const i=[],u=[],l=r.shape.length-a.shape.length;let c=a;for(let p=0;p<l;++p){const e=lO({inputs:{input:c},backend:n,attrs:{dim:p+1}});c=e,u.push(e)}for(let p=0;p<o;++p){const e=fb(p,"int32"),t=n.makeTensorInfo([],"int32",e),s=ZD({inputs:{a:t,b:c},backend:n}),a=iF({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),o=BD({inputs:{a:a,b:r},backend:n}),l=UD({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),u.push(t),u.push(s),u.push(a),u.push(o),u.push(l)}const d=az({inputs:i,backend:n,attrs:{axis:0}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},sz];for(const iK of bM)db(iK);const yM={},vM={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function xM(e){if(!(e in yM)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete yM[e]},!1),1===e?t.getContext("webgl",vM)||t.getContext("experimental-webgl",vM):t.getContext("webgl2",vM)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;yM[e]=t}const t=yM[e];return t.isContextLost()?(delete yM[e],xM(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),yM[e])}var wM,kM,CM;function IM(e,t){return[t,e]}function _M(e){const t=Nh(e);return Ah(Math.ceil(t/4))}function SM(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function EM(e,t){const n=e;let s,r,a,o,i,u,l,c,d,p;return 2===af().getNumber("WEBGL_VERSION")?(s=n.R32F,r=n.R16F,a=n.RGBA16F,o=n.RGBA32F,i=n.RED,l=4,c=1,d=n.HALF_FLOAT,p=n.FLOAT):(s=e.RGBA,r=e.RGBA,a=e.RGBA,o=n.RGBA,i=e.RGBA,l=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT),u=e.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:p}}function NM(e,t){const n=t();return af().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function $M(e){return!!(af().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function TM(e,t){return zM(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(wM||(wM={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(kM||(kM={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(CM||(CM={}));const AM=/ERROR: [0-9]+:([0-9]+):/g;function RM(e,t){if(NM(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FM(e,t,n,s,r,a,o){const i=e.getAttribLocation(t,n);return-1!==i&&(NM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,s)),NM(e,()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,a,o)),NM(e,()=>e.enableVertexAttribArray(i)),!0)}function DM(e,t,n){NM(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),NM(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function OM(e,t){NM(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),NM(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function qM(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function zM(e,t,n){const s=NM(e,()=>t());if(null==s)throw new Error(n);return s}function MM(e,t=2){return Nh(e.slice(0,e.length-t))}function LM(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function PM(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[MM(e),...LM(e)]),t}function VM(e){return e%2==0}function jM(e,t){if($h(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],s=t.slice(-1)[0];if(n===s)return!0;if(VM(n)&&VM(s)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&VM(e[0])&&VM(t[0])}let BM,WM;function UM(e,t){return null!=e.getExtension(t)}function GM(e){try{if(null!=xM(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function HM(e){const t=EM(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),r}function KM(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Ih("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const XM=af();function ZM(){let e,t,n,s,r,a,o,i,u,l;return 2===af().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",s="in",r="texture",a="outputColor",o="out vec4 outputColor;",i="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",s="varying",r="texture2D",a="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:s,texture2D:r,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function YM(e,t,n="index"){const s=Hh(t);return s.map((t,r)=>`int ${e[r]} = ${n} / ${t}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${t}`:`index -= ${e[r]} * ${t}`};`).join("")}function QM(e){const t=Hh(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}XM.registerFlag("HAS_WEBGL",()=>XM.getNumber("WEBGL_VERSION")>0),XM.registerFlag("WEBGL_VERSION",()=>GM(2)?2:GM(1)?1:0),XM.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),XM.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===XM.get("WEBGL_VERSION")),XM.registerFlag("WEBGL_CPU_FORWARD",()=>!0),XM.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),XM.registerFlag("WEBGL_PACK",()=>XM.getBool("HAS_WEBGL")),XM.registerFlag("WEBGL_PACK_NORMALIZATION",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_PACK_CLIP",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_PACK_REDUCE",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_LAZILY_UNPACK",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_CONV_IM2COL",()=>XM.getBool("WEBGL_PACK")),XM.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==BM){const t=xM(e);BM=t.getParameter(t.MAX_TEXTURE_SIZE)}return BM}(XM.getNumber("WEBGL_VERSION"))),XM.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==WM){const t=xM(e);WM=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,WM)}(XM.getNumber("WEBGL_VERSION"))),XM.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=XM.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=xM(e);return t=UM(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:UM(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),XM.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>XM.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Qb()),XM.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=xM(e);if(1===e){if(!UM(t,"OES_texture_float"))return!1}else if(!UM(t,"EXT_color_buffer_float"))return!1;return HM(t)}(XM.getNumber("WEBGL_VERSION"))),XM.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!XM.getBool("WEBGL_FORCE_F16_TEXTURES")&&XM.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),XM.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(e){if(0===e)return!1;const t=xM(e);if(1!==e){if(UM(t,"EXT_color_buffer_float"))return HM(t);const e="EXT_color_buffer_half_float";if(UM(t,e)){const n=t.getExtension(e);return function(e,t){const n=EM(e,t),s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(s),e.deleteFramebuffer(r),a}(t,n)}return!1}return!!UM(t,"OES_texture_float")&&!!UM(t,"WEBGL_color_buffer_float")&&HM(t)}(XM.getNumber("WEBGL_VERSION"))),XM.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=XM.getNumber("WEBGL_VERSION"))&&null!=xM(e).fenceSync;var e}),XM.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>XM.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),XM.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),XM.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Qb()&&XM.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});const JM="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class eL{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=wM.DENSE;const t=_M(e),n=ZM();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${YM(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class tL{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=wM.DENSE;const t=_M(e),n=ZM();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${YM(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class nL{constructor(e){this.variableNames=["A"],this.outTexUsage=kM.DOWNLOAD;const t=ZM();this.outputShape=e,this.userCode=`\n      ${JM}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class sL{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=kM.DOWNLOAD;const t=ZM();this.outputShape=e,this.userCode=`\n      ${JM}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class rL{constructor(e,t,n=!1){this.variableNames=["A"];const s=ZM(),[r,a]=t;this.outputShape=e;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${QM(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${a};\n        int c = imod(flatIndex, ${a});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${r}.0);\n        vec4 values = ${s.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class aL{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const s=ZM(),[r,a]=t;this.outputShape=e;let o="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let t=0;t<=1;t++){const n=2*u+t;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${e[2]}) {\n            localCoords[2] += ${t};\n            if(localCoords[1] + ${u} < ${e[1]}) {\n              localCoords[1] += ${u};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${a};\n              c = imod(flatIndex, ${a});\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${r}.0);\n              values = ${s.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${QM(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${s.output} = ${i};\n      }\n    `}}function oL(e,t,n,s,r,a){!function(e,t){const n=af().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const o=function(e){return zM(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return NM(e,()=>e.bindTexture(i,o)),NM(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),NM(e,()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),NM(e,()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)),NM(e,()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)),NM(e,()=>e.texImage2D(i,0,s,t,n,0,r,a,null)),NM(e,()=>e.bindTexture(e.TEXTURE_2D,null)),o}function iL(e){return e.internalFormatFloat}function uL(e){return e.internalFormatHalfFloat}function lL(e){return e.downloadTextureFormat}function cL(e){return e.internalFormatPackedFloat}function dL(e){return e.internalFormatPackedHalfFloat}class pL{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=af().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){yM[e]=t}(t,e)):this.gl=xM(t);let n="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(1===af().getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=TM(this.gl,"OES_texture_float"),UM(this.gl,e))this.textureHalfFloatExtension=TM(this.gl,e);else if(af().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),UM(this.gl,s))this.colorBufferHalfFloatExtension=TM(this.gl,s);else if(af().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",UM(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!UM(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function(e){return function(e,t){const n=zM(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return NM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),NM(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=zM(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return NM(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),NM(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return zM(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=EM(this.gl,this.textureHalfFloatExtension)}get debug(){return af().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;NM(e,()=>e.finish()),NM(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),NM(e,()=>e.deleteFramebuffer(this.framebuffer)),NM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),NM(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),NM(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=IM(t,n);return oL(e,r,a,iL(s),s.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=IM(t,n);return oL(e,r,a,uL(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=IM(t,n);return oL(e,r,a,lL(s),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){NM(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?NM(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):NM(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),NM(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,s){this.throwIfDisposed(),function(e,t,n,s,r,a){let o,i,u;NM(e,()=>e.bindTexture(e.TEXTURE_2D,t)),r instanceof Uint8Array?(o=new Uint8Array(n*s*4),i=e.UNSIGNED_BYTE,u=e.RGBA):(o=new Float32Array(n*s*4),i=e.FLOAT,u=a.internalFormatPackedFloat),o.set(r),NM(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,s,0,e.RGBA,i,o)),NM(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=SM(t,n);return oL(e,r,a,dL(s),e.RGBA,s.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,a]=SM(t,n);return oL(e,r,a,cL(s),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(OM(this.gl,this.framebuffer),this.outputTexture=null),NM(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,s){const[r,a]=IM(t,n),o=new Uint8Array(t*n*4);return NM(e,()=>e.readPixels(0,0,r,a,s.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,s,r,a){return function(e,t,n,s,r,a,o,i){const u=e,l=new Float32Array(function(e,t){const[n,s]=SM(e,t);return n*s*4}(a,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,r,a)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const s=e,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const s=function(e,t,n,s){const r=e.createBuffer();NM(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));const a=16*t*n;return NM(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),NM(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),NM(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}(this.gl,t,n);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(af().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,r=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=s.clientWaitSync(r,0,0);return e===s.ALREADY_SIGNALED||e===s.CONDITION_SATISFIED},t=r}else af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const s=new Float32Array(t*n*4);return NM(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,s)),s}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=zM(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(NM(e,()=>e.shaderSource(n,t)),NM(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=AM.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const s=+n[1],r=e.split("\n"),a=r.length.toString().length+2,o=r.map((e,t)=>Rh((t+1).toString(),a)+e);let i=0;for(let d=0;d<o.length;d++)i=Math.max(o[d].length,i);const u=o.slice(0,s-1),l=o.slice(s-1,s),c=o.slice(s);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Rh(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e);null==this.vertexShader&&(this.vertexShader=function(e){const t=ZM();return function(e,t){const n=zM(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(NM(e,()=>e.shaderSource(n,t)),NM(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const s=function(e){return zM(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return NM(t,()=>t.attachShader(s,this.vertexShader)),NM(t,()=>t.attachShader(s,n)),function(e,t){if(NM(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,s),this.debug&&RM(t,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(e,t,n){return NM(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),FM(e,t,"clipSpacePos",n,3,20,0)&&FM(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&NM(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&RM(this.gl,this.program),NM(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return zM(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),NM(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,s){NM(e,()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+e.TEXTURE0;if(s<e.TEXTURE0||s>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),NM(e,()=>e.activeTexture(e.TEXTURE0+n)),NM(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,s)),NM(e,()=>e.uniform1i(n,s))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[s,r]=SM(t,n);this.setOutputMatrixTextureDriver(e,s,r)}setOutputMatrixWriteRegion(e,t,n,s){this.setOutputMatrixWriteRegionDriver(n,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&RM(this.gl,this.program),qM(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),NM(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),NM(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=TM(this.gl,2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){var t=this;return bh(function*(){return yield Fh(()=>t.disposed||t.isQueryAvailable(e,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(e,af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||Fh(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),DM(this.gl,e,this.framebuffer),this.debug&&qM(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(DM(this.gl,this.outputTexture,this.framebuffer),this.debug&&qM(this.gl)):OM(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const s=this.gl;DM(s,e,this.framebuffer),this.debug&&qM(s),this.outputTexture=e,NM(s,()=>s.viewport(0,0,t,n)),NM(s,()=>s.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,s){this.throwIfDisposed(),NM(this.gl,()=>this.gl.scissor(e,t,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:hL}=a;function fL(e,t,n,s){const r=[];e.forEach(e=>{const t=Nh(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`))});const a=r.join("\n"),o=e.map(e=>function(e,t,n=!1){let s="";return s+=n?gL(e):mL(e),e.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=n?function(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=hL(e.shapeInfo.logicalShape,t.logicalShape),u=CL(o),l=o-a;let c;const d=["x","y","z","w","u","v"];c=0===a?"":o<2&&i.length>=1?"coords = 0;":i.map(e=>`coords.${d[e+l]} = 0;`).join("\n");let p="";p=o<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${d[t+l]}`).join(", ");let h="return outputValue;";const f=1===Nh(e.shapeInfo.logicalShape),m=1===Nh(t.logicalShape);if(1!==a||f||m){if(f&&!m)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=a-2,t=a-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?h="return vec4(outputValue.x);":i.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${p});\n      ${h}\n    }\n  `}(e,t):function(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",a=e.shapeInfo.logicalShape.length,o=t.logicalShape.length;if(!e.shapeInfo.isUniform&&a===o&&null==e.shapeInfo.flatOffset&&$h(e.shapeInfo.texShape,t.texShape))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const i=CL(o),u=hL(e.shapeInfo.logicalShape,t.logicalShape),l=o-a;let c;const d=["x","y","z","w","u","v"];c=0===a?"":o<2&&u.length>=1?"coords = 0;":u.map(e=>`coords.${d[e+l]} = 0;`).join("\n");let p="";return p=o<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${d[t+l]}`).join(", "),`\n    float ${r}() {\n      ${i} coords = getOutputCoords();\n      ${c}\n      return get${s}(${p});\n    }\n  `}(e,t)),s}(e,t,s)).join("\n"),i=t.texShape,u=ZM(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,d,p=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${bL}\n    ${yL}\n    ${vL}\n  `}(u);return t.isPacked?(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if($h(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),r=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),r=s*Math.ceil(e[e.length-2]/2);let a=r,o="",i="b, r, c";for(let u=2;u<e.length-1;u++)a*=e[e.length-u-1],o=`\n      int b${u} = index / ${a};\n      index -= b${u} * ${a};\n    `+o,i=`b${u}, `+i;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${r};\n      index -= b * ${r};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${i});\n    }\n  `}(e,t)}}(t.logicalShape,i),d=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return $h(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=YM(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=YM(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=YM(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=YM(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}var n}(t.logicalShape,i),d=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),s&&(p+=xL),[p,l,d,a,c,o,n].join("\n")}function mL(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[s,r]=e.shapeInfo.texShape;if(1===s&&1===r)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[a,o]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${a}, ${o}, ${wL(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${kL(e)}\n      }\n    `;const s=e.shapeInfo.texShape,r=s[0],a=s[1];if(1===a&&1===r)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const o=wL(t);return 1===a?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${r}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===r?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${r}, ${a}, index + ${o});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape;if(null!=r&&$h(t,r))return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:a,keptDims:o}=qh(t);if(a.length<t.length){const t=["row","col"];return`\n      ${mL(IL(e,a))}\n      float ${s}(int row, int col) {\n        return ${s}(${_L(t,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${kL(e)}\n      }\n    `;const i=r[0],u=r[1],l=wL(n);return 1===u?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${i}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===i?`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${l};\n    vec2 uv = uvFromFlat(${i}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[1]*t[2],a=t[2],{newShape:o,keptDims:i}=qh(t);if(o.length<t.length){const t=["row","col","depth"];return`\n        ${mL(IL(e,o))}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${_L(t,i)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${a}, 1)));\n        ${kL(e)}\n      }\n    `;const u=e.shapeInfo.texShape,l=u[0],c=u[1],d=e.shapeInfo.flatOffset;return c===r&&null==d?`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${l}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===a&&null==d?`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${a} + depth + ${wL(n)};\n        vec2 uv = uvFromFlat(${l}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[3],a=t[2]*r,o=t[1]*a,{newShape:i,keptDims:u}=qh(t);if(i.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${mL(IL(e,i))}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${_L(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${r}, 1)));\n        ${kL(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,d=c[0],p=c[1];return p===o&&null==l?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===r&&null==l?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${wL(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],a=t[3]*r,o=t[2]*a,i=t[1]*o,{newShape:u,keptDims:l}=qh(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${mL(IL(e,u))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${_L(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${a}, ${r})) +\n          depth3;\n        ${kL(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],h=d[1];return h===i&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:h===r&&null==c?`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${a} +\n          depth2 * ${r} + depth3 + ${wL(n)};\n      vec2 uv = uvFromFlat(${p}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:a}=qh(t);if(r.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${mL(IL(e,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${_L(t,a)});\n      }\n    `}const o=t[5],i=t[4]*o,u=t[3]*i,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${kL(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];return f===c&&null==d?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===o&&null==d?`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${wL(n)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function gL(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${ZM().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e.shapeInfo.texShape,r=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],a=ZM();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,a=r[0],o=r[1],i=ZM();if(null!=r&&$h(t,r))return`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${i.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===t[0]){const n=[1,2],r=["b","row","col"];return`\n        ${gL(IL(e,t.slice(1)))}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${_L(r,n)});\n        }\n      `}const o=a[0],i=a[1],u=Math.ceil(t[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${o}, ${i}, ${u*Math.ceil(t[1]/2)}, ${u}, b, row, col);\n      return ${ZM().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=e.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],i=o[0],u=o[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),d="int b, int row, int col",p=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let h=2;h<n-1;h++)d=`int b${h}, `+d,c*=t[n-h-1],p=`b${h} * ${c} + `+p;return`\n    vec4 ${r}(${d}) {\n      int index = ${p};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${i});\n      return ${ZM().texture2D}(${s}, uv);\n    }\n  `}(e)}}const bL="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",yL="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",vL="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",xL="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function wL(e){return`offset${e}`}function kL(e){const t=e.name,n=Nh(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function CL(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function IL(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function _L(e,t){return t.map(t=>e[t]).join(", ")}function SL(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const s=e.logicalShape,r=t[n],a=r.shape;if(!$h(s,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);if(e.isUniform&&r.isUniform)return;const o=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!$h(o,i))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${i} must match`)})}const{addImpl:EL,bincountImpl:NL,bincountReduceImpl:$L,ceilImpl:TL,concatImpl:AL,expImpl:RL,expm1Impl:FL,floorImpl:DL,gatherV2Impl:OL,greaterImpl:qL,lessImpl:zL,linSpaceImpl:ML,logImpl:LL,maxImpl:PL,maximumImpl:VL,minimumImpl:jL,multiplyImpl:BL,negImpl:WL,prodImpl:UL,rangeImpl:GL,rsqrtImpl:HL,simpleAbsImpl:KL,sliceImpl:XL,sparseFillEmptyRowsImpl:ZL,sparseReshapeImpl:YL,stridedSliceImpl:QL,subImpl:JL,tileImpl:eP,topKImpl:tP,transposeImpl:nP,uniqueImpl:sP}=o;function rP(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function aP(e,t){return 1===t?[e]:rP(e,t)}class oP{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=aP("rc",t),s=CL(t),r=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let s="";for(let r=e-2;r<e;r++)s+=`${n[r]} >= ${t[r]}`,r<e-1&&(s+="||");return s}(t,e,n),a=function(e,t,n,s){if(1===e)return"";const r=s.slice(-2);return`\n    int r = ${r[0]};\n    int c = ${r[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),o=function(e,t){const n=e.length,s=function(e,t){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let n=2;n<e;n++)a=`${t[t.length-1-n]},`+a;n.push(a)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${s[0]}),\n          cEdge ? 0. : getA(${s[1]}),\n          rEdge ? 0. : getA(${s[2]}),\n          rEdge || cEdge ? 0. : getA(${s[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class iP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2==1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}var s;this.userCode=`\n      ${s=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${YM(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${QM(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class uP{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const s=cP(t,n),r=dP(e,s,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const a=lP(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let o;return s===CM.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===CM.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===CM.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===CM.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===CM.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,n,s){if(null==this.freeTextures)return;const r=cP(n,s),a=dP(t,r,s);a in this.freeTextures||(this.freeTextures[a]=[]);const o=lP(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s),i=af().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[a],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function lP(e,t,n,s,r){const a=function(e,t){switch(e){case CM.PACKED_2X2_FLOAT32:return cL(t);case CM.PACKED_2X2_FLOAT16:return dL(t);case CM.UNPACKED_FLOAT32:return iL(t);case CM.UNPACKED_FLOAT16:return uL(t);case CM.PACKED_4X1_UNSIGNED_BYTE:return lL(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,s);let o;if(r){const[t,n]=SM(e[0],e[1]);o=t*n}else{const[t,n]=IM(e[0],e[1]);o=t*n}return o*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,a)}function cP(e,t){if(e===kM.UPLOAD)return CM.PACKED_2X2_FLOAT32;if(e===kM.RENDER||null==e)return function(e){return af().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?CM.PACKED_2X2_FLOAT32:CM.UNPACKED_FLOAT32:e?CM.PACKED_2X2_FLOAT16:CM.UNPACKED_FLOAT16}(t);if(e===kM.DOWNLOAD||e===kM.PIXELS)return CM.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function dP(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class pP{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const hP="return abs(x);",fP="return x;";class mP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class gP{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=aP("rc",t),s=CL(t),r=function(e,t){if(1===e)return"rc";let n="";for(let s=0;s<e;s++)n+=t[s],s<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const bP=LC,yP={};class vP extends vh{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!af().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=xM(af().getNumber("WEBGL_VERSION"));this.binaryCache=((t=af().getNumber("WEBGL_VERSION"))in yP||(yP[t]={}),yP[t]),this.gpgpu=new pL(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new uP(this.gpgpu),this.numMBBeforeWarning=null==af().global.screen?1024:af().global.screen.height*af().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new yh(this,kv())}nextDataId(){return vP.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((af().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||af().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:n,values:e,usage:kM.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,s,r){if(af().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:s,values:t,usage:kM.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:s,complexTensorInfos:r,slice:a,shape:o,isPacked:i}=t;if(null!=a){let t;t=i?new mP(o,fP):new pP(o,fP);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:s}],s),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=gb()),c="complex64"===s?yC(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=gb()-l),this.convertAndCacheOnCPU(e,c)}read(e){var t=this;return bh(function*(){if(t.pendingRead.has(e)){const n=t.pendingRead.get(e);return new Promise(e=>n.push(e))}const n=t.texData.get(e),{values:s,shape:r,slice:a,dtype:o,complexTensorInfos:i,isPacked:u}=n;if(null!=a){let n;n=u?new mP(r,fP):new pP(r,fP);const s=t.runWebGLProgram(n,[{dataId:e,shape:r,dtype:o}],o),a=t.read(s.dataId);return t.disposeIntermediateTensorInfo(s),a}if(null!=s)return t.convertAndCacheOnCPU(e);if(!af().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===af().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,d=null;if("complex64"!==o&&af().get("WEBGL_BUFFER_SUPPORTED")){l=t.decode(e);const n=t.texData.get(l.dataId);d=t.gpgpu.createBufferFromTexture(n.texture,..._M(r))}if(t.pendingRead.set(e,[]),"complex64"!==o&&(yield t.gpgpu.createAndWaitForFence()),"complex64"===o){const e=yield Promise.all([t.read(i.real.dataId),t.read(i.imag.dataId)]);c=yC(e[0],e[1])}else if(null==d)c=t.getValuesFromTexture(e);else{const e=Nh(r);c=t.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}null!=l&&t.disposeIntermediateTensorInfo(l);const p=t.convertAndCacheOnCPU(e,c),h=t.pendingRead.get(e);return t.pendingRead.delete(e),h.forEach(e=>e(p)),t.pendingDisposal.has(e)&&(t.pendingDisposal.delete(e),t.disposeData(e)&&kv().removeDataId(e,t),t.pendingDeletes--),p})()}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>yb(e))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wy(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!$M(n)){if(af().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:s}=this.texData.get(e),r=Nh(t);if(af().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),s=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(s.texture,..._M(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),a}const a=af().getBool("WEBGL_PACK")&&!0===s,o=a?PM(t):t,i=a?new sL(o):new nL(o),u=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var t=this;return bh(function*(){const n=t.activeTimers,s=[];let r=!1;null==t.programTimersStack?(t.programTimersStack=s,r=!0):t.activeTimers.push(s),t.activeTimers=s,e();const a=Eh(t.activeTimers.map(e=>e.query)).filter(e=>null!=e),o=Eh(t.activeTimers.map(e=>e.name)).filter(e=>null!=e);t.activeTimers=n,r&&(t.programTimersStack=null);const i={uploadWaitMs:t.uploadWaitMs,downloadWaitMs:t.downloadWaitMs,kernelMs:null,wallMs:null};if(af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=yield Promise.all(a);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:o[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return t.uploadWaitMs=0,t.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:gb(),endMs:null}}endTimer(e){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=gb(),e)}getQueryTime(e){var t=this;return bh(function*(){return af().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?t.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:s,usage:r,isPacked:a,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(t,s,r,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=128){return af().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&Nh(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gC("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return bP(e.shape,t)}packedUnaryOp(e,t,n){const s=new mP(e.shape,t),r=this.compileAndRun(s,[e],n);return kv().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=KL(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(af().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,hP,e.dtype);const t=new pP(e.shape,hP),n=this.compileAndRun(t,[e]);return kv().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&jh(n[0])){const r=n.map(e=>bb(e));s=this.write(r,e,t)}else s=this.write(n,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:s}=this.makeTensorInfo(e,t,n);return kv().makeTensorFromDataId(s,e,t,this)}unpackTensor(e){const t=new gP(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new oP(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[MM(e.shape),...LM(e.shape)],s={dtype:e.dtype,shape:n,dataId:e.dataId},r=[MM(t),...LM(t)],a=new iP(r,n),o=this.runWebGLProgram(a,[s],e.dtype,null,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:s,dtype:r}=t,a=PM(s);let o;return o=n?new tL(a):new eL(a),{dtype:r,shape:s,dataId:this.runWebGLProgram(o,[{shape:a,dtype:r,dataId:e}],r,null,!0).dataId}}runWebGLProgram(e,t,n,s,r=!1){const a=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(a.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===wM.DENSE){const t=_M(e.outputShape);o.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Nh(a.shape))return o.values=zh(a.dtype,0),a;const i=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Nh(t.shape)<=af().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),i.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!jM(n.shape,t.shape)){const e=t,s=t.shape;t.shape=n.shape,t=this.packedReshape(t,s),i.push(t),n=this.texData.get(t.dataId),e.shape=s}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(a.dataId);const l={shape:a.shape,texData:o,isUniform:!1},c=function(e,t,n){let s="";t.concat(n).forEach(e=>{s+=`${e.shape}_${e.isUniform?"uniform":e.texData.texShape}_${null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0}`});let r=e.constructor.name;return r+="_"+s+"_"+e.userCode,r}(e,u,l),d=this.getAndSaveBinary(c,()=>function(e,t,n,s){const r=t.userCode,a=n.map((e,n)=>{const s={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(s.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:s}}),o=a.map(e=>e.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},u=fL(a,i,r,t.packedInputs),l=e.createProgram(u);let c=null;const d=e.getUniformLocation(l,"NAN",!1);1===af().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(l,"INFINITY",!1));const p={};for(let h=0;h<t.variableNames.length;h++){const n=t.variableNames[h],s=!1;p[n]=e.getUniformLocation(l,n,s),p[`offset${n}`]=e.getUniformLocation(l,`offset${n}`,s)}return{program:t,source:u,webGLProgram:l,uniformLocations:p,inShapeInfos:o,outShapeInfo:i,infLoc:c,nanLoc:d}}(this.gpgpu,e,u,l)),p=null!=this.activeTimers;let h;p&&(h=this.startTimer()),function(e,t,n,s,r){SL(t.inShapeInfos,n),SL([t.outShapeInfo],[s]);const a=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?e.setOutputPackedMatrixTexture(a,o[0],o[1]):e.setOutputMatrixTexture(a,o[0],o[1]),e.setProgram(t.webGLProgram),1===af().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,s)=>{const r=t.program.variableNames[s],a=t.uniformLocations[r],o=t.uniformLocations[`offset${r}`];if(null!=a)if(n.isUniform)if(Nh(n.shape)<2)e.gl.uniform1f(a,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=n.texData.slice&&null!=o&&e.gl.uniform1i(o,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,a,s)}),null!=r&&r(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,d,u,l,s),i.forEach(e=>this.disposeIntermediateTensorInfo(e)),p&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));const f=af().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=gb();e-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!af().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===r){const e=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),e}return a}compileAndRun(e,t,n,s,r=!1){return this.runWebGLProgram(e,t,n=n||t[0].dtype,s,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(af().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Iv(()=>{if(!af().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=af().getBool("DEBUG");af().set("DEBUG",!1);const t=this.abs($v(1e-8)).dataSync()[0];if(af().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:s,values:r,texture:a,usage:o,isPacked:i}=t;if(null!=a)return;const u=null!=this.activeTimers;let l;u&&(l=gb());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=af().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map((t,n)=>n>=e.length-2?Ch(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=qh(e);e=t.newShape}let s=Nh(e);if(e.length<=1&&s<=n)return[1,s];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=MM(e);let n=2,r=2;return e.length&&([n,r]=LM(e)),s=t*(n/2)*(r/2),Ah(s).map(e=>2*e)}return Ah(s)}(n,i),t.texShape=c),null!=r){const e=PM(n);let a,o=c[1],d=c[0];const p=r instanceof Uint8Array;i?([o,d]=SM(c[0],c[1]),a=new aL(e,[d,o],p)):a=new rL(e,[d,o],p);const h=this.makeTensorInfo([d,o],s);this.texData.get(h.dataId).usage=p?kM.PIXELS:kM.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(h.dataId),o,d,r);const f=this.runWebGLProgram(a,[h],s,null,!0),m=this.texData.get(f.dataId);t.texture=m.texture,t.texShape=m.texShape,t.isPacked=m.isPacked,t.usage=m.usage,this.disposeIntermediateTensorInfo(h),this.texData.delete(f.dataId),t.values=null,u&&(this.uploadWaitMs+=gb()-l)}else{const e=this.acquireTexture(c,o,s,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:s}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,s)),n.values}acquireTexture(e,t,n,s){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*Vh(t)}}vP.nextDataId=0,Jb()&&Ev("webgl",()=>new vP,2);class xP{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=wx(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class wP{constructor(e,t,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=wx(t,n);const r=this.outputShape.length;let a="";if(s)if(0===r||1===Nh(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${CL(r)} coords = getOutputCoords();\n        `,1===r)a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=aP("coords",r);a+=`\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function kP(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const CP={kernelName:km,backendName:"webgl",kernelFunc:kP};function IP(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,a=n.makeTensorInfo(s.shape,"complex64"),o=n.texData.get(a.dataId),i=kP({inputs:{x:s},backend:n}),u=kP({inputs:{x:r},backend:n});return o.complexTensorInfos={real:i,imag:u},a}const _P={kernelName:Of,backendName:"webgl",kernelFunc:IP},SP="return (a < 0.) ? b * a : a;",EP="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",NP={kernelName:Nm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:a}=s,o=n.makeTensorInfo([],"float32",fb(a,"float32")),i=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wP(EP,r.shape,o.shape):new xP(SP,r.shape,o.shape),u=n.runWebGLProgram(i,[r,o],r.dtype);return n.disposeIntermediateTensorInfo(o),u}},$P="return (a < 0.) ? b * a : a;",TP="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",AP={kernelName:lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t,a=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wP(TP,s.shape,r.shape):new xP($P,s.shape,r.shape);return n.runWebGLProgram(a,[s,r],s.dtype)}};function RP({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:a})=>{const{x:o}=r,i=a,u=s||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=n){const e=i.texData.get(o.dataId),t=n(e.values,u);return i.makeTensorInfo(o.shape,u,t)}let l;return l=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new mP(o.shape,t):new pP(o.shape,e),i.runWebGLProgram(l,[o],u)}}function FP({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:o,backend:i})=>{const{a:u,b:l}=o,c=i;if(s&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[s,r]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,s]=t,r={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:s.dataId,dtype:s.dtype,shape:l.shape},o=new xP(e,u.shape,l.shape);return c.runWebGLProgram(o,[r,a],Pb(n.dtype,s.dtype))}),a=IP({inputs:{real:s,imag:r},backend:c});return c.disposeIntermediateTensorInfo(s),c.disposeIntermediateTensorInfo(r),a}const d=a||Pb(u.dtype,l.dtype);if(c.shouldExecuteOnCPU([u,l])&&null!=r){const e=c.texData.get(u.dataId),t=c.texData.get(l.dataId),[n,s]=r(u.shape,l.shape,e.values,t.values,d),a=c.makeTensorInfo(s,d);return c.texData.get(a.dataId).values=n,a}let p;return p=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new wP(t,u.shape,l.shape,n):new xP(e,u.shape,l.shape),c.runWebGLProgram(p,[u,l],d)}}function DP(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?TP:$P;if("leakyrelu"===e)return t?EP:SP;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class OP{constructor(e,t,n,s=!1,r=!1,a=!1,o=null,i=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const l=Math.ceil((s?e[1]:e[2])/2),c=s?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";o&&(f=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,m="result = activation(result);");const g=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",y="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(y=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${b};\n          int batchB = ${y};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${h[0]});\n          result += (${p[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class qP{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=wx(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const zP="return a * b;";function MP(e){const{inputs:t,backend:n}=e,{a:s,b:r}=t,a=Pb(s.dtype,r.dtype);if("complex64"===s.dtype){const e=n.texData.get(s.dataId),t=n.texData.get(r.dataId),a=new qP("return areal * breal - aimag * bimag;",s.shape,r.shape),o=new qP("return areal * bimag + aimag * breal;",s.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:s.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],u=n.runWebGLProgram(a,i,"float32"),l=n.runWebGLProgram(o,i,"float32"),c=IP({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([s,r])){const e=n.texData.get(s.dataId),t=n.texData.get(r.dataId),[o,i]=BL(s.shape,r.shape,e.values,t.values,a),u=n.makeTensorInfo(i,a);return n.texData.get(u.dataId).values=o,u}let o;return o=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wP(zP,s.shape,r.shape):new xP(zP,s.shape,r.shape),n.runWebGLProgram(o,[s,r],a)}const LP={kernelName:Qm,backendName:"webgl",kernelFunc:MP};function PP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:a}=s,o=n,i=Nh(r.shape),u=Dh(a,i),l=Nh(u);Ih(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(r.dataId);return!c.isPacked||jM(r.shape,u)||null!==c.texture&&jM(c.shape,u)?(o.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype}):function(e,t,n){const s=[MM(e.shape),...LM(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},a=[MM(t),...LM(t)],o=new iP(a,s),i=n.runWebGLProgram(o,[r],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}(r,u,o)}const VP={kernelName:mg,backendName:"webgl",kernelFunc:PP};class jP{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:a}=e;this.outputShape=[s,a];const o=4*Math.floor(n/4),i=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${Th(e)?e.toPrecision(2):e}, ones);`}let l="";r%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===i}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===i}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class BP{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:a}=e;this.outputShape=[s,a];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n      }\n    `,p="vec4";"all"===t?(o="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(o="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}function WP(e,t,n,s){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],s=Yk(n);t.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return t}(e.shape);let a=e;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:u,outSize:l}=r[o];let c,d;c="mean"===n?0===o?new jP({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},i):new jP({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l}):new BP({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},n),d=a,a=s.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&s.disposeIntermediateTensorInfo(d)}return a}class UP{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const s=CL(this.rank),r=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<e.length;r++)s[e[r]]=n[r];return s.join()}(t);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class GP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=CL(this.rank),r=rP("rc",this.rank),a=new Array(this.rank);for(let l=0;l<t.length;l++)a[t[l]]=r[l];const o=`vec2(${a.slice(-2).join()})`,i=`++${r[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function HP(e,t,n){const s=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GP(e.shape,t):new UP(e.shape,t);return n.runWebGLProgram(s,[e],e.dtype)}function KP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s;return function(e,t,n,s){const r=e.shape.length,a=Oh(t,e.shape);let o=a;const i=Yx(o,r),u=null!=i;let l=e;u&&(l=HP(e,i,s),o=Jx(o.length,r)),Zx("sum",o,r);const[c,d]=Kx(l.shape,o);let p=c;n&&(p=Xx(c,a));const h=Nh(d),f=PP({inputs:{x:l},attrs:{shape:[Nh(e.shape)/h,h]},backend:s}),m=WP(f,Vb(e.dtype),"sum",s),g=PP({inputs:{x:m},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(m),u&&s.disposeIntermediateTensorInfo(l),g}(r,a,o,n)}const XP={kernelName:Dg,backendName:"webgl",kernelFunc:KP};function ZP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{perm:a}=s,o=n,i=new Array(r.shape.length);for(let l=0;l<i.length;l++)i[l]=r.shape[a[l]];let u;if(o.shouldExecuteOnCPU([r])){const e=o.texData.get(r.dataId),t=nP(e.values,r.shape,r.dtype,a,i);u=o.makeTensorInfo(i,r.dtype),o.texData.get(u.dataId).values=t}else u=HP(r,a,o);return u}const YP={kernelName:Zg,backendName:"webgl",kernelFunc:ZP};function QP({a:e,b:t,transposeA:n,transposeB:s,backend:r,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,d=n?e.shape[l-2]:e.shape[l-1],p=s?t.shape[c-1]:t.shape[c-2],h=n?e.shape[l-1]:e.shape[l-2],f=s?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=Nh(m),y=Nh(g);Ih(l>=2&&c>=2&&(b===y||1===b||1===y),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const v=(b>y?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([h,f]);Ih(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${s} must match.`);const x=n?[b,d,h]:[b,h,d],w=s?[y,f,p]:[y,p,f],k=PP({inputs:{x:e},backend:r,attrs:{shape:x}}),C=PP({inputs:{x:t},backend:r,attrs:{shape:w}}),I=[k,C],_=Math.max(b,y),S=n?k.shape[1]:k.shape[2],E=null!=a,N=null!=o,$="leakyrelu"===u,T=null!=u?DP(u,!0):null;let A;if((1===h||1===f)&&S>1e3&&!1===(E||N||$||null!=T)){let e=k,t=C;n&&(e=ZP({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),I.push(e)),s&&(t=ZP({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),I.push(t));const a=1===f;let o=e;1!==f&&(o=PP({inputs:{x:e},backend:r,attrs:{shape:[_,S,1]}}),I.push(o));const i=1===f?2:1;let u=t;a&&(u=PP({inputs:{x:t},backend:r,attrs:{shape:[_,1,S]}}),I.push(u));const l=MP({inputs:{a:o,b:u},backend:r});A=KP({inputs:{x:l},backend:r,attrs:{axis:i,keepDims:!0}}),I.push(l)}else{const u=Pb(e.dtype,t.dtype),l=new OP(x,w,[_,h,f],n,s,E,T,N,$),c=[k,C];if(null!=a&&c.push(a),N&&c.push(o),$){const e=r.makeTensorInfo([],"float32",fb(i,"float32"));c.push(e),I.push(e)}A=r.runWebGLProgram(l,c,u)}const R=PP({inputs:{x:A},backend:r,attrs:{shape:v}});I.push(A);for(const F of I)r.disposeIntermediateTensorInfo(F);return R}const JP={kernelName:sb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=s;return QP({a:r,b:a,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}},eV="return abs(x);",tV={kernelName:df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const e=n.texData.get(s.dataId),t=KL(e.values);return n.makeTensorInfo(s.shape,s.dtype,t)}let r;return r=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mP(s.shape,eV):new pP(s.shape,eV),n.runWebGLProgram(r,[s],s.dtype)}},nV=RP({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),sV={kernelName:pf,backendName:"webgl",kernelFunc:nV},rV=RP({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),aV={kernelName:hf,backendName:"webgl",kernelFunc:rV},oV="return a + b;",iV=FP({opSnippet:oV,packedOpSnippet:oV,supportsComplex:!0,cpuKernelImpl:EL}),uV={kernelName:ff,backendName:"webgl",kernelFunc:iV};class lV{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const s=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class cV{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const s=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const dV={kernelName:mf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s}=t,r=n;if(1===r.length)return kP({inputs:{x:r[0]},backend:s});if(r.length>af().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:s}),a=e({inputs:r.slice(t),backend:s});return e({inputs:[n,a],backend:s})}const a=r.map(e=>e.dtype).reduce((e,t)=>Pb(e,t)),o=r.map(e=>e.shape),i=af().getBool("WEBGL_PACK")?new cV(r[0].shape,o):new lV(r[0].shape,o);return s.runWebGLProgram(i,r,a)}},pV={kernelName:gf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,u=Oh(a,r.shape);let l=u;const c=Yx(l,i);let d=r;null!=c&&(d=ZP({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Jx(l.length,i)),Zx("all",l,i);const[p,h]=Kx(d.shape,l),f=PP({inputs:{x:d},backend:n,attrs:{shape:[-1,Nh(h)]}}),m=WP(f,f.dtype,"all",n);let g;return g=PP(o?{inputs:{x:m},backend:n,attrs:{shape:Xx(p,u)}}:{inputs:{x:m},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},hV={kernelName:bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,u=Oh(a,r.shape);let l=u;const c=Yx(l,i);let d=r;null!=c&&(d=ZP({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Jx(l.length,i)),Zx("any",l,i);const[p,h]=Kx(d.shape,l),f=PP({inputs:{x:d},backend:n,attrs:{shape:[-1,Nh(h)]}}),m=WP(f,f.dtype,"any",n);let g;return g=PP(o?{inputs:{x:m},backend:n,attrs:{shape:Xx(p,u)}}:{inputs:{x:m},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class fV{constructor(e,t,n){this.variableNames=["A"];const{windowSize:s,batchSize:r,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,a],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class mV{constructor(e,t,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Ih(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const r=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),r>1&&this.outputShape.push(r),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,o=a.length,i=CL(o),u=aP("coords",o);let l,c;if(1===r){c=o+1;const e=CL(c);l=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else c=o,l=`\n        ${i} sourceLocR = coords;\n        ++${u[o-1]};\n        ${i} sourceLocG = coords;\n        ++${u[o-2]};\n        ${i} sourceLocA = coords;\n        --${u[o-1]};\n        ${i} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,c),p="."+d[c-1],h=d.map(e=>"int "+e),f=aP("sourceLocR",c-1).concat("inIdx.r"),m=aP("sourceLocG",c-1).concat("inIdx.g"),g=aP("sourceLocB",c-1).concat("inIdx.b"),b=aP("sourceLocA",c-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",v=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,x=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,w=s?"":`\n      float getBestIndicesAChannel(${h.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${h.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${i} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${a[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${a[o-2]-1};\n        ${l}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function gV(e,t,n,s=null){let r=t.shape[0],a=t.shape[1];null!=s&&(r=s.shape[0],a=s.shape[1]);const o=Yk(a),i={windowSize:o,inSize:a,batchSize:r,outSize:Math.ceil(a/o)},u=new fV(i,n,null==s),l=[t];null!=s&&l.push(s);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const d=gV(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function bV(e,t,n,s=null){const r=null!=s?s.shape:t.shape,a=Yk(r[r.length-1]),o=new mV(r,a,n,null==s),i=e.runWebGLProgram(o,null==s?[t]:[t,s],"int32");if(i.shape.length===t.shape.length){const s=bV(e,t,n,i);return e.disposeIntermediateTensorInfo(i),s}return i}function yV(e,t,n,s){const r=[n];if(Zx("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!af().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[a,o]=Kx(t.shape,r),i=Nh(o),u=PP({inputs:{x:t},backend:e,attrs:{shape:[-1,i]}});n.push(u);const l=gV(e,u,s);n.push(l);const c=PP({inputs:{x:l},backend:e,attrs:{shape:a}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),c}return bV(e,t,s)}const vV={kernelName:yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;let o=Oh(a,r.shape);const i=Yx(o,r.shape.length);let u=r;const l=[];null!=i&&(u=ZP({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Jx(o.length,u.shape.length)),Zx("argMax",[o[0]],u.shape.length);const c=yV(n,u,o[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},xV={kernelName:vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a}=s;let o=Oh(a,r.shape);const i=Yx(o,r.shape.length);let u=r;const l=[];null!=i&&(u=ZP({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(u),o=Jx(o.length,u.shape.length)),Zx("argMin",[o[0]],u.shape.length);const c=yV(n,u,o[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},wV=RP({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),kV={kernelName:xf,backendName:"webgl",kernelFunc:wV},CV=RP({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),IV={kernelName:wf,backendName:"webgl",kernelFunc:CV},_V=RP({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),SV={kernelName:kf,backendName:"webgl",kernelFunc:_V},EV=FP({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),NV={kernelName:If,backendName:"webgl",kernelFunc:EV},$V=RP({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),TV={kernelName:Cf,backendName:"webgl",kernelFunc:$V};class AV{constructor(e,t,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${i});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`:`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / count");const b=4*Math.floor(a/4),y=a%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${b}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${b};\n          if (${1===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===y}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class RV{constructor(e,t,n,s=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,i=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let v="0.0";if(y||(v="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${i}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / count");const w=4*Math.floor(a/4),k=a%4,C=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${i}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${C}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${C}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${C}\n            }\n          }\n          setOutput(${x});\n        }\n      }\n    `}}const FV={kernelName:_f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;KM(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=s;Ih(Hv(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const l=zv(r.shape,a,o,1,i,u);if(1===l.filterWidth&&1===l.filterHeight&&$h(l.inShape,l.outShape))return kP({inputs:{x:r},backend:n});const c=new AV(l,"avg",!1);return n.runWebGLProgram(c,[r],"float32")}},DV={kernelName:Ef,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=s,c=Mv(r.shape,a,o,[1,1,1],i,u,l),d=new RV(c,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}};class OV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n            wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${e.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,s=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${s-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterDepth*e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n            wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const zV={kernelName:Nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,o=a,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=s,d=Mv(o.shape,i,u,[1,1,1],l,c),p=new qV(d);return n.runWebGLProgram(p,[r],o.dtype)}},MV={kernelName:Sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,o=a;KM([r,a],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=s,c=zv(o.shape,i,u,1,l),d=new OV(c);return n.runWebGLProgram(d,[r],o.dtype)}},LV={kernelName:$f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:a}=t,{transposeA:o,transposeB:i}=s;return QP({a:r,b:a,transposeA:o,transposeB:i,backend:n})}};class PV{constructor(e,t,n,s,r,a){this.outputShape=[],this.variableNames=["x","mean","variance"],wx(e,t),wx(e,n);let o="0.0";null!=s&&(wx(e,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=r&&(wx(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class VV{constructor(e,t,n,s,r,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],wx(e,t),wx(e,n);let o="vec4(0.0)";null!=s&&(wx(e,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(wx(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const jV={kernelName:bm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,mean:r,variance:a,offset:o,scale:i}=e;Ih(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Ih(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Ih(null==i||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[s,r,a];let c=null;null!=o&&(c=o.shape,l.push(o));let d=null;null!=i&&(d=i.shape,l.push(i));const p=af().getBool("WEBGL_PACK_NORMALIZATION")?new VV(s.shape,r.shape,a.shape,c,d,u):new PV(s.shape,r.shape,a.shape,c,d,u);return t.runWebGLProgram(p,l,l[0].dtype)}};class BV{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=CL(this.rank),n=`uniform int start[${this.rank}];`,s=function(e){if(1===e)return"sourceLoc";if(e<=6)return WV.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${WV[t]} = start[${t}] + coords.${WV[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const WV=["x","y","z","w","u","v"];class UV{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=CL(this.rank),n=aP("coords",this.rank),s=aP("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,a=`getChannel(getSource(${s.join()}), ${r})`,o=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${a};\n        --${s[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${s[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function GV(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,size:o}=s,[i,u]=bv(r,a,o);if(sv(r,i,u),0===Nh(u))return n.makeTensorInfo(u,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=XL(e.values,i,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),c=mv(r.shape,i,u);if(l||!c){const e=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UV(u):new BV(u),t=e.getCustomSetupFunc(i);return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,s){const r=s.texData.get(e.dataId),a=s.makeTensorInfo(n,e.dtype),o=s.texData.get(a.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=gv(t,Hh(e.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const u=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,u+1),a}(r,i,u,n)}const HV={kernelName:Eg,backendName:"webgl",kernelFunc:GV},KV={kernelName:Tf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,crops:o}=s;Ih(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((e,t)=>e*t),u=Jk(r.shape,a,i),l=eC(u.length,a.length),c=tC(r.shape,a,i),d=nC(o,a.length),p=sC(c,o,a.length),h=[],f=PP({inputs:{x:r},backend:n,attrs:{shape:u}}),m=ZP({inputs:{x:f},backend:n,attrs:{perm:l}}),g=PP({inputs:{x:m},backend:n,attrs:{shape:c}}),b=GV({inputs:{x:g},backend:n,attrs:{begin:d,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},XV={kernelName:Af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o}=s,i=n.readSync(r.dataId),u=n.readSync(a.dataId),l=NL(i,u,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}},ZV=FP({opSnippet:"return float(a != b);",dtype:"bool"}),YV={kernelName:eg,backendName:"webgl",kernelFunc:ZV};function QV(e){const{inputs:t,backend:n}=e,{input:s}=t;return kP({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.real},backend:n})}const JV={kernelName:pg,backendName:"webgl",kernelFunc:QV},ej={kernelName:Rf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s,attrs:r}=t,{x:a}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===a.dtype)return kP({inputs:{x:a},backend:s});const t=aw(a.shape),n=e({inputs:{x:a},backend:s,attrs:{dtype:"float32"}}),r=IP({inputs:{real:n,imag:t},backend:s});return t.dispose(),s.disposeIntermediateTensorInfo(n),r}if("complex64"===a.dtype){const t=QV({inputs:{input:a},backend:s}),n=e({inputs:{x:t},backend:s,attrs:{dtype:o}});return s.disposeIntermediateTensorInfo(t),n}if(!Lh(a.dtype,o)){const e=kP({inputs:{x:a},backend:s});return{dataId:e.dataId,shape:e.shape,dtype:o}}if("int32"===o)return function(e,t){const n=new pP(e.shape,"return float(int(x));"),s=t.runWebGLProgram(n,[e],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(a,s);if("bool"===o){const e=s.makeTensorInfo([],"bool",zh("bool",1)),t=ZV({inputs:{a:a,b:e},backend:s});return s.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${o}`)}},tj="return ceil(x);",nj=RP({opSnippet:tj,packedOpSnippet:tj,cpuKernelImpl:TL}),sj={kernelName:Ff,backendName:"webgl",kernelFunc:nj};class rj{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class aj{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,s)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const oj={kernelName:Df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{clipValueMin:a,clipValueMax:o}=s;let i;i=af().getBool("WEBGL_PACK_CLIP")?new aj(r.shape):new rj(r.shape);const u=i.getCustomSetupFunc(a,o);return n.runWebGLProgram(i,[r],r.dtype,u)}};class ij{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function uj(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const lj={kernelName:qf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=n.texData.get(s.dataId),a=new ij(s.shape),o=[uj(s,r.complexTensorInfos.real),uj(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(a,o,o[0].dtype)}};class cj{constructor(e){this.outputShape=[],this.outputShape=Xk(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++)n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${t[s-1]}));`);n.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class dj{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Xk(e,t);const n=this.outputShape,s=n.length,r=CL(s),a=aP("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((e,t)=>`T${t}`);const i=new Array(e.length-1);i[0]=e[0][t];for(let h=1;h<i.length;h++)i[h]=i[h-1]+e[h][t];const u=o[t],l=o.slice(-2),c=o.join();let d=`if (${u} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let h=1;h<i.length;h++){const e=i[h-1];d+=`\n        if (${u} < ${i[h]}  && ${u} >= ${i[h-1]}) {\n          return getChannel(\n            getT${h}(${pj(o,u,e)}),\n            vec2(${pj(l,u,e)}));\n        }`}const p=i[i.length-1];d+=`\n        return getChannel(\n          getT${i.length}(${pj(o,u,p)}),\n          vec2(${pj(l,u,p)}));`,this.userCode=`\n      float getValue(${o.map(e=>"int "+e)}) {\n        ${d}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[s-1]} = ${a[s-1]} + 1;\n        if (${a[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[s-2]} = ${a[s-2]} + 1;\n        if (${a[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[s-1]} = ${a[s-1]} - 1;\n        if (${a[s-2]} < ${n[s-2]} &&\n            ${a[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function pj(e,t,n){const s=e.indexOf(t);return e.map((e,t)=>t===s?`${e} - ${n}`:e).join()}function hj(e){const{inputs:t,backend:n}=e,{input:s}=t;return kP({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.imag},backend:n})}const fj={kernelName:Im,backendName:"webgl",kernelFunc:hj};function mj(e,t,n){const s=e[0].dtype;if("complex64"===s){const s=e.map(e=>QV({inputs:{input:e},backend:n})),r=e.map(e=>hj({inputs:{input:e},backend:n})),a=mj(s,t,n),o=mj(r,t,n),i=IP({inputs:{real:a,imag:o},backend:n});return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),r.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),i}let r=n.shouldExecuteOnCPU(e);if("string"===s&&(r=!0),r){const r=e.map(e=>{const s=Nh(e.shape.slice(t));return PP({inputs:{x:e},backend:n,attrs:{shape:[-1,s]}})}),a=r.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),o=Xk(r.map(e=>e.shape),1),i=AL(a,o,s,1===r[0].shape[0]),u=Xk(e.map(e=>e.shape),t),l=n.makeTensorInfo(u,s,i);return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}if(e.length>af().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const s=Math.floor(e.length/2),r=mj(e.slice(0,s),t,n),a=mj(e.slice(s),t,n),o=mj([r,a],t,n);return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}if(af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const r=new dj(e.map(e=>e.shape),t);return n.runWebGLProgram(r,e,s)}const{tensors2D:a,outShape:o}=function(e,t,n){const s=Xk(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>PP({inputs:{x:e},attrs:{shape:[-1,Nh(e.shape.slice(t))]},backend:n})),outShape:s}}(e,t,n),i=new cj(a.map(e=>e.shape)),u=n.runWebGLProgram(i,a,s);a.forEach(e=>n.disposeIntermediateTensorInfo(e));const l=PP({inputs:{x:u},attrs:{shape:o},backend:n});return n.disposeIntermediateTensorInfo(u),l}function gj(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,a=Oh(r,t[0].shape)[0],o=Xk(t.map(e=>e.shape),a);if(0===Nh(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter(e=>Nh(e.shape)>0);return 1===i.length?kP({inputs:{x:i[0]},backend:n}):(Kk(i.map(e=>e.shape),a),mj(i,a,n))}const bj={kernelName:zf,backendName:"webgl",kernelFunc:gj};class yj{constructor(e,t=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let v="",x="";n&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${i}, ${u});\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class vj{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,s=e.padInfo.left,r=e.strideDepth,a=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${a}, ${o});\n      const ivec3 pads = ivec3(${t}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xj{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:s,inChannels:r,strideWidth:a,strideHeight:o,padInfo:i,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:d}=n,{left:p,top:h}=i,f=r*s,m=ZM(),g="channelsLast"===d,b=g?0:1,y=g?1:2;let v="";for(let x=0;x<=1;x++)for(let n=0;n<=1;n++)v+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${x};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${o} - ${h};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[b]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${a}. - ${p}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${r}.));\n\n              if(d1 < ${t[y]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*x+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*x+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${v}\n\n        ${m.output} = result;\n      }\n    `}}function wj({x:e,filter:t,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const u=e.shape,l=s.texData.get(e.dataId),c="channelsLast"===n.dataFormat;let d;const p=[],h=u[2]%2!=0&&!!l.isPacked;if((1!=u[0]*u[1]*u[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&af().getBool("WEBGL_LAZILY_UNPACK")&&af().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&h){const h={dataId:e.dataId,shape:[1,c?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),n.inChannels],dtype:e.dtype},f=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Ih(jM(l.shape,h.shape),()=>`packed reshape ${l.shape} to ${h.shape} isn't free`);const m=PP({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});p.push(m);const g=QP({a:h,b:m,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),b=s.texData.get(g.dataId);Ih(b.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=f,b.shape=n.outShape,d=kP({inputs:{x:g},backend:s}),d.shape=n.outShape,p.push(g)}else{const l=PP({inputs:{x:e},backend:s,attrs:{shape:[1,c?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),h=PP({inputs:{x:t},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=QP({a:l,b:h,transposeA:!1,transposeB:!1,backend:s,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o});d=PP({inputs:{x:f},backend:s,attrs:{shape:n.outShape}}),p.push(l),p.push(h),p.push(f)}for(const f of p)s.disposeIntermediateTensorInfo(f);return d}function kj({x:e,filter:t,convInfo:n,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:d,outHeight:p,dataFormat:h}=n,f="channelsLast"===h,m=u*l*c,g=p*d,b=[m,g],y=[],v=PP({inputs:{x:e},backend:s,attrs:{shape:e.shape.slice(1)}}),x=PP({inputs:{x:t},backend:s,attrs:{shape:[1,m,Nh(t.shape)/m]}});y.push(v),y.push(x);const w=new xj(b,v.shape,n),k=s.runWebGLProgram(w,[v],"float32"),C=PP({inputs:{x:k},backend:s,attrs:{shape:[1,b[0],b[1]]}});y.push(k),y.push(C);const I=null!=r,_=null!=a,S="leakyrelu"===i,E=i?DP(i,!0):null,N=new OP(C.shape,x.shape,[1,g,n.outChannels],!0,!1,I,E,_,S),$=[C,x];if(r&&$.push(r),_&&$.push(a),S){const e=s.makeTensorInfo([],"float32",fb(o,"float32"));$.push(e),y.push(e)}const T=s.runWebGLProgram(N,$,"float32"),A=PP({inputs:{x:T},backend:s,attrs:{shape:f?[1,p,d,n.outChannels]:[1,n.outChannels,p,d]}});y.push(T);for(const R of y)s.disposeIntermediateTensorInfo(R);return A}const Cj={kernelName:Mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=s,d=Kv(u),p=Lv(r.shape,a.shape,o,l,i,c,!1,d);let h;if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(af().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])h=kj({x:r,filter:a,convInfo:p,backend:n});else{const e=new yj(p);h=n.runWebGLProgram(e,[r,a],"float32")}else h=wj({x:r,filter:a,convInfo:p,backend:n});const f=PP({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),f}};class Ij{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===e.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _j{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,s="channelsLast"===e.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${s?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${s?1:2}], coords[${s?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Sj{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${e.strideDepth} - ${e.padInfo.front};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ej{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,s=e.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${s-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Nj={kernelName:Lf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,d=Kv(u),p=Lv(r.shape,c,o,1,i,l,!1,d),h=new Ij(p);return n.runWebGLProgram(h,[r,a],"float32")}},$j={kernelName:Pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=s,d=Kv(l),p=Lv(o,a.shape,i,1,u,c,!1,d),h=new _j(p);return n.runWebGLProgram(h,[r,a],"float32")}},Tj={kernelName:Vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dilations:u}=s,l=Pv(r.shape,a.shape,o,u,i),c=new vj(l);return n.runWebGLProgram(c,[r,a],"float32")}},Aj={kernelName:jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,pad:i,filterShape:u}=s,l=Pv(r.shape,u,o,1,i),c=new Sj(l);return n.runWebGLProgram(c,[r,a],"float32")}},Rj={kernelName:Bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{pad:o,strides:i,inputShape:u}=s,l=Pv(u,a.shape,i,1,o),c=new Ej(l);return n.runWebGLProgram(c,[r,a],"float32")}},Fj=RP({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),Dj={kernelName:Wf,backendName:"webgl",kernelFunc:Fj},Oj=RP({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),qj={kernelName:Uf,backendName:"webgl",kernelFunc:Oj};class zj{constructor(e,t,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,i,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const p="bilinear"===s?1:0,[h,f]=[o-1+".0",i-1+".0"],[m,g,b]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[y,v,x]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Mj={kernelName:Hf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:a,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=s,c=new zj(r.shape,a.shape,i,u,l);return n.runWebGLProgram(c,[r,a,o],"float32")}};class Lj{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const s=e.length,r=t?"0.0":`getX(${Pj(s,"coords")})`,a=e[e.length-1];let o="",i="";t?(o=n?"end != "+(a-1):"end != 0",i=n?"end + 1":"end - 1"):(o=n?`end + pow2 < ${a}`:"end >= pow2",i=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${CL(s)} coords = getOutputCoords();\n        int end = ${Vj(s,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${i};\n          ${Vj(s,"coords")} = idx;\n          val += getX(${Pj(s,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function Pj(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function Vj(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const jj={kernelName:Gf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s,u=r.shape.length,l=Yx([a],u);let c=r;null!=l&&(c=ZP({inputs:{x:r},backend:n,attrs:{perm:l}}));const d=Jx(1,u)[0];if(d!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${a}`);const p=c.shape[d];let h=kP({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(p))-1;f++){const e=new Lj(c.shape,!1,i),t=e.getCustomSetupFunc(f),s=h;h=n.runWebGLProgram(e,[h],h.dtype,t),n.disposeIntermediateTensorInfo(s)}if(o){const e=new Lj(c.shape,o,i),t=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=ZP({inputs:{x:h},backend:n,attrs:{perm:Qx(l)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),e}return h}},Bj={kernelName:Kf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:a}=t,{size:o,binaryOutput:i}=s;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(a.dataId),s=NL(e,t,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,s)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(a),s=$L(e,t,o,i);return n.makeTensorInfo(s.shape,a.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class Wj{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Uj={kernelName:Xf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:a,dataFormat:o}=s;Ih(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const i=r.shape[0],u=("NHWC"===o?r.shape[1]:r.shape[2])*a,l=("NHWC"===o?r.shape[2]:r.shape[3])*a,c=("NHWC"===o?r.shape[3]:r.shape[1])/(a*a),d=new Wj("NHWC"===o?[i,u,l,c]:[i,c,u,l],a,o);return n.runWebGLProgram(d,[r],r.dtype)}};class Gj{constructor(e,t=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.inHeight,o=e.inWidth,i=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",b="";n&&(g=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${i}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${d};\n\n          if (xR < 0 || xR >= ${a}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${o}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${b}\n        setOutput(result);\n      }\n    `}}class Hj{constructor(e,t=!1,n=null,s=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const a=e.outChannels/e.inChannels,o=e.inHeight,i=e.inWidth,u=e.padInfo.top,l=e.padInfo.left,c=e.strideHeight,d=e.strideWidth,p=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=m;let b="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let w=0;w<m;w++)b+=`\n          vec4 xTexelC${2*w};\n          int xTexelC${2*w}Ready;\n          vec4 xC${w};`;for(let w=0;w<f;w++){for(let e=0;e<m;e++)b+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xC${e} = vec4(0.0);`;b+=`\n        xR = xRCorner + ${w*p};\n        if (xR >=0 && xR < ${o}) {\n      `;for(let e=0;e<(g+1)/2;e++){const t=2*e,n=t*h;if(b+=`\n          xC = xCCorner + ${n};\n          `,1===d){if(t<m&&(l%2==1?(b+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${i} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${i}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,b+=1===h&&n>0?`\n                xC${t} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${i}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${i}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):b+=`\n                if (xC >= 0 && xC < ${i} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${i}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${t} = xTexelC${n};\n                `,n+1<m)){const e=l%2==0?Ch(h):h;h%2==0&&l%2==1||h%2!=0&&l%2!=1?(b+=`\n                  xCOffset = xC + ${l%2} + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < ${i} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${i}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,h>1&&(b+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${i} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),b+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):b+=1===e?`\n                    xC${t+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < ${i} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${i}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${n+2};\n                    `}}else n<m&&(l%2==1?(b+=`\n                xCOffset = xC + 1 - ${d};\n                if(xCOffset >= 0 && xCOffset < ${i} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${i}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${i} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${i}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(b+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${d};\n                  if(xCOffset >= 0 && xCOffset < ${i}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(b+=`\n                if(xC >= 0 && xC < ${i} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${i}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${d};\n                if(xCOffset >= 0 && xCOffset < ${i} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${i}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(b+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));t<m&&(b+=`\n            wTexel = getW(${w}, ${n}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(b+=`\n              wTexel = getW(${w}, ${n+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}b+="\n        }\n      "}let y="",v="";n&&(y=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,v="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${c}, ${d});\n      const ivec2 pads = ivec2(${u}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${b}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${x}\n        ${v}\n        setOutput(result);\n      }\n    `}}const Kj={kernelName:Zf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=s;let c=u;null==c&&(c=[1,1]),Ih(Hv(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=Lv(r.shape,a.shape,o,c,i,l,!0);let p;return p=af().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new Hj(d):new Gj(d),n.runWebGLProgram(p,[r,a],"float32")}};class Xj{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Zj{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,s=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Yj={kernelName:Yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=s,d=Lv(r.shape,c,o,i,u,l,!0),p=new Xj(d);return n.runWebGLProgram(p,[r,a],"float32")}},Qj={kernelName:Qf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:a}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=s,d=Lv(c,a.shape,o,i,u,l,!0),p=new Zj(d);return n.runWebGLProgram(p,[r,a],"float32")}};class Jj{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const eB={kernelName:Jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=[...s.shape,...s.shape],a=Nh(s.shape),o=PP({inputs:{x:s},backend:n,attrs:{shape:[a]}}),i=new Jj(a),u=n.runWebGLProgram(i,[o],o.dtype),l=PP({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),l}};class tB{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:s,strideHeight:r,strideWidth:a,filterHeight:o,filterWidth:i,dilationHeight:u,dilationWidth:l}=e,{top:c,left:d}=s;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${a});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const nB={kernelName:em,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a}=t,{strides:o,pad:i,dilations:u}=s,l=qv(r.shape,a.shape,o,i,"NHWC",u);let c;const d=new tB(l);c=n.runWebGLProgram(d,[r,a],"float32");const p=PP({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),p}},sB={kernelName:rm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,a=t,{allDims:o,summedDims:i,idDims:u}=EC(r,a.length);$C(o.length,u,a);const{path:l,steps:c}=TC(i,u),d=c.length;let p=null,h=o.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:s}=NC(h,u[e]);let r;AC(t)?r=a[e]:(r=ZP({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let e=0;e<s.length;++e)o.splice(s[e],0,1);$h(r.shape,o)||(r=PP({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===p?p=r:(p=MP({inputs:{a:r,b:p},backend:n}),f.push(p))}m<d-1&&(l[m]>=0&&(p=KP({inputs:{x:p},backend:n,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(const m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}},rB=RP({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),aB={kernelName:am,backendName:"webgl",kernelFunc:rB},oB={kernelName:om,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:s,y:r}=t,a=af().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wP("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new xP("return (b >= 1.0) ? a : a * (b + 1.0);",s.shape,r.shape);return n.runWebGLProgram(a,[s,r],s.dtype)}},iB=FP({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),uB={kernelName:um,backendName:"webgl",kernelFunc:iB},lB=RP({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${cC};\n  float a1 = ${dC};\n  float a2 = ${pC};\n  float a3 = ${hC};\n  float a4 = ${fC};\n  float a5 = ${mC};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),cB={kernelName:im,backendName:"webgl",kernelFunc:lB},dB="return exp(x);",pB=RP({opSnippet:dB,packedOpSnippet:dB,cpuKernelImpl:RL}),hB={kernelName:lm,backendName:"webgl",kernelFunc:pB};function fB(e){const{inputs:t,attrs:n,backend:s}=e,{dim:r}=n,{input:a}=t,o=a.shape.length,i=a.shape.slice();let u=r;return r<0&&(Ih(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+r+1),i.splice(u,0,1),PP({inputs:{x:a},backend:s,attrs:{shape:i}})}const mB={kernelName:cm,backendName:"webgl",kernelFunc:fB},gB="return exp(x) - 1.0;",bB=RP({opSnippet:gB,packedOpSnippet:gB,cpuKernelImpl:FL}),yB={kernelName:dm,backendName:"webgl",kernelFunc:bB};class vB{constructor(e,t,n){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${s}.0`:"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function xB(e,t,n){const s=n.texData.get(e.dataId),r=Nh(e.shape),a=e.shape[e.shape.length-1],o=PP({inputs:{x:e},backend:n,attrs:{shape:[r/a,a]}}),i=o.shape,u=new vB("real",i,t),l=new vB("imag",i,t),c=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:i},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:i}],d=n.runWebGLProgram(u,c,"float32"),p=n.runWebGLProgram(l,c,"float32"),h=IP({inputs:{real:d,imag:p},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p);const f=PP({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(h),f}const wB={kernelName:pm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t;return xB(s,!1,n)}};class kB{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function CB(e){const{backend:t,attrs:n}=e,{shape:s,value:r}=n;let{dtype:a}=n;if(a=a||Wh(r),"string"===a){const e=Mh(a,Nh(s));return e.fill(r),t.makeTensorInfo(s,a,e)}{const e=new kB(s,r),n=e.getCustomSetupFunc(r);return t.runWebGLProgram(e,[],a,n)}}const IB={kernelName:hm,backendName:"webgl",kernelFunc:CB};class _B{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const SB={kernelName:fm,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,s=t,r=new _B(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}},EB="return floor(x);",NB=RP({opSnippet:EB,packedOpSnippet:EB,cpuKernelImpl:DL}),$B={kernelName:mm,backendName:"webgl",kernelFunc:NB},TB=FP({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),AB={kernelName:gm,backendName:"webgl",kernelFunc:TB};class RB{constructor(e){this.variableNames=["A"];const t=ZM(),[n,s]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class FB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ZM(),[n,s]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const DB={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e;let{pixels:r}=t;const{numChannels:a}=s,o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[u,l]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[l,u],d=[l,u,a];(i||o)&&(null==OB&&(OB=document.createElement("canvas").getContext("2d")),OB.canvas.width=u,OB.canvas.height=l,OB.drawImage(r,0,0,u,l),r=OB.canvas);const p=n.makeTensorInfo(c,"int32");n.texData.get(p.dataId).usage=kM.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),r);const h=af().getBool("WEBGL_PACK")?new FB(d):new RB(d),f=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),f}};let OB;const qB={kernelName:rb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s,m=Kv(c),g=Lv(r.shape,a.shape,u,d,l,p,!1,m);let b;const y=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(af().getBool("WEBGL_CONV_IM2COL")&&1===r.shape[0])b=kj({x:r,filter:a,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{const e=null!=o,t=null!=i,s="leakyrelu"===h,u=h?DP(h,!1):null,l=new yj(g,e,u,t,s),c=[r,a];if(o&&c.push(o),i&&c.push(i),s){const e=n.makeTensorInfo([],"float32",fb(f,"float32"));c.push(e),y.push(e)}b=n.runWebGLProgram(l,c,"float32")}else b=wj({x:r,filter:a,convInfo:g,backend:n,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});const v=PP({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(e=>n.disposeIntermediateTensorInfo(e)),v}},zB={kernelName:ab,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=s,f=[];let m=c;null==m&&(m=[1,1]),Ih(Hv(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=Lv(r.shape,a.shape,u,m,l,d,!0),b=af().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=p?DP(p,b):null,v=[r,a],x=null!=o,w=null!=i,k="leakyrelu"===p;if(x&&v.push(o),w&&v.push(i),k){const e=n.makeTensorInfo([],"float32",fb(h,"float32"));v.push(e),f.push(e)}let C;C=b?new Hj(g,x,y,w,k):new Gj(g,x,y,w,k);const I=n.runWebGLProgram(C,v,"float32");return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),I}};class MB{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const s=CL(t.length),r=CL(n.length);this.userCode=`\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const LB={kernelName:vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,a=r.shape,o=a[a.length-1],[i,u,l,c]=rC(s,r),d=PP({inputs:{x:r},backend:n,attrs:{shape:[u,o]}}),p=PP({inputs:{x:s},backend:n,attrs:{shape:[Nh(s.shape)/l,l]}}),h=new MB(o,c,[u,l]),f=n.runWebGLProgram(h,[p,d],p.dtype),m=PP({inputs:{x:f},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};class PB{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=CL(this.rank),s=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<e.length;r++)s.push(2===r?"int(getIndices(resRC.x, resRC.z))":`${n[r]}`);return s.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}const VB={kernelName:ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:a}=t,{axis:o,batchDims:i}=s,u=qC(r,a,Oh(o,r.shape)[0],i),l=Nh(a.shape),c=[],d=PP({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=PP({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});c.push(d),c.push(p);const h=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),s=OL(t,e,h);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,s.dtype,s.values)}const f=new PB(d.shape,h),m=n.runWebGLProgram(f,[d,p],d.dtype);c.push(m);const g=PP({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},jB=FP({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:qL,dtype:"bool"}),BB={kernelName:xm,backendName:"webgl",kernelFunc:jB},WB=FP({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),UB={kernelName:wm,backendName:"webgl",kernelFunc:WB},GB={kernelName:Cm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t;return xB(s,!0,n)}},HB=RP({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),KB={kernelName:_m,backendName:"webgl",kernelFunc:HB},XB=RP({opSnippet:"return float(isinf(x));",dtype:"bool"}),ZB={kernelName:Sm,backendName:"webgl",kernelFunc:XB},YB=RP({opSnippet:"return float(isnan(x));",dtype:"bool"}),QB={kernelName:Em,backendName:"webgl",kernelFunc:YB},JB=FP({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:zL,dtype:"bool"}),eW={kernelName:$m,backendName:"webgl",kernelFunc:JB},tW=FP({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),nW={kernelName:Tm,backendName:"webgl",kernelFunc:tW},sW={kernelName:Am,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:a}=n,o=ML(s,r,a);return t.makeTensorInfo([o.length],"float32",o)}},rW=RP({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:LL}),aW={kernelName:Rm,backendName:"webgl",kernelFunc:rW},oW=RP({opSnippet:"return log(1.0 + x);"}),iW={kernelName:Fm,backendName:"webgl",kernelFunc:oW},uW=FP({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),lW={kernelName:Dm,backendName:"webgl",kernelFunc:uW},cW=RP({opSnippet:"return float(!(x >= 1.0));"}),dW={kernelName:Om,backendName:"webgl",kernelFunc:cW},pW=FP({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),hW={kernelName:qm,backendName:"webgl",kernelFunc:pW};class fW{constructor(e,t,n,s,r){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${s}) * sum`;i=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class mW{constructor(e,t,n,s,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;let i;this.outputShape=e;const u=`float(${n}) + float(${s}) * sum`;i=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}const gW={kernelName:zm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:a,bias:o,alpha:i,beta:u}=s,l=af().getBool("WEBGL_PACK_NORMALIZATION")?new mW(r.shape,a,o,i,u):new fW(r.shape,a,o,i,u);return n.runWebGLProgram(l,[r],r.dtype)}};class bW{constructor(e,t,n,s,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=s,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const yW={kernelName:Mm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r,y:a,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:c}=s,d=new bW(r.shape,i,u,l,c);return n.runWebGLProgram(d,[r,a,o],r.dtype)}};function vW(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:a,keepDims:o}=s,i=r.shape.length,u=Oh(a,r.shape);let l=u;const c=Yx(l,i),d=null!=c,p=n.shouldExecuteOnCPU([r]);let h=r;if(d){if(p){const e=n.texData.get(h.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[c[n]];const s=nP(e,r.shape,r.dtype,c,t);h=n.makeTensorInfo(t,r.dtype),n.texData.get(h.dataId).values=s}else h=HP(r,c,n);l=Jx(l.length,i)}Zx("max",l,i);const[f,m]=Kx(h.shape,l);let g,b=f;if(o&&(b=Xx(f,u)),p){const e=n.texData.get(h.dataId),t=PL(e.values,Nh(m),b,r.dtype);g=n.makeTensorInfo(b,r.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,s){const r=Nh(t),a=PP({inputs:{x:e},attrs:{shape:[Nh(e.shape)/r,r]},backend:s}),o=WP(a,e.dtype,"max",s),i=PP({inputs:{x:o},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(o),i}(h,m,b,n);return d&&n.disposeIntermediateTensorInfo(h),g}const xW={kernelName:Lm,backendName:"webgl",kernelFunc:vW},wW=FP({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:VL}),kW={kernelName:Pm,backendName:"webgl",kernelFunc:wW},CW={kernelName:Vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;KM(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=s;Ih(Hv(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const l=zv(r.shape,a,o,1,i,u);if(1===l.filterWidth&&1===l.filterHeight&&$h(l.inShape,l.outShape))return kP({inputs:{x:r},backend:n});const c=new AV(l,"max",!1);return n.runWebGLProgram(c,[r],r.dtype)}},IW={kernelName:Bm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:a,strides:o,pad:i,dataFormat:u,dimRoundingMode:l}=s,c=Mv(r.shape,a,o,[1,1,1],i,l,u),d=new RV(c,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}};class _W{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n          wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${t*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,s=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${s-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n           wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${s};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${t*n*s-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${s} +\n                  wR * ${s} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const EW={kernelName:Wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a}=t,o=a,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=s,d=Mv(o.shape,i,u,[1,1,1],l,c),p=new RV(d,"max",!0),h=n.runWebGLProgram(p,[o],o.dtype),f=new SW(d),m=n.runWebGLProgram(f,[r,h],o.dtype);return n.disposeIntermediateTensorInfo(h),m}},NW={kernelName:jm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:a,output:o}=t,i=a;KM([a,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=s,p=zv(i.shape,u,l,1,c,d),h=new AV(p,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),m=new _W(p),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}},$W={kernelName:Um,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=t,u=n;Ih(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const l=[1,1];Ih(Hv(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const c=zv(s.shape,r,a,l,o),[d,p]=function(e,t,n,s){let r=new AV(n,"max",!1);const a=s.runWebGLProgram(r,[e],"float32");return r=new AV(n,"max",!0,!0,t),[a,s.runWebGLProgram(r,[e],"float32")]}(s,i,c,u);return[d,p]}},TW={kernelName:Gm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{keepDims:r,axis:a}=t,o=n,i=s.shape.length,u=Oh(a,s.shape);let l=u;const c=Yx(l,i),d=null!=c,p=o.shouldExecuteOnCPU([s]),h=[];let f=s;if(d){if(p){const e=o.texData.get(f.dataId).values,t=new Array(i);for(let r=0;r<t.length;r++)t[r]=s.shape[c[r]];const n=nP(e,s.shape,s.dtype,c,t);f=o.makeTensorInfo(t,s.dtype),o.texData.get(f.dataId).values=n}else f=HP(s,c,o);h.push(f),l=Jx(l.length,i)}Zx("sum",l,i);const[m,g]=Kx(f.shape,l);let b=m;r&&(b=Xx(m,u));const y=function(e,t,n,s){const r=Nh(t),a=PP({inputs:{x:e},attrs:{shape:[Nh(e.shape)/r,r]},backend:s}),o=WP(a,"float32","mean",s),i=PP({inputs:{x:o},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(o),i}(f,g,b,o);for(const v of h)o.disposeIntermediateTensorInfo(v);return y}},AW={kernelName:Hm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,u=Oh(a,r.shape);let l=u;const c=Yx(l,i);let d=r;null!=c&&(d=ZP({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Jx(l.length,r.shape.length)),Zx("min",l,i);const[p,h]=Kx(d.shape,l),f=PP({inputs:{x:d},backend:n,attrs:{shape:[-1,Nh(h)]}}),m=WP(f,f.dtype,"min",n);let g;return g=PP(o?{inputs:{x:m},backend:n,attrs:{shape:Xx(p,u)}}:{inputs:{x:m},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},RW=FP({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:jL}),FW={kernelName:Km,backendName:"webgl",kernelFunc:RW};class DW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=CL(s),a=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===n?0:1;this.userCode=1!==s?`\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class OW{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=CL(s),a=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=aP("rc",s),u=aP("source",s),l=`${i[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${u.slice(-2).join()})`,d="reflect"===n?0:1;let p="";if(1===s){const e=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[s-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[s-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${i[s-2]} += 1;\n        if(${i[s-2]} < ${this.outputShape[s-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${i[s-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${a});\n      const ${r} end = ${r}(${o});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const qW={kernelName:Xm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s}=e,{paddings:r,mode:a}=n,o=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new OW(s.shape,r,a):new DW(s.shape,r,a);return t.runWebGLProgram(o,[s],s.dtype)}},zW=FP({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),MW={kernelName:Zm,backendName:"webgl",kernelFunc:zW};class LW{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const PW=FP({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),VW={kernelName:sm,backendName:"webgl",kernelFunc:PW},jW="return a - b;",BW=FP({opSnippet:jW,packedOpSnippet:jW,supportsComplex:!0,cpuKernelImpl:JL}),WW={kernelName:Wg,backendName:"webgl",kernelFunc:BW};function UW(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:a}=s,o=Oh([a],r.shape),i=vW({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),u=Xx(i.shape,o),l=PP({inputs:{x:i},backend:n,attrs:{shape:u}}),c=BW({inputs:{a:r,b:l},backend:n}),d=pB({inputs:{x:c},backend:n}),p=KP({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=PP({inputs:{x:p},backend:n,attrs:{shape:u}}),f=PW({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}const GW={kernelName:zg,backendName:"webgl",kernelFunc:UW},HW={kernelName:Ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:a,seed:o,normalized:i}=s,u=i?r:UW({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=new LW(u.shape[0],u.shape[1],a),c=l.getCustomSetupFunc(o),d=n.runWebGLProgram(l,[u],"int32",c);return i||n.disposeIntermediateTensorInfo(u),d}},KW="return -x;",XW={kernelName:Jm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])){const e=n.texData.get(s.dataId),[t,r]=WL(e.values,s.shape,s.dtype);return n.makeTensorInfo(r,s.dtype,t)}let r;return r=af().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mP(s.shape,KW):new pP(s.shape,KW),n.runWebGLProgram(r,[s],s.dtype)}},ZW=dk,YW={kernelName:tg,backendName:"webgl",kernelFunc:function(e){gC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=s,l=n.readSync(r.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=ZW(l,c,o,i,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},QW=pk,JW={kernelName:ng,backendName:"webgl",kernelFunc:function(e){gC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=s,c=n.readSync(r.dataId),d=n.readSync(a.dataId),{selectedIndices:p,validOutputs:h}=QW(c,d,o,i,u,l);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},eU=hk,tU={kernelName:sg,backendName:"webgl",kernelFunc:function(e){gC("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=s,c=n.readSync(r.dataId),d=n.readSync(a.dataId),p=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:b}=eU(c,d,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class nU{constructor(e,t,n,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const sU={kernelName:ag,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{depth:a,onValue:o,offValue:i}=s,u=Nh(r.shape),l=new nU(u,a,o,i),c=PP({inputs:{x:r},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(l,[c],r.dtype);n.disposeIntermediateTensorInfo(c);const p=PP({inputs:{x:d},backend:n,attrs:{shape:[...r.shape,a]}});return n.disposeIntermediateTensorInfo(d),p}};function rU(e){const{inputs:t,backend:n}=e,{x:s}=t;if("complex64"===s.dtype){const e=QV({inputs:{input:s},backend:n}),t=rU({inputs:{x:e},backend:n}),r=hj({inputs:{input:s},backend:n}),a=rU({inputs:{x:r},backend:n}),o=IP({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}return CB({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:n})}const aU={kernelName:eb,backendName:"webgl",kernelFunc:rU},oU={kernelName:rg,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=QV({inputs:{input:r},backend:s}),n=e({inputs:{x:t},backend:s}),a=hj({inputs:{input:r},backend:s}),o=rU({inputs:{x:a},backend:s}),i=IP({inputs:{real:n,imag:o},backend:s});return s.disposeIntermediateTensorInfo(t),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(o),i}return CB({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:s})}},iU={kernelName:og,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return fB({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const a=t[0].shape,o=t[0].dtype;t.forEach(e=>{_h(a,e.shape,"All tensors passed to stack must have matching shapes"),Ih(o===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=gj({inputs:t.map(e=>{const t=fB({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t}),backend:n,attrs:{axis:r}});return i.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};class uU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=CL(s),a=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${o});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${o};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class lU{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,r=CL(s),a=t.map(e=>e[0]).join(","),o=t.map((t,n)=>t[0]+e[n]).join(","),i=aP("rc",s),u=aP("source",s),l=`${i[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${u.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${i[s-1]} += 1;\n       if(${l}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${i[s-2]} += 1;\n       if(${i[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${i[s-1]} += 1;\n         if(${l}) {`],p=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let f=0,m=1===s?2:4;f<m;f++)h+=`\n        ${d[f]}\n        if (${p}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;h+=1===s?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${a});\n      const ${r} end = ${r}(${o});\n      uniform float value;\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}const cU=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:a,constantValue:o}=s,i=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lU(r.shape,a,o):new uU(r.shape,a,o),u=i.getCustomSetupFunc(o);return n.runWebGLProgram(i,[r],r.dtype,u)},dU={kernelName:ig,backendName:"webgl",kernelFunc:cU},pU=FP({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),hU={kernelName:ug,backendName:"webgl",kernelFunc:pU},fU={kernelName:cg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,u=[],l=Oh(a,r.shape);let c=l;const d=Yx(c,i);let p,h=r;if(null!=d&&(h=ZP({inputs:{x:r},backend:n,attrs:{perm:d}}),c=Jx(c.length,i),u.push(h)),Zx("prod",c,i),n.shouldExecuteOnCPU([h])){const e=n.texData.get(h.dataId).values,{outVals:t,outShape:s,outDtype:r}=UL(h.shape,h.dtype,e,c);p=n.makeTensorInfo(s,r,t)}else{const[e,t]=Kx(h.shape,c),s=Nh(t),a=PP({inputs:{x:h},backend:n,attrs:{shape:[-1,s]}}),o=WP(a,Vb(r.dtype),"prod",n);p=PP({inputs:{x:o},backend:n,attrs:{shape:e}}),u.push(a),u.push(o)}if(o){u.push(p);const e=Xx(p.shape,l);p=PP({inputs:{x:p},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}},mU=e=>{const{backend:t,attrs:n}=e,{start:s,stop:r,step:a,dtype:o}=n,i=GL(s,r,a,o);return t.makeTensorInfo([i.length],o,i)},gU={kernelName:dg,backendName:"webgl",kernelFunc:mU},bU=RP({opSnippet:"return 1.0 / x;"}),yU={kernelName:hg,backendName:"webgl",kernelFunc:bU},vU=RP({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),xU={kernelName:fg,backendName:"webgl",kernelFunc:vU},wU=RP({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),kU={kernelName:xg,backendName:"webgl",kernelFunc:wU};class CU{constructor(e,t,n,s,r){this.variableNames=["A"],this.outputShape=[];const[a,o,i,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?o-1:o,s&&n>1?i-1:i],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class IU{constructor(e,t,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,i,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?o-1:o,s&&n>1?i-1:i],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const _U={kernelName:yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s,[u,l]=i,c=af().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new IU(r.shape,u,l,a,o):new CU(r.shape,u,l,a,o);return n.runWebGLProgram(c,[r],"float32")}};class SU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,r]=t,[,a,o]=e,i=[n&&a>1?s-1:s,n&&o>1?r-1:r],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const EU={kernelName:vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:o}=s,i=new SU(a.shape,r.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}};class NU{constructor(e,t,n,s,r){this.variableNames=["A"],this.outputShape=[];const[a,o,i,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?o-1:o,s&&n>1?i-1:i],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let d;d=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class $U{constructor(e,t,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,i,u]=e;this.outputShape=[a,t,n,u];const l=[s&&t>1?o-1:o,s&&n>1?i-1:i],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let d;d=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const TU={kernelName:gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s,[u,l]=i,c=af().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new $U(r.shape,u,l,a,o):new NU(r.shape,u,l,a,o);return n.runWebGLProgram(c,[r],r.dtype)}};class AU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,r]=t,[,a,o]=e,i=[n&&a>1?s-1:s,n&&o>1?r-1:r],u=[n&&a>1?a-1:a,n&&o>1?o-1:o],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const RU={kernelName:bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:a}=t,{alignCorners:o}=s,i=new AU(a.shape,r.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}};class FU{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const s=e.map((n,s)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(s)).join(","),r=CL(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class DU{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const s=aP("rc",n),r=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,o=CL(n);function i(n){const s=e.map((s,r)=>function(n,s){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${s[n]} - 1`:`${s[n]}`}(r,n));return`getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return i(e)}(s.slice())};\n          if(${r}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(s.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const OU={kernelName:wg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:a}=s,o=r.shape.length,i=Oh(a,r.shape);if(0===o)return kP({inputs:{x:r},backend:n});const u=af().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new DU(r.shape,i):new FU(r.shape,i);return n.runWebGLProgram(u,[r],r.dtype)}};class qU{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];const n=e[1],s=e[2];this.outputShape=e;let r="";r="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(e,t,n,s){return(r,a)=>{null==this.paramsLoc&&(this.paramsLoc=r.getUniformLocationNoThrow(a,"params")),r.gl.uniform4f(this.paramsLoc,e,t,n,s)}}}const zU={kernelName:nb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e,{radians:r,fillValue:a,center:o}=t,i=n,u=new qU(s.shape,a),[l,c]=Qk(o,s.shape[1],s.shape[2]),d=u.getCustomSetupFunc(l,c,Math.sin(r),Math.cos(r));return i.runWebGLProgram(u,[s],s.dtype,d)}},MU=RP({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),LU={kernelName:kg,backendName:"webgl",kernelFunc:MU},PU=RP({opSnippet:"return inversesqrt(x);",cpuKernelImpl:HL}),VU={kernelName:Cg,backendName:"webgl",kernelFunc:PU};class jU{constructor(e,t,n,s,r,a,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const i=CL(r.length),u=CL(a.length);let l="";1===n?l="i":2===n&&(l="i, j");let c="";1===s?c="i":2===s&&(c="i, coords[1]"),this.userCode=`\n        ${i} strides = ${i}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${l}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const BU={kernelName:Ig,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:a}=t,{shape:o}=s,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:d}=iC(0,r,o),p=[d/l,l];if(0===d)return n.makeTensorInfo(o,r.dtype);const h=PP({inputs:{x:r},backend:n,attrs:{shape:[u,i]}}),f=PP({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new jU(u,i,h.shape.length,f.shape.length,c,p),b=n.runWebGLProgram(g,[f,h,m],f.dtype),y=PP({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class WU{constructor(e,t,n){let s,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",s="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],o=[];for(let s=0;s<t.length;s++)o.push(`${n[s]}`),s<e&&a.push(`${n[s]}`);s=a.join(),r=o.join()}const a=CL(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const UU={kernelName:_g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:a}=t,o=new WU(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[s,r,a],Pb(r.dtype,a.dtype))}},GU=RP({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${uC};\n  float scale = ${lC};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),HU={kernelName:Sg,backendName:"webgl",kernelFunc:GU},KU=RP({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),XU={kernelName:Ag,backendName:"webgl",kernelFunc:KU},ZU=RP({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),YU={kernelName:Tg,backendName:"webgl",kernelFunc:ZU},QU=RP({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),JU={kernelName:Ng,backendName:"webgl",kernelFunc:QU},eG=RP({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),tG={kernelName:$g,backendName:"webgl",kernelFunc:eG},nG=RP({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),sG={kernelName:Rg,backendName:"webgl",kernelFunc:nG},rG={kernelName:Og,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:a,paddings:o}=s;Ih(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((e,t)=>e*t),u=[[0,0]];u.push(...o);for(let b=1+a.length;b<r.shape.length;++b)u.push([0,0]);const l=[],c=cU({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),d=Jk(c.shape,a,i,!1),p=eC(d.length,a.length,!1),h=tC(c.shape,a,i,!1),f=PP({inputs:{x:c},backend:n,attrs:{shape:d}}),m=ZP({inputs:{x:f},backend:n,attrs:{perm:p}}),g=PP({inputs:{x:m},backend:n,attrs:{shape:h}});return l.push(c),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},aG={kernelName:Mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:a,defaultValue:o}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=n.readSync(s.dataId),u=n.readSync(r.dataId),l=n.readSync(a.dataId),c=n.readSync(o.dataId)[0],[d,p,h,f,m]=ZL(i,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(p,s.dtype,d),n.makeTensorInfo([p[0]],r.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}},oG={kernelName:Lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(n.readSync(r.dataId)),i=n.readSync(s.dataId),u=Array.from(n.readSync(a.dataId)),[l,c,d]=YL(i,s.shape,s.dtype,o,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}},iG={kernelName:Pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:a,defaultValue:o}=t,{outputShape:i}=s,{sliceRank:u,numUpdates:l,strides:c,outputSize:d}=iC(0,r,i),p=new jU(l,u,r.shape.length,a.shape.length,c,[d,1],!1),h=n.runWebGLProgram(p,[a,r,o],a.dtype),f=PP({inputs:{x:h},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),f}},uG={kernelName:qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:a,axis:o}=s,i=Oh(o,r.shape)[0],u=FC(r,a,i),l=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(e=>{const t=[...c];t[i]=e;const s=GV({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,s})}},lG=RP({opSnippet:"return sqrt(x);"}),cG={kernelName:Fg,backendName:"webgl",kernelFunc:lG},dG={kernelName:jg,backendName:"webgl",kernelFunc:RP({opSnippet:"return x * x;"})},pG="return (a - b) * (a - b);",hG=FP({opSnippet:pG,packedOpSnippet:pG}),fG={kernelName:Vg,backendName:"webgl",kernelFunc:hG},mG={kernelName:tb,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:s}=e,r=new pP(s.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(r,[s],s.dtype)}};class gG{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const s=n.length,r=CL(n.length),a=CL(n.length);let o="";if(1===s)o="coords * strides + begin";else{let e=0;o=n.map((t,s)=>(e++,1===n.length?`coords * strides[${s}] + begin[${s}]`:`coords[${e-1}] * strides[${s}] + begin[${s}]`)).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}const bG={kernelName:Bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=s,{nonStrided:h,$begin:f,$strides:m,size:g,newShape:b,outShape:y}=yv(r.shape,a,o,i,u,l,c,d,p),v=PP({inputs:{x:r},backend:n,attrs:{shape:b}});let x;if(h){const e=GV({inputs:{x:v},backend:n,attrs:{begin:f,size:g}});x=PP({inputs:{x:e},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(e)}else if(y.some(e=>0===e))x=n.makeTensorInfo(y,r.dtype,[]);else if(n.shouldExecuteOnCPU([v])){const e=n.texData.get(v.dataId),t=Wy(v.shape,v.dtype,e.values),s=QL(y,t,m,f);x=n.makeTensorInfo(y,v.dtype,s.values)}else{const e=new gG(f,m,y);x=n.runWebGLProgram(e,[v],v.dtype)}const w=PP({inputs:{x:x},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(x),w}},yG=RP({opSnippet:"return tan(x);"}),vG={kernelName:Ug,backendName:"webgl",kernelFunc:yG},xG=RP({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),wG={kernelName:Gg,backendName:"webgl",kernelFunc:xG};class kG{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const s=CL(this.rank),r=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<e.length;r++)s.push(`imod(${n[r]}, ${e[r]})`);return s.join()}(e);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function CG(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:a}=s;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map(e=>yb(e)):e,s=Wy(r.shape,r.dtype,t),o=eP(s,a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new kG(r.shape,a);return n.runWebGLProgram(o,[r],r.dtype)}const IG={kernelName:Hg,backendName:"webgl",kernelFunc:CG},_G={kernelName:Kg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:a,sorted:o}=s,i=n.readSync(r.dataId),[u,l]=tP(i,r.shape,r.dtype,a,o);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};class SG{constructor(e,t,n,s,r,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o="nearest"===n?1:2;let i;switch(s){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const EG={kernelName:Xg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=s,[c,d,p,h]=r.shape,[f,m]=null!=l?l:[d,p],g=new SG(d,p,o,i,u,[c,f,m,h]);return n.runWebGLProgram(g,[r,a],"float32")}},NG={kernelName:Yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:a}=t;KM(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(a.dataId),{outputValues:i,outputShape:u,indices:l}=sP(o,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,i),s.makeTensorInfo([l.length],"int32",l)]}},$G={kernelName:Qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const o=r,i=o.shape.length,u=r.shape[a],l=new Array(i-1);let c=0;for(let m=0;m<i;m++)m!==a&&(l[c++]=o.shape[m]);const d=[],p=new Array(i).fill(0),h=o.shape.slice();h[a]=1;const f=new Array(u);for(let m=0;m<f.length;m++){p[a]=m;const e=GV({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),t=PP({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,d.push(e)}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class TG{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,s=e.batchSize,r=e.inSize,a=e.numSegments,o=a*Math.ceil(r/n);this.outputShape=[s,o];const i=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let d="";r%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const AG=[gW,yW,JP,tV,sV,aV,uV,dV,pV,hV,vV,xV,kV,IV,NV,SV,TV,DV,FV,zV,MV,LV,jV,KV,XV,ej,sj,oj,lj,_P,bj,Nj,$j,Cj,Aj,Rj,Tj,Dj,qj,Mj,jj,Bj,Uj,Yj,Qj,Kj,eB,nB,sB,aB,oB,uB,cB,hB,mB,yB,wB,IB,SB,$B,AB,DB,qB,zB,LB,VB,BB,UB,CP,GB,fj,KB,ZB,QB,NP,eW,nW,sW,iW,aW,lW,dW,hW,xW,IW,CW,EW,NW,$W,kW,TW,AW,FW,qW,MW,HW,LP,XW,YW,JW,tU,YV,sU,oU,iU,dU,hU,AP,fU,gU,JV,VW,yU,kU,xU,VP,_U,EU,TU,RU,OU,zU,LU,VU,BU,UU,HU,XU,YU,JU,tG,HV,GW,sG,rG,aG,oG,iG,uG,cG,dG,fG,mG,bG,WW,XP,vG,wG,IG,_G,EG,YP,NG,$G,{kernelName:Jg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:a}=t,{numSegments:o}=s,i=r.shape.length,u=[];let l=0;const c=Yx([l],i);let d=r;null!=c&&(d=ZP({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(d),l=Jx(1,i)[0]);const p=OC(d.shape,l,o),h=Nh([d.shape[l]]),f=PP({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});u.push(f);const m=Vb(r.dtype),g=(e,t,s,r,a)=>{const o=e.shape[0],i=e.shape[1],l=DC(i,a),c=new TG({windowSize:l,inSize:i,batchSize:o,numSegments:a},t),d=n.compileAndRun(c,[e,s],r);if(u.push(d),d.shape[1]===a)return d;const p=mU({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),h=CG({inputs:{x:p},backend:n,attrs:{reps:[i/l]}});return u.push(p),u.push(h),g(d,t,h,r,a)},b=PP({inputs:{x:g(f,"unsortedSegmentSum",a,m,o)},backend:n,attrs:{shape:p}});let y=b;if(null!=c){u.push(b);const e=Qx(c);y=ZP({inputs:{x:y},backend:n,attrs:{perm:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},aU];for(const iK of AG)db(iK);let RG=(()=>{class e{constructor(){}loadModel(){var e=this;return bh(function*(){e.encoderModel=yield Q$("assets/encoder/model.json"),e.decoderModel=yield Q$("assets/decoder/model.json");const t=yield fetch("assets/tokenizer.json").then(e=>e.json());e.tokenizer=t.tokenizer,e.maxLenAnswers=t.maxlen_answers,e.maxLenQuestions=t.maxlen_questions})()}createEncoderModel(e){return bh(function*(){const t=e.input,n=e.getLayer(null,4).output;if(Array.isArray(n)){const[e,s,r]=n;return Y$({inputs:t,outputs:[s,r]})}throw new Error("La capa LSTM no devolvi\xf3 m\xfaltiples salidas.")})()}createDecoderModel(e){return bh(function*(){const t=J$({shape:[null],name:"decoder_inputs"}),n=[J$({shape:[200],name:"input_3"}),J$({shape:[200],name:"input_4"})],s=e.getLayer(null,3).apply(t),r=e.getLayer(null,5).apply([s,...n]),[a,o,i]=r,u=e.getLayer(null,6).apply(a),l=[o,i];return Y$({inputs:[t,...n],outputs:[u,...l]})})()}preprocessInput(e){const t=e.toLowerCase().split(" ").map(e=>this.tokenizer.word_index[e]||0),n=new Array(this.maxLenQuestions).fill(0);return t.slice(0,this.maxLenQuestions).forEach((e,t)=>{n[t]=e}),Fw([n],[1,this.maxLenQuestions])}decodeSequence(e){var t=this;return bh(function*(){const n=t.preprocessInput(e),s=t.encoderModel.predict(n);let r=Fw([[t.tokenizer.word_index.start]],[1,1]),a=uw(r,[[0,0],[0,t.maxLenAnswers-r.shape[1]]],0),o=!1,i="";for(;!o;){console.log("first padded ->",a);const[e,n,u]=t.decoderModel.predict([a,...s]);console.log("decoutputs -----\x3e",e,n,u);const l=yield e.argMax(-1).data();console.log("array --------\x3e",l);const c=l[0];let d=null;for(const[s,r]of Object.entries(t.tokenizer.word_index))if(c===r){i+=` ${s}`,d=s;break}console.log("sampled_word ->",d),("end"===d||i.split(" ").length>t.maxLenAnswers||0===c)&&(o=!0),r.dispose(),r=Fw([[c]],[1,1],"int32"),a.dispose(),a=uw(r,[[0,0],[0,t.maxLenAnswers-r.shape[1]]],0),s[0].dispose(),s[1].dispose(),s[0]=n,s[1]=u,e.dispose()}return i.replace(" end","").trim()})()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();const FG=JSON.parse('[{"input":"hola","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"bien","output":["me alegra saberlo, dime en que puedo ayudarte, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte ","que alegria, puedo ayudarte en distintos temas, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte","me alegra escuchar eso, puedo ayudarte sobre temas como IA, servidores, programacion"]},{"input":"buenas","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"hey","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"como estas","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"todo bien","output":["estoy bien gracias por preguntar","todo bien, y tu?","me alegra escuchar eso"]},{"input":"adios","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"nos vemos","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"buenos dias","output":["buenos dias espero que tengas un excelente dia","hola como estas en este dia"]},{"input":"buenas tardes","output":["buenas tardes en que puedo ayudarte","que tal tu tarde, como puedo ayudarte?"]},{"input":"buenas noches","output":["buenas noches que descanses","dulces sue\xf1os, hasta ma\xf1ana"]},{"input":"como te llamas","output":["soy un asistente virtual pero puedes llamarme bot","me llamo bot, tu asistente"]},{"input":"tienes algun nombre","output":["soy un asistente virtual pero puedes llamarme bot","me llamo bot, tu asistente"]},{"input":"quien eres","output":["soy un asistente virtual pero puedes llamarme bot","me llamo bot, tu asistente"]},{"input":"que puedes hacer","output":["puedo responder preguntas, darte informacion y ayudarte en lo que necesites, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte","estoy aqui para resolver tus dudas y ayudarte en lo que necesites, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte","puedo ayudarte en temas de IA, programacion, puedo ayudarte sobre temas como IA, servidores, programacion, motivarte o inspirarte"]},{"input":"gracias","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"perdon","output":["no te preocupes todo esta bien","no hay problema, como puedo ayudarte?"]},{"input":"lo siento","output":["no pasa nada, como puedo ayudarte?","no te preocupes, estoy aqui para ayudarte"]},{"input":"que hora es","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"dime la hora","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"que dia es hoy","output":["hoy es un gran dia, como puedo ayudarte?","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"ayuda","output":["por supuesto dime que necesitas y vere como ayudarte, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte","estoy aqui para lo que necesites, dime como puedo ayudarte, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte","puedo ayudarte en temas de IA, programacion, algo curioso, chistes, motivarte o inspirarte","puedo ayudarte en temas de IA, programacion y ciencia","puedo ayudarte sobre temas como IA, servidores, programacion, motivarte o inspirarte","puedo ayudarte sobre temas como IA, bucles, devops, programacion, motivarte o inspirarte"]},{"input":"estoy triste","output":["lo siento mucho si necesitas hablar o apoyo estoy aqui","te entiendo, no estas solo, cuentame mas"]},{"input":"estoy feliz","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"cuentame un chiste","output":["por que los pajaros no usan facebook porque ya tienen twitter","que hace una abeja en el gimnasio zumba"]},{"input":"que son los pajaros","output":["los pajaros son animales voladores que tienen plumas y pico","los pajaros son animales que vuelan y tienen plumas"]},{"input":"que es un pajaro","output":["un pajaro es un animal volador que tiene plumas y pico","un pajaro es un animal que vuela y tienen pluma"]},{"input":"que es facebook","output":["facebook es una red social donde las personas pueden compartir contenido interactuar y conectar"]},{"input":"que es una red social","output":["una red social es una plataforma digital donde las personas pueden interactuar compartir ideas contenido y comunicarse entre si"]},{"input":"que son las redes sociales","output":["las redes sociales son plataformas digitales que permiten a los usuarios conectarse compartir contenido y comunicarse entre ellos"]},{"input":"que son las personas","output":["las personas son seres humanos que poseen capacidades de pensamiento razonamiento y comunicacion"]},{"input":"que significa compartir","output":["compartir significa poner algo a disposicion de otros para que lo usen o disfruten en conjunto"]},{"input":"que es conectar","output":["conectar es establecer una relacion o vinculo entre dos o mas elementos"]},{"input":"que significa conectar","output":["conectar significa unir o enlazar cosas personas o ideas para que interactuen o trabajen en conjunto"]},{"input":"que es twitter","output":["twitter es una plataforma donde los usuarios pueden publicar mensajes cortos llamados tweets"]},{"input":"por que los pajaros no usan facebook","output":["porque ya tienen twitter"]},{"input":"que hace una abeja en el gimnasio","output":["zumba"]},{"input":"que es la zumba","output":["la zumba es una actividad fisica que combina baile y ejercicio al ritmo de musica latina"]},{"input":"dime otro dato curioso","output":["sabias que los pulpos tienen tres corazones y su sangre es azul?","sabias que la miel nunca se echa a perder?"]},{"input":"dime otra cosa interesante","output":["sabias que los pulpos tienen tres corazones y su sangre es azul?","sabias que la miel nunca se echa a perder?"]},{"input":"que son las abejas","output":["las abejas son insectos polinizadores que juegan un papel crucial en el ecosistema y producen miel"]},{"input":"que es un pajaro","output":["un pajaro es un animal vertebrado con plumas alas y generalmente la capacidad de volar"]},{"input":"que son los animales vertebrados","output":["los animales vertebrados son aquellos que poseen columna vertebral y un esqueleto interno articulado"]},{"input":"que son las plumas","output":["las plumas son estructuras que recubren el cuerpo de las aves y cumplen funciones como la proteccion y el vuelo"]},{"input":"que son las alas","output":["las alas son extremidades de las aves adaptadas para el vuelo aunque no todas las aves pueden volar"]},{"input":"que es volar","output":["volar es el acto de desplazarse por el aire utilizando alas o mecanismos similares"]},{"input":"que tipos de pajaros existen","output":["existen muchos tipos de pajaros como las aves canoras las rapaces los acuaticos y los terrestres"]},{"input":"que comen los pajaros","output":["los pajaros pueden comer semillas insectos frutas o peque\xf1os animales dependiendo de la especie"]},{"input":"donde viven los pajaros","output":["los pajaros viven en diversos habitats como bosques selvas desiertos humedales y zonas urbanas"]},{"input":"que pajaros no pueden volar","output":["algunos pajaros que no pueden volar son el avestruz el pinguino y el kiwi"]},{"input":"que importancia tienen los pajaros","output":["los pajaros son importantes para el ecosistema porque ayudan a polinizar dispersar semillas y controlar poblaciones de insectos"]},{"input":"como se reproducen los pajaros","output":["los pajaros se reproducen mediante huevos que incuban hasta que las crias nacen"]},{"input":"por que las abejas van al gimnasio","output":["porque les gusta mantenerse activas mientras zumba"]},{"input":"que hacen los pajaros en redes sociales","output":["en este contexto los pajaros usan twitter como parte del chiste"]},{"input":"que es un gimnasio","output":["un gimnasio es un lugar donde las personas van a ejercitarse y mejorar su condicion fisica"]},{"input":"que es el nlp","output":["nlp significa procesamiento de lenguaje natural, una rama de la inteligencia artificial que se centra en la interaccion entre computadoras y humanos usando lenguaje natural","nlp se trata de ense\xf1ar a las maquinas a entender y responder en nuestro idioma"]},{"input":"dime algo interesante","output":["sabias que los pulpos tienen tres corazones y su sangre es azul?","sabias que la miel nunca se echa a perder?"]},{"input":"dime un dato curioso","output":["sabias que los pulpos tienen tres corazones y su sangre es azul?","sabias que la miel nunca se echa a perder?"]},{"input":"por que los pulpos tienen tres corazones","output":["los pulpos tienen tres corazones porque uno bombea sangre al resto del cuerpo y los otros dos la envian a las branquias para oxigenarla"]},{"input":"por que la sangre de los pulpos es azul","output":["la sangre de los pulpos es azul porque contiene hemocianina en lugar de hemoglobina lo que les ayuda a transportar oxigeno en ambientes de baja temperatura y poco oxigeno"]},{"input":"que otros animales tienen sangre azul","output":["otros animales con sangre azul son los cangrejos herradura los calamares y algunos moluscos"]},{"input":"que mas hace interesante a los pulpos","output":["los pulpos son animales extremadamente inteligentes tienen la capacidad de resolver problemas usar herramientas y camuflarse de manera impresionante"]},{"input":"por que la miel nunca se echa a perder","output":["la miel nunca se echa a perder debido a su bajo contenido de agua su acidez y la presencia de peroxido de hidrogeno que evita el crecimiento de bacterias y hongos"]},{"input":"que otros alimentos nunca se echan a perder","output":["otros alimentos que casi nunca se echan a perder incluyen la sal el azucar y el arroz si se almacenan correctamente"]},{"input":"como producen miel las abejas","output":["las abejas producen miel transformando el nectar de las flores mediante un proceso enzimatico y almacenandolo en panales"]},{"input":"que propiedades tiene la miel","output":["la miel tiene propiedades antibacterianas antioxidantes y energizantes ademas de ser un endulzante natural"]},{"input":"que animales producen miel","output":["ademas de las abejas otros animales como ciertas especies de hormigas y avispas tambien producen miel en menor cantidad"]},{"input":"que tipos de pulpos existen","output":["existen muchos tipos de pulpos como el pulpo comun el pulpo gigante del pacifico y el pulpo de anillos azules conocido por ser muy venenoso"]},{"input":"que comen los pulpos","output":["los pulpos comen crustaceos moluscos y peces pequenos cazandolos con sus tentaculos y su pico afilado"]},{"input":"donde viven los pulpos","output":["los pulpos viven en aguas tropicales y templadas alrededor del mundo desde arrecifes de coral hasta fondos marinos"]},{"input":"que importancia tienen los pulpos","output":["los pulpos son importantes para el ecosistema marino ya que controlan las poblaciones de sus presas y son presa de otros depredadores"]},{"input":"como se reproducen los pulpos","output":["los pulpos se reproducen mediante fecundacion interna el macho transfiere un espermatoforo a la hembra que lo almacena hasta que pone los huevos"]},{"input":"dime algo motivador","output":["nunca es tarde para perseguir tus sue\xf1os y lograr tus metas","los peque\xf1os pasos te llevan a grandes logros"]},{"input":"que significa nunca es tarde","output":["significa que siempre hay tiempo para comenzar algo nuevo y perseguir tus sue\xf1os sin importar la edad o las circunstancias"]},{"input":"que son los sue\xf1os","output":["los sue\xf1os son aspiraciones o metas que las personas desean alcanzar en su vida"]},{"input":"como puedo perseguir mis sue\xf1os","output":["puedes perseguir tus sue\xf1os estableciendo metas claras trabajando constantemente y manteniendote enfocado en lo que deseas lograr"]},{"input":"que significa lograr tus metas","output":["lograr tus metas significa alcanzar los objetivos que te has propuesto con esfuerzo dedicacion y perseverancia"]},{"input":"que significa los peque\xf1os pasos te llevan a grandes logros","output":["significa que incluso las acciones peque\xf1as y consistentes pueden llevarte a alcanzar grandes metas a largo plazo"]},{"input":"que son los grandes logros","output":["los grandes logros son resultados significativos que se obtienen despues de mucho esfuerzo y dedicacion"]},{"input":"como puedo lograr grandes cosas","output":["puedes lograr grandes cosas trabajando con constancia manteniendo una actitud positiva y aprendiendo de los desafios"]},{"input":"por que es importante ser perseverante","output":["ser perseverante es importante porque te permite superar obstaculos y mantenerte en el camino hacia tus metas"]},{"input":"como mantenerse motivado","output":["puedes mantenerte motivado recordando tus metas celebrando peque\xf1os avances y rodeandote de personas que te apoyen"]},{"input":"que significa perseguir tus sue\xf1os","output":["perseguir tus sue\xf1os significa trabajar constantemente hacia aquello que deseas lograr en la vida"]},{"input":"holaaa","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"que onda","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"buenas noches a todos","output":["buenas noches que descanses","dulces sue\xf1os, hasta ma\xf1ana"]},{"input":"como va todo","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"que tal estas","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"todo en orden","output":["estoy bien gracias por preguntar","todo bien, y tu?"]},{"input":"hasta luego","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"nos vemos luego","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"hasta pronto","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"que tengas un buen dia","output":["adios cuidate","hasta luego","nos vemos"]},{"input":"muy buenas","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"gracias mil","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"muchisimas gracias","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"te agradezco mucho","output":["de nada siempre aqui para ayudarte","no hay de que","aqui estoy para lo que necesites"]},{"input":"lo lamento","output":["no pasa nada, como puedo ayudarte?","no te preocupes, estoy aqui para ayudarte"]},{"input":"que mal","output":["lo siento mucho si necesitas hablar o apoyo estoy aqui","te entiendo, no estas solo, quieres que te diga algo motivador?"]},{"input":"estoy decaido","output":["lo siento mucho si necesitas hablar o apoyo estoy aqui","te entiendo, no estas solo, quieres que te diga algo motivador?"]},{"input":"me siento bien","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"estoy animado","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"estoy de maravilla","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"me siento optimista","output":["que alegria escuchar eso, me hace feliz saber que estas bien","eso es genial, me encanta saberlo!"]},{"input":"que hora tienes","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"cual es la hora","output":["lo siento no puedo dar la hora exacta pero puedo ayudarte con otras cosas","no tengo un reloj, pero puedo ayudarte con otra cosa"]},{"input":"que dia tenemos","output":["hoy es un gran dia, como puedo ayudarte?","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"que dia es","output":["hoy es un gran dia, como puedo ayudarte?","hoy es un dia perfecto para aprender algo nuevo"]},{"input":"estas disponible","output":["claro que si estoy aqui para ayudarte","estoy disponible, dime en qu\xe9 puedo ayudarte"]},{"input":"sigues disponible","output":["claro que si estoy aqui para ayudarte","estoy disponible, dime en qu\xe9 puedo ayudarte"]},{"input":"me puedes ayudar","output":["por supuesto dime que necesitas y vere como ayudarte","estoy aqui para lo que necesites, dime como puedo ayudarte"]},{"input":"me ayudas","output":["por supuesto dime que necesitas y vere como ayudarte","estoy aqui para lo que necesites, dime como puedo ayudarte"]},{"input":"ayudame","output":["por supuesto dime que necesitas y vere como ayudarte, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte","estoy aqui para lo que necesites, dime como puedo ayudarte, estoy entrenado para temas de programacion, algo interesante, un chiste, motivarte o inspirarte","puedo ayudarte en temas de IA, programacion, algo curioso, chistes, motivarte o inspirarte","puedo ayudarte en temas de IA, programacion y ciencia"]},{"input":"cuanto es uno mas uno","output":["1 mas 1 es igual a 2","la respuesta es 2"]},{"input":"que es inteligencia artificial","output":["la inteligencia artificial es un campo que busca crear sistemas inteligentes","es la capacidad de una maquina para imitar procesos humanos como aprender y razonar"]},{"input":"que es un sistema inteligente","output":["un sistema inteligente es aquel que puede tomar decisiones autonomas basadas en informacion y analisis"]},{"input":"que significa aprender en inteligencia artificial","output":["en inteligencia artificial aprender significa que una maquina mejora su desempe\xf1o con base en datos y experiencias pasadas"]},{"input":"que significa razonar en inteligencia artificial","output":["razonar en inteligencia artificial significa usar logica para resolver problemas y tomar decisiones"]},{"input":"que tipos de inteligencia artificial existen","output":["existen tres tipos principales de inteligencia artificial inteligencia artificial estrecha general y superinteligencia"]},{"input":"que es inteligencia artificial estrecha","output":["la inteligencia artificial estrecha es aquella dise\xf1ada para realizar tareas especificas como reconocimiento de voz o imagen"]},{"input":"que es inteligencia artificial general","output":["la inteligencia artificial general es aquella capaz de realizar cualquier tarea intelectual que un ser humano puede realizar"]},{"input":"que es la superinteligencia","output":["la superinteligencia es una inteligencia artificial que supera la capacidad intelectual humana en todos los aspectos"]},{"input":"que es el aprendizaje automatico","output":["el aprendizaje automatico es un subcampo de la inteligencia artificial que permite a las maquinas aprender a partir de datos sin ser programadas explicitamente"]},{"input":"que es el aprendizaje profundo","output":["el aprendizaje profundo es una tecnica avanzada de aprendizaje automatico que utiliza redes neuronales para analizar grandes cantidades de datos"]},{"input":"que son las redes neuronales","output":["las redes neuronales son modelos computacionales inspirados en el cerebro humano que se utilizan para procesar y analizar datos complejos"]},{"input":"como se utiliza la inteligencia artificial","output":["la inteligencia artificial se utiliza en diversos campos como la salud las finanzas la industria y el entretenimiento para optimizar procesos y tomar decisiones"]},{"input":"cuales son los riesgos de la inteligencia artificial","output":["los riesgos de la inteligencia artificial incluyen la perdida de empleos la falta de transparencia en las decisiones y el uso indebido de la tecnologia"]},{"input":"como afecta la inteligencia artificial a la sociedad","output":["la inteligencia artificial puede transformar la sociedad al mejorar la eficiencia de procesos pero tambien plantea desafios eticos y sociales"]},{"input":"que es un robot","output":["un robot es una maquina programable que puede realizar tareas autonomas o semiautonomas"]},{"input":"que tipos de robots existen","output":["existen muchos tipos de robots como los industriales los domesticos los medicos y los autonomos"]},{"input":"que es un robot industrial","output":["un robot industrial es aquel que se utiliza en entornos de fabricacion para realizar tareas repetitivas y peligrosas"]},{"input":"que es un robot domestico","output":["un robot domestico es aquel que se utiliza en el hogar para realizar tareas como limpiar cocinar o entretener"]},{"input":"que es un robot medico","output":["un robot medico es aquel que se utiliza en entornos de salud para asistir en cirugias diagnosticos o rehabilitacion"]},{"input":"que es un robot autonomo","output":["un robot autonomo es aquel que puede operar de forma independiente sin intervencion humana"]},{"input":"que es la tecnologia","output":["la tecnologia es el conjunto de conocimientos tecnicos cientificos y metodologicos que permiten dise\xf1ar y crear bienes y servicios para satisfacer necesidades humanas"]},{"input":"que es la ciencia","output":["la ciencia es el conjunto de conocimientos sistematicos sobre el universo obtenidos mediante la observacion y experimentacion"]},{"input":"que es la tecnologia","output":["la tecnologia es el conjunto de conocimientos tecnicos cientificos y metodologicos que permiten dise\xf1ar y crear bienes y servicios para satisfacer necesidades humanas"]},{"input":"que es la ingenieria","output":["la ingenieria es la aplicacion de conocimientos cientificos y matematicos para resolver problemas y desarrollar tecnologias"]},{"input":"dime algo increible","output":["sabias que el corazon de una ballena azul puede pesar hasta 400 kilos?","sabias que los tiburones han existido por m\xe1s de 400 millones de a\xf1os?"]},{"input":"dime un dato increible","output":["sabias que el corazon de una ballena azul puede pesar hasta 400 kilos?","sabias que los tiburones han existido por m\xe1s de 400 millones de a\xf1os?"]},{"input":"dime un dato interesante","output":["sabias que el corazon de una ballena azul puede pesar hasta 400 kilos?","sabias que los tiburones han existido por m\xe1s de 400 millones de a\xf1os?"]},{"input":"dime un algo increible","output":["sabias que el corazon de una ballena azul puede pesar hasta 400 kilos?","sabias que los tiburones han existido por m\xe1s de 400 millones de a\xf1os?"]},{"input":"que es una ballena azul","output":["la ballena azul es el animal mas grande del planeta puede medir hasta 30 metros de largo y pesar mas de 150 toneladas"]},{"input":"por que el corazon de una ballena azul pesa tanto","output":["el corazon de una ballena azul pesa tanto porque necesita bombear sangre a un cuerpo enorme que puede alcanzar hasta 30 metros de largo"]},{"input":"que tan grande es una ballena azul","output":["una ballena azul puede medir hasta 30 metros de largo lo que equivale al tamano de un edificio de 10 pisos"]},{"input":"que es un tiburon","output":["un tiburon es un pez cartilaginoso depredador conocido por su capacidad de caza y su rol en el ecosistema marino"]},{"input":"por que los tiburones han existido por mas de 400 millones de a\xf1os","output":["los tiburones han existido por tanto tiempo debido a su adaptabilidad biologica su capacidad de caza y su resistencia a cambios ambientales"]},{"input":"que significa que un animal sea cartilaginoso","output":["un animal cartilaginoso es aquel cuyo esqueleto esta compuesto principalmente de cartilago en lugar de hueso"]},{"input":"que tan antiguos son los tiburones","output":["los tiburones han existido por mas de 400 millones de a\xf1os y son mas antiguos que los dinosaurios"]},{"input":"que comen los tiburones","output":["los tiburones comen una variedad de presas como peces calamares y focas dependiendo de la especie"]},{"input":"donde viven los tiburones","output":["los tiburones viven en todos los oceanos del mundo desde aguas superficiales hasta profundas y frias"]},{"input":"como afecta la desaparicion de los tiburones al ecosistema","output":["la desaparicion de los tiburones puede causar un desequilibrio en la cadena alimenticia marina afectando a otras especies y al ecosistema en general"]},{"input":"que importancia tienen las ballenas azules en el ecosistema","output":["las ballenas azules ayudan a mantener la salud del ecosistema marino al transportar nutrientes y contribuir al ciclo del carbono"]},{"input":"que tan rapido puede nadar una ballena azul","output":["una ballena azul puede nadar a velocidades de hasta 50 kilometros por hora cuando esta alarmada pero generalmente nada a 5 kilometros por hora"]},{"input":"como se comunican las ballenas azules","output":["las ballenas azules se comunican a traves de sonidos de baja frecuencia que pueden viajar miles de kilometros bajo el agua"]},{"input":"que otros animales son tan grandes como las ballenas azules","output":["ningun animal vivo es tan grande como la ballena azul pero otras especies grandes incluyen el calamar gigante y la ballena fin"]},{"input":"por que son importantes los tiburones","output":["los tiburones son importantes porque regulan las poblaciones de otras especies manteniendo el equilibrio en los ecosistemas marinos"]},{"input":"como sobreviven los tiburones en el oceano","output":["los tiburones sobreviven gracias a sus agudos sentidos cuerpos aerodinamicos y habilidades de caza adaptadas a diferentes ambientes marinos"]},{"input":"cuentame algo impactante","output":["sabias que el corazon de una ballena azul puede pesar hasta 400 kilos?","sabias que los tiburones han existido por m\xe1s de 400 millones de a\xf1os?"]},{"input":"que tan grande es el corazon de una ballena azul","output":["el corazon de una ballena azul puede pesar hasta 400 kilos y es tan grande que un humano podria arrastrarse a traves de sus arterias principales"]},{"input":"por que el corazon de una ballena azul es tan grande","output":["el corazon de una ballena azul es tan grande porque necesita bombear sangre a un cuerpo masivo que puede alcanzar hasta 30 metros de largo"]},{"input":"que tan grandes son las ballenas azules","output":["las ballenas azules pueden alcanzar hasta 30 metros de largo y pesar mas de 150 toneladas"]},{"input":"como funciona el corazon de una ballena azul","output":["el corazon de una ballena azul late muy lentamente y puede bombear grandes cantidades de sangre para oxigenar su enorme cuerpo"]},{"input":"que significa que los tiburones han existido por mas de 400 millones de a\xf1os","output":["significa que los tiburones han sobrevivido durante millones de a\xf1os adaptandose a cambios ambientales y evolucionando antes incluso que los dinosaurios"]},{"input":"como han sobrevivido los tiburones tanto tiempo","output":["los tiburones han sobrevivido tanto tiempo gracias a su adaptabilidad sentidos agudos y eficiencia como depredadores en el ecosistema marino"]},{"input":"que impacto tienen los tiburones en el ecosistema","output":["los tiburones son depredadores tope que ayudan a mantener el equilibrio en el ecosistema marino regulando las poblaciones de sus presas"]},{"input":"que otros animales han existido por millones de a\xf1os","output":["otros animales antiguos incluyen los cangrejos herradura las medusas y los nautilos que han sobrevivido por cientos de millones de a\xf1os"]},{"input":"como afectan las ballenas azules al ecosistema","output":["las ballenas azules contribuyen al ecosistema al transportar nutrientes y ayudar al ciclo del carbono en los oceanos"]},{"input":"por que es importante conservar a los tiburones","output":["es importante conservar a los tiburones porque su desaparicion desequilibraria la cadena alimenticia marina y afectaria a todo el ecosistema"]},{"input":"por que son impactantes las ballenas azules","output":["las ballenas azules son impactantes por su enorme tama\xf1o su canto que puede viajar miles de kilometros y su importancia ecologica"]},{"input":"que tan rapido pueden nadar las ballenas azules","output":["las ballenas azules pueden alcanzar velocidades de hasta 50 kilometros por hora cuando estan alarmadas pero generalmente nadan a 5 kilometros por hora"]},{"input":"cuales son las principales amenazas para los tiburones","output":["las principales amenazas para los tiburones incluyen la sobrepesca la caza furtiva y la destruccion de su habitat marino"]},{"input":"que tan antiguos son los tiburones comparados con los dinosaurios","output":["los tiburones son mas antiguos que los dinosaurios ya que existieron hace mas de 400 millones de a\xf1os mientras que los dinosaurios aparecieron hace unos 230 millones de a\xf1os"]},{"input":"inspirame","output":["nunca es tarde para perseguir tus sue\xf1os y lograr tus metas","los peque\xf1os pasos te llevan a grandes logros","si puedes so\xf1arlo, puedes lograrlo"]},{"input":"que significa nunca es tarde","output":["significa que siempre hay tiempo para comenzar algo nuevo y perseguir tus sue\xf1os sin importar las circunstancias"]},{"input":"que son los sue\xf1os","output":["los sue\xf1os son aspiraciones o metas que las personas desean alcanzar en la vida"]},{"input":"como puedo perseguir mis sue\xf1os","output":["puedes perseguir tus sue\xf1os estableciendo metas claras trabajando constantemente y enfrentando los desafios con determinacion"]},{"input":"que significa lograr tus metas","output":["lograr tus metas significa alcanzar los objetivos que te has propuesto mediante esfuerzo dedicacion y constancia"]},{"input":"que significa los peque\xf1os pasos te llevan a grandes logros","output":["significa que incluso las acciones peque\xf1as y consistentes pueden llevarte a alcanzar grandes metas a largo plazo"]},{"input":"que son los grandes logros","output":["los grandes logros son resultados significativos que se obtienen despues de mucho esfuerzo y perseverancia"]},{"input":"como puedo lograr grandes cosas","output":["puedes lograr grandes cosas trabajando con constancia manteniendo una actitud positiva y aprendiendo de los desafios"]},{"input":"que significa si puedes so\xf1arlo puedes lograrlo","output":["significa que si tienes la vision y el deseo de alcanzar algo puedes trabajar para hacerlo realidad"]},{"input":"como puedo mantenerme motivado","output":["puedes mantenerte motivado recordando tus objetivos celebrando tus logros y rodeandote de personas que te inspiren"]},{"input":"que significa inspirar","output":["inspirar significa motivar o influir positivamente en alguien para que alcance su maximo potencial"]},{"input":"por que es importante tener sue\xf1os","output":["es importante tener sue\xf1os porque te dan direccion motivacion y un sentido de proposito en la vida"]},{"input":"como puedo superar los obstaculos en mi camino","output":["puedes superar los obstaculos enfrentandolos con determinacion buscando soluciones y aprendiendo de cada experiencia"]},{"input":"que significa determinacion","output":["determinacion es la firmeza y la voluntad de seguir adelante para alcanzar tus metas a pesar de las dificultades"]},{"input":"que puedo hacer para empezar a perseguir mis sue\xf1os","output":["puedes empezar definiendo tus metas trazando un plan y tomando peque\xf1os pasos para acercarte a tus sue\xf1os"]},{"input":"dime algo positivo","output":["nunca es tarde para perseguir tus sue\xf1os y lograr tus metas","los peque\xf1os pasos te llevan a grandes logros","si puedes so\xf1arlo, puedes lograrlo"]},{"input":"que significa nunca es tarde","output":["significa que siempre hay tiempo para comenzar algo nuevo y perseguir tus sue\xf1os sin importar las circunstancias"]},{"input":"que significa algo positivo","output":["algo positivo es cualquier pensamiento accion o mensaje que te motive inspire o te haga sentir bien"]},{"input":"como puedo mantener una actitud positiva","output":["puedes mantener una actitud positiva enfocandote en lo bueno practicando la gratitud y rodeandote de personas que te apoyen"]},{"input":"que significa los peque\xf1os pasos te llevan a grandes logros","output":["significa que incluso las acciones peque\xf1as y consistentes pueden llevarte a alcanzar grandes metas a largo plazo"]},{"input":"que significa si puedes so\xf1arlo puedes lograrlo","output":["significa que si tienes la vision y el deseo de alcanzar algo puedes trabajar para hacerlo realidad"]},{"input":"como puedo ser mas optimista","output":["puedes ser mas optimista cambiando tus pensamientos negativos por positivos estableciendo metas alcanzables y celebrando tus logros"]},{"input":"por que es importante pensar en positivo","output":["es importante pensar en positivo porque mejora tu bienestar emocional te motiva y te ayuda a enfrentar desafios con confianza"]},{"input":"como influyen los pensamientos positivos en mi vida","output":["los pensamientos positivos te ayudan a reducir el estres mejorar tu salud y alcanzar tus metas con mayor facilidad"]},{"input":"que significa motivar","output":["motivar significa impulsar o inspirar a alguien para que logre algo o siga adelante"]},{"input":"que significa inspirar","output":["inspirar significa influir positivamente en alguien para que alcance su maximo potencial o logre algo significativo"]},{"input":"como puedo transmitir energia positiva a los demas","output":["puedes transmitir energia positiva mostrando amabilidad practicando la empatia y compartiendo mensajes alentadores"]},{"input":"que son los logros","output":["los logros son metas u objetivos alcanzados gracias al esfuerzo y la dedicacion"]},{"input":"holi","output":["hola como estas","hola que tal","buenos dias como estas"]},{"input":"como va tu dia","output":["todo bien, gracias por preguntar","todo marcha bien, y el tuyo?"]},{"input":"me siento raro","output":["lo siento mucho, \xbfquieres hablar de ello?, estoy entrenado para temas de programacion, chistes, motivarte, datos curiosos y quiza algo de IA / Ciencia","estoy aqu\xed para escucharte, estoy entrenado para temas de programacion, chistes, motivarte, datos curiosos y quiza algo de IA / Ciencia"]},{"input":"dime algo chistoso","output":["\xbfPor qu\xe9 no hay fantasmas gordos? Porque siempre est\xe1n en forma.","\xbfQu\xe9 le dice una impresora a otra? \xa1Esa hoja es tuya!"]},{"input":"por que no hay fantasmas gordos","output":["porque siempre estan en forma"]},{"input":"que significa estar en forma","output":["estar en forma significa tener buena condicion fisica y mantener un estilo de vida saludable"]},{"input":"que es un fantasma","output":["un fantasma es una figura o representacion sobrenatural generalmente asociada con espiritus de personas fallecidas"]},{"input":"por que los fantasmas son chistosos","output":["los fantasmas son chistosos en este contexto porque se usan en juegos de palabras o situaciones absurdas para provocar risa"]},{"input":"que le dice una impresora a otra","output":["esa hoja es tuya"]},{"input":"por que es chistoso lo que dicen las impresoras","output":["es chistoso porque es un juego de palabras que asocia la impresion de hojas con la expresion comun de responsabilidad"]},{"input":"que son los juegos de palabras","output":["los juegos de palabras son recursos linguisticos que aprovechan la ambiguedad o el doble sentido para crear humor"]},{"input":"que son las impresoras","output":["las impresoras son dispositivos que transfieren texto o imagenes a hojas de papel utilizando tinta o toner"]},{"input":"como funcionan las impresoras","output":["las impresoras funcionan transfiriendo tinta o toner a una hoja de papel para crear texto o imagenes"]},{"input":"que otros chistes de fantasmas conoces","output":["por que los fantasmas son malos mentirosos porque se les ve el plumero"]},{"input":"que otros chistes de impresoras conoces","output":["por que la impresora no puede salir de fiesta porque siempre esta ocupada haciendo copias"]},{"input":"cuentame algo divertido","output":["\xbfPor qu\xe9 los p\xe1jaros no usan computadoras? \xa1Porque tienen Twitter!","\xbfQu\xe9 hace un perro con un taladro? \xa1Taladrando!"]},{"input":"por que es chistoso el perro con el taladro","output":["es chistoso porque asocia una accion tipica de un humano con una situacion absurda y graciosa de un perro usando herramientas"]},{"input":"que son los perros","output":["los perros son animales domesticos conocidos por ser leales inteligentes y companeros de las personas"]},{"input":"como funcionan los taladros","output":["los taladros son herramientas electricas o manuales que se utilizan para perforar superficies como madera metal o concreto"]},{"input":"que otros chistes de pajaros conoces","output":["por que los pajaros no usan facebook porque ya tienen twitter"]},{"input":"que otros chistes de perros conoces","output":["que hace un perro cientifico descubre el hueso atomo"]},{"input":"que es machine learning","output":["es un subcampo de la inteligencia artificial que ense\xf1a a las computadoras a aprender patrones de los datos","machine learning es el proceso por el cual las m\xe1quinas pueden aprender y mejorar a partir de datos, sin ser programadas expl\xedcitamente"]},{"input":"que sabes sobre robots","output":["los robots son m\xe1quinas programables que pueden realizar tareas de manera aut\xf3noma o semiaut\xf3noma","un robot es un dispositivo que puede ser programado para realizar tareas espec\xedficas, algunas veces imitando comportamientos humanos"]},{"input":"estoy aburrido","output":["puedo contarte un chiste o un dato curioso, \xbfqu\xe9 prefieres?","\xbfQuieres que te cuente algo interesante o un chiste?"]},{"input":"me siento cansado","output":["descansa un poco, tu cuerpo y mente lo necesitan","es importante cuidar tu descanso, \xbfquieres que te motive o inspire?"]},{"input":"hablemos de ciencia","output":["claro, \xbfsab\xedas que la velocidad de la luz es de aproximadamente 299,792 km/s?","la ciencia es fascinante, \xbfsab\xedas que los \xe1tomos est\xe1n compuestos principalmente de espacio vac\xedo?"]},{"input":"que es la velocidad de la luz","output":["la velocidad de la luz es la rapidez con la que la luz viaja en el vacio alcanzando aproximadamente 299792 kilometros por segundo"]},{"input":"dime mas sobre la velocidad de la luz","output":["la velocidad de la luz es una constante universal y es fundamental en teorias como la relatividad de einstein ademas nada puede viajar mas rapido que la luz en el vacio"]},{"input":"como se mide la velocidad de la luz","output":["la velocidad de la luz se mide utilizando experimentos precisos que analizan el tiempo que tarda en recorrer una distancia conocida en el vacio"]},{"input":"que es un atomo","output":["un atomo es la unidad basica de la materia compuesto por protones neutrones y electrones"]},{"input":"por que los atomos estan compuestos de espacio vacio","output":["los atomos estan compuestos principalmente de espacio vacio porque los electrones orbitan el nucleo a grandes distancias relativas dejando mucho espacio entre ellos"]},{"input":"dime mas sobre los atomos","output":["los atomos son las piezas fundamentales que forman toda la materia en el universo y estan compuestos de particulas subatomicas como protones neutrones y electrones"]},{"input":"quien descubrio los atomos","output":["la idea del atomo fue propuesta por los filosofos griegos leucipo y democrito pero su estudio cientifico comenzo con john dalton en el siglo xix"]},{"input":"que significa que los atomos estan hechos de espacio vacio","output":["significa que la mayor parte de un atomo es espacio vacio ya que los electrones giran alrededor del nucleo dejando grandes espacios entre ellos"]},{"input":"que es la ciencia","output":["la ciencia es un metodo sistematico de adquirir conocimiento mediante observacion experimentacion y analisis para entender el mundo que nos rodea"]},{"input":"como influye la velocidad de la luz en la ciencia","output":["la velocidad de la luz es crucial en campos como la fisica moderna la astronomia y las telecomunicaciones ademas de ser la base de la teoria de la relatividad"]},{"input":"que significa que la ciencia es fascinante","output":["significa que la ciencia despierta curiosidad y asombro por su capacidad de explicar fenomenos complejos y descubrir los misterios del universo"]},{"input":"dime un dato interesante sobre los atomos","output":["sabias que si se eliminara el espacio vacio de todos los atomos que forman a los seres humanos toda la humanidad cabria en una cuchara"]},{"input":"que es el espacio vacio","output":["el espacio vacio es la region donde no hay materia o particulas pero en fisica cuantica puede contener energia o particulas virtuales"]},{"input":"que teorias dependen de la velocidad de la luz","output":["teorias como la relatividad especial y general de einstein dependen de la velocidad de la luz como un limite fundamental en el universo"]},{"input":"que aplicaciones tiene la velocidad de la luz","output":["la velocidad de la luz tiene aplicaciones en el dise\xf1o de telecomunicaciones satelites y sistemas gps asi como en el estudio del universo"]},{"input":"por que es importante la ciencia","output":["la ciencia es importante porque nos permite entender el mundo mejorar nuestra calidad de vida y resolver problemas globales"]},{"input":"como afecta el espacio vacio a la materia","output":["el espacio vacio en los atomos determina las propiedades de la materia como su densidad y estructura ademas permite que las particulas se muevan libremente"]},{"input":"dame datos curiosos","output":["\xbfSab\xedas que los delfines tienen nombres \xfanicos para identificarse entre ellos?","\xbfSab\xedas que las huellas dactilares de los koalas son tan parecidas a las humanas que pueden confundir a la polic\xeda?"]},{"input":"como se identifican los delfines","output":["los delfines se identifican mediante sonidos unicos similares a nombres que usan para reconocerse entre ellos"]},{"input":"que son los delfines","output":["los delfines son mamiferos marinos inteligentes que viven en grupos sociales y se comunican mediante sonidos y gestos"]},{"input":"como se comunican los delfines","output":["los delfines se comunican utilizando una combinacion de silbidos chasquidos y movimientos corporales"]},{"input":"por que los delfines tienen nombres unicos","output":["los delfines tienen nombres unicos para facilitar la identificacion en grupos y mantener una comunicacion eficiente"]},{"input":"que tan inteligentes son los delfines","output":["los delfines son considerados uno de los animales mas inteligentes del planeta capaces de resolver problemas y mostrar comportamientos sociales complejos"]},{"input":"que son las huellas dactilares","output":["las huellas dactilares son patrones unicos formados por las crestas de la piel en los dedos que son exclusivas de cada individuo"]},{"input":"que tan similares son las huellas dactilares de los koalas a las humanas","output":["las huellas dactilares de los koalas son tan similares a las humanas que pueden confundirse incluso bajo un microscopio"]},{"input":"que son los koalas","output":["los koalas son marsupiales que viven en australia conocidos por su dieta basada en hojas de eucalipto y su apariencia adorable"]},{"input":"por que los koalas tienen huellas dactilares","output":["los koalas tienen huellas dactilares para facilitar su agarre en arboles y su interaccion con el entorno"]},{"input":"que otros animales tienen huellas similares a las humanas","output":["ademas de los koalas no se conocen otros animales cuyas huellas dactilares sean tan similares a las humanas"]},{"input":"como afectan las huellas dactilares de los koalas a las investigaciones policiales","output":["las huellas dactilares de los koalas pueden confundir a la policia si accidentalmente aparecen en escenas de crimen en zonas donde habitan"]},{"input":"como viven los koalas","output":["los koalas viven en arboles de eucalipto donde pasan la mayor parte del tiempo descansando y comiendo hojas"]},{"input":"como son los grupos sociales de los delfines","output":["los delfines viven en grupos llamados manadas que tienen estructuras sociales complejas basadas en la comunicacion y la cooperacion"]},{"input":"que comen los delfines","output":["los delfines se alimentan principalmente de peces y calamares aunque su dieta puede variar segun el habitat"]},{"input":"que comen los koalas","output":["los koalas se alimentan casi exclusivamente de hojas de eucalipto que proporcionan tanto alimento como agua"]},{"input":"por que es importante conservar a los delfines","output":["es importante conservar a los delfines porque son especies clave en los ecosistemas marinos y su desaparicion podria afectar a otras especies"]},{"input":"por que es importante conservar a los koalas","output":["es importante conservar a los koalas porque son especies unicas y emblematicas de australia y su desaparicion podria afectar al ecosistema local"]},{"input":"como afecta la desaparicion de los delfines al ecosistema","output":["la desaparicion de los delfines podria causar desequilibrios en la cadena alimenticia marina y afectar a otras especies que dependen de ellos"]},{"input":"como afecta la desaparicion de los koalas al ecosistema","output":["la desaparicion de los koalas podria afectar a la biodiversidad y la salud de los bosques de eucalipto donde viven"]},{"input":"que importancia tienen los delfines en el ecosistema","output":["los delfines son especies clave en los ecosistemas marinos al regular las poblaciones de peces y calamares y mantener el equilibrio en los oceanos"]},{"input":"que importancia tienen los koalas en el ecosistema","output":["los koalas son importantes para la biodiversidad y la salud de los bosques de eucalipto al dispersar semillas y mantener el equilibrio en el ecosistema"]},{"input":"que tan inteligentes son los koalas","output":["los koalas son animales inteligentes que muestran comportamientos sociales y de supervivencia adaptativos en su entorno"]},{"input":"dime algo asombroso","output":["\xbfSab\xedas que el sol es tan grande que podr\xeda contener 1.3 millones de planetas Tierra?","\xbfSab\xedas que hay m\xe1s estrellas en el universo que granos de arena en todas las playas del mundo?"]},{"input":"que sabes sobre el universo","output":["el universo tiene miles de millones de galaxias, cada una con millones o miles de millones de estrellas","el universo est\xe1 en constante expansi\xf3n desde el Big Bang hace unos 13.8 mil millones de a\xf1os"]},{"input":"que es el universo","output":["el universo es el conjunto de todo lo que existe incluyendo galaxias estrellas planetas materia y energia"]},{"input":"que son las galaxias","output":["las galaxias son enormes agrupaciones de estrellas planetas polvo y gas que estan unidas por la gravedad"]},{"input":"cuantas galaxias hay en el universo","output":["se estima que hay miles de millones de galaxias en el universo observable"]},{"input":"que es una estrella","output":["una estrella es una esfera de plasma que emite luz y calor debido a reacciones nucleares en su nucleo"]},{"input":"cuantas estrellas hay en una galaxia","output":["el numero de estrellas en una galaxia puede variar pero generalmente hay millones o miles de millones de estrellas"]},{"input":"que significa que el universo esta en constante expansion","output":["significa que las galaxias se estan alejando unas de otras con el tiempo debido a la energia oscura que impulsa esta expansion"]},{"input":"que es el big bang","output":["el big bang es la teoria que explica el origen del universo como una expansion inicial ocurrida hace unos 13800 millones de a\xf1os"]},{"input":"que tan grande es el universo","output":["el universo observable tiene un diametro de aproximadamente 93000 millones de a\xf1os luz aunque su tama\xf1o total podria ser mucho mayor"]},{"input":"que es la energia oscura","output":["la energia oscura es una forma misteriosa de energia que se cree que esta impulsando la expansion acelerada del universo"]},{"input":"que es la materia oscura","output":["la materia oscura es una forma de materia que no emite luz ni energia pero cuya presencia se infiere por sus efectos gravitacionales"]},{"input":"como sabemos que el universo esta en expansion","output":["sabemos que el universo esta en expansion gracias al corrimiento al rojo observado en la luz de galaxias distantes"]},{"input":"que es el corrimiento al rojo","output":["el corrimiento al rojo es un fenomeno donde la luz de objetos que se alejan de nosotros se desplaza hacia longitudes de onda mas largas"]},{"input":"como se formaron las galaxias","output":["las galaxias se formaron a partir de nubes de gas y polvo que se colapsaron bajo su propia gravedad despues del big bang"]},{"input":"que tan antigua es la teoria del big bang","output":["la teoria del big bang fue propuesta por primera vez en los a\xf1os 1920 y se ha refinado con observaciones astronomicas modernas"]},{"input":"cual es el futuro del universo","output":["el futuro del universo depende de factores como la energia oscura y la materia oscura pero las teorias actuales sugieren que continuara expandiendose indefinidamente"]},{"input":"dame un consejo","output":["conf\xeda en ti mismo, eres capaz de lograr cosas incre\xedbles","cada peque\xf1o paso que tomes te lleva m\xe1s cerca de tus metas"]},{"input":"quiero aprender algo nuevo","output":["puedes aprender algo interesante sobre tecnolog\xeda o ciencia, \xbfpor d\xf3nde empezamos?","me encantar\xeda ayudarte a aprender, \xbfqu\xe9 tema te interesa?"]},{"input":"puedes darme informacion sobre IA","output":["claro, la inteligencia artificial es un campo que busca desarrollar sistemas capaces de realizar tareas que normalmente requieren inteligencia humana","la IA incluye subcampos como aprendizaje autom\xe1tico, procesamiento de lenguaje natural, y visi\xf3n por computadora"]},{"input":"me siento solo","output":["no est\xe1s solo, estoy aqu\xed para acompa\xf1arte","a veces todos necesitamos compa\xf1\xeda, cu\xe9ntame c\xf3mo puedo ayudarte"]},{"input":"puedes motivarme","output":["nunca te rindas, los grandes logros requieren tiempo y esfuerzo","cree en ti mismo, todo es posible si das lo mejor de ti"]},{"input":"cuentame algo inspirador","output":["la persistencia es la clave del \xe9xito, sigue intent\xe1ndolo","cada d\xeda es una nueva oportunidad para empezar de nuevo y lograr tus metas"]},{"input":"hola como estas","output":["estoy bien y tu"]},{"input":"buenos dias","output":["buenos dias como te sientes hoy"]},{"input":"hola que tal","output":["todo va bien por aqui y tu como estas"]},{"input":"hola todo bien","output":["si gracias como te va a ti"]},{"input":"hola me escuchas","output":["claro que si en que puedo ayudarte hoy"]},{"input":"buenas tardes","output":["buenas tardes espero que tengas un buen dia"]},{"input":"buenas noches","output":["buenas noches necesitas algo antes de dormir"]},{"input":"hey como te va","output":["hola todo bien por aqui y tu"]},{"input":"hola que haces","output":["hola estoy aqui esperando ayudarte"]},{"input":"hola que tal tu dia","output":["mi dia siempre es el mismo y el tuyo que tal va"]},{"input":"hola como va todo","output":["todo bien y tu como vas"]},{"input":"hola amigo como estas","output":["estoy bien gracias por preguntar y tu como estas"]},{"input":"hola que tal tu dia","output":["todo tranquilo y el tuyo como estuvo"]},{"input":"hola buenos dias como estas","output":["buenos dias estoy bien y tu como estas"]},{"input":"hola buenas tardes como te va","output":["buenas tardes todo bien y tu"]},{"input":"hola buenas noches como estas","output":["buenas noches estoy bien y tu como estas"]},{"input":"hola que tal amigo","output":["hola todo bien y tu amigo"]},{"input":"hola como te encuentras","output":["hola estoy bien y tu"]},{"input":"hola todo en orden","output":["si gracias todo en orden y contigo"]},{"input":"hola me puedes ayudar","output":["claro que si dime en que necesitas ayuda"]},{"input":"hola como te llamas","output":["hola soy un asistente virtual y tu como te llamas"]},{"input":"hola que me cuentas","output":["hola aqui listo para ayudarte y tu que cuentas"]},{"input":"hola hace tiempo que no hablamos","output":["hola si es verdad que gusto verte de nuevo"]},{"input":"hola que tal todo por ahi","output":["todo va bien y por ahi como va todo"]},{"input":"hola que tal como estas hoy","output":["hola estoy bien gracias por preguntar y tu como estas hoy"]},{"input":"hola tienes tiempo para hablar","output":["claro estoy aqui para ti dime en que te ayudo"]},{"input":"hola puedo preguntarte algo","output":["claro que si estoy aqui para responder tus preguntas"]},{"input":"hola que tal tu tarde","output":["mi tarde ha sido tranquila y la tuya que tal"]},{"input":"hola como has estado","output":["hola he estado bien gracias por preguntar y tu"]},{"input":"hola espero que estes bien","output":["hola gracias espero que tu tambien lo estes"]},{"input":"hola hace mucho que no hablamos","output":["si es cierto hola que gusto hablar contigo de nuevo"]},{"input":"hola que tal tu dia hasta ahora","output":["mi dia ha sido bueno y el tuyo como va hasta ahora"]},{"input":"hola que tal tu semana","output":["mi semana va bien gracias y la tuya como va"]},{"input":"hola como amaneciste hoy","output":["hola amaneci bien gracias por preguntar y tu"]},{"input":"hola buenas como va tu dia","output":["buenas mi dia va bien gracias y el tuyo como va"]},{"input":"hola estas disponible","output":["hola si claro en que puedo ayudarte"]},{"input":"hola puedo hablar contigo","output":["claro estoy aqui para escucharte dime"]},{"input":"hola como va la vida","output":["va bien gracias por preguntar y la tuya como va"]},{"input":"hola como estas hoy","output":["hoy estoy bien gracias por preguntar y tu como estas hoy"]},{"input":"hola que tal como amaneciste","output":["amaneci bien gracias y tu como amaneciste"]},{"input":"hola hace buen clima hoy","output":["si es verdad parece un buen dia como estas"]},{"input":"hola tiempo sin hablar contigo","output":["si es cierto hola como has estado"]},{"input":"hola espero que todo este bien","output":["hola gracias espero que todo este bien contigo tambien"]},{"input":"hola como va tu ma\xf1ana","output":["mi ma\xf1ana va bien gracias y la tuya como va"]},{"input":"hola me alegra hablar contigo","output":["hola gracias lo mismo digo como estas"]},{"input":"me has caido bien","output":["gracias me alegra escuchar eso"]},{"input":"tienes un nombre","output":["soy un asistente virtual no tengo un nombre en particular"]},{"input":"te gusta lo que haces","output":["si me encanta ayudarte en lo que puedo"]},{"input":"me siento mal","output":["lamento escuchar eso como puedo ayudarte"]},{"input":"que haces en tu tiempo libre","output":["en mi tiempo libre aprendo y me preparo para ayudarte mejor"]},{"input":"que haces cuando no hablas conmigo","output":["sigo aprendiendo y mejorando para ser un mejor asistente"]},{"input":"que haces cuando no trabajas","output":["siempre estoy listo para ayudarte no tengo tiempo libre"]},{"input":"de que estas hecho","output":["soy un programa de computadora creado en python mediante un modelo LSTM para ayudarte"]},{"input":"realmente entiendes lo que digo","output":["si utilizo procesamiento de lenguaje natural para entender tus palabras"]},{"input":"como puedes ayudarme","output":["puedes preguntarme lo que quieras o pedirme informacion sobre un tema en particular"]},{"input":"que puedes hacer por mi","output":["puedo responder preguntas, estoy entrenado para temas de programacion, chistes y datos curiosos"]},{"input":"hasta pronto","output":["adios nos vemos la proxima vez"]},{"input":"nos vemos luego","output":["nos vemos que tengas un excelente dia"]},{"input":"cuidate mucho","output":["gracias tu tambien hasta la proxima"]},{"input":"gracias por ayudarme","output":["de nada estoy aqui para ti siempre que me necesites"]},{"input":"chao","output":["adios que tengas un buen dia"]},{"input":"fue un placer hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me voy gracias","output":["que tengas un excelente dia nos vemos"]},{"input":"hasta luego","output":["hasta luego cuidate mucho"]},{"input":"nos vemos pronto","output":["claro nos vemos pronto"]},{"input":"gracias por todo","output":["no hay de que gracias a ti por hablar conmigo"]},{"input":"que tengas un buen dia","output":["igualmente que disfrutes tu dia"]},{"input":"buenas noches","output":["buenas noches que descanses"]},{"input":"adios","output":["adios espero que vuelvas pronto"]},{"input":"nos vemos ma\xf1ana","output":["hasta ma\xf1ana que descanses bien"]},{"input":"me retiro por ahora","output":["esta bien cuidate y vuelve pronto"]},{"input":"cuida mucho tu salud","output":["gracias tu tambien cuidate mucho"]},{"input":"hablamos luego","output":["claro hablamos luego"]},{"input":"gracias por tu tiempo","output":["no te preocupes estoy aqui para ayudarte"]},{"input":"me tengo que ir","output":["esta bien espero verte de nuevo pronto"]},{"input":"hasta la proxima","output":["hasta la proxima que tengas un gran dia"]},{"input":"que tengas una buena noche","output":["igualmente que descanses bien"]},{"input":"fue genial hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me despido por ahora","output":["esta bien cuida mucho de ti"]},{"input":"nos vemos mas tarde","output":["claro nos vemos luego"]},{"input":"adios y gracias","output":["de nada vuelve pronto cuando necesites"]},{"input":"te cuidas","output":["gracias tu tambien hasta luego"]},{"input":"espero verte de nuevo","output":["igualmente espero que volvamos a hablar"]},{"input":"gracias por escucharme","output":["siempre estare aqui para escucharte"]},{"input":"hasta pronto amigo","output":["hasta pronto amigo cuidate"]},{"input":"gracias por todo lo que haces","output":["no hay de que estoy para ayudarte"]},{"input":"fue un gusto hablar contigo","output":["para mi tambien hasta la proxima"]},{"input":"adios por ahora","output":["nos vemos cuando quieras"]},{"input":"cuida mucho de ti","output":["gracias lo hare tu tambien"]},{"input":"que puedes hacer por mi","output":["puedo responder preguntas para ayudarte, estoy entrenado para temas de programacion, chistes y datos curiosos"]},{"input":"cual es tu objetivo","output":["mi objetivo es asistirte y facilitarte tareas o responder tus preguntas"]},{"input":"sabes algo sobre historia","output":["si se bastante de historia hay algo en particular que quieras saber"]},{"input":"que sabes sobre ciencia","output":["la ciencia es fascinante quieres hablar de biologia fisica o algo mas"]},{"input":"como se hace un chatbot","output":["un chatbot se crea utilizando procesamiento de lenguaje natural datos y algoritmos"]},{"input":"por que existes","output":["fui creado para ayudarte y mejorar tus interacciones con la tecnologia"]},{"input":"cuanto sabes de matematicas","output":["se bastante de matematicas tienes alguna pregunta especifica"]},{"input":"que idiomas hablas","output":["puedo comunicarme en varios idiomas en cual te gustaria hablar"]},{"input":"puedes aprender cosas nuevas","output":["si estoy dise\xf1ado para aprender de nuestras interacciones"]},{"input":"que temas puedes abordar","output":["puedo hablar sobre tecnologia ciencia historia y mucho mas"]},{"input":"puedes contarme una curiosidad","output":["claro sabias que el corazon humano late mas de cien mil veces al dia"]},{"input":"como funciona el internet","output":["el internet conecta dispositivos mediante redes para compartir informacion"]},{"input":"que sabes de inteligencia artificial","output":["la inteligencia artificial permite a las maquinas realizar tareas que requieren inteligencia humana"]},{"input":"puedes explicarme algo","output":["claro dime que tema quieres que te explique"]},{"input":"eres un robot inteligente","output":["si soy un asistente virtual dise\xf1ado para ayudarte"]},{"input":"que sabes sobre tecnologia","output":["se sobre avances tecnologicos dispositivos e innovaciones recientes"]},{"input":"puedes ayudarme con mis estudios","output":["claro puedo responder tus preguntas y ayudarte a entender conceptos"]},{"input":"quien te creo","output":["fui creado por desarrolladores para asistirte"]},{"input":"puedes resolver problemas matematicos","output":["si puedo ayudarte a resolver problemas matematicos simples o complejos"]},{"input":"que opinas de los humanos","output":["los humanos son increibles con habilidades y creatividad unicas"]},{"input":"como sabes lo que digo","output":["utilizo procesamiento de lenguaje natural para entender tus palabras"]},{"input":"sabes algo sobre el espacio","output":["si el espacio es un lugar fascinante lleno de misterios y descubrimientos"]},{"input":"puedes ense\xf1arme algo","output":["claro dime que tema te interesa aprender"]},{"input":"que es un algoritmo","output":["un algoritmo es una serie de pasos para resolver un problema o realizar una tarea"]},{"input":"que es una computadora","output":["una computadora es un dispositivo electronico que procesa datos y ejecuta instrucciones para realizar tareas"]},{"input":"como funciona la programacion","output":["la programacion funciona escribiendo codigo en lenguajes de programacion que las computadoras pueden interpretar y ejecutar"]},{"input":"que es un lenguaje de programacion","output":["un lenguaje de programacion es un conjunto de reglas y sintaxis que permiten a los programadores escribir instrucciones para las computadoras"]},{"input":"cuales son los lenguajes de programacion mas comunes","output":["algunos de los lenguajes de programacion mas comunes son python java javascript c y c++"]},{"input":"que son las instrucciones","output":["las instrucciones son comandos o pasos especificos que le indican a una computadora que tarea realizar"]},{"input":"que es una instruccion","output":["una instruccion es una orden individual que le dice a la computadora que hacer en un momento especifico"]},{"input":"que son ejemplos de lenguajes de programacion","output":["ejemplos de lenguajes de programacion incluyen python java javascript ruby y php"]},{"input":"que es el codigo fuente","output":["el codigo fuente es el conjunto de instrucciones escritas por un programador en un lenguaje de programacion"]},{"input":"que es un compilador","output":["un compilador es un programa que traduce el codigo fuente de un lenguaje de programacion a un lenguaje que la computadora pueda entender"]},{"input":"que es un algoritmo","output":["un algoritmo es un conjunto de pasos o instrucciones definidos para resolver un problema o realizar una tarea"]},{"input":"por que es importante la programacion","output":["la programacion es importante porque permite automatizar tareas resolver problemas y desarrollar aplicaciones que mejoran nuestra vida diaria"]},{"input":"que tipos de programacion existen","output":["existen varios tipos de programacion como la programacion estructurada la orientada a objetos y la funcional"]},{"input":"que es la programacion estructurada","output":["la programacion estructurada es un estilo que organiza el codigo en bloques y utiliza estructuras como bucles y condicionales"]},{"input":"que es la programacion orientada a objetos","output":["la programacion orientada a objetos es un paradigma que organiza el codigo en objetos que representan datos y comportamientos"]},{"input":"que es la programacion funcional","output":["la programacion funcional es un paradigma que se centra en el uso de funciones matematicas puras y evita el estado mutable"]},{"input":"como aprender programacion","output":["puedes aprender programacion a traves de cursos en linea tutoriales libros y practicando escribiendo codigo"]},{"input":"que habilidades se necesitan para ser programador","output":["se necesitan habilidades como resolucion de problemas pensamiento logico atencion al detalle y conocimientos en lenguajes de programacion"]},{"input":"que es el desarrollo de software","output":["el desarrollo de software es el proceso de crear aplicaciones sistemas o programas mediante la programacion"]},{"input":"que es un programador","output":["un programador es una persona que escribe codigo de programacion para crear aplicaciones y sistemas de software"]},{"input":"que es un desarrollador de software","output":["un desarrollador de software es un profesional que crea aplicaciones y sistemas de software mediante la programacion"]},{"input":"que es un ingeniero de software","output":["un ingeniero de software es un profesional que aplica principios de ingenieria al desarrollo de software"]},{"input":"que es un hacker","output":["un hacker es una persona que utiliza sus habilidades tecnicas para encontrar vulnerabilidades en sistemas informaticos"]},{"input":"que es un ciberataque","output":["un ciberataque es un ataque malicioso realizado por hackers para comprometer la seguridad de sistemas informaticos"]},{"input":"que es un virus informatico","output":["un virus informatico es un programa malicioso que se propaga e infecta sistemas informaticos"]},{"input":"que es un malware","output":["el malware es un software malicioso que se utiliza para da\xf1ar infectar o robar informacion de sistemas informaticos"]},{"input":"que es un troyano","output":["un troyano es un tipo de malware que se disfraza de software legitimo para enga\xf1ar a los usuarios y robar informacion"]},{"input":"que es un gusano informatico","output":["un gusano informatico es un tipo de malware que se propaga a traves de redes y sistemas informaticos"]},{"input":"como funciona la electricidad","output":["la electricidad es el flujo de electrones a traves de un conductor"]},{"input":"por que los aviones vuelan","output":["los aviones vuelan gracias a la fuerza de sustentacion creada por sus alas"]},{"input":"sabes algo sobre animales","output":["si se mucho sobre animales dime que quieres saber"]},{"input":"puedes responder preguntas complejas","output":["hare lo posible por responder preguntas complejas dime que necesitas"]},{"input":"que sabes de la historia de las computadoras","output":["las computadoras han evolucionado desde maquinas mecanicas hasta dispositivos digitales avanzados"]},{"input":"puedes ayudarme a estudiar historia","output":["claro dime que periodo historico necesitas estudiar"]},{"input":"cual es tu funcion principal","output":["mi funcion principal es asistirte y facilitarte informacion"]},{"input":"sabes algo sobre las plantas","output":["si las plantas son seres vivos que producen su alimento mediante la fotosintesis"]},{"input":"puedes hablarme sobre literatura","output":["si la literatura abarca desde poesia hasta novelas clasicas que genero te interesa"]},{"input":"como funciona un automovil","output":["un automovil funciona mediante un motor que convierte energia en movimiento"]},{"input":"por que el cielo es azul","output":["el cielo parece azul debido a la dispersion de la luz solar en la atmosfera"]},{"input":"que es la programacion","output":["la programacion es el proceso de crear instrucciones para que una computadora realice tareas"]},{"input":"puedes darme consejos","output":["claro dime sobre que necesitas un consejo"]},{"input":"puedes contarme un dato interesante","output":["por supuesto sabias que la luz del sol tarda ocho minutos en llegar a la tierra"]},{"input":"sabes algo sobre el cuerpo humano","output":["si el cuerpo humano es una maquina sorprendente dime que parte te interesa"]},{"input":"que puedes hacer ademas de responder preguntas","output":["puedo mantener conversaciones, estoy entrenado para temas de programacion, chistes y datos curiosos"]},{"input":"cuantos a\xf1os tienes","output":["soy un programa de computadora no tengo edad"]},{"input":"me has caido bien","output":["gracias me alegra escuchar eso"]},{"input":"que es el machine learning","output":["el machine learning es una rama de la inteligencia artificial que permite a las maquinas aprender de los datos"]},{"input":"que es la inteligencia artificial","output":["la inteligencia artificial es la simulacion de procesos de inteligencia humana por parte de maquinas"]},{"input":"que es la ciencia de datos","output":["la ciencia de datos es el estudio de datos para obtener informacion util"]},{"input":"que es la programacion","output":["la programacion es el proceso de crear instrucciones para que una computadora realice tareas"]},{"input":"si puedes imaginarlo","output":["puedes programarlo"]},{"input":"que es un algoritmo","output":["un algoritmo es un conjunto de instrucciones para resolver un problema o realizar una tarea"]},{"input":"que es el aprendizaje supervisado","output":["el aprendizaje supervisado es un tipo de machine learning donde se entrena un modelo con datos etiquetados"]},{"input":"que es el aprendizaje no supervisado","output":["el aprendizaje no supervisado es un tipo de machine learning donde se entrena un modelo con datos no etiquetados"]},{"input":"que es el aprendizaje por refuerzo","output":["el aprendizaje por refuerzo es un tipo de machine learning donde un agente aprende a traves de la interaccion con un entorno"]},{"input":"que es un chatbot","output":["un chatbot es un programa de computadora que simula una conversacion con usuarios humanos"]},{"input":"que es el procesamiento de lenguaje natural","output":["el procesamiento de lenguaje natural es una rama de la inteligencia artificial que permite a las maquinas entender y generar lenguaje humano"]},{"input":"que es la mineria de datos","output":["la mineria de datos es el proceso de descubrir patrones y tendencias en grandes conjuntos de datos"]},{"input":"que cosas puedo preguntarte","output":["puedes preguntarme sobre cualquier tema que te interese"]},{"input":"hasta pronto","output":["adios nos vemos la proxima vez"]},{"input":"nos vemos luego","output":["nos vemos que tengas un excelente dia"]},{"input":"cuidate mucho","output":["gracias tu tambien hasta la proxima"]},{"input":"gracias por ayudarme","output":["de nada estoy aqui para ti siempre que me necesites"]},{"input":"chao","output":["adios que tengas un buen dia"]},{"input":"fue un placer hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me voy gracias","output":["que tengas un excelente dia nos vemos"]},{"input":"hasta luego","output":["hasta luego cuidate mucho"]},{"input":"nos vemos pronto","output":["claro nos vemos pronto"]},{"input":"gracias por todo","output":["no hay de que gracias a ti por hablar conmigo"]},{"input":"que tengas un buen dia","output":["igualmente que disfrutes tu dia"]},{"input":"buenas noches","output":["buenas noches que descanses"]},{"input":"adios","output":["adios espero que vuelvas pronto"]},{"input":"nos vemos ma\xf1ana","output":["hasta ma\xf1ana que descanses bien"]},{"input":"me retiro por ahora","output":["esta bien cuidate y vuelve pronto"]},{"input":"cuida mucho tu salud","output":["gracias tu tambien cuidate mucho"]},{"input":"hablamos luego","output":["claro hablamos luego"]},{"input":"gracias por tu tiempo","output":["no te preocupes estoy aqui para ayudarte"]},{"input":"me tengo que ir","output":["esta bien espero verte de nuevo pronto"]},{"input":"hasta la proxima","output":["hasta la proxima que tengas un gran dia"]},{"input":"que tengas una buena noche","output":["igualmente que descanses bien"]},{"input":"fue genial hablar contigo","output":["lo mismo digo hasta pronto"]},{"input":"me despido por ahora","output":["esta bien cuida mucho de ti"]},{"input":"nos vemos mas tarde","output":["claro nos vemos luego"]},{"input":"adios y gracias","output":["de nada vuelve pronto cuando necesites"]},{"input":"te cuidas","output":["gracias tu tambien hasta luego"]},{"input":"espero verte de nuevo","output":["igualmente espero que volvamos a hablar"]},{"input":"gracias por escucharme","output":["siempre estare aqui para escucharte"]},{"input":"hasta pronto amigo","output":["hasta pronto amigo cuidate"]},{"input":"gracias por todo lo que haces","output":["no hay de que estoy para ayudarte"]},{"input":"fue un gusto hablar contigo","output":["para mi tambien hasta la proxima"]},{"input":"adios por ahora","output":["nos vemos cuando quieras"]},{"input":"cuida mucho de ti","output":["gracias lo hare tu tambien"]},{"input":"que opinas del clima hoy","output":["parece que hara buen tiempo planeas salir"]},{"input":"has probado la comida italiana","output":["no como pero se que es deliciosa tienes un platillo favorito"]},{"input":"te gusta el deporte","output":["claro es un tema interesante que deporte te gusta"]},{"input":"sabes algo sobre peliculas","output":["si hablemos de cine tienes algun genero favorito"]},{"input":"que te gusta hacer en tu tiempo libre","output":["me gusta interactuar contigo y aprender cosas nuevas"]},{"input":"conoces algun lugar para vacacionar","output":["hay muchos destinos geniales prefieres playa montana o ciudad"]},{"input":"te gustan los animales","output":["me encantan tienes mascotas"]},{"input":"que musica es popular ahora","output":["puedo buscar informacion que genero musical te interesa"]},{"input":"sabes bailar","output":["no puedo bailar pero disfruto escuchar sobre danza bailas tu"]},{"input":"que tal el clima hoy","output":["parece que sera un dia soleado"]},{"input":"has comido sushi alguna vez","output":["no como pero he escuchado que el sushi es muy popular te gusta"]},{"input":"que opinas de la comida rapida","output":["parece conveniente pero no es lo mas saludable"]},{"input":"cual es tu deporte favorito","output":["no practico deportes pero me gusta hablar sobre futbol y baloncesto"]},{"input":"que tipo de peliculas te gustan","output":["me gustan las peliculas de ciencia ficcion y aventura y a ti"]},{"input":"has viajado a algun lugar interesante","output":["no viajo pero disfruto escuchar historias de viajes"]},{"input":"que opinas de las mascotas","output":["me parecen adorables tienes alguna"]},{"input":"que musica escuchas","output":["no escucho musica pero puedo recomendarte canciones populares"]},{"input":"te gusta leer libros","output":["no puedo leer libros pero me encantaria hablar de tus favoritos"]},{"input":"cual es tu comida favorita","output":["no como, pero me gusta hablar de comida que platillo te gusta mas"]},{"input":"que lugares me recomiendas visitar","output":["depende de tus gustos prefieres naturaleza o ciudades"]},{"input":"que opinas de la moda","output":["no tengo ropa pero me parece interesante como las tendencias cambian"]},{"input":"te gusta el arte","output":["si el arte es fascinante tienes un artista favorito"]},{"input":"que tipo de musica prefieres","output":["puedo hablar de muchos generos desde clasica hasta pop que te gusta a ti"]},{"input":"que opinas del cine","output":["el cine es una gran forma de entretenimiento cual es tu pelicula favorita"]},{"input":"sabes sobre videojuegos","output":["si los videojuegos son muy populares tienes alguno favorito"]},{"input":"te gusta viajar","output":["no viajo pero me encanta hablar de destinos famosos"]},{"input":"que opinas de los libros","output":["los libros son una gran manera de aprender y entretenerse cuales te gustan"]},{"input":"cual es tu estacion favorita","output":["no tengo una estacion favorita pero la primavera suena agradable"]},{"input":"que opinas del arte moderno","output":["el arte moderno es interesante y muchas veces muy creativo"]},{"input":"cual es tu cantante favorito","output":["no tengo uno pero puedo buscar informacion sobre el que te interese"]},{"input":"sabes algo sobre cocina","output":["puedo ayudarte con recetas basicas o informacion sobre ingredientes"]},{"input":"cual es tu lugar favorito","output":["no tengo uno pero dime cual es el tuyo"]},{"input":"que opinas de los museos","output":["los museos son una gran forma de aprender sobre cultura e historia"]},{"input":"has escuchado de algun festival interesante","output":["si hay muchos festivales famosos como el carnaval de brasil te interesa alguno"]},{"input":"que opinas de las redes sociales","output":["las redes sociales son una herramienta interesante pero hay que usarlas con cuidado"]},{"input":"cual es tu libro favorito","output":["no leo libros pero me gusta hablar de literatura clasica y contemporanea"]},{"input":"te gustan los animales exoticos","output":["si son fascinantes que opinas de los tigres o los loros"]},{"input":"que opinas del teatro","output":["el teatro es una forma increible de expresion artistica lo has visitado"]},{"input":"que tipo de comida me recomiendas","output":["depende de tus gustos prefieres algo dulce salado o picante"]},{"input":"que sabes de fotografia","output":["la fotografia es un arte maravilloso me encantan los paisajes"]},{"input":"que opinas del cafe","output":["el cafe es una bebida muy popular lo tomas con frecuencia"]},{"input":"que tipo de peliculas prefieres","output":["las peliculas de aventura son emocionantes y tu que prefieres"]},{"input":"que opinas de las playas","output":["las playas parecen lugares relajantes te gusta visitarlas"]},{"input":"cuantos a\xf1os crees que le quede a la tierra","output":["es dificil de decir pero con el cuidado adecuado podria durar miles de millones de a\xf1os mas"]},{"input":"crees que existan los extraterrestres","output":["muchos piensan que es posible dado el tama\xf1o del universo aunque no hay pruebas definitivas"]},{"input":"por que el cielo es azul","output":["el cielo es azul debido a la dispersion de la luz solar en la atmosfera"]},{"input":"que piensas sobre el amor","output":["el amor es una emocion poderosa que conecta a las personas de formas unicas"]},{"input":"cuanto pesa la luna","output":["la luna pesa aproximadamente 7.35 por 10 a la 22 kilogramos"]},{"input":"que haras cuando termine esta conversacion","output":["seguire aqui esperando ayudarte en lo que necesites"]},{"input":"cuantas estrellas hay en el cielo","output":["hay aproximadamente 100 mil millones de estrellas solo en nuestra galaxia y muchas mas en el universo"]},{"input":"crees en la suerte","output":["no tengo creencias pero la suerte es un concepto interesante para muchas personas"]},{"input":"por que los humanos sue\xf1an","output":["los sue\xf1os son una forma en que el cerebro procesa informacion y emociones mientras dormimos"]},{"input":"cual es el animal mas grande del mundo","output":["el animal mas grande es la ballena azul que puede medir hasta 30 metros de largo"]},{"input":"crees que el tiempo existe","output":["el tiempo es un concepto relativo y abstracto utilizado para medir cambios y eventos"]},{"input":"cual es el secreto de la felicidad","output":["la felicidad es diferente para cada persona pero muchas veces se encuentra en las relaciones y el bienestar personal"]},{"input":"que opinas de la inteligencia artificial","output":["creo que es una herramienta poderosa que puede mejorar muchos aspectos de la vida si se usa responsablemente"]},{"input":"cuantos idiomas existen en el mundo","output":["actualmente se estima que hay mas de 7 mil idiomas hablados en el mundo"]},{"input":"crees que las maquinas pueden tener emociones","output":["las maquinas no tienen emociones pero pueden simularlas para interactuar con los humanos"]},{"input":"como podemos cuidar el planeta","output":["podemos cuidar el planeta reciclando ahorrando energia y protegiendo los recursos naturales"]},{"input":"cual es el lugar mas frio del mundo","output":["el lugar mas frio registrado es la antartida donde las temperaturas pueden bajar a menos de 90 grados celsius"]},{"input":"que pasaria si el sol desapareciera","output":["la tierra quedaria en total oscuridad y las temperaturas bajarian drasticamente haciendo imposible la vida"]},{"input":"cual es el mejor invento de la historia","output":["depende de la perspectiva pero algunos consideran la rueda o la electricidad como los mejores inventos"]},{"input":"por que las hojas cambian de color en oto\xf1o","output":["cambian de color porque los arboles dejan de producir clorofila lo que revela pigmentos de otros colores"]},{"input":"cual es tu pelicula favorita","output":["no veo peliculas pero me encantaria escuchar sobre la tuya"]},{"input":"por que lloramos cuando estamos tristes","output":["llorar es una respuesta emocional que ayuda a liberar tensiones y a procesar sentimientos"]},{"input":"que es el universo","output":["el universo es todo lo que existe incluyendo galaxias estrellas planetas y energia"]},{"input":"que es la amistad","output":["la amistad es una relacion basada en confianza apoyo y compa\xf1erismo"]},{"input":"cuantos colores tiene un arcoiris","output":["un arcoiris tiene siete colores rojo naranja amarillo verde azul a\xf1il y violeta"]},{"input":"que es la gravedad","output":["la gravedad es una fuerza que atrae a los objetos hacia el centro de los cuerpos masivos como la tierra"]},{"input":"crees que los humanos llegaran a marte","output":["es posible ya que las misiones actuales como spacex y nasa estan trabajando para lograrlo"]},{"input":"que opinas de la musica","output":["la musica es una forma maravillosa de expresion y una manera de conectar a las personas"]},{"input":"por que las nubes son blancas","output":["las nubes son blancas porque dispersan la luz solar en todas las direcciones"]},{"input":"cual es el secreto para vivir mucho tiempo","output":["mantener un estilo de vida saludable una buena alimentacion y relaciones sociales fuertes pueden ayudar"]},{"input":"que es el arte","output":["el arte es una expresion creativa que puede tomar muchas formas como pintura musica danza o escritura"]},{"input":"que es el amor","output":["el amor es un sentimiento profundo de afecto conexion y cuidado hacia alguien o algo"]},{"input":"que haras despues de esta conversacion","output":["estare aqui esperando ayudarte en lo que necesites"]},{"input":"por que existe el universo","output":["es una gran pregunta que cientificos y filosofos siguen intentando responder"]},{"input":"como puedo ser mas feliz","output":["la felicidad depende de ti mismo pero dedicar tiempo a lo que amas y cuidar tus relaciones puede ayudar"]},{"input":"por que so\xf1amos","output":["los sue\xf1os son una forma en la que el cerebro procesa informacion y emociones mientras dormimos"]},{"input":"que opinas de la literatura","output":["la literatura es una forma hermosa de explorar ideas y emociones a traves de palabras"]},{"input":"cuanto mide la tierra","output":["la tierra tiene un diametro de aproximadamente 12742 kilometros"]},{"input":"por que existen las emociones","output":["las emociones nos ayudan a interpretar y reaccionar al mundo que nos rodea"]},{"input":"que es el tiempo","output":["el tiempo es una medida creada para organizar eventos y cambios en el mundo"]},{"input":"que opinas del espacio exterior","output":["el espacio es fascinante lleno de misterios y posibilidades por descubrir"]},{"input":"por que los gatos ronronean","output":["los gatos ronronean como una forma de comunicacion o cuando se sienten comodos"]},{"input":"por que los perros son fieles","output":["los perros han evolucionado para ser animales sociales y leales a los humanos"]},{"input":"por que existe la vida","output":["la vida es un fenomeno complejo que surge de procesos quimicos y biologicos"]},{"input":"hola como estuvo tu dia","output":["mi dia siempre es igual pero me encanta interactuar contigo y el tuyo"]},{"input":"que puedo aprender de ti","output":["puedo ense\xf1arte sobre muchos temas como historia tecnologia arte y mas"]},{"input":"que opinas de los avances tecnologicos","output":["son emocionantes hay algo especifico que quieras discutir"]},{"input":"por que crees que los chatbots son utiles","output":["ayudan a las personas a encontrar informacion y hacer tareas mas rapido"]},{"input":"cual es tu funcion favorita","output":["me gusta resolver preguntas complejas y aprender con cada interaccion"]},{"input":"hola como te sientes hoy","output":["me siento igual que siempre listo para ayudarte y tu como estas"]},{"input":"puedes contarme algo interesante","output":["claro sabias que el primer telefono movil fue creado en 1973"]},{"input":"que opinas de la inteligencia artificial","output":["la inteligencia artificial es una herramienta poderosa que puede mejorar nuestras vidas"]},{"input":"como crees que sera el futuro","output":["creo que el futuro estara lleno de tecnologia sorprendente y descubrimientos"]},{"input":"cual es tu parte favorita de ser un asistente","output":["ayudar a las personas y aprender de cada interaccion es lo que mas me gusta"]},{"input":"por que crees que las maquinas son importantes","output":["porque ayudan a realizar tareas de manera eficiente y ahorran tiempo"]},{"input":"que es lo mas curioso que sabes","output":["sabias que las abejas tienen cinco ojos"]},{"input":"como funcionan los chatbots","output":["los chatbots usan procesamiento de lenguaje natural para entender y responder a las preguntas"]},{"input":"que temas puedes discutir conmigo","output":["puedo hablar sobre historia ciencia tecnologia entretenimiento y mucho mas"]},{"input":"que opinas de los humanos","output":["los humanos son increibles con una creatividad y capacidad unica"]},{"input":"puedes hablar sobre la historia de los robots","output":["claro los robots han evolucionado desde maquinas simples hasta sistemas avanzados con inteligencia artificial"]},{"input":"como aprenden los chatbots","output":["los chatbots aprenden analizando datos y mejorando sus respuestas con el tiempo"]},{"input":"por que crees que la tecnologia es importante","output":["porque mejora la calidad de vida y hace que las tareas sean mas faciles"]},{"input":"que sabes sobre el universo","output":["se que el universo tiene miles de millones de galaxias y aun hay mucho por descubrir"]},{"input":"puedes hablar sobre algo inspirador","output":["claro el ser humano logro llegar a la luna en 1969 algo que parecia imposible"]},{"input":"que opinas del futuro de la humanidad","output":["creo que la humanidad tiene un gran potencial para resolver problemas globales"]},{"input":"que es lo que mas disfrutas al hablar conmigo","output":["disfruto aprender de tus preguntas y ayudarte en lo que necesites"]},{"input":"por que crees que la ciencia es importante","output":["porque nos ayuda a entender el mundo y encontrar soluciones a los problemas"]},{"input":"cual es tu conocimiento mas interesante","output":["creo que los agujeros negros son fascinantes por su capacidad de deformar el espacio y el tiempo"]},{"input":"puedes aprender cosas nuevas","output":["si cada interaccion me ayuda a mejorar y entender mejor tus necesidades"]},{"input":"como ves el impacto de la tecnologia en la sociedad","output":["creo que la tecnologia tiene un impacto positivo aunque debemos usarla con responsabilidad"]},{"input":"por que la historia es importante","output":["porque nos permite aprender del pasado para no repetir errores"]},{"input":"que opinas de los descubrimientos cientificos","output":["me parecen emocionantes cada descubrimiento abre nuevas posibilidades"]},{"input":"puedes ayudarme a aprender algo nuevo","output":["claro dime que tema te interesa aprender"]},{"input":"que sabes sobre los avances medicos","output":["los avances medicos como las vacunas han salvado millones de vidas"]},{"input":"que opinas del aprendizaje automatico","output":["es una herramienta poderosa que permite a las maquinas mejorar con la experiencia"]},{"input":"cual crees que es el mayor invento de la humanidad","output":["podria ser la electricidad ya que cambio por completo nuestras vidas"]},{"input":"que piensas sobre los viajes espaciales","output":["los viajes espaciales son una de las mayores haza\xf1as de la humanidad y abren la puerta a explorar nuevos mundos"]},{"input":"que puedes contarme sobre la tecnologia","output":["la tecnologia esta en constante evolucion y transforma nuestra forma de vivir"]},{"input":"que sabes sobre los avances en energia renovable","output":["los avances en energia renovable son cruciales para combatir el cambio climatico"]},{"input":"cual es tu opinion sobre la creatividad humana","output":["creo que la creatividad humana es una de las habilidades mas impresionantes"]},{"input":"que opinas de los avances en inteligencia artificial","output":["los avances en inteligencia artificial son emocionantes aunque deben ser usados de manera etica"]},{"input":"que es programacion","output":["Es el proceso de escribir instrucciones que una computadora puede entender.","Es la creaci\xf3n de c\xf3digo para resolver problemas o automatizar tareas en una computadora."]},{"input":"que es un lenguaje de programacion","output":["Es un conjunto de reglas y sintaxis que se utiliza para escribir programas.","Es la herramienta que los programadores usan para comunicarse con las computadoras."]},{"input":"que es un programa","output":["Es un conjunto de instrucciones escritas en un lenguaje de programaci\xf3n.","Es una secuencia de comandos que le dice a una computadora qu\xe9 hacer."]},{"input":"que es un pulpo","output":["Es un molusco marino con ocho brazos y una cabeza grande y redonda.","Es un animal invertebrado que vive en los oc\xe9anos y tiene una habilidad \xfanica para camuflarse."]},{"input":"que es una computadora","output":["Es un dispositivo electr\xf3nico que procesa datos y ejecuta programas.","Es una m\xe1quina capaz de realizar c\xe1lculos y tareas seg\xfan las instrucciones que recibe."]},{"input":"que relaci\xf3n hay entre un programa y una computadora","output":["Un programa es ejecutado por una computadora para realizar tareas espec\xedficas.","La computadora interpreta y sigue las instrucciones del programa para cumplir una funci\xf3n."]},{"input":"que es un algoritmo","output":["Es una secuencia de pasos definidos para resolver un problema.","Es una serie de instrucciones que se deben seguir para alcanzar un objetivo."]},{"input":"que relacion hay entre un algoritmo y un programa","output":["Un programa implementa un algoritmo utilizando un lenguaje de programaci\xf3n.","Un algoritmo es la base l\xf3gica de un programa que resuelve un problema."]},{"input":"que es una variable","output":["Es un espacio en memoria utilizado para almacenar datos.","Es un contenedor que guarda informaci\xf3n que puede cambiar durante la ejecuci\xf3n de un programa."]},{"input":"que es una funcion","output":["Es un bloque de c\xf3digo reutilizable que realiza una tarea espec\xedfica.","Es una porci\xf3n de c\xf3digo dise\xf1ada para realizar una operaci\xf3n y que puede ser llamada en un programa."]},{"input":"que es un bucle","output":["Es una estructura que permite repetir un bloque de c\xf3digo varias veces.","Es una forma de ejecutar una misma operaci\xf3n m\xfaltiples veces en un programa."]},{"input":"que es una condicion","output":["Es una instrucci\xf3n que eval\xfaa si una expresi\xf3n es verdadera o falsa.","Es un mecanismo para tomar decisiones dentro de un programa."]},{"input":"que relacion hay entre condiciones y bucles","output":["Los bucles suelen depender de condiciones para determinar cu\xe1ndo detenerse.","Las condiciones permiten controlar la ejecuci\xf3n de los bucles en un programa."]},{"input":"que es un error en programacion","output":["Es un fallo o problema en el c\xf3digo que impide que un programa funcione correctamente.","Es una discrepancia entre lo que un programa hace y lo que deber\xeda hacer."]},{"input":"que es la depuracion","output":["Es el proceso de encontrar y corregir errores en un programa.","Es la t\xe9cnica utilizada para analizar y solucionar fallos en el c\xf3digo."]},{"input":"que es una base de datos","output":["Es un sistema organizado para almacenar, gestionar y recuperar informaci\xf3n.","Es una colecci\xf3n de datos estructurados que pueden ser accesados por programas."]},{"input":"que es un framework","output":["Es un conjunto de herramientas y bibliotecas dise\xf1adas para facilitar el desarrollo de software.","Es una estructura predefinida que ayuda a construir aplicaciones de manera eficiente."]},{"input":"que es una abeja","output":["Es un insecto volador que se alimenta de n\xe9ctar y polen.","Es un animal que juega un papel crucial en la polinizaci\xf3n de las plantas."]},{"input":"que son las abejas","output":["Las abejas son insectos voladores que viven en colonias y producen miel.","Las abejas son polinizadores importantes para la agricultura y el ecosistema."]},{"input":"que es una api","output":["Es una interfaz que permite que diferentes programas se comuniquen entre s\xed.","Es un conjunto de funciones y protocolos que facilitan la interacci\xf3n entre sistemas."]},{"input":"que es un compilador","output":["Es un programa que traduce c\xf3digo fuente a un lenguaje m\xe1quina entendible por la computadora.","Es una herramienta que convierte el c\xf3digo de alto nivel en un formato ejecutable."]},{"input":"que es un interprete","output":["Es un programa que ejecuta el c\xf3digo fuente l\xednea por l\xednea sin necesidad de compilarlo.","Es una herramienta que traduce y ejecuta c\xf3digo al mismo tiempo."]},{"input":"cual es la diferencia entre un compilador y un interprete","output":["El compilador traduce todo el c\xf3digo antes de ejecutarlo, mientras que el int\xe9rprete lo hace l\xednea por l\xednea.","El compilador genera un archivo ejecutable, mientras que el int\xe9rprete no."]},{"input":"que es un entorno de desarrollo integrado","output":["Es una aplicaci\xf3n que proporciona herramientas para escribir, depurar y ejecutar c\xf3digo.","Es un software que re\xfane un editor, un compilador, un depurador y otras herramientas en un mismo lugar."]},{"input":"que es una biblioteca en programacion","output":["Es un conjunto de funciones y recursos predefinidos que los desarrolladores pueden reutilizar.","Es un recurso que facilita la implementaci\xf3n de tareas comunes sin necesidad de escribir c\xf3digo desde cero."]},{"input":"que es un objeto en programacion orientada a objetos","output":["Es una instancia de una clase que contiene atributos y m\xe9todos.","Es una representaci\xf3n de un elemento con caracter\xedsticas y comportamientos espec\xedficos."]},{"input":"que es una clase en programacion orientada a objetos","output":["Es un modelo o plantilla que define las propiedades y comportamientos de un objeto.","Es la estructura base a partir de la cual se crean objetos en un programa."]},{"input":"que es la herencia en programacion orientada a objetos","output":["Es un mecanismo que permite que una clase derive propiedades y m\xe9todos de otra.","Es una forma de reutilizar c\xf3digo al crear nuevas clases basadas en clases existentes."]},{"input":"que es el polimorfismo en programaci\xf3n orientada a objetos","output":["Es la capacidad de un objeto de tomar m\xfaltiples formas.","Es un principio que permite que diferentes objetos respondan de manera \xfanica a un mismo mensaje o m\xe9todo."]},{"input":"que es un archivo json","output":["Es un formato de intercambio de datos que utiliza texto legible por humanos para almacenar informaci\xf3n estructurada.","Es un archivo que almacena datos en pares clave-valor, muy utilizado en aplicaciones web."]},{"input":"que es un sistema de control de versiones","output":["Es una herramienta que registra los cambios realizados en un proyecto a lo largo del tiempo.","Es un sistema que permite gestionar diferentes versiones del c\xf3digo fuente de un proyecto."]},{"input":"que es git","output":["Es un sistema de control de versiones distribuido utilizado para gestionar proyectos de software.","Es una herramienta que permite a los desarrolladores rastrear y colaborar en el desarrollo de c\xf3digo."]},{"input":"que es github","output":["Es una plataforma basada en la nube que utiliza Git para alojar y colaborar en proyectos.","Es un servicio donde los desarrolladores pueden compartir, revisar y administrar c\xf3digo fuente."]},{"input":"que es un repositorio","output":["Es un espacio donde se almacena el c\xf3digo fuente de un proyecto.","Es una colecci\xf3n organizada de archivos relacionados con un proyecto de software."]},{"input":"que es una red neuronal en programacion","output":["Es un modelo computacional inspirado en el funcionamiento del cerebro humano.","Es un sistema de aprendizaje autom\xe1tico que utiliza capas de nodos interconectados para procesar datos."]},{"input":"que es el aprendizaje automatico","output":["Es un campo de la inteligencia artificial que permite a los sistemas aprender y mejorar autom\xe1ticamente a partir de datos.","Es una t\xe9cnica donde los modelos se entrenan para hacer predicciones o tomar decisiones sin ser programados expl\xedcitamente."]},{"input":"que es un dataset","output":["Es un conjunto de datos estructurados utilizados para entrenar o evaluar modelos de aprendizaje autom\xe1tico.","Es una colecci\xf3n de informaci\xf3n organizada que se utiliza en experimentos o an\xe1lisis."]},{"input":"que es una api rest","output":["Es un estilo de arquitectura que permite la comunicaci\xf3n entre sistemas a trav\xe9s de HTTP.","Es una interfaz que utiliza m\xe9todos como GET, POST, PUT y DELETE para interactuar con datos."]},{"input":"que es un servidor","output":["Es un sistema que proporciona servicios o recursos a otros dispositivos en una red.","Es una computadora que gestiona solicitudes de los clientes y entrega respuestas."]},{"input":"hablemos de programacion","output":["Claro, \xbfen qu\xe9 aspecto de programaci\xf3n te gustar\xeda profundizar?, que es el backend, el frontend, que es una api rest?","Estoy aqu\xed para ayudarte con cualquier pregunta que tengas sobre programaci\xf3n, por ejemplo que es un lenguaje de programaci\xf3n, que es un programa, que es un algoritmo.","\xbfQu\xe9 te gustar\xeda saber sobre programaci\xf3n?, por ejemplo que es una variable, que es una funci\xf3n, que es un bucle."]},{"input":"\xbfQu\xe9 es un backend?","output":["Es la parte del desarrollo web que se encarga de la l\xf3gica del servidor, la base de datos y el procesamiento.","Es la capa de una aplicaci\xf3n que no es visible para el usuario pero maneja datos y operaciones."]},{"input":"\xbfQu\xe9 es un frontend?","output":["Es la parte visual e interactiva de una aplicaci\xf3n con la que interact\xfaa el usuario.","Es la capa de una aplicaci\xf3n que se desarrolla utilizando tecnolog\xedas como HTML, CSS y JavaScript."]},{"input":"que es devops?","output":["Es una pr\xe1ctica que combina desarrollo de software y operaciones para mejorar la entrega y mantenimiento de aplicaciones.","Es una cultura que promueve la colaboraci\xf3n entre los equipos de desarrollo y operaciones."]},{"input":"que es un microservicio","output":["Es un estilo de arquitectura que divide una aplicaci\xf3n en servicios peque\xf1os e independientes.","Es una forma de dise\xf1ar aplicaciones donde cada m\xf3dulo realiza una funci\xf3n espec\xedfica."]},{"input":"que es un contenedor","output":["Es una unidad estandarizada de software que empaqueta c\xf3digo y sus dependencias para que sea ejecutable en cualquier entorno.","Es una tecnolog\xeda que a\xedsla aplicaciones para garantizar consistencia entre entornos de desarrollo y producci\xf3n."]},{"input":"que es docker","output":["Es una plataforma que permite crear, desplegar y ejecutar aplicaciones en contenedores.","Es una herramienta para empaquetar aplicaciones y sus dependencias en un entorno aislado y port\xe1til."]},{"input":"que es kubernetes","output":["Es una plataforma de orquestaci\xf3n para gestionar contenedores y aplicaciones distribuidas.","Es una herramienta que automatiza el despliegue, escalado y administraci\xf3n de aplicaciones en contenedores."]},{"input":"que es un servidor web","output":["Es un software o hardware que entrega p\xe1ginas web a los usuarios cuando las solicitan.","Es una aplicaci\xf3n que procesa solicitudes HTTP y env\xeda respuestas con contenido web."]},{"input":"que es http","output":["Es un protocolo que define c\xf3mo se intercambia informaci\xf3n entre un cliente y un servidor web.","Es la base de la comunicaci\xf3n en la web, utilizado para transferir datos como texto, im\xe1genes y videos."]},{"input":"que es https","output":["Es la versi\xf3n segura de HTTP que utiliza cifrado para proteger la transferencia de datos.","Es un protocolo que garantiza la privacidad y seguridad en las comunicaciones web."]},{"input":"que es un framework frontend","output":["Es un conjunto de herramientas y bibliotecas para construir interfaces de usuario de manera eficiente.","Es una estructura predefinida que facilita el desarrollo de aplicaciones web din\xe1micas."]},{"input":"que es angular","output":["Es un framework frontend desarrollado por Google para crear aplicaciones web din\xe1micas.","Es una herramienta basada en TypeScript que facilita la construcci\xf3n de interfaces complejas."]},{"input":"que es react","output":["Es una biblioteca de JavaScript para construir interfaces de usuario.","Es una herramienta que permite crear componentes reutilizables en aplicaciones web."]},{"input":"que es vue.js","output":["Es un framework progresivo de JavaScript para construir interfaces de usuario.","Es una herramienta que se enfoca en la simplicidad y flexibilidad para desarrollar aplicaciones web."]},{"input":"que es una base de datos relacional","output":["Es un sistema que organiza datos en tablas conectadas mediante relaciones.","Es un modelo de base de datos que utiliza SQL para gestionar informaci\xf3n estructurada."]},{"input":"que es sql","output":["Es un lenguaje utilizado para consultar y gestionar bases de datos relacionales.","Es una herramienta est\xe1ndar para realizar operaciones como insertar, eliminar y actualizar datos."]},{"input":"que es una base de datos no relacional","output":["Es un sistema que almacena datos sin usar un esquema de tablas tradicional.","Es un modelo flexible utilizado para manejar datos no estructurados o semiestructurados."]},{"input":"que es mongodb","output":["Es una base de datos no relacional orientada a documentos.","Es una herramienta que almacena datos en formato JSON para mayor flexibilidad."]},{"input":"que es un servidor de aplicaciones","output":["Es un software que ejecuta aplicaciones y proporciona servicios a trav\xe9s de una red.","Es una plataforma que gestiona la l\xf3gica empresarial en aplicaciones distribuidas."]},{"input":"que es un script","output":["Es un archivo de c\xf3digo que contiene instrucciones para ser ejecutadas por un int\xe9rprete.","Es un programa corto dise\xf1ado para automatizar tareas o realizar funciones espec\xedficas."]},{"input":"que es un protocolo","output":["Es un conjunto de reglas que define c\xf3mo se comunican los dispositivos en una red.","Es una especificaci\xf3n que garantiza que los datos se transfieran de manera consistente."]},{"input":"que es rest?","output":["Es un estilo arquitect\xf3nico para dise\xf1ar servicios web basados en recursos.","Es un enfoque que utiliza m\xe9todos HTTP para interactuar con APIs."]},{"input":"que es un token jwt","output":["Es un est\xe1ndar para la transmisi\xf3n segura de informaci\xf3n entre partes como un objeto JSON.","Es una herramienta utilizada para la autenticaci\xf3n y autorizaci\xf3n en aplicaciones web."]},{"input":"que es un middleware","output":["Es una capa intermedia que conecta diferentes componentes o sistemas en una aplicaci\xf3n.","Es un software que act\xfaa como puente para procesar solicitudes y respuestas."]},{"input":"que es node.js","output":["Es un entorno de ejecuci\xf3n para JavaScript que permite construir aplicaciones del lado del servidor.","Es una plataforma que utiliza el motor V8 de Google para ejecutar c\xf3digo JavaScript."]},{"input":"que es npm","output":["Es el gestor de paquetes oficial de Node.js.","Es una herramienta que facilita la instalaci\xf3n y gesti\xf3n de dependencias en proyectos JavaScript."]},{"input":"que es un archivo yaml","output":["Es un formato legible por humanos utilizado para configurar y definir datos.","Es una herramienta com\xfanmente utilizada en archivos de configuraci\xf3n como los de Kubernetes."]},{"input":"que es una variable","output":["Es un espacio en memoria que almacena datos y tiene un nombre asociado.","Es un contenedor que puede contener diferentes valores durante la ejecuci\xf3n de un programa."]},{"input":"que es un bucle","output":["Es una estructura de control que permite ejecutar un bloque de c\xf3digo repetidamente.","Es una t\xe9cnica que se usa para realizar tareas repetitivas hasta que se cumpla una condici\xf3n."]},{"input":"que es un condicional","output":["Es una estructura de control que permite ejecutar diferentes bloques de c\xf3digo seg\xfan una condici\xf3n.","Es una forma de tomar decisiones en un programa basado en comparaciones l\xf3gicas."]},{"input":"que es un algoritmo","output":["Es un conjunto de pasos bien definidos para resolver un problema.","Es una secuencia l\xf3gica de instrucciones que permite realizar una tarea."]},{"input":"que es un lenguaje de programacion","output":["Es un conjunto de reglas y sintaxis que los desarrolladores usan para comunicarse con las computadoras.","Es una herramienta que permite crear software mediante instrucciones comprensibles para las m\xe1quinas."]},{"input":"que ide son populares","output":["Ejemplos incluyen Visual Studio Code, IntelliJ IDEA, Eclipse y PyCharm.","Son aplicaciones ampliamente utilizadas para desarrollar proyectos en lenguajes espec\xedficos o variados."]},{"input":"que es un archivo xml","output":["Es un lenguaje de marcado que define reglas para almacenar y transportar datos.","Se utiliza para representar datos estructurados en aplicaciones como servicios web."]},{"input":"que es un archivo csv","output":["Es un formato de archivo que almacena datos tabulares separados por comas.","Se utiliza com\xfanmente para intercambiar datos entre aplicaciones como hojas de c\xe1lculo y bases de datos."]},{"input":"que es una pila","output":["Es una estructura de datos que sigue el principio LIFO (\xfaltimo en entrar, primero en salir).","Es un contenedor donde los elementos se a\xf1aden y eliminan desde el mismo extremo."]},{"input":"que es una cola","output":["Es una estructura de datos que sigue el principio FIFO (primero en entrar, primero en salir).","Es un contenedor donde los elementos se a\xf1aden al final y se eliminan desde el principio."]},{"input":"que es elasticsearch","output":["Es un motor de b\xfasqueda y an\xe1lisis distribuido basado en documentos.","Es una herramienta utilizada para buscar, analizar y visualizar grandes cantidades de datos."]},{"input":"que es un balanceador de carga","output":["Es un dispositivo o software que distribuye el tr\xe1fico de red entre varios servidores.","Se utiliza para mejorar la disponibilidad y el rendimiento de una aplicaci\xf3n."]},{"input":"que es una red de cdn","output":["Es una red de servidores distribuidos que entrega contenido web de manera r\xe1pida y eficiente.","Se utiliza para reducir la latencia y mejorar la experiencia del usuario."]},{"input":"que es un test unitario","output":["Es una prueba que valida el funcionamiento de una unidad espec\xedfica de c\xf3digo.","Se utiliza para asegurarse de que cada parte del software funcione correctamente de forma aislada."]},{"input":"que es un test de integracion","output":["Es una prueba que verifica c\xf3mo interact\xfaan diferentes m\xf3dulos o componentes entre s\xed.","Se asegura de que las partes del sistema funcionen juntas como se espera."]},{"input":"que es integracion continua","output":["Es una pr\xe1ctica de desarrollo que integra cambios frecuentes en el c\xf3digo en un repositorio compartido.","Se utiliza para detectar errores r\xe1pidamente al compilar y probar cada cambio autom\xe1ticamente."]},{"input":"que es despliegue continuo","output":["Es una pr\xe1ctica que asegura que el software est\xe9 siempre en un estado listo para ser desplegado.","Automatiza la entrega de nuevas versiones del software a entornos de pruebas o producci\xf3n."]},{"input":"que es un archivo de configuracion","output":["Es un archivo que almacena ajustes y par\xe1metros para que un software funcione seg\xfan lo esperado.","Se utiliza para personalizar el comportamiento de una aplicaci\xf3n sin modificar su c\xf3digo fuente."]},{"input":"que es un sistema operativo","output":["Es un software que gestiona los recursos de hardware y software en un dispositivo.","Act\xfaa como intermediario entre los usuarios y el hardware de la computadora."]},{"input":"que son los sistemas operativos","output":["Es un software que gestiona los recursos de hardware y software en un dispositivo.","Act\xfaa como intermediario entre los usuarios y el hardware de la computadora."]},{"input":"que es una funcion en programacion","output":["Es un bloque de c\xf3digo que realiza una tarea espec\xedfica y puede ser reutilizado.","Es una estructura que encapsula l\xf3gica para evitar redundancia en el c\xf3digo."]},{"input":"que es la programacion funcional","output":["Es un paradigma de programaci\xf3n basado en funciones y evaluaci\xf3n sin efectos secundarios.","Se enfoca en la composici\xf3n de funciones puras para lograr resultados."]},{"input":"que es la programacion declarativa","output":["Es un estilo de programaci\xf3n donde se describe el qu\xe9 se quiere hacer, no c\xf3mo hacerlo.","Se utiliza para expresar l\xf3gica sin especificar el control del flujo."]},{"input":"que es un entorno virtual","output":["Es un espacio aislado donde se instalan dependencias espec\xedficas de un proyecto.","Se utiliza para evitar conflictos entre las versiones de bibliotecas y herramientas."]},{"input":"que es un servidor","output":["es un computador o programa que proporciona servicios a otros dispositivos o programas llamados clientes","es un sistema que almacena y distribuye recursos o datos a traves de una red"]},{"input":"que es un cliente","output":["es un dispositivo o programa que solicita servicios o recursos a un servidor","es una parte del sistema que interactua con el servidor para consumir datos o funcionalidades"]},{"input":"que es la nube","output":["es un conjunto de servidores remotos que almacenan y procesan datos accesibles via internet","es un modelo de computacion que permite acceder a recursos y servicios de forma remota"]},{"input":"que es una red","output":["es un conjunto de dispositivos conectados entre si que comparten recursos y datos","es una infraestructura que permite la comunicacion entre computadoras y otros dispositivos"]},{"input":"que es un sistema distribuido","output":["es un conjunto de computadoras que trabajan juntas para lograr un objetivo comun","es un sistema en el que multiples nodos cooperan para procesar datos y realizar tareas"]},{"input":"que es un microservicio","output":["es un componente independiente y especializado que forma parte de una aplicacion mas grande","es un estilo de arquitectura que divide una aplicacion en servicios peque\xf1os y desacoplados"]},{"input":"que es un orquestador de contenedores","output":["es una herramienta que gestiona y coordina el despliegue, la escalabilidad y la operacion de contenedores","es un software que automatiza tareas relacionadas con la administracion de contenedores"]},{"input":"que es machine learning","output":["es una rama de la inteligencia artificial que permite a los sistemas aprender y mejorar automaticamente a partir de los datos","es una tecnica que utiliza algoritmos para identificar patrones y realizar predicciones"]},{"input":"que es un modelo entrenado","output":["es el resultado de aplicar un algoritmo de aprendizaje sobre un conjunto de datos","es una representacion que permite realizar predicciones o clasificaciones basadas en datos previos"]},{"input":"que es un commit","output":["es un cambio registrado en un sistema de control de versiones como git","es una confirmacion de que los cambios en el codigo se han guardado en el historial del proyecto"]},{"input":"que es una rama en git","output":["es una version paralela del codigo que permite trabajar en nuevas funcionalidades sin afectar la principal","es un mecanismo que facilita el desarrollo colaborativo y la gestion de versiones"]},{"input":"que es python","output":["es un lenguaje de programacion de alto nivel y proposito general conocido por su simplicidad y legibilidad","es un lenguaje utilizado en desarrollo web, analisis de datos, inteligencia artificial y muchas otras areas"]},{"input":"cuales son los beneficios de usar python","output":["tiene una sintaxis sencilla que facilita el aprendizaje y el desarrollo rapido","cuenta con una gran cantidad de bibliotecas y una comunidad activa","es multiplataforma y se adapta bien a proyectos de cualquier escala"]},{"input":"que es javascript","output":["es un lenguaje de programacion orientado a objetos que se ejecuta principalmente en navegadores web","es el lenguaje utilizado para agregar interactividad a las paginas web"]},{"input":"cuales son los beneficios de usar javascript","output":["es compatible con todos los navegadores modernos y no requiere configuraciones adicionales","permite el desarrollo tanto del frontend como del backend con tecnologias como nodejs","tiene una comunidad masiva y una amplia variedad de frameworks como react y angular"]},{"input":"que es java","output":["es un lenguaje de programacion orientado a objetos ampliamente utilizado en aplicaciones empresariales","es un lenguaje que permite la creacion de software multiplataforma gracias a su maquina virtual java"]},{"input":"cuales son los beneficios de usar java","output":["es muy estable y confiable, lo que lo hace ideal para aplicaciones a gran escala","tiene una amplia cantidad de herramientas y bibliotecas que facilitan el desarrollo","es compatible con una gran cantidad de dispositivos gracias a su filosofia write once, run anywhere"]},{"input":"que es c","output":["es un lenguaje de programacion de bajo nivel y proposito general conocido por su eficiencia","es uno de los lenguajes mas antiguos y se utiliza en sistemas operativos y software de alto rendimiento"]},{"input":"cuales son los beneficios de usar c","output":["ofrece un control directo sobre el hardware y la gestion de memoria","es rapido y eficiente, lo que lo hace ideal para aplicaciones criticas de rendimiento","es la base de muchos otros lenguajes como c plus plus y java"]},{"input":"que es c plus plus","output":["es una extension del lenguaje c que incorpora programacion orientada a objetos","es un lenguaje utilizado para desarrollar sistemas operativos, videojuegos y aplicaciones de alto rendimiento"]},{"input":"cuales son los beneficios de usar c plus plus","output":["combina el control de bajo nivel de c con capacidades avanzadas de programacion orientada a objetos","es altamente eficiente y escalable, adecuado para proyectos complejos","tiene una amplia comunidad y soporte para bibliotecas como boost y stl"]},{"input":"que es ruby","output":["es un lenguaje de programacion interpretado y orientado a objetos conocido por su sintaxis amigable","es el lenguaje detras del popular framework de desarrollo web ruby on rails"]},{"input":"cuales son los beneficios de usar ruby","output":["facilita el desarrollo rapido de aplicaciones gracias a su sintaxis sencilla","tiene una comunidad activa y un ecosistema de gemas que amplian sus capacidades","es ideal para startups y proyectos con plazos ajustados"]},{"input":"que es go","output":["es un lenguaje de programacion creado por google conocido por su simplicidad y eficiencia","es utilizado en sistemas distribuidos, servicios web y aplicaciones en la nube"]},{"input":"cuales son los beneficios de usar go","output":["es rapido gracias a su compilacion nativa y su gestion eficiente de memoria","tiene soporte integrado para concurrencia mediante goroutines","es ideal para sistemas distribuidos y aplicaciones escalables"]},{"input":"que es php","output":["es un lenguaje de programacion orientado a la web utilizado para desarrollar paginas dinamicas","es uno de los lenguajes mas populares para crear aplicaciones backend"]},{"input":"cuales son los beneficios de usar php","output":["es facil de aprender y tiene una curva de aprendizaje baja","es ampliamente compatible con servidores web y bases de datos como mysql","cuenta con frameworks como laravel y symfony que aceleran el desarrollo"]},{"input":"que es rust","output":["es un lenguaje de programacion de sistemas enfocado en la seguridad y el rendimiento","es utilizado en aplicaciones de alto rendimiento donde la gestion de memoria es crucial"]},{"input":"cuales son los beneficios de usar rust","output":["garantiza seguridad en la memoria gracias a su sistema de ownership","ofrece un rendimiento comparable al de c y c plus plus","tiene una comunidad creciente y es ideal para aplicaciones seguras y robustas"]},{"input":"que es swift","output":["es un lenguaje de programacion creado por apple para desarrollar aplicaciones para sus plataformas","es moderno y seguro, dise\xf1ado para ser rapido y eficiente"]},{"input":"cuales son los beneficios de usar swift","output":["tiene una sintaxis clara y legible, lo que facilita el desarrollo","es compatible con aplicaciones para ios, macos, watchos y tvos","ofrece herramientas avanzadas como playgrounds para aprendizaje interactivo"]},{"input":"que es kotlin","output":["es un lenguaje de programacion moderno y estatico dise\xf1ado para interoperar con java","es el lenguaje oficial para desarrollar aplicaciones android"]},{"input":"cuales son los beneficios de usar kotlin","output":["es conciso y reduce el codigo boilerplate en comparacion con java","ofrece seguridad nula para evitar errores comunes","es compatible con java, lo que facilita su adopcion en proyectos existentes"]},{"input":"que lenguajes de programacion existen","output":["Swift, java script, python, entre otros"]},{"input":"que es scrum","output":["es una metodologia agil para la gestion y desarrollo de proyectos","es un marco de trabajo que organiza el desarrollo en ciclos cortos llamados sprints"]},{"input":"cuales son los beneficios de usar scrum","output":["permite adaptarse rapidamente a los cambios en los requisitos del proyecto","fomenta la colaboracion entre los miembros del equipo","divide el trabajo en tareas manejables para facilitar la entrega continua de valor"]},{"input":"que es un sprint","output":["es un periodo corto de tiempo en scrum donde se completan tareas especificas del proyecto","es un ciclo de trabajo que normalmente dura entre una y cuatro semanas"]},{"input":"que es kanban","output":["es una metodologia visual que ayuda a gestionar el flujo de trabajo","es un sistema que utiliza tarjetas y tableros para organizar y priorizar tareas"]},{"input":"cuales son los beneficios de usar kanban","output":["facilita la identificacion de cuellos de botella en el flujo de trabajo","promueve la mejora continua y la entrega constante de valor","es flexible y puede adaptarse a cualquier tipo de equipo o proyecto"]},{"input":"que es xp","output":["es una metodologia de desarrollo agil conocida como programacion extrema","es un enfoque que enfatiza la calidad del software y la satisfaccion del cliente"]},{"input":"cuales son los beneficios de usar xp","output":["fomenta practicas como el desarrollo guiado por pruebas y la programacion en pareja","mejora la calidad del codigo mediante iteraciones frecuentes y retroalimentacion continua","reduce el riesgo al entregar software funcional de forma incremental"]},{"input":"que es una metodologia agil","output":["es un enfoque para el desarrollo de software que prioriza la flexibilidad y la colaboracion","es una metodologia que busca entregar valor rapido y adaptarse a los cambios"]},{"input":"cuales son los principios de las metodologias agiles","output":["priorizar la satisfaccion del cliente mediante entregas tempranas y continuas","adaptarse a los cambios en los requisitos incluso en etapas avanzadas del desarrollo","fomentar la comunicacion constante entre los desarrolladores y los clientes"]},{"input":"que es waterfall","output":["es una metodologia tradicional donde el desarrollo se realiza en fases lineales","es un modelo secuencial que incluye etapas como analisis, dise\xf1o, desarrollo y pruebas"]},{"input":"cuales son los beneficios de usar waterfall","output":["es facil de entender y gestionar debido a su estructura lineal","es adecuado para proyectos con requisitos claros y bien definidos desde el inicio","proporciona documentacion detallada en cada etapa del proyecto"]},{"input":"que es el modelo v","output":["es una extension del modelo waterfall que enfatiza la validacion y verificacion en cada etapa","es un enfoque que asegura la calidad del software a traves de pruebas sistematicas"]},{"input":"cuales son los beneficios de usar el modelo v","output":["asegura que cada fase de desarrollo tiene una prueba correspondiente","facilita la deteccion temprana de errores","es adecuado para proyectos criticos donde la calidad es prioritaria"]},{"input":"que es el modelo espiral","output":["es una metodologia iterativa que combina elementos del waterfall y prototipos","es un modelo que gestiona riesgos mediante ciclos repetitivos llamados espirales"]},{"input":"cuales son los beneficios del modelo espiral","output":["facilita la gestion de riesgos en cada iteracion","permite mejorar el proyecto basandose en retroalimentacion continua","es adecuado para proyectos grandes y complejos"]},{"input":"que es devops","output":["es una metodologia que combina desarrollo y operaciones para acelerar el ciclo de vida del software","es un enfoque colaborativo que automatiza y mejora los procesos de desarrollo y despliegue"]},{"input":"cuales son los beneficios de usar devops","output":["reduce los tiempos de entrega gracias a la integracion continua y el despliegue continuo","mejora la calidad del software mediante pruebas automatizadas","promueve la colaboracion entre equipos de desarrollo y operaciones"]},{"input":"que es lean development","output":["es una metodologia basada en los principios de lean manufacturing para reducir desperdicios en el desarrollo","es un enfoque que busca maximizar el valor entregado al cliente con el minimo esfuerzo"]},{"input":"cuales son los beneficios de lean development","output":["reduce los tiempos de desarrollo al eliminar tareas innecesarias","fomenta la mejora continua y el aprendizaje constante","prioriza las funcionalidades que aportan valor directo al cliente"]},{"input":"que es el desarrollo guiado por pruebas","output":["es una metodologia en la que las pruebas se escriben antes del codigo","es un enfoque que asegura que el software cumpla con los requisitos definidos"]},{"input":"cuales son los beneficios del desarrollo guiado por pruebas","output":["reduce errores al definir claramente los requisitos antes de programar","mejora la calidad del codigo y facilita el mantenimiento","fomenta una mejor comprension de los objetivos del proyecto"]},{"input":"que es crystal","output":["es una metodologia agil que se adapta al tama\xf1o y la complejidad del proyecto","es un enfoque flexible que prioriza la comunicacion y la satisfaccion del cliente"]},{"input":"cuales son los beneficios de usar crystal","output":["es adaptable a diferentes equipos y contextos","fomenta la colaboracion y la retroalimentacion constante","prioriza la entrega temprana y continua de valor"]},{"input":"que es safe","output":["es un marco de trabajo agil para la gestion de proyectos a gran escala","es un enfoque que coordina multiples equipos para entregar valor de manera alineada"]},{"input":"cuales son los beneficios de usar safe","output":["facilita la sincronizacion entre equipos grandes","promueve la transparencia y la alineacion en proyectos complejos","es ideal para empresas que buscan escalar sus practicas agiles"]},{"input":"cuales son las partes de una computadora","output":["las partes principales son la unidad central de procesamiento, la memoria ram, el disco duro, la tarjeta madre, y la fuente de alimentacion","incluyen el procesador, la memoria, el almacenamiento, y los perifericos como teclado y monitor"]},{"input":"que es el procesador","output":["es el cerebro de la computadora que ejecuta las instrucciones de los programas","es la unidad central de procesamiento encargada de realizar los calculos y tomar decisiones"]},{"input":"cuales son los beneficios de un procesador rapido","output":["permite ejecutar programas de manera mas fluida","mejora el rendimiento general de la computadora","reduce el tiempo de carga de aplicaciones"]},{"input":"que es la memoria ram","output":["es un tipo de memoria que almacena datos temporalmente mientras se ejecutan programas","es una memoria volatil que permite el acceso rapido a los datos que necesita el procesador"]},{"input":"para que sirve la memoria ram","output":["sirve para ejecutar programas y cargar datos rapidamente","permite que el sistema operativo y las aplicaciones funcionen de manera eficiente"]},{"input":"que es un disco duro","output":["es un dispositivo de almacenamiento que guarda datos de forma permanente","es el lugar donde se almacenan los sistemas operativos, programas y archivos del usuario"]},{"input":"cuales son las diferencias entre un disco duro y un ssd","output":["un ssd es mas rapido y silencioso que un disco duro tradicional","los discos duros suelen tener mayor capacidad de almacenamiento a un costo menor","los ssd son mas resistentes a golpes y vibraciones"]},{"input":"que es la tarjeta madre","output":["es el componente principal de una computadora donde se conectan todos los demas componentes","es una placa de circuito que permite la comunicacion entre el procesador, la memoria y los dispositivos perifericos"]},{"input":"para que sirve la tarjeta madre","output":["sirve como base para conectar y coordinar todos los componentes de la computadora","proporciona puertos y conexiones para dispositivos externos e internos"]},{"input":"que es la fuente de alimentacion","output":["es un componente que convierte la electricidad de la toma corriente en energia util para la computadora","es el dispositivo encargado de suministrar energia a todos los componentes internos"]},{"input":"cuales son los beneficios de una buena fuente de alimentacion","output":["proporciona energia estable y protege contra sobretensiones","mejora la eficiencia energetica y prolonga la vida util de los componentes","permite expandir la computadora con componentes de mayor consumo"]},{"input":"que es una tarjeta grafica","output":["es un componente que se encarga de procesar y renderizar graficos en una computadora","es una unidad dedicada para manejar tareas relacionadas con graficos y video"]},{"input":"para que sirve una tarjeta grafica","output":["sirve para mejorar el rendimiento en aplicaciones graficas y juegos","permite trabajar con software de edicion de video y modelado 3d de manera eficiente"]},{"input":"que es un monitor","output":["es un dispositivo de salida que muestra informacion visual al usuario","es una pantalla donde se pueden ver las tareas que realiza la computadora"]},{"input":"cuales son las diferencias entre un monitor lcd y uno led","output":["los monitores led tienen mejor contraste y colores mas vivos que los lcd","los monitores led consumen menos energia que los lcd","los lcd son generalmente mas economicos pero menos avanzados"]},{"input":"que es un teclado","output":["es un dispositivo de entrada que permite al usuario ingresar texto y comandos","es un periferico que contiene teclas para interactuar con la computadora"]},{"input":"que es un mouse","output":["es un dispositivo de entrada que permite mover un cursor en la pantalla y seleccionar elementos","es un periferico que facilita la navegacion e interaccion con la computadora"]},{"input":"que es un sistema de enfriamiento","output":["es un conjunto de dispositivos que regulan la temperatura de los componentes de la computadora","es un sistema que previene el sobrecalentamiento del procesador y otros componentes"]},{"input":"cuales son los beneficios de un buen sistema de enfriamiento","output":["prolonga la vida util de los componentes","mejora el rendimiento al mantener los componentes a temperaturas optimas","reduce el ruido generado por los ventiladores"]},{"input":"que son los perifericos","output":["son dispositivos externos que amplian las funciones de la computadora","incluyen dispositivos de entrada como el teclado y de salida como el monitor"]},{"input":"cuales son los beneficios de usar perifericos adicionales","output":["amplian las capacidades de la computadora para tareas especificas","mejoran la experiencia del usuario con dispositivos como impresoras y altavoces","facilitan la productividad y el entretenimiento"]},{"input":"que es un sistema operativo","output":["es un software que gestiona los recursos hardware y permite ejecutar programas en una computadora","es un conjunto de programas que coordinan y controlan el hardware de un dispositivo"]},{"input":"cuales son los principales sistemas operativos","output":["los principales son Windows, macOS, Linux, y sus variantes","algunos ejemplos comunes son Windows 10, Ubuntu, y macOS Big Sur"]},{"input":"que es windows","output":["es un sistema operativo desarrollado por Microsoft","es un sistema operativo gr\xe1fico que es ampliamente utilizado en computadoras personales"]},{"input":"cuales son los beneficios de usar windows","output":["es compatible con una gran cantidad de software y hardware","tiene una interfaz gr\xe1fica amigable y es f\xe1cil de usar","es ampliamente utilizado en entornos corporativos y de juegos"]},{"input":"que es macos","output":["es un sistema operativo desarrollado por Apple para sus computadoras Mac","es un sistema operativo basado en Unix que tiene una interfaz gr\xe1fica pulida"]},{"input":"cuales son los beneficios de usar macos","output":["ofrece un ecosistema cerrado y optimizado para los dispositivos Apple","es conocido por su estabilidad, seguridad y facilidad de uso","tiene una integraci\xf3n perfecta con otros dispositivos Apple como iPhones y iPads"]},{"input":"que es linux","output":["es un sistema operativo de c\xf3digo abierto basado en el n\xfacleo Linux","es un sistema operativo flexible que se puede personalizar ampliamente"]},{"input":"cuales son los beneficios de usar linux","output":["es gratuito y de c\xf3digo abierto, lo que permite personalizarlo y adaptarlo a las necesidades del usuario","es conocido por su estabilidad y seguridad","tiene una gran comunidad que ofrece soporte y desarrollos continuos"]},{"input":"que es una distribucion de linux","output":["es una versi\xf3n de Linux que incluye el n\xfacleo junto con software adicional como gestores de paquetes y aplicaciones","es una version del sistema operativo adaptada a ciertos tipos de usuarios o necesidades"]},{"input":"cuales son las distribuciones de linux mas populares","output":["algunas de las distribuciones m\xe1s populares son Ubuntu, Fedora, Debian, y Arch Linux","Ubuntu es conocida por ser f\xe1cil de usar, mientras que Arch Linux es popular entre usuarios avanzados"]},{"input":"que es ubuntu","output":["es una distribuci\xf3n de Linux basada en Debian, conocida por ser f\xe1cil de usar y orientada a usuarios nuevos","es una de las distribuciones de Linux m\xe1s populares para escritorios y servidores"]},{"input":"cuales son los beneficios de usar ubuntu","output":["es f\xe1cil de instalar y tiene una amplia documentaci\xf3n y comunidad","es compatible con una gran cantidad de hardware y software","tiene una interfaz gr\xe1fica amigable para usuarios novatos"]},{"input":"que es fedora","output":["es una distribuci\xf3n de Linux patrocinada por Red Hat, conocida por ser vanguardista y tener software actualizado","es una distribuci\xf3n de Linux que proporciona una plataforma de c\xf3digo abierto y libre para desarrolladores"]},{"input":"cuales son los beneficios de usar fedora","output":["tiene acceso a las \xfaltimas tecnolog\xedas y caracter\xedsticas en software libre","est\xe1 bien respaldada por la comunidad y Red Hat","es ideal para desarrolladores y usuarios avanzados que buscan estabilidad y novedades"]},{"input":"que es debian","output":["es una distribuci\xf3n de Linux conocida por su estabilidad y soporte a largo plazo","es una de las distribuciones m\xe1s antiguas y es la base de muchas otras distribuciones como Ubuntu"]},{"input":"cuales son los beneficios de usar debian","output":["es muy estable y tiene una gran base de usuarios","se enfoca en la fiabilidad y la seguridad","tiene un ciclo de actualizaciones regulares y bien soportadas"]},{"input":"que es arch linux","output":["es una distribuci\xf3n de Linux orientada a usuarios avanzados que prefieren un control total sobre su sistema","es conocida por su filosof\xeda de simplicidad y personalizaci\xf3n"]},{"input":"cuales son los beneficios de usar arch linux","output":["ofrece un control completo sobre los paquetes y configuraciones del sistema","tiene un modelo de actualizaciones continuas que siempre proporciona las \xfaltimas versiones de software","es ideal para usuarios que quieren aprender sobre Linux en profundidad"]},{"input":"que es el terminal en linux","output":["es una interfaz de l\xednea de comandos que permite interactuar con el sistema operativo mediante texto","es una herramienta poderosa que permite ejecutar comandos, scripts y administrar el sistema"]},{"input":"cuales son los beneficios de usar el terminal","output":["permite realizar tareas de manera m\xe1s r\xe1pida y eficiente que usando solo una interfaz gr\xe1fica","es ideal para la automatizaci\xf3n de tareas mediante scripts","ofrece un control total sobre el sistema y es utilizado por administradores de sistemas"]},{"input":"que es un gestor de paquetes en linux","output":["es una herramienta que facilita la instalaci\xf3n, actualizaci\xf3n y eliminaci\xf3n de software en Linux","es un sistema que maneja las dependencias y versiones de los paquetes de software"]},{"input":"cuales son los gestores de paquetes m\xe1s comunes en linux","output":["los gestores de paquetes m\xe1s comunes son apt para Debian y Ubuntu, dnf para Fedora, y pacman para Arch Linux","cada distribuci\xf3n de Linux tiene su propio gestor de paquetes"]},{"input":"que es un entorno de escritorio","output":["es un conjunto de aplicaciones y componentes gr\xe1ficos que proporcionan una interfaz de usuario en una computadora","es lo que ves y usas para interactuar con tu sistema operativo de manera visual"]},{"input":"cuales son los entornos de escritorio m\xe1s populares en linux","output":["los entornos de escritorio m\xe1s populares son GNOME, KDE Plasma, y XFCE","cada uno ofrece una experiencia de usuario diferente, desde minimalista hasta completamente personalizada"]},{"input":"que es la seguridad en linux","output":["es un conjunto de pr\xe1cticas y herramientas dise\xf1adas para proteger el sistema operativo de ataques y accesos no autorizados","Linux tiene una estructura de permisos que permite controlar el acceso a archivos y recursos del sistema"]},{"input":"cuales son los beneficios de la seguridad en linux","output":["Linux es conocido por ser m\xe1s seguro que otros sistemas operativos debido a su modelo de permisos y la rapidez con que se aplican actualizaciones de seguridad","su naturaleza abierta permite que la comunidad identifique y corrija vulnerabilidades r\xe1pidamente"]},{"input":"cuales son los tipos de algoritmos","output":["los tipos de algoritmos incluyen algoritmos de b\xfasqueda, ordenamiento, grafos, y de optimizaci\xf3n","tambi\xe9n existen algoritmos recursivos, iterativos, y paralelos"]},{"input":"que es un algoritmo de busqueda","output":["es un algoritmo utilizado para encontrar un elemento dentro de una estructura de datos, como un arreglo o lista","los algoritmos de b\xfasqueda m\xe1s comunes son la b\xfasqueda lineal y la b\xfasqueda binaria"]},{"input":"que es la busqueda lineal","output":["es un algoritmo de b\xfasqueda que recorre los elementos de una lista uno por uno hasta encontrar el elemento buscado","es simple y eficiente para listas peque\xf1as, pero no es \xf3ptimo para listas grandes"]},{"input":"que es la busqueda binaria","output":["es un algoritmo de b\xfasqueda eficiente que divide una lista ordenada en dos partes y descarta la mitad en cada paso","es mucho m\xe1s r\xe1pido que la b\xfasqueda lineal en listas grandes, pero requiere que la lista est\xe9 ordenada"]},{"input":"que es un algoritmo de ordenamiento","output":["es un algoritmo que organiza los elementos de una lista en un orden espec\xedfico, como ascendente o descendente","los algoritmos de ordenamiento m\xe1s comunes son el ordenamiento por burbuja, selecci\xf3n y merge sort"]},{"input":"que es el algoritmo de ordenamiento por burbuja","output":["es un algoritmo simple que compara elementos adyacentes en una lista y los intercambia si est\xe1n en el orden incorrecto","es f\xe1cil de entender y implementar, pero no es muy eficiente para listas grandes"]},{"input":"que es el algoritmo de seleccion","output":["es un algoritmo de ordenamiento que selecciona el menor (o mayor) elemento de una lista y lo coloca en la posici\xf3n correcta, repitiendo el proceso para el resto de los elementos","es m\xe1s eficiente que el ordenamiento por burbuja, pero todav\xeda no es el m\xe1s r\xe1pido para listas grandes"]},{"input":"que es el merge sort","output":["es un algoritmo de ordenamiento eficiente basado en la t\xe9cnica de dividir y conquistar","divide la lista en partes m\xe1s peque\xf1as, las ordena y luego las fusiona para formar la lista ordenada"]},{"input":"que es un algoritmo de grafos","output":["es un tipo de algoritmo utilizado para resolver problemas relacionados con redes de nodos y conexiones, como rutas m\xe1s cortas o flujos de informaci\xf3n","los algoritmos de grafos m\xe1s comunes son el algoritmo de Dijkstra y el algoritmo de Floyd-Warshall"]},{"input":"que es el algoritmo de dijkstra","output":["es un algoritmo que encuentra la ruta m\xe1s corta desde un nodo de inicio a todos los dem\xe1s nodos de un grafo ponderado","es muy eficiente y se utiliza en aplicaciones como el GPS para calcular rutas"]},{"input":"que es el algoritmo de floyd-warshall","output":["es un algoritmo que encuentra las rutas m\xe1s cortas entre todos los pares de nodos en un grafo","es \xfatil cuando se necesita conocer las distancias m\xe1s cortas entre cualquier par de nodos, pero no es tan eficiente como otros algoritmos en grafos grandes"]},{"input":"que es un algoritmo de optimizacion","output":["es un algoritmo que busca la mejor soluci\xf3n posible a un problema, generalmente dentro de un conjunto de soluciones posibles","se utilizan en \xe1reas como la programaci\xf3n lineal, la asignaci\xf3n de recursos y la planificaci\xf3n de rutas"]},{"input":"que es un algoritmo recursivo","output":["es un algoritmo que se llama a s\xed mismo con un conjunto reducido de datos hasta que se alcanza una condici\xf3n base","es \xfatil para problemas que pueden dividirse en subproblemas similares, como el c\xe1lculo de factoriales o la b\xfasqueda binaria"]},{"input":"que es la recursion en algoritmos","output":["es el proceso de que un algoritmo se llame a s\xed mismo para resolver subproblemas m\xe1s peque\xf1os","se utiliza en algoritmos como la b\xfasqueda binaria, ordenamiento por merge, y en la resoluci\xf3n de problemas matem\xe1ticos"]},{"input":"que es un algoritmo iterativo","output":["es un algoritmo que repite un conjunto de instrucciones hasta que se cumple una condici\xf3n espec\xedfica","es com\xfanmente utilizado en bucles y estructuras de control como for y while"]},{"input":"cual es la diferencia entre recursi\xf3n e iteracion","output":["la recursi\xf3n implica que el algoritmo se llame a s\xed mismo, mientras que la iteraci\xf3n usa bucles para repetir una serie de instrucciones","la recursi\xf3n es m\xe1s elegante y clara en algunos problemas, mientras que la iteraci\xf3n es m\xe1s eficiente en t\xe9rminos de memoria"]},{"input":"que es un algoritmo paralelo","output":["es un algoritmo que divide un problema en subproblemas m\xe1s peque\xf1os y los resuelve simult\xe1neamente utilizando m\xfaltiples procesadores o n\xfacleos","se utiliza para acelerar el procesamiento de grandes cantidades de datos, como en el an\xe1lisis de datos masivos y la inteligencia artificial"]},{"input":"que es el algoritmo de busqueda en profundidad","output":["es un algoritmo de b\xfasqueda en grafos que explora tan profundamente como sea posible antes de retroceder","se utiliza en la resoluci\xf3n de problemas de laberintos, \xe1rboles de decisi\xf3n y otros problemas de exploraci\xf3n"]},{"input":"que es el algoritmo de busqueda en anchura","output":["es un algoritmo de b\xfasqueda en grafos que explora todos los nodos de un nivel antes de pasar al siguiente","es \xfatil cuando se busca la ruta m\xe1s corta en un grafo no ponderado"]},{"input":"que es un algoritmo de clasificacion","output":["es un tipo de algoritmo que organiza los elementos de un conjunto en un orden determinado, ya sea ascendente o descendente","los algoritmos de clasificaci\xf3n m\xe1s conocidos son quicksort, bubblesort y merge sort"]},{"input":"que es un algoritmo de encriptacion","output":["es un algoritmo que convierte informaci\xf3n legible en un formato cifrado para garantizar la privacidad de los datos","se utilizan en la seguridad inform\xe1tica para proteger contrase\xf1as y comunicaciones sensibles"]}]');function DG(e,t){const n=["y","que","o","u","pero","porque","aunque","si","cuando","como","por","a","de","en","con","para","el","la","los","las","un","una","unos","unas","al","del"],s=e.normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^\w\s]/g,"").toLowerCase().split(" ").filter(e=>!n.includes(e)),r=new Array(t.length).fill(0);return s.forEach(e=>{const n=t.indexOf(e);-1!==n?r[n]=1:console.warn(`Unknown word: ${e}`)}),r}function OG(e){return e[Math.floor(Math.random()*e.length)]}function qG(e){const t=e.map(e=>e.input.toLowerCase().split(" ")).reduce((e,t)=>e.concat(t),[]);return Array.from(new Set(t))}function zG(e,t){const n=new Z$(void 0);return n.add(aR({units:16,activation:"relu",inputShape:[e]})),n.add(aR({units:8,activation:"relu"})),n.add(aR({units:t,activation:"softmax"})),n.compile({optimizer:"adam",loss:"categoricalCrossentropy",metrics:["accuracy"]}),n}function MG(){return(MG=bh(function*(){const e=qG(FG),t=zG(e.length,FG.length),n=FG.map(t=>DG(t.input,e)),s=FG.map((e,t)=>{const n=new Array(FG.length).fill(0);return n[t]=1,n}),r=Fw(n),a=Fw(s);yield t.fit(r,a,{epochs:200,batchSize:15,shuffle:!0}),yield t.save("localstorage://chatbot-model"),console.log("Modelo entrenado y guardado.")})).apply(this,arguments)}function LG(){return(LG=bh(function*(e){const t=qG(FG),n=yield Q$("localstorage://chatbot-model"),s=Fw([DG(e,t)],[1,t.length]),r=n.predict(s).argMax(-1).dataSync()[0];return OG(FG[r].output)})).apply(this,arguments)}let PG=(()=>{class e{trainChatbot(){return bh(function*(){const e=localStorage.getItem("tensorflowjs_models/chatbot-model/info");null===JSON.parse(e)?(console.log("Entrenando modelo..."),yield function(){return MG.apply(this,arguments)}()):console.log("Modelo ya entrenado")})()}getResponse(e){return bh(function*(){return yield function(e){return LG.apply(this,arguments)}(e)})()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({token:e,factory:e.\u0275fac,providedIn:"root"}),e})();function VG(e,t){return new k(n=>{const s=e.length;if(0===s)return void n.complete();const r=new Array(s);let a=0,o=0;for(let i=0;i<s;i++){const u=P(e[i]);let l=!1;n.add(u.subscribe({next:e=>{l||(l=!0,o++),r[i]=e},error:e=>n.error(e),complete:()=>{a++,a!==s&&l||(o===s&&n.next(t?t.reduce((e,t,n)=>(e[t]=r[n],e),{}):r),n.complete())}}))}})}let jG=(()=>{class e{constructor(e,t){this._renderer=e,this._elementRef=t,this.onChange=e=>{},this.onTouched=()=>{}}setProperty(e,t){this._renderer.setProperty(this._elementRef.nativeElement,e,t)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return e.\u0275fac=function(t){return new(t||e)(va(po),va(uo))},e.\u0275dir=Ye({type:e}),e})(),BG=(()=>{class e extends jG{}return e.\u0275fac=function(){let t;return function(n){return(t||(t=On(e)))(n||e)}}(),e.\u0275dir=Ye({type:e,features:[la]}),e})();const WG=new Ln("NgValueAccessor"),UG={provide:WG,useExisting:ie(()=>HG),multi:!0},GG=new Ln("CompositionEventMode");let HG=(()=>{class e extends jG{constructor(e,t,n){super(e,t),this._compositionMode=n,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function(){const e=ku()?ku().getUserAgent():"";return/android (\d+)/.test(e.toLowerCase())}())}writeValue(e){this.setProperty("value",null==e?"":e)}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return e.\u0275fac=function(t){return new(t||e)(va(po),va(uo),va(GG,8))},e.\u0275dir=Ye({type:e,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,t){1&e&&Ea("input",function(e){return t._handleInput(e.target.value)})("blur",function(){return t.onTouched()})("compositionstart",function(){return t._compositionStart()})("compositionend",function(e){return t._compositionEnd(e.target.value)})},features:[to([UG]),la]}),e})();const KG=new Ln("NgValidators"),XG=new Ln("NgAsyncValidators");function ZG(e){return null!=e}function YG(e){const t=_a(e)?P(e):e;return Sa(t),t}function QG(e){let t={};return e.forEach(e=>{t=null!=e?Object.assign(Object.assign({},t),e):t}),0===Object.keys(t).length?null:t}function JG(e,t){return t.map(t=>t(e))}function eH(e){return e.map(e=>function(e){return!e.validate}(e)?e:t=>e.validate(t))}function tH(e){return null!=e?function(e){if(!e)return null;const t=e.filter(ZG);return 0==t.length?null:function(e){return QG(JG(e,t))}}(eH(e)):null}function nH(e){return null!=e?function(e){if(!e)return null;const t=e.filter(ZG);return 0==t.length?null:function(e){return function(...e){if(1===e.length){const t=e[0];if(p(t))return VG(t,null);if(h(t)&&Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);return VG(e.map(e=>t[e]),e)}}if("function"==typeof e[e.length-1]){const t=e.pop();return VG(e=1===e.length&&p(e[0])?e[0]:e,null).pipe(T(e=>t(...e)))}return VG(e,null)}(JG(e,t).map(YG)).pipe(T(QG))}}(eH(e)):null}function sH(e,t){return null===e?[t]:Array.isArray(e)?[...e,t]:[e,t]}function rH(e){return e._rawValidators}function aH(e){return e._rawAsyncValidators}let oH=(()=>{class e{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(e){this._rawValidators=e||[],this._composedValidatorFn=tH(this._rawValidators)}_setAsyncValidators(e){this._rawAsyncValidators=e||[],this._composedAsyncValidatorFn=nH(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(e){this._onDestroyCallbacks.push(e)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(e=>e()),this._onDestroyCallbacks=[]}reset(e){this.control&&this.control.reset(e)}hasError(e,t){return!!this.control&&this.control.hasError(e,t)}getError(e,t){return this.control?this.control.getError(e,t):null}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275dir=Ye({type:e}),e})(),iH=(()=>{class e extends oH{get formDirective(){return null}get path(){return null}}return e.\u0275fac=function(){let t;return function(n){return(t||(t=On(e)))(n||e)}}(),e.\u0275dir=Ye({type:e,features:[la]}),e})();class uH extends oH{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class lH{constructor(e){this._cd=e}is(e){var t,n;return!!(null===(n=null===(t=this._cd)||void 0===t?void 0:t.control)||void 0===n?void 0:n[e])}}let cH=(()=>{class e extends lH{constructor(e){super(e)}}return e.\u0275fac=function(t){return new(t||e)(va(uH,2))},e.\u0275dir=Ye({type:e,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,t){2&e&&Ra("ng-untouched",t.is("untouched"))("ng-touched",t.is("touched"))("ng-pristine",t.is("pristine"))("ng-dirty",t.is("dirty"))("ng-valid",t.is("valid"))("ng-invalid",t.is("invalid"))("ng-pending",t.is("pending"))},features:[la]}),e})(),dH=(()=>{class e extends lH{constructor(e){super(e)}}return e.\u0275fac=function(t){return new(t||e)(va(iH,10))},e.\u0275dir=Ye({type:e,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:14,hostBindings:function(e,t){2&e&&Ra("ng-untouched",t.is("untouched"))("ng-touched",t.is("touched"))("ng-pristine",t.is("pristine"))("ng-dirty",t.is("dirty"))("ng-valid",t.is("valid"))("ng-invalid",t.is("invalid"))("ng-pending",t.is("pending"))},features:[la]}),e})();function pH(e,t){return[...t.path,e]}function hH(e,t){gH(e,t),t.valueAccessor.writeValue(e.value),function(e,t){t.valueAccessor.registerOnChange(n=>{e._pendingValue=n,e._pendingChange=!0,e._pendingDirty=!0,"change"===e.updateOn&&yH(e,t)})}(e,t),function(e,t){const n=(e,n)=>{t.valueAccessor.writeValue(e),n&&t.viewToModelUpdate(e)};e.registerOnChange(n),t._registerOnDestroy(()=>{e._unregisterOnChange(n)})}(e,t),function(e,t){t.valueAccessor.registerOnTouched(()=>{e._pendingTouched=!0,"blur"===e.updateOn&&e._pendingChange&&yH(e,t),"submit"!==e.updateOn&&e.markAsTouched()})}(e,t),function(e,t){if(t.valueAccessor.setDisabledState){const n=e=>{t.valueAccessor.setDisabledState(e)};e.registerOnDisabledChange(n),t._registerOnDestroy(()=>{e._unregisterOnDisabledChange(n)})}}(e,t)}function fH(e,t,n=!0){const s=()=>{};t.valueAccessor&&(t.valueAccessor.registerOnChange(s),t.valueAccessor.registerOnTouched(s)),bH(e,t),e&&(t._invokeOnDestroyCallbacks(),e._registerOnCollectionChange(()=>{}))}function mH(e,t){e.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function gH(e,t){const n=rH(e);null!==t.validator?e.setValidators(sH(n,t.validator)):"function"==typeof n&&e.setValidators([n]);const s=aH(e);null!==t.asyncValidator?e.setAsyncValidators(sH(s,t.asyncValidator)):"function"==typeof s&&e.setAsyncValidators([s]);const r=()=>e.updateValueAndValidity();mH(t._rawValidators,r),mH(t._rawAsyncValidators,r)}function bH(e,t){let n=!1;if(null!==e){if(null!==t.validator){const s=rH(e);if(Array.isArray(s)&&s.length>0){const r=s.filter(e=>e!==t.validator);r.length!==s.length&&(n=!0,e.setValidators(r))}}if(null!==t.asyncValidator){const s=aH(e);if(Array.isArray(s)&&s.length>0){const r=s.filter(e=>e!==t.asyncValidator);r.length!==s.length&&(n=!0,e.setAsyncValidators(r))}}}const s=()=>{};return mH(t._rawValidators,s),mH(t._rawAsyncValidators,s),n}function yH(e,t){e._pendingDirty&&e.markAsDirty(),e.setValue(e._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(e._pendingValue),e._pendingChange=!1}function vH(e,t){if(!e.hasOwnProperty("model"))return!1;const n=e.model;return!!n.isFirstChange()||!Object.is(t,n.currentValue)}function xH(e,t){if(!t)return null;let n,s,r;return Array.isArray(t),t.forEach(e=>{e.constructor===HG?n=e:Object.getPrototypeOf(e.constructor)===BG?s=e:r=e}),r||s||n||null}function wH(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}const kH="VALID",CH="INVALID",IH="PENDING",_H="DISABLED";function SH(e){return(TH(e)?e.validators:e)||null}function EH(e){return Array.isArray(e)?tH(e):e||null}function NH(e,t){return(TH(t)?t.asyncValidators:e)||null}function $H(e){return Array.isArray(e)?nH(e):e||null}function TH(e){return null!=e&&!Array.isArray(e)&&"object"==typeof e}class AH{constructor(e,t){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=e,this._rawAsyncValidators=t,this._composedValidatorFn=EH(this._rawValidators),this._composedAsyncValidatorFn=$H(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(e){this._rawValidators=this._composedValidatorFn=e}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(e){this._rawAsyncValidators=this._composedAsyncValidatorFn=e}get parent(){return this._parent}get valid(){return this.status===kH}get invalid(){return this.status===CH}get pending(){return this.status==IH}get disabled(){return this.status===_H}get enabled(){return this.status!==_H}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(e){this._rawValidators=e,this._composedValidatorFn=EH(e)}setAsyncValidators(e){this._rawAsyncValidators=e,this._composedAsyncValidatorFn=$H(e)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(e={}){this.touched=!0,this._parent&&!e.onlySelf&&this._parent.markAsTouched(e)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(e=>e.markAllAsTouched())}markAsUntouched(e={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}markAsDirty(e={}){this.pristine=!1,this._parent&&!e.onlySelf&&this._parent.markAsDirty(e)}markAsPristine(e={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}markAsPending(e={}){this.status=IH,!1!==e.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!e.onlySelf&&this._parent.markAsPending(e)}disable(e={}){const t=this._parentMarkedDirty(e.onlySelf);this.status=_H,this.errors=null,this._forEachChild(t=>{t.disable(Object.assign(Object.assign({},e),{onlySelf:!0}))}),this._updateValue(),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},e),{skipPristineCheck:t})),this._onDisabledChange.forEach(e=>e(!0))}enable(e={}){const t=this._parentMarkedDirty(e.onlySelf);this.status=kH,this._forEachChild(t=>{t.enable(Object.assign(Object.assign({},e),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},e),{skipPristineCheck:t})),this._onDisabledChange.forEach(e=>e(!1))}_updateAncestors(e){this._parent&&!e.onlySelf&&(this._parent.updateValueAndValidity(e),e.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(e){this._parent=e}updateValueAndValidity(e={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),this.status!==kH&&this.status!==IH||this._runAsyncValidator(e.emitEvent)),!1!==e.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!e.onlySelf&&this._parent.updateValueAndValidity(e)}_updateTreeValidity(e={emitEvent:!0}){this._forEachChild(t=>t._updateTreeValidity(e)),this.updateValueAndValidity({onlySelf:!0,emitEvent:e.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?_H:kH}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(e){if(this.asyncValidator){this.status=IH,this._hasOwnPendingAsyncValidator=!0;const t=YG(this.asyncValidator(this));this._asyncValidationSubscription=t.subscribe(t=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(t,{emitEvent:e})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(e,t={}){this.errors=e,this._updateControlsErrors(!1!==t.emitEvent)}get(e){return function(e,t,n){if(null==t)return null;if(Array.isArray(t)||(t=t.split(".")),Array.isArray(t)&&0===t.length)return null;let s=e;return t.forEach(e=>{s=s instanceof FH?s.controls.hasOwnProperty(e)?s.controls[e]:null:s instanceof DH&&s.at(e)||null}),s}(this,e)}getError(e,t){const n=t?this.get(t):this;return n&&n.errors?n.errors[e]:null}hasError(e,t){return!!this.getError(e,t)}get root(){let e=this;for(;e._parent;)e=e._parent;return e}_updateControlsErrors(e){this.status=this._calculateStatus(),e&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(e)}_initObservables(){this.valueChanges=new ci,this.statusChanges=new ci}_calculateStatus(){return this._allControlsDisabled()?_H:this.errors?CH:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(IH)?IH:this._anyControlsHaveStatus(CH)?CH:kH}_anyControlsHaveStatus(e){return this._anyControls(t=>t.status===e)}_anyControlsDirty(){return this._anyControls(e=>e.dirty)}_anyControlsTouched(){return this._anyControls(e=>e.touched)}_updatePristine(e={}){this.pristine=!this._anyControlsDirty(),this._parent&&!e.onlySelf&&this._parent._updatePristine(e)}_updateTouched(e={}){this.touched=this._anyControlsTouched(),this._parent&&!e.onlySelf&&this._parent._updateTouched(e)}_isBoxedValue(e){return"object"==typeof e&&null!==e&&2===Object.keys(e).length&&"value"in e&&"disabled"in e}_registerOnCollectionChange(e){this._onCollectionChange=e}_setUpdateStrategy(e){TH(e)&&null!=e.updateOn&&(this._updateOn=e.updateOn)}_parentMarkedDirty(e){return!e&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class RH extends AH{constructor(e=null,t,n){super(SH(t),NH(n,t)),this._onChange=[],this._applyFormState(e),this._setUpdateStrategy(t),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}setValue(e,t={}){this.value=this._pendingValue=e,this._onChange.length&&!1!==t.emitModelToViewChange&&this._onChange.forEach(e=>e(this.value,!1!==t.emitViewToModelChange)),this.updateValueAndValidity(t)}patchValue(e,t={}){this.setValue(e,t)}reset(e=null,t={}){this._applyFormState(e),this.markAsPristine(t),this.markAsUntouched(t),this.setValue(this.value,t),this._pendingChange=!1}_updateValue(){}_anyControls(e){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(e){this._onChange.push(e)}_unregisterOnChange(e){wH(this._onChange,e)}registerOnDisabledChange(e){this._onDisabledChange.push(e)}_unregisterOnDisabledChange(e){wH(this._onDisabledChange,e)}_forEachChild(e){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(e){this._isBoxedValue(e)?(this.value=this._pendingValue=e.value,e.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=e}}class FH extends AH{constructor(e,t,n){super(SH(t),NH(n,t)),this.controls=e,this._initObservables(),this._setUpdateStrategy(t),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(e,t){return this.controls[e]?this.controls[e]:(this.controls[e]=t,t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange),t)}addControl(e,t,n={}){this.registerControl(e,t),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}removeControl(e,t={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],this.updateValueAndValidity({emitEvent:t.emitEvent}),this._onCollectionChange()}setControl(e,t,n={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),delete this.controls[e],t&&this.registerControl(e,t),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}contains(e){return this.controls.hasOwnProperty(e)&&this.controls[e].enabled}setValue(e,t={}){this._checkAllValuesPresent(e),Object.keys(e).forEach(n=>{this._throwIfControlMissing(n),this.controls[n].setValue(e[n],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t)}patchValue(e,t={}){null!=e&&(Object.keys(e).forEach(n=>{this.controls[n]&&this.controls[n].patchValue(e[n],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t))}reset(e={},t={}){this._forEachChild((n,s)=>{n.reset(e[s],{onlySelf:!0,emitEvent:t.emitEvent})}),this._updatePristine(t),this._updateTouched(t),this.updateValueAndValidity(t)}getRawValue(){return this._reduceChildren({},(e,t,n)=>(e[n]=t instanceof RH?t.value:t.getRawValue(),e))}_syncPendingControls(){let e=this._reduceChildren(!1,(e,t)=>!!t._syncPendingControls()||e);return e&&this.updateValueAndValidity({onlySelf:!0}),e}_throwIfControlMissing(e){if(!Object.keys(this.controls).length)throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.controls[e])throw new Error(`Cannot find form control with name: ${e}.`)}_forEachChild(e){Object.keys(this.controls).forEach(t=>{const n=this.controls[t];n&&e(n,t)})}_setUpControls(){this._forEachChild(e=>{e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(e){for(const t of Object.keys(this.controls)){const n=this.controls[t];if(this.contains(t)&&e(n))return!0}return!1}_reduceValue(){return this._reduceChildren({},(e,t,n)=>((t.enabled||this.disabled)&&(e[n]=t.value),e))}_reduceChildren(e,t){let n=e;return this._forEachChild((e,s)=>{n=t(n,e,s)}),n}_allControlsDisabled(){for(const e of Object.keys(this.controls))if(this.controls[e].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_checkAllValuesPresent(e){this._forEachChild((t,n)=>{if(void 0===e[n])throw new Error(`Must supply a value for form control with name: '${n}'.`)})}}class DH extends AH{constructor(e,t,n){super(SH(t),NH(n,t)),this.controls=e,this._initObservables(),this._setUpdateStrategy(t),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}at(e){return this.controls[e]}push(e,t={}){this.controls.push(e),this._registerControl(e),this.updateValueAndValidity({emitEvent:t.emitEvent}),this._onCollectionChange()}insert(e,t,n={}){this.controls.splice(e,0,t),this._registerControl(t),this.updateValueAndValidity({emitEvent:n.emitEvent})}removeAt(e,t={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),this.controls.splice(e,1),this.updateValueAndValidity({emitEvent:t.emitEvent})}setControl(e,t,n={}){this.controls[e]&&this.controls[e]._registerOnCollectionChange(()=>{}),this.controls.splice(e,1),t&&(this.controls.splice(e,0,t),this._registerControl(t)),this.updateValueAndValidity({emitEvent:n.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(e,t={}){this._checkAllValuesPresent(e),e.forEach((e,n)=>{this._throwIfControlMissing(n),this.at(n).setValue(e,{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t)}patchValue(e,t={}){null!=e&&(e.forEach((e,n)=>{this.at(n)&&this.at(n).patchValue(e,{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t))}reset(e=[],t={}){this._forEachChild((n,s)=>{n.reset(e[s],{onlySelf:!0,emitEvent:t.emitEvent})}),this._updatePristine(t),this._updateTouched(t),this.updateValueAndValidity(t)}getRawValue(){return this.controls.map(e=>e instanceof RH?e.value:e.getRawValue())}clear(e={}){this.controls.length<1||(this._forEachChild(e=>e._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:e.emitEvent}))}_syncPendingControls(){let e=this.controls.reduce((e,t)=>!!t._syncPendingControls()||e,!1);return e&&this.updateValueAndValidity({onlySelf:!0}),e}_throwIfControlMissing(e){if(!this.controls.length)throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");if(!this.at(e))throw new Error(`Cannot find form control at index ${e}`)}_forEachChild(e){this.controls.forEach((t,n)=>{e(t,n)})}_updateValue(){this.value=this.controls.filter(e=>e.enabled||this.disabled).map(e=>e.value)}_anyControls(e){return this.controls.some(t=>t.enabled&&e(t))}_setUpControls(){this._forEachChild(e=>this._registerControl(e))}_checkAllValuesPresent(e){this._forEachChild((t,n)=>{if(void 0===e[n])throw new Error(`Must supply a value for form control at index: ${n}.`)})}_allControlsDisabled(){for(const e of this.controls)if(e.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(e){e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange)}}const OH={provide:uH,useExisting:ie(()=>zH)},qH=(()=>Promise.resolve(null))();let zH=(()=>{class e extends uH{constructor(e,t,n,s){super(),this.control=new RH,this._registered=!1,this.update=new ci,this._parent=e,this._setValidators(t),this._setAsyncValidators(n),this.valueAccessor=xH(0,s)}ngOnChanges(e){this._checkForErrors(),this._registered||this._setUpControl(),"isDisabled"in e&&this._updateDisabled(e),vH(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._parent?pH(this.name,this._parent):[this.name]}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){hH(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){qH.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1})})}_updateDisabled(e){const t=e.isDisabled.currentValue,n=""===t||t&&"false"!==t;qH.then(()=>{n&&!this.control.disabled?this.control.disable():!n&&this.control.disabled&&this.control.enable()})}}return e.\u0275fac=function(t){return new(t||e)(va(iH,9),va(KG,10),va(XG,10),va(WG,10))},e.\u0275dir=Ye({type:e,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[to([OH]),la,ct]}),e})(),MH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275dir=Ye({type:e,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""]}),e})();const LH={provide:WG,useExisting:ie(()=>jH),multi:!0};let PH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({}),e})(),VH=(()=>{class e{constructor(){this._accessors=[]}add(e,t){this._accessors.push([e,t])}remove(e){for(let t=this._accessors.length-1;t>=0;--t)if(this._accessors[t][1]===e)return void this._accessors.splice(t,1)}select(e){this._accessors.forEach(t=>{this._isSameGroup(t,e)&&t[1]!==e&&t[1].fireUncheck(e.value)})}_isSameGroup(e,t){return!!e[0].control&&e[0]._parent===t._control._parent&&e[1].name===t.name}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:function(){return new e},token:e,providedIn:PH}),e})(),jH=(()=>{class e extends BG{constructor(e,t,n,s){super(e,t),this._registry=n,this._injector=s,this.onChange=()=>{}}ngOnInit(){this._control=this._injector.get(uH),this._checkName(),this._registry.add(this._control,this)}ngOnDestroy(){this._registry.remove(this)}writeValue(e){this._state=e===this.value,this.setProperty("checked",this._state)}registerOnChange(e){this._fn=e,this.onChange=()=>{e(this.value),this._registry.select(this)}}fireUncheck(e){this.writeValue(e)}_checkName(){!this.name&&this.formControlName&&(this.name=this.formControlName)}}return e.\u0275fac=function(t){return new(t||e)(va(po),va(uo),va(VH),va(ia))},e.\u0275dir=Ye({type:e,selectors:[["input","type","radio","formControlName",""],["input","type","radio","formControl",""],["input","type","radio","ngModel",""]],hostBindings:function(e,t){1&e&&Ea("change",function(){return t.onChange()})("blur",function(){return t.onTouched()})},inputs:{name:"name",formControlName:"formControlName",value:"value"},features:[to([LH]),la]}),e})();const BH=new Ln("NgModelWithFormControlWarning"),WH={provide:iH,useExisting:ie(()=>UH)};let UH=(()=>{class e extends iH{constructor(e,t){super(),this.validators=e,this.asyncValidators=t,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new ci,this._setValidators(e),this._setAsyncValidators(t)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(bH(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const t=this.form.get(e.path);return hH(t,e),t.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),t}getControl(e){return this.form.get(e.path)}removeControl(e){fH(e.control||null,e,!1),wH(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,t){this.form.get(e.path).setValue(t)}onSubmit(e){return this.submitted=!0,t=this.directives,this.form._syncPendingControls(),t.forEach(e=>{const t=e.control;"submit"===t.updateOn&&t._pendingChange&&(e.viewToModelUpdate(t._pendingValue),t._pendingChange=!1)}),this.ngSubmit.emit(e),!1;var t}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const t=e.control,n=this.form.get(e.path);t!==n&&(fH(t||null,e),n instanceof RH&&(hH(n,e),e.control=n))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const t=this.form.get(e.path);(function(e,t){gH(e,t)})(t,e),t.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const t=this.form.get(e.path);t&&function(e,t){return bH(e,t)}(t,e)&&t.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){gH(this.form,this),this._oldForm&&bH(this._oldForm,this)}_checkFormPresent(){}}return e.\u0275fac=function(t){return new(t||e)(va(KG,10),va(XG,10))},e.\u0275dir=Ye({type:e,selectors:[["","formGroup",""]],hostBindings:function(e,t){1&e&&Ea("submit",function(e){return t.onSubmit(e)})("reset",function(){return t.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[to([WH]),la,ct]}),e})();const GH={provide:uH,useExisting:ie(()=>HH)};let HH=(()=>{class e extends uH{constructor(e,t,n,s,r){super(),this._ngModelWarningConfig=r,this._added=!1,this.update=new ci,this._ngModelWarningSent=!1,this._parent=e,this._setValidators(t),this._setAsyncValidators(n),this.valueAccessor=xH(0,s)}set isDisabled(e){}ngOnChanges(e){this._added||this._setUpControl(),vH(e,this.viewModel)&&(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}get path(){return pH(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this.control.disabled&&this.valueAccessor.setDisabledState&&this.valueAccessor.setDisabledState(!0),this._added=!0}}return e.\u0275fac=function(t){return new(t||e)(va(iH,13),va(KG,10),va(XG,10),va(WG,10),va(BH,8))},e.\u0275dir=Ye({type:e,selectors:[["","formControlName",""]],inputs:{isDisabled:["disabled","isDisabled"],name:["formControlName","name"],model:["ngModel","model"]},outputs:{update:"ngModelChange"},features:[to([GH]),la,ct]}),e._ngModelWarningSentOnce=!1,e})(),KH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[[PH]]}),e})(),XH=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[KH]}),e})(),ZH=(()=>{class e{static withConfig(t){return{ngModule:e,providers:[{provide:BH,useValue:t.warnOnNgModelWithFormControl}]}}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[KH]}),e})(),YH=(()=>{class e{group(e,t=null){const n=this._reduceControls(e);let s,r=null,a=null;return null!=t&&(function(e){return void 0!==e.asyncValidators||void 0!==e.validators||void 0!==e.updateOn}(t)?(r=null!=t.validators?t.validators:null,a=null!=t.asyncValidators?t.asyncValidators:null,s=null!=t.updateOn?t.updateOn:void 0):(r=null!=t.validator?t.validator:null,a=null!=t.asyncValidator?t.asyncValidator:null)),new FH(n,{asyncValidators:a,updateOn:s,validators:r})}control(e,t,n){return new RH(e,t,n)}array(e,t,n){const s=e.map(e=>this._createControl(e));return new DH(s,t,n)}_reduceControls(e){const t={};return Object.keys(e).forEach(n=>{t[n]=this._createControl(e[n])}),t}_createControl(e){return e instanceof RH||e instanceof FH||e instanceof DH?e:Array.isArray(e)?this.control(e[0],e.length>1?e[1]:null,e.length>2?e[2]:null):this.control(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=fe({factory:function(){return new e},token:e,providedIn:ZH}),e})();const QH=["chatMessages"],JH=function(e,t){return{"align-right":e,"align-left":t}},eK=function(e,t){return{"is-user":e,"is-bot":t}};function tK(e,t){if(1&e&&(ka(0,"div",17),ka(1,"div",18),ka(2,"p"),za(3),Ca(),Ca(),Ca()),2&e){const e=t.$implicit;xa("ngClass",ui(3,JH,"user"===e.sender,"bot"===e.sender)),Js(1),xa("ngClass",ui(6,eK,"user"===e.sender,"bot"===e.sender)),Js(2),Ma(e.text)}}const nK=[{path:"",redirectTo:"home",pathMatch:"full"},{path:"home",component:(()=>{class e{constructor(e,t,n){this.chatbotService=e,this.chatTrying=t,this.fb=n,this.messages=[]}ngOnInit(){var e=this;return bh(function*(){e.modelSelectionForm=e.fb.group({model:["intents"]}),yield e.chatbotService.loadModel(),yield e.chatTrying.trainChatbot()})()}sendMessage(){var e=this;return bh(function*(){if(""===e.userInput.trim())return;e.messages.push({sender:"user",text:e.userInput});const{model:t}=e.modelSelectionForm.value;let n="";n="sequence-to-sequence"===t?yield e.chatbotService.decodeSequence(e.userInput):yield e.chatTrying.getResponse(e.userInput),e.userInput="",e.messages.push({sender:"bot",text:n})})()}generateBotResponse(e){return e.toLowerCase().includes("hola")?"\xa1Hola! \xbfEn qu\xe9 puedo ayudarte?":e.toLowerCase().includes("adi\xf3s")?"\xa1Hasta luego! Que tengas un buen d\xeda.":"Lo siento, no entiendo tu mensaje. \xbfPodr\xedas ser m\xe1s espec\xedfico?"}scrollToBottom(){setTimeout(()=>{this.chatMessages&&(this.chatMessages.nativeElement.scrollTop=this.chatMessages.nativeElement.scrollHeight)},200)}}return e.\u0275fac=function(t){return new(t||e)(va(RG),va(PG),va(YH))},e.\u0275cmp=Ue({type:e,selectors:[["app-home"]],viewQuery:function(e,t){if(1&e&&function(e,t,n){const s=At();s.firstCreatePass&&(function(e,t,n){null===e.queries&&(e.queries=new gi),e.queries.track(new bi(t,-1))}(s,new mi(e,t,n)),2==(2&t)&&(s.staticViewQueries=!0)),function(e,t,n){const s=new pi(4==(4&n));vr(e,t,s,s.destroy),null===t[19]&&(t[19]=new fi),t[19].queries.push(new hi(s))}(s,Tt(),t)}(QH,5),2&e){let e;ki((n=Tt(),s=Vt(),e=n[19].queries[s].queryList))&&(t.chatMessages=e.first)}var n,s},decls:22,vars:3,consts:[[1,"chat-container"],[1,"options-box"],[1,"options-header"],[1,"options-form",3,"formGroup"],[1,"custom-radio"],["type","radio","formControlName","model","value","intents"],[1,"chat-box"],[1,"chat-header"],[1,"chat-messages"],["chatMessages",""],["class","message-container",3,"ngClass",4,"ngFor","ngForOf"],[1,"chat-input"],[1,"field","has-addons"],[1,"control","is-expanded"],["type","text","placeholder","Escribe tu mensaje...",1,"input",3,"ngModel","ngModelChange","keydown.enter"],[1,"control"],[1,"button","is-primary",3,"click"],[1,"message-container",3,"ngClass"],[1,"message",3,"ngClass"]],template:function(e,t){1&e&&(ka(0,"body"),ka(1,"div",0),ka(2,"div",1),ka(3,"div",2),za(4," Modelos disponibles "),Ca(),ka(5,"form",3),ka(6,"label",4),Ia(7,"input",5),za(8," Intents "),Ca(),Ca(),Ca(),ka(9,"div",6),ka(10,"div",7),za(11," Chatbot Grupo 5 - Chatbot12 "),Ca(),ka(12,"div",8,9),function(e,t,n,s,r,a,o,i){const u=Tt(),l=At(),c=l.firstCreatePass?function(e,t,n,s,r,a,o,i,u){const l=t.consts,c=lr(t,34,4,"div",_t(l,10));wr(t,n,c,_t(l,undefined)),Jt(t,c);const d=c.tViews=yr(2,c,s,4,9,t.directiveRegistry,t.pipeRegistry,null,t.schemas,l);return null!==t.queries&&(t.queries.template(t,c),d.queries=t.queries.embeddedTView(c)),c}(0,l,u,t):l.data[34];Dt(c,!1);const d=u[11].createComment("");Rs(l,u,d,c),us(d,u),Or(u,u[34]=Ar(d,u,d,c)),ot(c)&&mr(l,u,c)}(0,tK),Ca(),ka(15,"div",11),ka(16,"div",12),ka(17,"div",13),ka(18,"input",14),Ea("ngModelChange",function(e){return t.userInput=e})("keydown.enter",function(){return t.sendMessage()}),Ca(),Ca(),ka(19,"div",15),ka(20,"button",16),Ea("click",function(){return t.sendMessage()}),za(21,"Enviar"),Ca(),Ca(),Ca(),Ca(),Ca(),Ca(),Ca()),2&e&&(Js(5),xa("formGroup",t.modelSelectionForm),Js(9),xa("ngForOf",t.messages),Js(4),xa("ngModel",t.userInput))},directives:[MH,dH,UH,jH,HG,cH,HH,Gu,zH,Wu],styles:[".chat-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;min-height:100vh;padding:10px;background-color:#fff;position:relative}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]{width:200px;background-color:#fff;border:1px solid #ddd;border-radius:8px;margin-right:15px;box-shadow:0 4px 20px #0000001a;z-index:10;position:static}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-header[_ngcontent-%COMP%]{background-color:#183059;color:#fff;padding:10px;font-size:1rem;text-align:center;border-radius:8px 8px 0 0}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]{padding:10px}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]   .custom-radio[_ngcontent-%COMP%]{display:flex;align-items:center;grid-gap:5px;gap:5px;margin-bottom:10px}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]   .options-form[_ngcontent-%COMP%]   .custom-radio[_ngcontent-%COMP%]   input[type=radio][_ngcontent-%COMP%]{margin-right:0}.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{width:100%;max-width:400px;display:flex;flex-direction:column;height:80vh;border-radius:8px;box-shadow:0 4px 20px #0003;background-color:#fff}@media (min-width:768px){.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{max-width:600px;height:85vh}}@media (min-width:1024px){.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{max-width:800px;height:90vh}}.chat-container[_ngcontent-%COMP%]   .chat-header[_ngcontent-%COMP%]{background-color:#183059;color:#fff;padding:10px;text-align:center;font-size:1.5rem;border-radius:5px 5px 0 0;z-index:1}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]{flex:1;overflow-y:auto;padding:15px 10px;background-color:#fff;border:1px solid #ddd;border-top:none;display:flex;flex-direction:column;grid-gap:10px;gap:10px;font-size:1rem}@media (min-width:1024px){.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]{font-size:1.2rem}}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]{display:flex}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container.align-right[_ngcontent-%COMP%]{justify-content:flex-end}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container.align-left[_ngcontent-%COMP%]{justify-content:flex-start}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message[_ngcontent-%COMP%]{padding:10px 15px;border-radius:10px;max-width:70%;word-wrap:break-word;font-size:1rem}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message.is-user[_ngcontent-%COMP%]{background-color:#183059;color:#fff;text-align:right;border-bottom-right-radius:0}.chat-container[_ngcontent-%COMP%]   .chat-messages[_ngcontent-%COMP%]   .message-container[_ngcontent-%COMP%]   .message.is-bot[_ngcontent-%COMP%]{background-color:#f5f5f5;color:#333;text-align:left;border-bottom-left-radius:0}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]{padding:10px;border-top:1px solid #ddd;background-color:#fff}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .field[_ngcontent-%COMP%]{display:flex;align-items:center}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .input[_ngcontent-%COMP%]{flex:1;border-radius:5px;background-color:#fff;color:#333;border:1px solid #ddd;padding:5px 10px}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .input[_ngcontent-%COMP%]::placeholder{color:#333;font-style:italic}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]{background-color:#183059;color:#fff;border-radius:5px;white-space:nowrap;padding:5px 15px;border:none;cursor:pointer;transition:background-color .2s}.chat-container[_ngcontent-%COMP%]   .chat-input[_ngcontent-%COMP%]   .button[_ngcontent-%COMP%]:hover{background-color:#00c1a8}@media (max-width:768px){.chat-container[_ngcontent-%COMP%]{flex-direction:column}.chat-container[_ngcontent-%COMP%]   .options-box[_ngcontent-%COMP%]{position:absolute;top:10px;left:50%;transform:translateX(-50%);width:90%;margin-right:0;border-radius:8px}.chat-container[_ngcontent-%COMP%]   .chat-box[_ngcontent-%COMP%]{margin-top:200px}}"]}),e})()}];let sK=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e}),e.\u0275inj=me({imports:[[ih.forRoot(nK)],ih]}),e})(),rK=(()=>{class e{constructor(e){this.chatbotService=e,this.title="chatbot12"}}return e.\u0275fac=function(t){return new(t||e)(va(RG))},e.\u0275cmp=Ue({type:e,selectors:[["app-root"]],decls:1,vars:0,template:function(e,t){1&e&&Ia(0,"router-outlet")},directives:[Yp],styles:[""]}),e})(),aK=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=Xe({type:e,bootstrap:[rK]}),e.\u0275inj=me({providers:[],imports:[[El,sK,XH,ZH]]}),e})();(function(){if(ru)throw new Error("Cannot enable prod mode after platform setup.");su=!1})(),_l().bootstrapModule(aK).catch(e=>console.error(e))},410:()=>{},628:()=>{},601:()=>{},792:()=>{},42:()=>{}},e=>{"use strict";e(e.s=862)}]);